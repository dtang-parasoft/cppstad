# 1 "D:\\Download\\gitlab\\gitlabRunner\\builds\\4qPaxrvx6\\0\\dtangParasoft\\cppstad\\test\\lib\\googletest\\googletest\\src\\gtest-all.cc"

#define CPPTEST_INSTRUMENTATION

#include <cpptest/instrumentation.h>



struct __CPTR_Dummy_Type {
    char nonEmpty;
};




struct __CPTR_Finalizer_3200903944_13504_4049562350
{
    __CPTR_Finalizer_3200903944_13504_4049562350()
    {
        cpptestAutoFinalizerConstructor();
    }

    ~__CPTR_Finalizer_3200903944_13504_4049562350()
    {
        cpptestAutoFinalizerDestructor();
    }
};





#define _coverage_data_unit_size 0
    


#define _coverage_code_size (1 + (3619) / (sizeof(unsigned char) * 8))
#define _coverage_func_data_offset 2861

static unsigned char _coverage_code[_coverage_code_size];

EXTERN_C_LINKAGE_START
CppTestCoverageInfo __CPTR_cui_3200903944_13504_4049562350 = 
{
    /*id=*/0U,
    /*externalId=*/{8, 235, 192, 52, 241, 0, 0, 0}, 
    /*idAssociationWasSent=*/0,
    /*prev=*/0, 
    /*covDataUnitSize=*/_coverage_data_unit_size,
    /*data=*/(unsigned char*)_coverage_code,
    /*size=*/_coverage_code_size * sizeof(char), 
    /*funcDataOffset=*/_coverage_func_data_offset,
    /*flags=*/0
    | CPPTEST_COVERAGE_FAST_COVERAGE_FLAG
};
EXTERN_C_LINKAGE_END

#define __CPTR_cui &__CPTR_cui_3200903944_13504_4049562350


#define CPPTEST_GET_SET_BIT_SHIFT 3U
#define CPPTEST_GET_SET_BIT_MASK  7U
#define CPPTEST_GET_SET_BIT_SHIFT_D 2U
#define CPPTEST_GET_SET_BIT_MASK_D  3U
#define CPPTEST_COVERAGE_CACHE_SET(DATA, ID) ((DATA)[(ID) >> CPPTEST_GET_SET_BIT_SHIFT] |= (1U << ((ID) & CPPTEST_GET_SET_BIT_MASK)))


#define CPPTEST_COVERAGE_AUTO_INIT(INFO) ((INFO)->id ? 0 : (cpptestInitializeCoverageInfo(INFO), 1))

#define cpptestFastCoverageFunction(funcDefId) (CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, _coverage_func_data_offset + funcDefId - 1))

#define cpptestFastCoverageStmt(offset) (CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, offset))

#define cpptestFastCoverageBlock(offset) (CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, offset))

int cpptestFastCoverageCond_3200903944_13504_4049562350(int val, int falseOffset, int trueOffset)
{
    CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, (val ? trueOffset : falseOffset));
    return val;
}

#define cpptestFastCoverageCond(val, falseOffset, trueOffset) cpptestFastCoverageCond_3200903944_13504_4049562350(val, falseOffset, trueOffset)

#define cpptestFastCoverageBranch(offset) (CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, offset))

#define cpptestFastCoverageDec(val, offset) \
    ((val) ? (cpptestFastCoverageBranch(offset), 1) : (cpptestFastCoverageBranch(offset + 1), 0))

#define cpptestFastCoverageCall(offset) (CPPTEST_COVERAGE_CACHE_SET((__CPTR_cui)->data, offset))


#define _cpptest_strdata_var(id, bogus) _cpptest_strdata[id]
static 
const char* _cpptest_strdata[] = {
    0,
    "",
    0
};
#undef unix
#undef __unix
# 252 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++config.h" 3
namespace std { 

typedef unsigned size_t; 
typedef int ptrdiff_t; 


typedef __decltype((nullptr)) nullptr_t; 

}
# 274 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++config.h" 3
namespace std { 

inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
}
namespace __gnu_cxx { 

inline namespace __cxx11 __attribute((__abi_tag__("cxx11"))) { }
}
# 158 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
namespace std { 
# 167
enum float_round_style { 

round_indeterminate = (-1), 
round_toward_zero = 0, 
round_to_nearest, 
round_toward_infinity, 
round_toward_neg_infinity
}; 
# 182
enum float_denorm_style { 


denorm_indeterminate = (-1), 

denorm_absent = 0, 

denorm_present
}; 
# 202 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
struct __numeric_limits_base { 



static constexpr bool is_specialized = false; 




static constexpr int digits = 0; 


static constexpr int digits10 = 0; 




static constexpr int max_digits10 = 0; 



static constexpr bool is_signed = false; 


static constexpr bool is_integer = false; 




static constexpr bool is_exact = false; 



static constexpr int radix = 0; 



static constexpr int min_exponent = 0; 



static constexpr int min_exponent10 = 0; 




static constexpr int max_exponent = 0; 



static constexpr int max_exponent10 = 0; 


static constexpr bool has_infinity = false; 



static constexpr bool has_quiet_NaN = false; 



static constexpr bool has_signaling_NaN = false; 


static constexpr float_denorm_style has_denorm = denorm_absent; 



static constexpr bool has_denorm_loss = false; 



static constexpr bool is_iec559 = false; 




static constexpr bool is_bounded = false; 
# 288 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
static constexpr bool is_modulo = false; 


static constexpr bool traps = false; 


static constexpr bool tinyness_before = false; 




static constexpr float_round_style round_style = round_toward_zero; 

}; 
# 311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
template < typename _Tp > 
struct numeric_limits : public __numeric_limits_base 
{ 


static constexpr _Tp 
min () noexcept { return _Tp () ; } 


static constexpr _Tp 
max () noexcept { return _Tp () ; } 




static constexpr _Tp 
lowest () noexcept { return _Tp () ; } 




static constexpr _Tp 
epsilon () noexcept { return _Tp () ; } 


static constexpr _Tp 
round_error () noexcept { return _Tp () ; } 


static constexpr _Tp 
infinity () noexcept { return _Tp () ; } 



static constexpr _Tp 
quiet_NaN () noexcept { return _Tp () ; } 



static constexpr _Tp 
signaling_NaN () noexcept { return _Tp () ; } 




static constexpr _Tp 
denorm_min () noexcept { return _Tp () ; } 
} ;




template < typename _Tp > 
struct numeric_limits < const _Tp > 
: public numeric_limits < _Tp > { } ;

template < typename _Tp > 
struct numeric_limits < volatile _Tp > 
: public numeric_limits < _Tp > { } ;

template < typename _Tp > 
struct numeric_limits < const volatile _Tp > 
: public numeric_limits < _Tp > { } ;
# 384 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
template<> struct numeric_limits< bool>  { 

static constexpr bool is_specialized = true; 


static constexpr bool min() noexcept { return false; } 


static constexpr bool max() noexcept { return true; } 



static constexpr bool lowest() noexcept { return min(); } 

static constexpr int digits = 1; 
static constexpr int digits10 = 0; 

static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr bool epsilon() noexcept { return false; } 


static constexpr bool round_error() noexcept { return false; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr bool infinity() noexcept { return false; } 


static constexpr bool quiet_NaN() noexcept { return false; } 


static constexpr bool signaling_NaN() noexcept { return false; } 


static constexpr bool denorm_min() noexcept { return false; } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 




static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< char>  { 

static constexpr bool is_specialized = true; 


static constexpr char min() noexcept { return ((((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char)0))) - 1 : ((char)0))); } 


static constexpr char max() noexcept { return ((((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char)0)))); } 



static constexpr char lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(char) * 8 - ((char)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L) / 2136)); 

static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = ((char)(-1) < 0); 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr char epsilon() noexcept { return 0; } 


static constexpr char round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr char infinity() noexcept { return ((char)0); } 


static constexpr char quiet_NaN() noexcept { return ((char)0); } 


static constexpr char signaling_NaN() noexcept { return ((char)0); } 


static constexpr char denorm_min() noexcept { return static_cast< char>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = (!is_signed); 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< signed char>  { 

static constexpr bool is_specialized = true; 


static constexpr signed char min() noexcept { return -0x7f - 1; } 


static constexpr signed char max() noexcept { return 0x7f; } 



static constexpr signed char lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = true; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr signed char epsilon() noexcept { return 0; } 


static constexpr signed char round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr signed char infinity() noexcept { return static_cast< signed char>(0); } 


static constexpr signed char quiet_NaN() noexcept { return static_cast< signed char>(0); } 


static constexpr signed char signaling_NaN() noexcept 
{ return static_cast< signed char>(0); } 


static constexpr signed char denorm_min() noexcept 
{ return static_cast< signed char>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< unsigned char>  { 

static constexpr bool is_specialized = true; 


static constexpr unsigned char min() noexcept { return 0; } 


static constexpr unsigned char max() noexcept { return 0x7f * 2U + 1; } 



static constexpr unsigned char lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr unsigned char epsilon() noexcept { return 0; } 


static constexpr unsigned char round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr unsigned char infinity() noexcept 
{ return static_cast< unsigned char>(0); } 


static constexpr unsigned char quiet_NaN() noexcept 
{ return static_cast< unsigned char>(0); } 


static constexpr unsigned char signaling_NaN() noexcept 
{ return static_cast< unsigned char>(0); } 


static constexpr unsigned char denorm_min() noexcept 
{ return static_cast< unsigned char>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = true; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< wchar_t>  { 

static constexpr bool is_specialized = true; 


static constexpr wchar_t min() noexcept { return ((((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((wchar_t)0))) - 1 : ((wchar_t)0))); } 


static constexpr wchar_t max() noexcept { return ((((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((wchar_t)0)))); } 



static constexpr wchar_t lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = ((wchar_t)(-1) < 0); 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr wchar_t epsilon() noexcept { return 0; } 


static constexpr wchar_t round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr wchar_t infinity() noexcept { return ((wchar_t)0); } 


static constexpr wchar_t quiet_NaN() noexcept { return ((wchar_t)0); } 


static constexpr wchar_t signaling_NaN() noexcept { return ((wchar_t)0); } 


static constexpr wchar_t denorm_min() noexcept { return ((wchar_t)0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = (!is_signed); 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 
# 797 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
template<> struct numeric_limits< char16_t>  { 

static constexpr bool is_specialized = true; 


static constexpr char16_t min() noexcept { return ((((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char16_t)0))) - 1 : ((char16_t)0))); } 


static constexpr char16_t max() noexcept { return ((((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char16_t)0)))); } 


static constexpr char16_t lowest() noexcept { return min(); } 

static constexpr int digits = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L) / 2136)); 
static constexpr int max_digits10 = 0; 
static constexpr bool is_signed = ((char16_t)(-1) < 0); 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr char16_t epsilon() noexcept { return 0; } 


static constexpr char16_t round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 
static constexpr bool has_denorm_loss = false; 


static constexpr char16_t infinity() noexcept { return ((char16_t)0); } 


static constexpr char16_t quiet_NaN() noexcept { return ((char16_t)0); } 


static constexpr char16_t signaling_NaN() noexcept { return ((char16_t)0); } 


static constexpr char16_t denorm_min() noexcept { return ((char16_t)0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = (!is_signed); 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 
}; 



template<> struct numeric_limits< char32_t>  { 

static constexpr bool is_specialized = true; 


static constexpr char32_t min() noexcept { return ((((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char32_t)0))) - 1 : ((char32_t)0))); } 


static constexpr char32_t max() noexcept { return ((((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : (~((char32_t)0)))); } 


static constexpr char32_t lowest() noexcept { return min(); } 

static constexpr int digits = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L) / 2136)); 
static constexpr int max_digits10 = 0; 
static constexpr bool is_signed = ((char32_t)(-1) < 0); 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr char32_t epsilon() noexcept { return 0; } 


static constexpr char32_t round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 
static constexpr bool has_denorm_loss = false; 


static constexpr char32_t infinity() noexcept { return ((char32_t)0); } 


static constexpr char32_t quiet_NaN() noexcept { return ((char32_t)0); } 


static constexpr char32_t signaling_NaN() noexcept { return ((char32_t)0); } 


static constexpr char32_t denorm_min() noexcept { return ((char32_t)0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = (!is_signed); 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 
}; 




template<> struct numeric_limits< short>  { 

static constexpr bool is_specialized = true; 


static constexpr short min() noexcept { return -0x7fff - 1; } 


static constexpr short max() noexcept { return 0x7fff; } 



static constexpr short lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(short) * 8 - ((short)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L) / 2136)); 

static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = true; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr short epsilon() noexcept { return 0; } 


static constexpr short round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr short infinity() noexcept { return ((short)0); } 


static constexpr short quiet_NaN() noexcept { return ((short)0); } 


static constexpr short signaling_NaN() noexcept { return ((short)0); } 


static constexpr short denorm_min() noexcept { return ((short)0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< unsigned short>  { 

static constexpr bool is_specialized = true; 


static constexpr unsigned short min() noexcept { return 0; } 


static constexpr unsigned short max() noexcept { return 0x7fff * 2U + 1; } 



static constexpr unsigned short lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr unsigned short epsilon() noexcept { return 0; } 


static constexpr unsigned short round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr unsigned short infinity() noexcept 
{ return static_cast< unsigned short>(0); } 


static constexpr unsigned short quiet_NaN() noexcept 
{ return static_cast< unsigned short>(0); } 


static constexpr unsigned short signaling_NaN() noexcept 
{ return static_cast< unsigned short>(0); } 


static constexpr unsigned short denorm_min() noexcept 
{ return static_cast< unsigned short>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = true; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< int>  { 

static constexpr bool is_specialized = true; 


static constexpr int min() noexcept { return -0x7fffffff - 1; } 


static constexpr int max() noexcept { return 0x7fffffff; } 



static constexpr int lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(int) * 8 - ((int)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L) / 2136)); 

static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = true; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr int epsilon() noexcept { return 0; } 


static constexpr int round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr int infinity() noexcept { return static_cast< int>(0); } 


static constexpr int quiet_NaN() noexcept { return static_cast< int>(0); } 


static constexpr int signaling_NaN() noexcept { return static_cast< int>(0); } 


static constexpr int denorm_min() noexcept { return static_cast< int>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< unsigned>  { 

static constexpr bool is_specialized = true; 


static constexpr unsigned min() noexcept { return 0; } 


static constexpr unsigned max() noexcept { return 0x7fffffff * 2U + 1; } 



static constexpr unsigned lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(unsigned) * 8 - ((unsigned)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(unsigned) * 8 - ((unsigned)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr unsigned epsilon() noexcept { return 0; } 


static constexpr unsigned round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr unsigned infinity() noexcept { return static_cast< unsigned>(0); } 


static constexpr unsigned quiet_NaN() noexcept 
{ return static_cast< unsigned>(0); } 


static constexpr unsigned signaling_NaN() noexcept 
{ return static_cast< unsigned>(0); } 


static constexpr unsigned denorm_min() noexcept 
{ return static_cast< unsigned>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = true; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< long>  { 

static constexpr bool is_specialized = true; 


static constexpr long min() noexcept { return -0x7fffffffL - 1; } 


static constexpr long max() noexcept { return 0x7fffffffL; } 



static constexpr long lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(long) * 8 - ((long)(-1) < 0))); 
static constexpr int digits10 = ((((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L) / 2136)); 

static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = true; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr long epsilon() noexcept { return 0; } 


static constexpr long round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr long infinity() noexcept { return static_cast< long>(0); } 


static constexpr long quiet_NaN() noexcept { return static_cast< long>(0); } 


static constexpr long signaling_NaN() noexcept { return static_cast< long>(0); } 


static constexpr long denorm_min() noexcept { return static_cast< long>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< unsigned long>  { 

static constexpr bool is_specialized = true; 


static constexpr unsigned long min() noexcept { return 0; } 


static constexpr unsigned long max() noexcept { return 0x7fffffffL * 2UL + 1; } 



static constexpr unsigned long lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr unsigned long epsilon() noexcept { return 0; } 


static constexpr unsigned long round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr unsigned long infinity() noexcept 
{ return static_cast< unsigned long>(0); } 


static constexpr unsigned long quiet_NaN() noexcept 
{ return static_cast< unsigned long>(0); } 


static constexpr unsigned long signaling_NaN() noexcept 
{ return static_cast< unsigned long>(0); } 


static constexpr unsigned long denorm_min() noexcept 
{ return static_cast< unsigned long>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = true; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< long long>  { 

static constexpr bool is_specialized = true; 


static constexpr long long min() noexcept { return -0x7fffffffffffffffLL - 1; } 


static constexpr long long max() noexcept { return 0x7fffffffffffffffLL; } 



static constexpr long long lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(long long) * 8 - ((long long)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = true; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr long long epsilon() noexcept { return 0; } 


static constexpr long long round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr long long infinity() noexcept { return static_cast< long long>(0); } 


static constexpr long long quiet_NaN() noexcept { return static_cast< long long>(0); } 


static constexpr long long signaling_NaN() noexcept 
{ return static_cast< long long>(0); } 


static constexpr long long denorm_min() noexcept { return static_cast< long long>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 



template<> struct numeric_limits< unsigned long long>  { 

static constexpr bool is_specialized = true; 


static constexpr unsigned long long min() noexcept { return 0; } 


static constexpr unsigned long long max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; } 



static constexpr unsigned long long lowest() noexcept { return min(); } 


static constexpr int digits = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0))); 

static constexpr int digits10 = ((((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L) / 2136)); 


static constexpr int max_digits10 = 0; 

static constexpr bool is_signed = false; 
static constexpr bool is_integer = true; 
static constexpr bool is_exact = true; 
static constexpr int radix = 2; 


static constexpr unsigned long long epsilon() noexcept { return 0; } 


static constexpr unsigned long long round_error() noexcept { return 0; } 

static constexpr int min_exponent = 0; 
static constexpr int min_exponent10 = 0; 
static constexpr int max_exponent = 0; 
static constexpr int max_exponent10 = 0; 

static constexpr bool has_infinity = false; 
static constexpr bool has_quiet_NaN = false; 
static constexpr bool has_signaling_NaN = false; 
static constexpr float_denorm_style has_denorm = denorm_absent; 

static constexpr bool has_denorm_loss = false; 


static constexpr unsigned long long infinity() noexcept 
{ return static_cast< unsigned long long>(0); } 


static constexpr unsigned long long quiet_NaN() noexcept 
{ return static_cast< unsigned long long>(0); } 


static constexpr unsigned long long signaling_NaN() noexcept 
{ return static_cast< unsigned long long>(0); } 


static constexpr unsigned long long denorm_min() noexcept 
{ return static_cast< unsigned long long>(0); } 

static constexpr bool is_iec559 = false; 
static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = true; 

static constexpr bool traps = true; 
static constexpr bool tinyness_before = false; 
static constexpr float_round_style round_style = round_toward_zero; 

}; 
# 1660 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\limits" 3
template<> struct numeric_limits< float>  { 

static constexpr bool is_specialized = true; 


static constexpr float min() noexcept { return (1.175494351e-38F); } 


static constexpr float max() noexcept { return (3.402823466e+38F); } 



static constexpr float lowest() noexcept { return -(3.402823466e+38F); } 


static constexpr int digits = 24; 
static constexpr int digits10 = 6; 

static constexpr int max_digits10 = ((2 + ((24) * 643L) / 2136)); 


static constexpr bool is_signed = true; 
static constexpr bool is_integer = false; 
static constexpr bool is_exact = false; 
static constexpr int radix = 2; 


static constexpr float epsilon() noexcept { return (1.192092896e-07F); } 


static constexpr float round_error() noexcept { return (0.5F); } 

static constexpr int min_exponent = (-125); 
static constexpr int min_exponent10 = (-37); 
static constexpr int max_exponent = 128; 
static constexpr int max_exponent10 = 38; 

static constexpr bool has_infinity = (1); 
static constexpr bool has_quiet_NaN = (1); 
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 

static constexpr bool has_denorm_loss = false; 



static constexpr float infinity() noexcept { return __builtin_huge_valf(); } 


static constexpr float quiet_NaN() noexcept { return __builtin_nanf(""); } 


static constexpr float signaling_NaN() noexcept { return __builtin_nansf(""); } 


static constexpr float denorm_min() noexcept { return (1.401298464e-45F); } 

static constexpr bool is_iec559 = ((has_infinity && has_quiet_NaN) && has_denorm == denorm_present); 

static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = false; 
static constexpr bool tinyness_before = false; 

static constexpr float_round_style round_style = round_to_nearest; 

}; 
# 1735
template<> struct numeric_limits< double>  { 

static constexpr bool is_specialized = true; 


static constexpr double min() noexcept { return (double)(2.2250738585072014e-308L); } 


static constexpr double max() noexcept { return (double)(1.7976931348623157e+308L); } 



static constexpr double lowest() noexcept { return -((double)(1.7976931348623157e+308L)); } 


static constexpr int digits = 53; 
static constexpr int digits10 = 15; 

static constexpr int max_digits10 = ((2 + ((53) * 643L) / 2136)); 


static constexpr bool is_signed = true; 
static constexpr bool is_integer = false; 
static constexpr bool is_exact = false; 
static constexpr int radix = 2; 


static constexpr double epsilon() noexcept { return (double)(2.2204460492503131e-16L); } 


static constexpr double round_error() noexcept { return (0.5); } 

static constexpr int min_exponent = (-1021); 
static constexpr int min_exponent10 = (-307); 
static constexpr int max_exponent = 1024; 
static constexpr int max_exponent10 = 308; 

static constexpr bool has_infinity = (1); 
static constexpr bool has_quiet_NaN = (1); 
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 

static constexpr bool has_denorm_loss = false; 



static constexpr double infinity() noexcept { return __builtin_huge_val(); } 


static constexpr double quiet_NaN() noexcept { return __builtin_nan(""); } 


static constexpr double signaling_NaN() noexcept { return __builtin_nans(""); } 


static constexpr double denorm_min() noexcept { return (double)(4.9406564584124654e-324L); } 

static constexpr bool is_iec559 = ((has_infinity && has_quiet_NaN) && has_denorm == denorm_present); 

static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = false; 
static constexpr bool tinyness_before = false; 

static constexpr float_round_style round_style = round_to_nearest; 

}; 
# 1810
template<> struct numeric_limits< long double>  { 

static constexpr bool is_specialized = true; 


static constexpr long double min() noexcept { return (0.0L); } 


static constexpr long double max() noexcept { return ((__builtin_huge_vall())); } 



static constexpr long double lowest() noexcept { return -((__builtin_huge_vall())); } 


static constexpr int digits = 64; 
static constexpr int digits10 = 18; 

static constexpr int max_digits10 = ((2 + ((64) * 643L) / 2136)); 


static constexpr bool is_signed = true; 
static constexpr bool is_integer = false; 
static constexpr bool is_exact = false; 
static constexpr int radix = 2; 


static constexpr long double epsilon() noexcept { return (1.0842021724855044e-19L); } 


static constexpr long double round_error() noexcept { return (0.5L); } 

static constexpr int min_exponent = (-16381); 
static constexpr int min_exponent10 = (-4931); 
static constexpr int max_exponent = 16384; 
static constexpr int max_exponent10 = 4932; 

static constexpr bool has_infinity = (1); 
static constexpr bool has_quiet_NaN = (1); 
static constexpr bool has_signaling_NaN = has_quiet_NaN; 
static constexpr float_denorm_style has_denorm = (((bool)1) ? denorm_present : denorm_absent); 

static constexpr bool has_denorm_loss = false; 



static constexpr long double infinity() noexcept { return __builtin_huge_vall(); } 


static constexpr long double quiet_NaN() noexcept { return __builtin_nanl(""); } 


static constexpr long double signaling_NaN() noexcept { return __builtin_nansl(""); } 


static constexpr long double denorm_min() noexcept { return (0.0L); } 

static constexpr bool is_iec559 = ((has_infinity && has_quiet_NaN) && has_denorm == denorm_present); 

static constexpr bool is_bounded = true; 
static constexpr bool is_modulo = false; 

static constexpr bool traps = false; 
static constexpr bool tinyness_before = false; 

static constexpr float_round_style round_style = round_to_nearest; 

}; 
# 1884
}
# 50 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\memoryfwd.h" 3
namespace std { 
# 63 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\memoryfwd.h" 3
template < typename >
    class allocator;


template<> class allocator< void> ; 


template < typename, typename >
    struct uses_allocator;




}
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stringfwd.h" 3
namespace std { 
# 52
template < class _CharT >
    struct char_traits;

template<> struct char_traits< char> ; 


template<> struct char_traits< wchar_t> ; 
# 66
template<> struct char_traits< char16_t> ; 
template<> struct char_traits< char32_t> ; 


inline namespace __cxx11 { 

template < typename _CharT, typename _Traits = char_traits < _CharT >,
           typename _Alloc = allocator < _CharT > >
    class basic_string;

}


typedef __cxx11::basic_string< char>  string; 



typedef __cxx11::basic_string< wchar_t>  wstring; 
# 93 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stringfwd.h" 3
typedef __cxx11::basic_string< char16_t>  u16string; 


typedef __cxx11::basic_string< char32_t>  u32string; 
# 102
}
# 350 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stddef.h" 3
typedef unsigned short wint_t; 
# 89 "d:\\mingw\\mingw\\include\\wctype.h" 3
typedef wchar_t wctype_t; 


extern "C" {
# 100
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswalnum(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswalpha(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswascii(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswcntrl(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int iswctype(wint_t, wctype_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswdigit(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswgraph(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswlower(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswprint(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswpunct(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswspace(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswupper(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswxdigit(wint_t); 
# 120
__attribute((__deprecated__)) __attribute((__cdecl__)) __attribute((__nothrow__)) int is_wctype(wint_t, wctype_t); 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswblank(wint_t); 
# 131
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t towlower(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t towupper(wint_t); 
# 140
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswalnum(wint_t wc) 
{ return (iswctype(wc, 0x103 | 0x4)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswalpha(wint_t wc) 
{ return (iswctype(wc, 0x103)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswascii(wint_t wc) 
{ return (((wc & ~0x7f) == 0)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswcntrl(wint_t wc) 
{ return (iswctype(wc, 0x20)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswdigit(wint_t wc) 
{ return (iswctype(wc, 0x4)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswgraph(wint_t wc) 
{ return (iswctype(wc, (0x10 | 0x103) | 0x4)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswlower(wint_t wc) 
{ return (iswctype(wc, 0x2)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswprint(wint_t wc) 
{ return (iswctype(wc, ((0x40 | 0x10) | 0x103) | 0x4)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswpunct(wint_t wc) 
{ return (iswctype(wc, 0x10)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswspace(wint_t wc) 
{ return (iswctype(wc, 0x8)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswupper(wint_t wc) 
{ return (iswctype(wc, 0x1)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswxdigit(wint_t wc) 
{ return (iswctype(wc, 0x80)); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iswblank(wint_t wc) 
{ return ((iswctype(wc, 0x40) || wc == L'\x9')); } 



}
# 191 "d:\\mingw\\mingw\\include\\wctype.h" 3
typedef wchar_t wctrans_t; 

extern "C" {
# 202 "d:\\mingw\\mingw\\include\\wctype.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t towctrans(wint_t, wctrans_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wctrans_t wctrans(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wctype_t wctype(const char *); 

}
# 62 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef long __off32_t; 




typedef __off32_t _off_t; 
# 75
typedef _off_t off_t; 
# 91 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef long long __off64_t; 
# 98
typedef __off64_t off64_t; 
# 115 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef int _ssize_t; 
# 123
typedef _ssize_t ssize_t; 
# 139 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef long __time32_t; 
typedef long long __time64_t; 
# 149 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef __time32_t time_t; 
# 143 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stddef.h" 3
typedef int ptrdiff_t; 
# 209 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stddef.h" 3
typedef unsigned size_t; 
# 184 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef unsigned _dev_t; 
# 195 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef short _ino_t; 
typedef unsigned short _mode_t; 
typedef int _pid_t; 
typedef int _sigset_t; 
# 207 "d:\\mingw\\mingw\\include\\sys\\types.h" 3
typedef _dev_t dev_t; 
typedef _ino_t ino_t; 
typedef _mode_t mode_t; 
typedef _pid_t pid_t; 
typedef _sigset_t sigset_t; 


typedef long long fpos64_t; 
# 221
typedef unsigned long useconds_t __attribute((__deprecated__)); 
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list; 
# 220 "d:\\mingw\\mingw\\include\\stdio.h" 3
typedef 
# 210
struct _iobuf { 

char *_ptr; 
int _cnt; 
char *_base; 
int _flag; 
int _file; 
int _charbuf; 
int _bufsiz; 
char *_tmpfname; 
} FILE; 
# 252 "d:\\mingw\\mingw\\include\\stdio.h" 3
extern "C" {
# 1041 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int fwprintf(FILE *, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wprintf(const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vfwprintf(FILE *, const wchar_t *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vwprintf(const wchar_t *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _snwprintf(wchar_t *, size_t, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _vscwprintf(const wchar_t *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _vsnwprintf(wchar_t *, size_t, const wchar_t *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fwscanf(FILE *, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wscanf(const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int swscanf(const wchar_t *, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t fgetwc(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t fputwc(wchar_t, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t ungetwc(wchar_t, FILE *); 




__attribute((__cdecl__)) __attribute((__nothrow__)) int swprintf(wchar_t *, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vswprintf(wchar_t *, const wchar_t *, __builtin_va_list); 



__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *fgetws(wchar_t *, int, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fputws(const wchar_t *, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t getwc(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t getwchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t putwc(wint_t, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t putwchar(wint_t); 


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_getws(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _putws(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_wfdopen(int, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_wfopen(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_wfreopen(const wchar_t *, const wchar_t *, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_wfsopen(const wchar_t *, const wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wtmpnam(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wtempnam(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wrename(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wremove(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void _wperror(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_wpopen(const wchar_t *, const wchar_t *); 
# 1089
__attribute((__cdecl__)) __attribute((__nothrow__)) int snwprintf(wchar_t *, size_t, const wchar_t *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int vsnwprintf(wchar_t *, size_t, const wchar_t *, __builtin_va_list); 




__attribute((__cdecl__)) __attribute((__nothrow__)) inline int vsnwprintf(wchar_t *__s, size_t __n, const wchar_t *__fmt, __builtin_va_list __arg) 
{ return _vsnwprintf(__s, __n, __fmt, __arg); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) int vwscanf(const wchar_t *, __builtin_va_list); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int vfwscanf(FILE *, const wchar_t *, __builtin_va_list); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int vswscanf(const wchar_t *, const wchar_t *, __builtin_va_list); 
# 1131 "d:\\mingw\\mingw\\include\\stdio.h" 3
}
# 90 "d:\\mingw\\mingw\\include\\stdlib.h" 3
extern "C" {
# 422 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) long wcstol(const wchar_t *, wchar_t **, int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long wcstoul(const wchar_t *, wchar_t **, int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) double wcstod(const wchar_t *, wchar_t **); 
# 435
__attribute((__cdecl__)) __attribute((__nothrow__)) double __mingw_wcstod(const wchar_t *, wchar_t **); 


__attribute((__cdecl__)) __attribute((__nothrow__)) float __mingw_wcstof(const wchar_t *, wchar_t **); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long double __mingw_wcstold(const wchar_t *, wchar_t **); 
# 448
__attribute((__cdecl__)) __attribute((__nothrow__)) float wcstof(const wchar_t *, wchar_t **); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long double wcstold(const wchar_t *, wchar_t **); 
# 492 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wgetenv(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wputenv(const wchar_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) void _wsearchenv(const wchar_t *, const wchar_t *, wchar_t *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _wsystem(const wchar_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) void _wmakepath(wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *, const wchar_t *); 




__attribute((__cdecl__)) __attribute((__nothrow__)) void _wsplitpath(const wchar_t *, wchar_t *, wchar_t *, wchar_t *, wchar_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wfullpath(wchar_t *, const wchar_t *, size_t); 
# 993 "d:\\mingw\\mingw\\include\\stdlib.h" 3
}
# 60 "d:\\mingw\\mingw\\include\\direct.h" 3
extern "C" {
# 86 "d:\\mingw\\mingw\\include\\direct.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wchdir(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wgetcwd(wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wgetdcwd(int, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wmkdir(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wrmdir(const wchar_t *); 



}
# 173 "d:\\mingw\\mingw\\include\\sys/stat.h" 3
struct _stat { _dev_t st_dev; _ino_t st_ino; _mode_t st_mode; short st_nlink; short st_uid; short st_gid; _dev_t st_rdev; _off_t st_size; time_t st_atime; time_t st_mtime; time_t st_ctime; }; 
# 180
struct stat { _dev_t st_dev; _ino_t st_ino; _mode_t st_mode; short st_nlink; short st_uid; short st_gid; _dev_t st_rdev; _off_t st_size; time_t st_atime; time_t st_mtime; time_t st_ctime; }; 
# 188
struct _stati64 { _dev_t st_dev; _ino_t st_ino; _mode_t st_mode; short st_nlink; short st_uid; short st_gid; _dev_t st_rdev; __off64_t st_size; time_t st_atime; time_t st_mtime; time_t st_ctime; }; 
# 195
struct __stat64 { _dev_t st_dev; _ino_t st_ino; _mode_t st_mode; short st_nlink; short st_uid; short st_gid; _dev_t st_rdev; __off64_t st_size; __time64_t st_atime; __time64_t st_mtime; __time64_t st_ctime; }; 
# 218 "d:\\mingw\\mingw\\include\\sys/stat.h" 3
extern "C" {
# 352 "d:\\mingw\\mingw\\include\\sys/stat.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wstat(const wchar_t *, struct _stat *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wstati64(const wchar_t *, struct _stati64 *); 
# 360
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wstat64(const wchar_t *, __stat64 *); 
# 398 "d:\\mingw\\mingw\\include\\sys/stat.h" 3
}
# 65 "d:\\mingw\\mingw\\include\\conio.h" 3
extern "C" {
# 146 "d:\\mingw\\mingw\\include\\conio.h" 3
}
# 106 "d:\\mingw\\mingw\\include\\stdint.h" 3
typedef int __intptr_t; 

typedef __intptr_t intptr_t; 
# 105 "d:\\mingw\\mingw\\include\\io.h" 3
typedef unsigned long _fsize_t; 
# 175 "d:\\mingw\\mingw\\include\\io.h" 3
extern "C" {
# 342 "d:\\mingw\\mingw\\include\\io.h" 3
struct _wfinddata_t { unsigned attrib; time_t time_create; time_t time_access; time_t time_write; _fsize_t size; wchar_t name[(260)]; }; 
struct _wfinddatai64_t { unsigned attrib; time_t time_create; time_t time_access; time_t time_write; long long size; wchar_t name[(260)]; }; 
# 352
__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wfindfirst(const wchar_t *, _wfinddata_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _wfindnext(intptr_t, _wfinddata_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wfindfirsti64(const wchar_t *, _wfinddatai64_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _wfindnexti64(intptr_t, _wfinddatai64_t *); 
# 369
struct __wfinddata64_t { unsigned attrib; __time64_t time_create; __time64_t time_access; __time64_t time_write; long long size; wchar_t name[(260)]; }; 
# 379 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wfindfirst64(const wchar_t *, __wfinddata64_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _wfindnext64(intptr_t, __wfinddata64_t *); 
# 478 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _findclose(intptr_t); 
# 526 "d:\\mingw\\mingw\\include\\io.h" 3
}
# 552 "d:\\mingw\\mingw\\include\\io.h" 3
extern "C" {
# 637 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _waccess(const wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wchmod(const wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcreat(const wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wunlink(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wopen(const wchar_t *, int, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wsopen(const wchar_t *, int, int, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wmktemp(wchar_t *); 
# 702 "d:\\mingw\\mingw\\include\\io.h" 3
}
# 80 "d:\\mingw\\mingw\\include\\time.h" 3
struct tm; 
# 482 "d:\\mingw\\mingw\\include\\time.h" 3
extern "C" {


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wasctime(const tm *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wstrdate(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wstrtime(wchar_t *); 
# 494
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wctime64(const __time64_t *); 
# 508 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wctime(const time_t *); 
# 538 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcsftime(wchar_t *, size_t, const wchar_t *, const tm *); 

}
# 135 "d:\\mingw\\mingw\\include\\locale.h" 3
extern "C" {
# 151 "d:\\mingw\\mingw\\include\\locale.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wsetlocale(int, const wchar_t *); 
# 178 "d:\\mingw\\mingw\\include\\locale.h" 3
}
# 93 "d:\\mingw\\mingw\\include\\process.h" 3
extern "C" {
# 261 "d:\\mingw\\mingw\\include\\process.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecl(const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecle(const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexeclp(const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexeclpe(const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecv(const wchar_t *, const wchar_t *const *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecve(const wchar_t *, const wchar_t *const *, const wchar_t *const *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecvp(const wchar_t *, const wchar_t *const *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wexecvpe(const wchar_t *, const wchar_t *const *, const wchar_t *const *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnl(int, const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnle(int, const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnlp(int, const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnlpe(int, const wchar_t *, const wchar_t *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnv(int, const wchar_t *, const wchar_t *const *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnve(int, const wchar_t *, const wchar_t *const *, const wchar_t *const *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnvp(int, const wchar_t *, const wchar_t *const *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _wspawnvpe(int, const wchar_t *, const wchar_t *const *, const wchar_t *const *); 




}
# 388 "d:\\mingw\\mingw\\include\\wchar.h" 3
extern "C" {
# 410 "d:\\mingw\\mingw\\include\\wchar.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcscat(wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcschr(const wchar_t *, wchar_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcscmp(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcscoll(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcscpy(wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcscspn(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcslen(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcsncmp(const wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcspbrk(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsrchr(const wchar_t *, wchar_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcsspn(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsstr(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcstok(wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcsxfrm(wchar_t *, const wchar_t *, size_t); 




__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcsdup(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcsicmp(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcsicoll(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcslwr(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcsnicmp(const wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcsnset(wchar_t *, wchar_t, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcsrev(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcsset(wchar_t *, wchar_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wcsupr(wchar_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcsncoll(const wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wcsnicoll(const wchar_t *, const wchar_t *, size_t); 
# 463 "d:\\mingw\\mingw\\include\\wchar.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int wcscmpi(const wchar_t *, const wchar_t *); 



__attribute((__always_inline__)) inline int wcscmpi(const wchar_t *__ws1, const wchar_t *__ws2) 
{ return _wcsicmp(__ws1, __ws2); } 
# 475
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsdup(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcsicmp(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcsicoll(const wchar_t *, const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcslwr(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wcsnicmp(const wchar_t *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsnset(wchar_t *, wchar_t, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsrev(wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsset(wchar_t *, wchar_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wcsupr(wchar_t *); 
# 509 "d:\\mingw\\mingw\\include\\wchar.h" 3
extern size_t __mingw_wcsnlen(const wchar_t *, size_t); 


__attribute((__always_inline__)) inline size_t wcsnlen(const wchar_t *__text, size_t __maxlen) 
{ return __mingw_wcsnlen(__text, __maxlen); } 
# 527 "d:\\mingw\\mingw\\include\\wchar.h" 3
typedef wchar_t _Wint_t; 


typedef int mbstate_t; 
# 539 "d:\\mingw\\mingw\\include\\wchar.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t btowc(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wctob(wint_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) size_t mbrlen(const char *, size_t, mbstate_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcrtomb(char *, wchar_t, mbstate_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *); 
# 563
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int fwide(FILE *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int mbsinit(const mbstate_t *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) inline int fwide(FILE *, int __mode) 
{ return __mode; } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int mbsinit(const mbstate_t *__ps) 
{ return (((__ps == __null) || (*__ps == (mbstate_t)(0)))); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wmemset(wchar_t *, wchar_t, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wmemchr(const wchar_t *, wchar_t, size_t); 
# 583
int wmemcmp(const wchar_t *, const wchar_t *, size_t); 


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long long wcstoll(const wchar_t *, wchar_t **, int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long long wcstoull(const wchar_t *, wchar_t **, int); 



}
# 62 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cwchar" 3
namespace std { 

using ::mbstate_t;
}
# 135 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cwchar" 3
extern "C++" {

namespace std { 



using ::wint_t;

using ::btowc;
using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::getwchar;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::putwc;
using ::putwchar;



using ::swscanf;
using ::ungetwc;
using ::vfwprintf;

using ::vfwscanf;
# 172
using ::vswscanf;

using ::vwprintf;

using ::vwscanf;

using ::wcrtomb;
using ::wcscat;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcsrtombs;
using ::wcsspn;
using ::wcstod;

using ::wcstof;

using ::wcstok;
using ::wcstol;
using ::wcstoul;
using ::wcsxfrm;
using ::wctob;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;



inline wchar_t *wcschr(wchar_t *__p, wchar_t __c) 
{ return wcschr(const_cast< const wchar_t *>(__p), __c); } 


inline wchar_t *wcspbrk(wchar_t *__s1, const wchar_t *__s2) 
{ return wcspbrk(const_cast< const wchar_t *>(__s1), __s2); } 


inline wchar_t *wcsrchr(wchar_t *__p, wchar_t __c) 
{ return wcsrchr(const_cast< const wchar_t *>(__p), __c); } 


inline wchar_t *wcsstr(wchar_t *__s1, const wchar_t *__s2) 
{ return wcsstr(const_cast< const wchar_t *>(__s1), __s2); } 


inline wchar_t *wmemchr(wchar_t *__p, wchar_t __c, size_t __n) 
{ return wmemchr(const_cast< const wchar_t *>(__p), __c, __n); } 



}
}
# 244
namespace __gnu_cxx { 
# 251
using ::wcstold;
# 260 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cwchar" 3
using ::wcstoll;
using ::wcstoull;

}

namespace std { 

using __gnu_cxx::wcstold;
using __gnu_cxx::wcstoll;
using __gnu_cxx::wcstoull;
}
# 280 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cwchar" 3
namespace std { 
# 300
}
# 68 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\postypes.h" 3
namespace std { 
# 90 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\postypes.h" 3
typedef long long streamoff; 
# 98
typedef ptrdiff_t streamsize; 
# 111 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\postypes.h" 3
template < typename _StateT > 
class fpos 
{ 
private : 
streamoff _M_off ; 
_StateT _M_state ; 

public : 




fpos () 
: _M_off (0) , _M_state () { } 
# 133 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\postypes.h" 3
fpos (streamoff __off) 
: _M_off (__off) , _M_state () { } 


fpos (const fpos &) = default ; 
fpos & operator = (const fpos &) = default ; 
~ fpos () = default ; 



operator streamoff () const { return _M_off ; } 


void 
state (_StateT __st) 
{ _M_state = __st ; } 


_StateT 
state () const 
{ return _M_state ; } 
# 159
fpos & 
operator += (streamoff __off) 
{ 
_M_off += __off ; 
return * this ; 
} 
# 170
fpos & 
operator -= (streamoff __off) 
{ 
_M_off -= __off ; 
return * this ; 
} 
# 183
fpos 
operator + (streamoff __off) const 
{ 
fpos __pos (* this) ; 
__pos += __off ; 
return __pos ; 
} 
# 197
fpos 
operator - (streamoff __off) const 
{ 
fpos __pos (* this) ; 
__pos -= __off ; 
return __pos ; 
} 
# 210
streamoff 
operator - (const fpos & __other) const 
{ return _M_off - __other . _M_off ; } 
} ;
# 220
template < typename _StateT > 
inline bool 
operator == (const fpos < _StateT > & __lhs , const fpos < _StateT > & __rhs) 
{ return streamoff (__lhs) == streamoff (__rhs) ; } 

template < typename _StateT > 
inline bool 
operator != (const fpos < _StateT > & __lhs , const fpos < _StateT > & __rhs) 
{ return streamoff (__lhs) != streamoff (__rhs) ; } 
# 234
typedef fpos< int>  streampos; 

typedef fpos< int>  wstreampos; 
# 245 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\postypes.h" 3
typedef fpos< int>  u16streampos; 

typedef fpos< int>  u32streampos; 



}
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iosfwd" 3
namespace std { 
# 74 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iosfwd" 3
class ios_base; 

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ios;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_streambuf;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_istream;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ostream;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_iostream;


inline namespace __cxx11 { 

template < typename _CharT, typename _Traits = char_traits < _CharT >,
     typename _Alloc = allocator < _CharT > >
    class basic_stringbuf;

template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_istringstream;

template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_ostringstream;

template < typename _CharT, typename _Traits = char_traits < _CharT >,
    typename _Alloc = allocator < _CharT > >
    class basic_stringstream;

}

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_filebuf;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ifstream;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_ofstream;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class basic_fstream;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class istreambuf_iterator;

template < typename _CharT, typename _Traits = char_traits < _CharT > >
    class ostreambuf_iterator;



typedef basic_ios< char>  ios; 


typedef basic_streambuf< char>  streambuf; 


typedef basic_istream< char>  istream; 


typedef basic_ostream< char>  ostream; 


typedef basic_iostream< char>  iostream; 


typedef __cxx11::basic_stringbuf< char>  stringbuf; 


typedef __cxx11::basic_istringstream< char>  istringstream; 


typedef __cxx11::basic_ostringstream< char>  ostringstream; 


typedef __cxx11::basic_stringstream< char>  stringstream; 


typedef basic_filebuf< char>  filebuf; 


typedef basic_ifstream< char>  ifstream; 


typedef basic_ofstream< char>  ofstream; 


typedef basic_fstream< char>  fstream; 



typedef basic_ios< wchar_t>  wios; 


typedef basic_streambuf< wchar_t>  wstreambuf; 


typedef basic_istream< wchar_t>  wistream; 


typedef basic_ostream< wchar_t>  wostream; 


typedef basic_iostream< wchar_t>  wiostream; 


typedef __cxx11::basic_stringbuf< wchar_t>  wstringbuf; 


typedef __cxx11::basic_istringstream< wchar_t>  wistringstream; 


typedef __cxx11::basic_ostringstream< wchar_t>  wostringstream; 


typedef __cxx11::basic_stringstream< wchar_t>  wstringstream; 


typedef basic_filebuf< wchar_t>  wfilebuf; 


typedef basic_ifstream< wchar_t>  wifstream; 


typedef basic_ofstream< wchar_t>  wofstream; 


typedef basic_fstream< wchar_t>  wfstream; 




}
# 35 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\exception" 3
#pragma GCC visibility push ( default )
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception.h" 3
#pragma GCC visibility push ( default )



extern "C++" {

namespace std { 
# 60 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception.h" 3
class exception { 


public: exception() noexcept { } 
virtual ~exception() noexcept; 

exception(const exception &) = default;
exception &operator=(const exception &) = default;
exception(exception &&) = default;
exception &operator=(exception &&) = default;
# 75
virtual const char *what() const noexcept; 
}; 

}

}

#pragma GCC visibility pop
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\exception" 3
extern "C++" {

namespace std { 



class bad_exception : public exception { 


public: bad_exception() noexcept { } 



virtual ~bad_exception() noexcept; 



virtual const char *what() const noexcept; 
}; 


typedef void (*terminate_handler)(void); 


typedef void (*unexpected_handler)(void); 


terminate_handler set_terminate(terminate_handler) noexcept; 



terminate_handler get_terminate() noexcept; 




void terminate() noexcept __attribute((__noreturn__)); 


unexpected_handler set_unexpected(unexpected_handler) noexcept; 



unexpected_handler get_unexpected() noexcept; 




void unexpected() __attribute((__noreturn__)); 
# 102 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\exception" 3
bool uncaught_exception() noexcept __attribute((__pure__)); 




int uncaught_exceptions() noexcept __attribute((__pure__)); 



}

namespace __gnu_cxx { 
# 133 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\exception" 3
void __verbose_terminate_handler(); 


}

}

#pragma GCC visibility pop
# 34 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception_ptr.h" 3
#pragma GCC visibility push ( default )
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cxxabi_init_exception.h" 3
#pragma GCC visibility push ( default )
# 426 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stddef.h" 3
typedef 
# 415
struct { 
long long __max_align_ll __attribute((__aligned__(__alignof__(long long)))); 
long double __max_align_ld __attribute((__aligned__(__alignof__(long double)))); 
# 424
__float128 __max_align_f128 __attribute((__aligned__(__alignof__(__float128)))); 

} max_align_t; 
# 433
typedef __decltype((nullptr)) nullptr_t; 
# 50 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cxxabi_init_exception.h" 3
namespace std { 

class type_info; 
}

namespace __cxxabiv1 { 

struct __cxa_refcounted_exception; 

extern "C" {



void *__cxa_allocate_exception(size_t) noexcept; 


void __cxa_free_exception(void *) noexcept; 



__cxa_refcounted_exception *__cxa_init_primary_exception(void * object, std::type_info * tinfo, void ( __attribute((__thiscall__))* dest)(void *) ) noexcept; 


}
}



#pragma GCC visibility pop
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\hash_bytes.h" 3
namespace std { 
# 47
size_t _Hash_bytes(const void * __ptr, size_t __len, size_t __seed); 
# 54
size_t _Fnv_hash_bytes(const void * __ptr, size_t __len, size_t __seed); 


}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\typeinfo" 3
#pragma GCC visibility push ( default )

extern "C++" {

namespace __cxxabiv1 { 

class __class_type_info; 
}
# 80 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\typeinfo" 3
namespace std { 
# 88
class type_info { 
# 95
public: virtual ~type_info(); 



const char *name() const noexcept 
{ return (__name[0] == '*') ? __name + 1 : __name; } 
# 106
bool before(const type_info & __arg) const noexcept; 
bool operator==(const type_info & __arg) const noexcept; 
# 136 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\typeinfo" 3
bool operator!=(const type_info &__arg) const noexcept 
{ return !this->operator==(__arg); } 


size_t hash_code() const noexcept 
{ 

return _Hash_bytes(this->name(), __builtin_strlen(this->name()), static_cast< size_t>(0xc70f6907UL)); 




} 



virtual bool __is_pointer_p() const; 


virtual bool __is_function_p() const; 
# 163
virtual bool __do_catch(const type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 



virtual bool __do_upcast(const __cxxabiv1::__class_type_info * __target, void ** __obj_ptr) const; 



protected: const char *__name; 

explicit type_info(const char *__n) : __name(__n) { } 



private: type_info &operator=(const type_info &); 
type_info(const type_info &); 
}; 
# 187
class bad_cast : public exception { 


public: bad_cast() noexcept { } 



virtual ~bad_cast() noexcept; 


virtual const char *what() const noexcept; 
}; 
# 204
class bad_typeid : public exception { 


public: bad_typeid() noexcept { } 



virtual ~bad_typeid() noexcept; 


virtual const char *what() const noexcept; 
}; 
}

}

#pragma GCC visibility pop
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\new" 3
#pragma GCC visibility push ( default )

extern "C++" {

namespace std { 
# 54
class bad_alloc : public exception { 


public: bad_alloc() throw() { } 


bad_alloc(const bad_alloc &) = default;
bad_alloc &operator=(const bad_alloc &) = default;




virtual ~bad_alloc() throw(); 


virtual const char *what() const throw(); 
}; 


class bad_array_new_length : public bad_alloc { 


public: bad_array_new_length() throw() { } 



virtual ~bad_array_new_length() throw(); 


virtual const char *what() const throw(); 
}; 
# 91
struct nothrow_t { 


explicit nothrow_t() = default;

}; 

extern const nothrow_t nothrow; 



typedef void (*new_handler)(void); 



new_handler set_new_handler(new_handler) throw(); 



new_handler get_new_handler() noexcept; 

}
# 125 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\new" 3
void *operator new(std::size_t) __attribute((__externally_visible__)); 

void *operator new[](std::size_t) __attribute((__externally_visible__)); 

void operator delete(void *) noexcept __attribute((__externally_visible__)); 

void operator delete[](void *) noexcept __attribute((__externally_visible__)); 
# 139
void *operator new(std::size_t, const std::nothrow_t &) noexcept __attribute((__externally_visible__, __malloc__)); 

void *operator new[](std::size_t, const std::nothrow_t &) noexcept __attribute((__externally_visible__, __malloc__)); 

void operator delete(void *, const std::nothrow_t &) noexcept __attribute((__externally_visible__)); 

void operator delete[](void *, const std::nothrow_t &) noexcept __attribute((__externally_visible__)); 
# 173 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\new" 3
inline void *operator new(std::size_t, void *__p) noexcept 
{ return __p; } 
inline void *operator new[](std::size_t, void *__p) noexcept 
{ return __p; } 


inline void operator delete(void *, void *) noexcept { } 
inline void operator delete[](void *, void *) noexcept { } 

}
# 226 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\new" 3
#pragma GCC visibility pop
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception_ptr.h" 3
extern "C++" {

namespace std { 

class type_info; 
# 52
namespace __exception_ptr { 

class exception_ptr; 
}

using __exception_ptr::exception_ptr;
# 63
__exception_ptr::exception_ptr current_exception() noexcept; 

template < typename _Ex >
  exception_ptr make_exception_ptr ( _Ex ) noexcept;


void rethrow_exception(__exception_ptr::exception_ptr) __attribute((__noreturn__)); 

namespace __exception_ptr { 

using std::rethrow_exception;
# 79
class exception_ptr { 

void *_M_exception_object; 

explicit exception_ptr(void * __e) noexcept; 

void _M_addref() noexcept; 
void _M_release() noexcept; 

void *_M_get() const noexcept __attribute((__pure__)); 

friend exception_ptr std::current_exception() noexcept; 
friend void std::rethrow_exception(exception_ptr); 
template < typename _Ex >
      friend exception_ptr std :: make_exception_ptr ( _Ex ) noexcept;


public: exception_ptr() noexcept; 

exception_ptr(const exception_ptr &) noexcept; 


exception_ptr(nullptr_t) noexcept : _M_exception_object((0)) 

{ } 

exception_ptr(exception_ptr &&__o) noexcept : _M_exception_object(__o._M_exception_object) 

{ __o._M_exception_object = 0; } 
# 118 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception_ptr.h" 3
exception_ptr &operator=(const exception_ptr &) noexcept; 



exception_ptr &operator=(exception_ptr &&__o) noexcept 
{ 
((exception_ptr)(static_cast< exception_ptr &&>(__o))).swap(*this); 
return *this; 
} 


~exception_ptr() noexcept; 


void swap(exception_ptr &) noexcept; 
# 144 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception_ptr.h" 3
explicit operator bool() const 
{ return _M_exception_object; } 



friend bool operator==(const exception_ptr &, const exception_ptr &) noexcept __attribute((__pure__)); 



const type_info *__cxa_exception_type() const noexcept __attribute((__pure__)); 

}; 


bool operator==(const exception_ptr &, const exception_ptr &) noexcept __attribute((__pure__)); 



bool operator!=(const exception_ptr &, const exception_ptr &) noexcept __attribute((__pure__)); 



inline void swap(exception_ptr &__lhs, exception_ptr &__rhs) 
{ __lhs.swap(__rhs); } 

template < typename _Ex > 
inline void 
__dest_thunk (void * __x) 
{ static_cast < _Ex * > (__x) -> ~ _Ex () ; } 

}


template < typename _Ex > 
exception_ptr 
make_exception_ptr (_Ex __ex) noexcept 
{ 
# 197 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\exception_ptr.h" 3
try 
{ 
throw __ex ; 
} 
catch (...) 
{ 
return current_exception () ; 
} 



} 


}

}

#pragma GCC visibility pop
# 33 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\nested_exception.h" 3
#pragma GCC visibility push ( default )
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
namespace std { 
# 45
template < typename _Tp > 
inline constexpr _Tp * 
__addressof (_Tp & __r) noexcept 
{ return __builtin_addressof (__r) ; } 




}
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
namespace std { 
# 56 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp , _Tp __v > 
struct integral_constant 
{ 
static constexpr _Tp value = __v ; 
typedef _Tp value_type ; 
typedef integral_constant < _Tp , __v > type ; 
constexpr operator value_type () const noexcept { return value ; } 
# 69
} ;

template < typename _Tp, _Tp __v >
    constexpr _Tp integral_constant < _Tp, __v > :: value;


typedef integral_constant< bool, true>  true_type; 


typedef integral_constant< bool, false>  false_type; 

template < bool __v >
    using __bool_constant = integral_constant < bool, __v >;
# 91 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < bool, typename, typename >
    struct conditional;

template < typename ... >
    struct __or_;


template<> struct __or_< >  : public false_type { 

}; 

template < typename _B1 > 
struct __or_ < _B1 > 
: public _B1 
{ } ;

template < typename _B1 , typename _B2 > 
struct __or_ < _B1 , _B2 > 
: public conditional < _B1 :: value , _B1 , _B2 > :: type 
{ } ;

template < typename _B1 , typename _B2 , typename _B3 , typename ... _Bn > 
struct __or_ < _B1 , _B2 , _B3 , _Bn ... > 
: public conditional < _B1 :: value , _B1 , __or_ < _B2 , _B3 , _Bn ... > > :: type 
{ } ;

template < typename ... >
    struct __and_;


template<> struct __and_< >  : public true_type { 

}; 

template < typename _B1 > 
struct __and_ < _B1 > 
: public _B1 
{ } ;

template < typename _B1 , typename _B2 > 
struct __and_ < _B1 , _B2 > 
: public conditional < _B1 :: value , _B2 , _B1 > :: type 
{ } ;

template < typename _B1 , typename _B2 , typename _B3 , typename ... _Bn > 
struct __and_ < _B1 , _B2 , _B3 , _Bn ... > 
: public conditional < _B1 :: value , __and_ < _B2 , _B3 , _Bn ... > , _B1 > :: type 
{ } ;

template < typename _Pp > 
struct __not_ 
: public __bool_constant < ! bool (_Pp :: value) > 
{ } ;
# 185 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct __success_type 
{ typedef _Tp type ; } ;

struct __failure_type { 
}; 



template < typename >
    struct remove_cv;

template < typename > 
struct __is_void_helper 
: public false_type { } ;


template<> struct __is_void_helper< void>  : public true_type { 
}; 


template < typename _Tp > 
struct is_void 
: public __is_void_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;

template < typename > 
struct __is_integral_helper 
: public false_type { } ;


template<> struct __is_integral_helper< bool>  : public true_type { 
}; 


template<> struct __is_integral_helper< char>  : public true_type { 
}; 


template<> struct __is_integral_helper< signed char>  : public true_type { 
}; 


template<> struct __is_integral_helper< unsigned char>  : public true_type { 
}; 



template<> struct __is_integral_helper< wchar_t>  : public true_type { 
}; 
# 244 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template<> struct __is_integral_helper< char16_t>  : public true_type { 
}; 


template<> struct __is_integral_helper< char32_t>  : public true_type { 
}; 


template<> struct __is_integral_helper< short>  : public true_type { 
}; 


template<> struct __is_integral_helper< unsigned short>  : public true_type { 
}; 


template<> struct __is_integral_helper< int>  : public true_type { 
}; 


template<> struct __is_integral_helper< unsigned>  : public true_type { 
}; 


template<> struct __is_integral_helper< long>  : public true_type { 
}; 


template<> struct __is_integral_helper< unsigned long>  : public true_type { 
}; 


template<> struct __is_integral_helper< long long>  : public true_type { 
}; 


template<> struct __is_integral_helper< unsigned long long>  : public true_type { 
}; 
# 323 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct is_integral 
: public __is_integral_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;

template < typename > 
struct __is_floating_point_helper 
: public false_type { } ;


template<> struct __is_floating_point_helper< float>  : public true_type { 
}; 


template<> struct __is_floating_point_helper< double>  : public true_type { 
}; 


template<> struct __is_floating_point_helper< long double>  : public true_type { 
}; 



template<> struct __is_floating_point_helper< __float128>  : public true_type { 
}; 



template < typename _Tp > 
struct is_floating_point 
: public __is_floating_point_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;


template < typename > 
struct is_array 
: public false_type { } ;

template < typename _Tp , std :: size_t _Size > 
struct is_array < _Tp [ _Size ] > 
: public true_type { } ;

template < typename _Tp > 
struct is_array < _Tp [ ] > 
: public true_type { } ;

template < typename > 
struct __is_pointer_helper 
: public false_type { } ;

template < typename _Tp > 
struct __is_pointer_helper < _Tp * > 
: public true_type { } ;


template < typename _Tp > 
struct is_pointer 
: public __is_pointer_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;


template < typename > 
struct is_lvalue_reference 
: public false_type { } ;

template < typename _Tp > 
struct is_lvalue_reference < _Tp & > 
: public true_type { } ;


template < typename > 
struct is_rvalue_reference 
: public false_type { } ;

template < typename _Tp > 
struct is_rvalue_reference < _Tp && > 
: public true_type { } ;

template < typename >
    struct is_function;

template < typename > 
struct __is_member_object_pointer_helper 
: public false_type { } ;

template < typename _Tp , typename _Cp > 
struct __is_member_object_pointer_helper < _Tp _Cp :: * > 
: public __not_ < is_function < _Tp > > :: type { } ;


template < typename _Tp > 
struct is_member_object_pointer 
: public __is_member_object_pointer_helper < 
typename remove_cv < _Tp > :: type > :: type 
{ } ;

template < typename > 
struct __is_member_function_pointer_helper 
: public false_type { } ;

template < typename _Tp , typename _Cp > 
struct __is_member_function_pointer_helper < _Tp _Cp :: * > 
: public is_function < _Tp > :: type { } ;


template < typename _Tp > 
struct is_member_function_pointer 
: public __is_member_function_pointer_helper < 
typename remove_cv < _Tp > :: type > :: type 
{ } ;


template < typename _Tp > 
struct is_enum 
: public integral_constant < bool , __is_enum (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_union 
: public integral_constant < bool , __is_union (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_class 
: public integral_constant < bool , __is_class (_Tp) > 
{ } ;


template < typename > 
struct is_function 
: public false_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) volatile > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) volatile & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) volatile && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) volatile > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) volatile & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) volatile && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const volatile > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const volatile & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ...) const volatile && > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const volatile > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const volatile & > 
: public true_type { } ;

template < typename _Res , typename ... _ArgTypes > 
struct is_function < _Res (_ArgTypes ... ...) const volatile && > 
: public true_type { } ;



template < typename > 
struct __is_null_pointer_helper 
: public false_type { } ;


template<> struct __is_null_pointer_helper< __decltype((nullptr))>  : public true_type { 
}; 


template < typename _Tp > 
struct is_null_pointer 
: public __is_null_pointer_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;


template < typename _Tp > 
struct __is_nullptr_t 
: public is_null_pointer < _Tp > 
{ } ;




template < typename _Tp > 
struct is_reference 
: public __or_ < is_lvalue_reference < _Tp > , 
is_rvalue_reference < _Tp > > :: type 
{ } ;


template < typename _Tp > 
struct is_arithmetic 
: public __or_ < is_integral < _Tp > , is_floating_point < _Tp > > :: type 
{ } ;


template < typename _Tp > 
struct is_fundamental 
: public __or_ < is_arithmetic < _Tp > , is_void < _Tp > , 
is_null_pointer < _Tp > > :: type 
{ } ;


template < typename _Tp > 
struct is_object 
: public __not_ < __or_ < is_function < _Tp > , is_reference < _Tp > , 
is_void < _Tp > > > :: type 
{ } ;

template < typename >
    struct is_member_pointer;


template < typename _Tp > 
struct is_scalar 
: public __or_ < is_arithmetic < _Tp > , is_enum < _Tp > , is_pointer < _Tp > , 
is_member_pointer < _Tp > , is_null_pointer < _Tp > > :: type 
{ } ;


template < typename _Tp > 
struct is_compound 
: public __not_ < is_fundamental < _Tp > > :: type { } ;

template < typename _Tp > 
struct __is_member_pointer_helper 
: public false_type { } ;

template < typename _Tp , typename _Cp > 
struct __is_member_pointer_helper < _Tp _Cp :: * > 
: public true_type { } ;


template < typename _Tp > 
struct is_member_pointer 
: public __is_member_pointer_helper < typename remove_cv < _Tp > :: type > :: type 
{ } ;



template < typename _Tp > 
struct __is_referenceable 
: public __or_ < is_object < _Tp > , is_reference < _Tp > > :: type 
{ } ;

template < typename _Res , typename ... _Args > 
struct __is_referenceable < _Res (_Args ...) > 
: public true_type 
{ } ;

template < typename _Res , typename ... _Args > 
struct __is_referenceable < _Res (_Args ... ...) > 
: public true_type 
{ } ;




template < typename > 
struct is_const 
: public false_type { } ;

template < typename _Tp > 
struct is_const < _Tp const > 
: public true_type { } ;


template < typename > 
struct is_volatile 
: public false_type { } ;

template < typename _Tp > 
struct is_volatile < _Tp volatile > 
: public true_type { } ;


template < typename _Tp > 
struct is_trivial 
: public integral_constant < bool , __is_trivial (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_trivially_copyable 
: public integral_constant < bool , __is_trivially_copyable (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_standard_layout 
: public integral_constant < bool , __is_standard_layout (_Tp) > 
{ } ;



template < typename _Tp > 
struct is_pod 
: public integral_constant < bool , __is_pod (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_literal_type 
: public integral_constant < bool , __is_literal_type (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_empty 
: public integral_constant < bool , __is_empty (_Tp) > 
{ } ;


template < typename _Tp > 
struct is_polymorphic 
: public integral_constant < bool , __is_polymorphic (_Tp) > 
{ } ;
# 723 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct is_abstract 
: public integral_constant < bool , __is_abstract (_Tp) > 
{ } ;

template < typename _Tp , 
bool = is_arithmetic < _Tp > :: value > 
struct __is_signed_helper 
: public false_type { } ;

template < typename _Tp > 
struct __is_signed_helper < _Tp , true > 
: public integral_constant < bool , _Tp (- 1) < _Tp (0) > 
{ } ;


template < typename _Tp > 
struct is_signed 
: public __is_signed_helper < _Tp > :: type 
{ } ;


template < typename _Tp > 
struct is_unsigned 
: public __and_ < is_arithmetic < _Tp > , __not_ < is_signed < _Tp > > > 
{ } ;
# 758 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp, typename _Up = _Tp && >
    _Up
    __declval ( int );

template < typename _Tp >
    _Tp
    __declval ( long );

template < typename _Tp >
    auto declval ( ) noexcept -> __decltype ( __declval < _Tp > ( 0 ) );

template < typename, unsigned = 0 >
    struct extent;

template < typename >
    struct remove_all_extents;

template < typename _Tp > 
struct __is_array_known_bounds 
: public integral_constant < bool , (extent < _Tp > :: value > 0) > 
{ } ;

template < typename _Tp > 
struct __is_array_unknown_bounds 
: public __and_ < is_array < _Tp > , __not_ < extent < _Tp > > > 
{ } ;
# 790
struct __do_is_destructible_impl { 

template < typename _Tp, typename = __decltype ( declval < _Tp & > ( ) . ~ _Tp ( ) ) >
      static true_type __test ( int );

template < typename >
      static false_type __test ( ... );
}; 

template < typename _Tp > 
struct __is_destructible_impl 
: public __do_is_destructible_impl 
{ 
typedef decltype (__test < _Tp > (0)) type ; 
} ;

template < typename _Tp,
           bool = __or_ < is_void < _Tp >,
                        __is_array_unknown_bounds < _Tp >,
                        is_function < _Tp > > :: value,
           bool = __or_ < is_reference < _Tp >, is_scalar < _Tp > > :: value >
    struct __is_destructible_safe;

template < typename _Tp > 
struct __is_destructible_safe < _Tp , false , false > 
: public __is_destructible_impl < typename 
remove_all_extents < _Tp > :: type > :: type 
{ } ;

template < typename _Tp > 
struct __is_destructible_safe < _Tp , true , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_destructible_safe < _Tp , false , true > 
: public true_type { } ;


template < typename _Tp > 
struct is_destructible 
: public __is_destructible_safe < _Tp > :: type 
{ } ;
# 837
struct __do_is_nt_destructible_impl { 

template < typename _Tp >
      static __bool_constant < noexcept ( declval < _Tp & > ( ) . ~ _Tp ( ) ) >
      __test ( int );

template < typename >
      static false_type __test ( ... );
}; 

template < typename _Tp > 
struct __is_nt_destructible_impl 
: public __do_is_nt_destructible_impl 
{ 
typedef decltype (__test < _Tp > (0)) type ; 
} ;

template < typename _Tp,
           bool = __or_ < is_void < _Tp >,
                        __is_array_unknown_bounds < _Tp >,
                        is_function < _Tp > > :: value,
           bool = __or_ < is_reference < _Tp >, is_scalar < _Tp > > :: value >
    struct __is_nt_destructible_safe;

template < typename _Tp > 
struct __is_nt_destructible_safe < _Tp , false , false > 
: public __is_nt_destructible_impl < typename 
remove_all_extents < _Tp > :: type > :: type 
{ } ;

template < typename _Tp > 
struct __is_nt_destructible_safe < _Tp , true , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_nt_destructible_safe < _Tp , false , true > 
: public true_type { } ;


template < typename _Tp > 
struct is_nothrow_destructible 
: public __is_nt_destructible_safe < _Tp > :: type 
{ } ;


template < typename _Tp , typename ... _Args > 
struct is_constructible 
: public __bool_constant < __is_constructible (_Tp , _Args ...) > 
{ } ;


template < typename _Tp > 
struct is_default_constructible 
: public is_constructible < _Tp > :: type 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_copy_constructible_impl;

template < typename _Tp > 
struct __is_copy_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_copy_constructible_impl < _Tp , true > 
: public is_constructible < _Tp , const _Tp & > 
{ } ;


template < typename _Tp > 
struct is_copy_constructible 
: public __is_copy_constructible_impl < _Tp > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_move_constructible_impl;

template < typename _Tp > 
struct __is_move_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_move_constructible_impl < _Tp , true > 
: public is_constructible < _Tp , _Tp && > 
{ } ;


template < typename _Tp > 
struct is_move_constructible 
: public __is_move_constructible_impl < _Tp > 
{ } ;

template < typename _Tp > 
struct __is_nt_default_constructible_atom 
: public integral_constant < bool , noexcept (_Tp ()) > 
{ } ;

template < typename _Tp, bool = is_array < _Tp > :: value >
    struct __is_nt_default_constructible_impl;

template < typename _Tp > 
struct __is_nt_default_constructible_impl < _Tp , true > 
: public __and_ < __is_array_known_bounds < _Tp > , 
__is_nt_default_constructible_atom < typename 
remove_all_extents < _Tp > :: type > > 
{ } ;

template < typename _Tp > 
struct __is_nt_default_constructible_impl < _Tp , false > 
: public __is_nt_default_constructible_atom < _Tp > 
{ } ;


template < typename _Tp > 
struct is_nothrow_default_constructible 
: public __and_ < is_default_constructible < _Tp > , 
__is_nt_default_constructible_impl < _Tp > > 
{ } ;

template < typename _Tp , typename ... _Args > 
struct __is_nt_constructible_impl 
: public integral_constant < bool , noexcept (_Tp (declval < _Args > () ...)) > 
{ } ;

template < typename _Tp , typename _Arg > 
struct __is_nt_constructible_impl < _Tp , _Arg > 
: public integral_constant < bool , 
noexcept (static_cast < _Tp > (declval < _Arg > ())) > 
{ } ;

template < typename _Tp > 
struct __is_nt_constructible_impl < _Tp > 
: public is_nothrow_default_constructible < _Tp > 
{ } ;


template < typename _Tp , typename ... _Args > 
struct is_nothrow_constructible 
: public __and_ < is_constructible < _Tp , _Args ... > , 
__is_nt_constructible_impl < _Tp , _Args ... > > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nothrow_copy_constructible_impl;

template < typename _Tp > 
struct __is_nothrow_copy_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_nothrow_copy_constructible_impl < _Tp , true > 
: public is_nothrow_constructible < _Tp , const _Tp & > 
{ } ;


template < typename _Tp > 
struct is_nothrow_copy_constructible 
: public __is_nothrow_copy_constructible_impl < _Tp > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nothrow_move_constructible_impl;

template < typename _Tp > 
struct __is_nothrow_move_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_nothrow_move_constructible_impl < _Tp , true > 
: public is_nothrow_constructible < _Tp , _Tp && > 
{ } ;


template < typename _Tp > 
struct is_nothrow_move_constructible 
: public __is_nothrow_move_constructible_impl < _Tp > 
{ } ;


template < typename _Tp , typename _Up > 
struct is_assignable 
: public __bool_constant < __is_assignable (_Tp , _Up) > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_copy_assignable_impl;

template < typename _Tp > 
struct __is_copy_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_copy_assignable_impl < _Tp , true > 
: public is_assignable < _Tp & , const _Tp & > 
{ } ;


template < typename _Tp > 
struct is_copy_assignable 
: public __is_copy_assignable_impl < _Tp > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_move_assignable_impl;

template < typename _Tp > 
struct __is_move_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_move_assignable_impl < _Tp , true > 
: public is_assignable < _Tp & , _Tp && > 
{ } ;


template < typename _Tp > 
struct is_move_assignable 
: public __is_move_assignable_impl < _Tp > 
{ } ;

template < typename _Tp , typename _Up > 
struct __is_nt_assignable_impl 
: public integral_constant < bool , noexcept (declval < _Tp > () = declval < _Up > ()) > 
{ } ;


template < typename _Tp , typename _Up > 
struct is_nothrow_assignable 
: public __and_ < is_assignable < _Tp , _Up > , 
__is_nt_assignable_impl < _Tp , _Up > > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nt_copy_assignable_impl;

template < typename _Tp > 
struct __is_nt_copy_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_nt_copy_assignable_impl < _Tp , true > 
: public is_nothrow_assignable < _Tp & , const _Tp & > 
{ } ;


template < typename _Tp > 
struct is_nothrow_copy_assignable 
: public __is_nt_copy_assignable_impl < _Tp > 
{ } ;

template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_nt_move_assignable_impl;

template < typename _Tp > 
struct __is_nt_move_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_nt_move_assignable_impl < _Tp , true > 
: public is_nothrow_assignable < _Tp & , _Tp && > 
{ } ;


template < typename _Tp > 
struct is_nothrow_move_assignable 
: public __is_nt_move_assignable_impl < _Tp > 
{ } ;


template < typename _Tp , typename ... _Args > 
struct is_trivially_constructible 
: public __bool_constant < __is_trivially_constructible (_Tp , _Args ...) > 
{ } ;


template < typename _Tp > 
struct is_trivially_default_constructible 
: public is_trivially_constructible < _Tp > :: type 
{ } ;

struct __do_is_implicitly_default_constructible_impl { 

template < typename _Tp >
    static void __helper ( const _Tp & );

template < typename _Tp >
    static true_type __test ( const _Tp &,
                            __decltype ( __helper < const _Tp & > ( { } ) ) * = 0 );

static false_type __test(...); 
}; 

template < typename _Tp > 
struct __is_implicitly_default_constructible_impl 
: public __do_is_implicitly_default_constructible_impl 
{ 
typedef decltype (__test (declval < _Tp > ())) type ; 
} ;

template < typename _Tp > 
struct __is_implicitly_default_constructible_safe 
: public __is_implicitly_default_constructible_impl < _Tp > :: type 
{ } ;

template < typename _Tp > 
struct __is_implicitly_default_constructible 
: public __and_ < is_default_constructible < _Tp > , 
__is_implicitly_default_constructible_safe < _Tp > > 
{ } ;



template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_trivially_copy_constructible_impl;

template < typename _Tp > 
struct __is_trivially_copy_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_trivially_copy_constructible_impl < _Tp , true > 
: public __and_ < is_copy_constructible < _Tp > , 
integral_constant < bool , 
__is_trivially_constructible (_Tp , const _Tp &) > > 
{ } ;

template < typename _Tp > 
struct is_trivially_copy_constructible 
: public __is_trivially_copy_constructible_impl < _Tp > 
{ } ;



template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_trivially_move_constructible_impl;

template < typename _Tp > 
struct __is_trivially_move_constructible_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_trivially_move_constructible_impl < _Tp , true > 
: public __and_ < is_move_constructible < _Tp > , 
integral_constant < bool , 
__is_trivially_constructible (_Tp , _Tp &&) > > 
{ } ;

template < typename _Tp > 
struct is_trivially_move_constructible 
: public __is_trivially_move_constructible_impl < _Tp > 
{ } ;


template < typename _Tp , typename _Up > 
struct is_trivially_assignable 
: public __bool_constant < __is_trivially_assignable (_Tp , _Up) > 
{ } ;



template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_trivially_copy_assignable_impl;

template < typename _Tp > 
struct __is_trivially_copy_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_trivially_copy_assignable_impl < _Tp , true > 
: public __bool_constant < __is_trivially_assignable (_Tp & , const _Tp &) > 
{ } ;

template < typename _Tp > 
struct is_trivially_copy_assignable 
: public __is_trivially_copy_assignable_impl < _Tp > 
{ } ;



template < typename _Tp, bool = __is_referenceable < _Tp > :: value >
    struct __is_trivially_move_assignable_impl;

template < typename _Tp > 
struct __is_trivially_move_assignable_impl < _Tp , false > 
: public false_type { } ;

template < typename _Tp > 
struct __is_trivially_move_assignable_impl < _Tp , true > 
: public __bool_constant < __is_trivially_assignable (_Tp & , _Tp &&) > 
{ } ;

template < typename _Tp > 
struct is_trivially_move_assignable 
: public __is_trivially_move_assignable_impl < _Tp > 
{ } ;


template < typename _Tp > 
struct is_trivially_destructible 
: public __and_ < is_destructible < _Tp > , 
__bool_constant < __has_trivial_destructor (_Tp) > > 
{ } ;



template < typename _Tp > 
struct has_virtual_destructor 
: public integral_constant < bool , __has_virtual_destructor (_Tp) > 
{ } ;
# 1251
template < typename _Tp > 
struct alignment_of 
: public integral_constant < std :: size_t , alignof (_Tp) > { } ;


template < typename > 
struct rank 
: public integral_constant < std :: size_t , 0 > { } ;

template < typename _Tp , std :: size_t _Size > 
struct rank < _Tp [ _Size ] > 
: public integral_constant < std :: size_t , 1 + rank < _Tp > :: value > { } ;

template < typename _Tp > 
struct rank < _Tp [ ] > 
: public integral_constant < std :: size_t , 1 + rank < _Tp > :: value > { } ;


template < typename , unsigned _Uint > 
struct extent 
: public integral_constant < std :: size_t , 0 > { } ;

template < typename _Tp , unsigned _Uint , std :: size_t _Size > 
struct extent < _Tp [ _Size ] , _Uint > 
: public integral_constant < std :: size_t , 
_Uint == 0 ? _Size : extent < _Tp , 
_Uint - 1 > :: value > 
{ } ;

template < typename _Tp , unsigned _Uint > 
struct extent < _Tp [ ] , _Uint > 
: public integral_constant < std :: size_t , 
_Uint == 0 ? 0 : extent < _Tp , 
_Uint - 1 > :: value > 
{ } ;
# 1291
template < typename , typename > 
struct is_same 
: public false_type { } ;

template < typename _Tp > 
struct is_same < _Tp , _Tp > 
: public true_type { } ;


template < typename _Base , typename _Derived > 
struct is_base_of 
: public integral_constant < bool , __is_base_of (_Base , _Derived) > 
{ } ;

template < typename _From , typename _To , 
bool = __or_ < is_void < _From > , is_function < _To > , 
is_array < _To > > :: value > 
struct __is_convertible_helper 
{ 
typedef typename is_void < _To > :: type type ; 
} ;

template < typename _From , typename _To > 
class __is_convertible_helper < _From , _To , false > 
{ 
template < typename _To1 > 
static void __test_aux (_To1) noexcept ; 

template < typename _From1 , typename _To1 , 
typename = decltype (__test_aux < _To1 > (std :: declval < _From1 > ())) > 
static true_type 
__test (int) ; 

template < typename , typename > 
static false_type 
__test (...) ; 

public : 
typedef decltype (__test < _From , _To > (0)) type ; 
} ;



template < typename _From , typename _To > 
struct is_convertible 
: public __is_convertible_helper < _From , _To > :: type 
{ } ;
# 1380 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct remove_const 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct remove_const < _Tp const > 
{ typedef _Tp type ; } ;


template < typename _Tp > 
struct remove_volatile 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct remove_volatile < _Tp volatile > 
{ typedef _Tp type ; } ;


template < typename _Tp > 
struct remove_cv 
{ 
typedef typename 
remove_const < typename remove_volatile < _Tp > :: type > :: type type ; 
} ;


template < typename _Tp > 
struct add_const 
{ typedef _Tp const type ; } ;


template < typename _Tp > 
struct add_volatile 
{ typedef _Tp volatile type ; } ;


template < typename _Tp > 
struct add_cv 
{ 
typedef typename 
add_const < typename add_volatile < _Tp > :: type > :: type type ; 
} ;
# 1455 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct remove_reference 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct remove_reference < _Tp & > 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct remove_reference < _Tp && > 
{ typedef _Tp type ; } ;

template < typename _Tp , bool = __is_referenceable < _Tp > :: value > 
struct __add_lvalue_reference_helper 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct __add_lvalue_reference_helper < _Tp , true > 
{ typedef _Tp & type ; } ;


template < typename _Tp > 
struct add_lvalue_reference 
: public __add_lvalue_reference_helper < _Tp > 
{ } ;

template < typename _Tp , bool = __is_referenceable < _Tp > :: value > 
struct __add_rvalue_reference_helper 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct __add_rvalue_reference_helper < _Tp , true > 
{ typedef _Tp && type ; } ;


template < typename _Tp > 
struct add_rvalue_reference 
: public __add_rvalue_reference_helper < _Tp > 
{ } ;
# 1512 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Unqualified, bool _IsConst, bool _IsVol >
    struct __cv_selector;

template < typename _Unqualified > 
struct __cv_selector < _Unqualified , false , false > 
{ typedef _Unqualified __type ; } ;

template < typename _Unqualified > 
struct __cv_selector < _Unqualified , false , true > 
{ typedef volatile _Unqualified __type ; } ;

template < typename _Unqualified > 
struct __cv_selector < _Unqualified , true , false > 
{ typedef const _Unqualified __type ; } ;

template < typename _Unqualified > 
struct __cv_selector < _Unqualified , true , true > 
{ typedef const volatile _Unqualified __type ; } ;

template < typename _Qualified , typename _Unqualified , 
bool _IsConst = is_const < _Qualified > :: value , 
bool _IsVol = is_volatile < _Qualified > :: value > 
class __match_cv_qualifiers 
{ 
typedef __cv_selector < _Unqualified , _IsConst , _IsVol > __match ; 

public : 
typedef typename __match :: __type __type ; 
} ;


template < typename _Tp > 
struct __make_unsigned 
{ typedef _Tp __type ; } ;


template<> struct __make_unsigned< char>  { 
typedef unsigned char __type; }; 


template<> struct __make_unsigned< signed char>  { 
typedef unsigned char __type; }; 


template<> struct __make_unsigned< short>  { 
typedef unsigned short __type; }; 


template<> struct __make_unsigned< int>  { 
typedef unsigned __type; }; 


template<> struct __make_unsigned< long>  { 
typedef unsigned long __type; }; 


template<> struct __make_unsigned< long long>  { 
typedef unsigned long long __type; }; 
# 1593 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp,
    bool _IsInt = is_integral < _Tp > :: value,
    bool _IsEnum = is_enum < _Tp > :: value >
    class __make_unsigned_selector;

template < typename _Tp > 
class __make_unsigned_selector < _Tp , true , false > 
{ 
using __unsigned_type 
= typename __make_unsigned < typename remove_cv < _Tp > :: type > :: __type ; 

public : 
using __type 
= typename __match_cv_qualifiers < _Tp , __unsigned_type > :: __type ; 
} ;

class __make_unsigned_selector_base { 


protected: template < typename ... > struct _List { } ;

template < typename _Tp , typename ... _Up > 
struct _List < _Tp , _Up ... > : _List < _Up ... > 
{ static constexpr size_t __size = sizeof (_Tp) ; } ;

template < size_t _Sz, typename _Tp, bool = ( _Sz <= _Tp :: __size ) >
      struct __select;

template < size_t _Sz , typename _Uint , typename ... _UInts > 
struct __select < _Sz , _List < _Uint , _UInts ... > , true > 
{ using __type = _Uint ; } ;

template < size_t _Sz , typename _Uint , typename ... _UInts > 
struct __select < _Sz , _List < _Uint , _UInts ... > , false > 
: __select < _Sz , _List < _UInts ... > > 
{ } ;
}; 


template < typename _Tp > 
class __make_unsigned_selector < _Tp , false , true > 
: __make_unsigned_selector_base 
{ 

using _UInts = _List < unsigned char , unsigned short , unsigned int , 
unsigned long , unsigned long long > ; 

using __unsigned_type = typename __select < sizeof (_Tp) , _UInts > :: __type ; 

public : 
using __type 
= typename __match_cv_qualifiers < _Tp , __unsigned_type > :: __type ; 
} ;
# 1653
template<> struct __make_unsigned< wchar_t>  { 

using __type = __make_unsigned_selector< wchar_t, false, true> ::__type; 

}; 
# 1670 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template<> struct __make_unsigned< char16_t>  { 

using __type = __make_unsigned_selector< char16_t, false, true> ::__type; 

}; 


template<> struct __make_unsigned< char32_t>  { 

using __type = __make_unsigned_selector< char32_t, false, true> ::__type; 

}; 
# 1687
template < typename _Tp > 
struct make_unsigned 
{ typedef typename __make_unsigned_selector < _Tp > :: __type type ; } ;



template<> struct make_unsigned< bool> ; 



template < typename _Tp > 
struct __make_signed 
{ typedef _Tp __type ; } ;


template<> struct __make_signed< char>  { 
typedef signed char __type; }; 


template<> struct __make_signed< unsigned char>  { 
typedef signed char __type; }; 


template<> struct __make_signed< unsigned short>  { 
typedef signed short __type; }; 


template<> struct __make_signed< unsigned>  { 
typedef signed int __type; }; 


template<> struct __make_signed< unsigned long>  { 
typedef signed long __type; }; 


template<> struct __make_signed< unsigned long long>  { 
typedef signed long long __type; }; 
# 1747 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp,
    bool _IsInt = is_integral < _Tp > :: value,
    bool _IsEnum = is_enum < _Tp > :: value >
    class __make_signed_selector;

template < typename _Tp > 
class __make_signed_selector < _Tp , true , false > 
{ 
using __signed_type 
= typename __make_signed < typename remove_cv < _Tp > :: type > :: __type ; 

public : 
using __type 
= typename __match_cv_qualifiers < _Tp , __signed_type > :: __type ; 
} ;


template < typename _Tp > 
class __make_signed_selector < _Tp , false , true > 
{ 
typedef typename __make_unsigned_selector < _Tp > :: __type __unsigned_type ; 

public : 
typedef typename __make_signed_selector < __unsigned_type > :: __type __type ; 
} ;
# 1779
template<> struct __make_signed< wchar_t>  { 

using __type = __make_signed_selector< wchar_t, false, true> ::__type; 

}; 
# 1796 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template<> struct __make_signed< char16_t>  { 

using __type = __make_signed_selector< char16_t, false, true> ::__type; 

}; 


template<> struct __make_signed< char32_t>  { 

using __type = __make_signed_selector< char32_t, false, true> ::__type; 

}; 
# 1813
template < typename _Tp > 
struct make_signed 
{ typedef typename __make_signed_selector < _Tp > :: __type type ; } ;



template<> struct make_signed< bool> ; 
# 1834 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp > 
struct remove_extent 
{ typedef _Tp type ; } ;

template < typename _Tp , std :: size_t _Size > 
struct remove_extent < _Tp [ _Size ] > 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct remove_extent < _Tp [ ] > 
{ typedef _Tp type ; } ;


template < typename _Tp > 
struct remove_all_extents 
{ typedef _Tp type ; } ;

template < typename _Tp , std :: size_t _Size > 
struct remove_all_extents < _Tp [ _Size ] > 
{ typedef typename remove_all_extents < _Tp > :: type type ; } ;

template < typename _Tp > 
struct remove_all_extents < _Tp [ ] > 
{ typedef typename remove_all_extents < _Tp > :: type type ; } ;
# 1871 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp , typename > 
struct __remove_pointer_helper 
{ typedef _Tp type ; } ;

template < typename _Tp , typename _Up > 
struct __remove_pointer_helper < _Tp , _Up * > 
{ typedef _Up type ; } ;


template < typename _Tp > 
struct remove_pointer 
: public __remove_pointer_helper < _Tp , typename remove_cv < _Tp > :: type > 
{ } ;


template < typename _Tp , bool = __or_ < __is_referenceable < _Tp > , 
is_void < _Tp > > :: value > 
struct __add_pointer_helper 
{ typedef _Tp type ; } ;

template < typename _Tp > 
struct __add_pointer_helper < _Tp , true > 
{ typedef typename remove_reference < _Tp > :: type * type ; } ;

template < typename _Tp > 
struct add_pointer 
: public __add_pointer_helper < _Tp > 
{ } ;
# 1910 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < std :: size_t _Len > 
struct __aligned_storage_msa 
{ 
union __type 
{ 
unsigned char __data [ _Len ] ; 
struct __attribute__ ((__aligned__)) { } __align ; 
} ; 
} ;
# 1930 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < std :: size_t _Len , std :: size_t _Align = 
__alignof__ (typename __aligned_storage_msa < _Len > :: __type) > 
struct aligned_storage 
{ 
union type 
{ 
unsigned char __data [ _Len ] ; 
struct __attribute__ ((__aligned__ ((_Align)))) { } __align ; 
} ; 
} ;

template < typename ... _Types > 
struct __strictest_alignment 
{ 
static const size_t _S_alignment = 0 ; 
static const size_t _S_size = 0 ; 
} ;

template < typename _Tp , typename ... _Types > 
struct __strictest_alignment < _Tp , _Types ... > 
{ 
static const size_t _S_alignment = 
alignof (_Tp) > __strictest_alignment < _Types ... > :: _S_alignment 
? alignof (_Tp) : __strictest_alignment < _Types ... > :: _S_alignment ; 
static const size_t _S_size = 
sizeof (_Tp) > __strictest_alignment < _Types ... > :: _S_size 
? sizeof (_Tp) : __strictest_alignment < _Types ... > :: _S_size ; 
} ;
# 1969 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < size_t _Len , typename ... _Types > 
struct aligned_union 
{ 
private : 
static_assert (sizeof ... (_Types) != 0 , "At least one type is required") ; 

using __strictest = __strictest_alignment < _Types ... > ; 
static const size_t _S_len = _Len > __strictest :: _S_size 
? _Len : __strictest :: _S_size ; 
public : 

static const size_t alignment_value = __strictest :: _S_alignment ; 

typedef typename aligned_storage < _S_len , alignment_value > :: type type ; 
} ;

template < size_t _Len, typename ... _Types >
    const size_t aligned_union < _Len, _Types ... > :: alignment_value;



template < typename _Up,
    bool _IsArray = is_array < _Up > :: value,
    bool _IsFunction = is_function < _Up > :: value >
    struct __decay_selector;


template < typename _Up > 
struct __decay_selector < _Up , false , false > 
{ typedef typename remove_cv < _Up > :: type __type ; } ;

template < typename _Up > 
struct __decay_selector < _Up , true , false > 
{ typedef typename remove_extent < _Up > :: type * __type ; } ;

template < typename _Up > 
struct __decay_selector < _Up , false , true > 
{ typedef typename add_pointer < _Up > :: type __type ; } ;


template < typename _Tp > 
class decay 
{ 
typedef typename remove_reference < _Tp > :: type __remove_type ; 

public : 
typedef typename __decay_selector < __remove_type > :: __type type ; 
} ;

template < typename _Tp >
    class reference_wrapper;


template < typename _Tp > 
struct __strip_reference_wrapper 
{ 
typedef _Tp __type ; 
} ;

template < typename _Tp > 
struct __strip_reference_wrapper < reference_wrapper < _Tp > > 
{ 
typedef _Tp & __type ; 
} ;

template < typename _Tp > 
struct __decay_and_strip 
{ 
typedef typename __strip_reference_wrapper < 
typename decay < _Tp > :: type > :: __type __type ; 
} ;




template < bool , typename _Tp = void > 
struct enable_if 
{ } ;


template < typename _Tp > 
struct enable_if < true , _Tp > 
{ typedef _Tp type ; } ;

template < typename ... _Cond >
    using _Require = typename enable_if < __and_ < _Cond ... > :: value > :: type;



template < bool _Cond , typename _Iftrue , typename _Iffalse > 
struct conditional 
{ typedef _Iftrue type ; } ;


template < typename _Iftrue , typename _Iffalse > 
struct conditional < false , _Iftrue , _Iffalse > 
{ typedef _Iffalse type ; } ;


template < typename ... _Tp >
    struct common_type;



struct __do_common_type_impl { 

template < typename _Tp, typename _Up >
      static __success_type < typename decay < __decltype
       ( true ? std :: declval < _Tp > ( )
        : std :: declval < _Up > ( ) ) > :: type > _S_test ( int );

template < typename, typename >
      static __failure_type _S_test ( ... );
}; 

template < typename _Tp , typename _Up > 
struct __common_type_impl 
: private __do_common_type_impl 
{ 
typedef decltype (_S_test < _Tp , _Up > (0)) type ; 
} ;

struct __do_member_type_wrapper { 

template < typename _Tp >
      static __success_type < typename _Tp :: type > _S_test ( int );

template < typename >
      static __failure_type _S_test ( ... );
}; 

template < typename _Tp > 
struct __member_type_wrapper 
: private __do_member_type_wrapper 
{ 
typedef decltype (_S_test < _Tp > (0)) type ; 
} ;

template < typename _CTp , typename ... _Args > 
struct __expanded_common_type_wrapper 
{ 
typedef common_type < typename _CTp :: type , _Args ... > type ; 
} ;

template < typename ... _Args > 
struct __expanded_common_type_wrapper < __failure_type , _Args ... > 
{ typedef __failure_type type ; } ;


template<> struct common_type< >  { 
}; 

template < typename _Tp > 
struct common_type < _Tp > 
: common_type < _Tp , _Tp > 
{ } ;

template < typename _Tp , typename _Up > 
struct common_type < _Tp , _Up > 
: public __common_type_impl < _Tp , _Up > :: type 
{ } ;

template < typename _Tp , typename _Up , typename ... _Vp > 
struct common_type < _Tp , _Up , _Vp ... > 
: public __expanded_common_type_wrapper < typename __member_type_wrapper < 
common_type < _Tp , _Up > > :: type , _Vp ... > :: type 
{ } ;

template < typename _Tp , bool = is_enum < _Tp > :: value > 
struct __underlying_type_impl 
{ 
using type = __underlying_type (_Tp) ; 
} ;

template < typename _Tp > 
struct __underlying_type_impl < _Tp , false > 
{ } ;


template < typename _Tp > 
struct underlying_type 
: public __underlying_type_impl < _Tp > 
{ } ;

template < typename _Tp > 
struct __declval_protector 
{ 
static const bool __stop = false ; 
} ;

template < typename _Tp > 
auto declval () noexcept -> decltype (__declval < _Tp > (0)) 
{ 
static_assert (__declval_protector < _Tp > :: __stop , 
"declval() must not be used!") ; 
return __declval < _Tp > (0) ; 
} 


template < typename _Tp >
    using __remove_cvref_t
     = typename remove_cv < typename remove_reference < _Tp > :: type > :: type;


template < typename _Signature >
    class result_of;
# 2180
struct __invoke_memfun_ref { }; 
struct __invoke_memfun_deref { }; 
struct __invoke_memobj_ref { }; 
struct __invoke_memobj_deref { }; 
struct __invoke_other { }; 


template < typename _Tp , typename _Tag > 
struct __result_of_success : __success_type < _Tp > 
{ using __invoke_type = _Tag ; } ;


struct __result_of_memfun_ref_impl { 

template < typename _Fp, typename _Tp1, typename ... _Args >
      static __result_of_success < __decltype (
      ( std :: declval < _Tp1 > ( ) .* std :: declval < _Fp > ( ) ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_memfun_ref > _S_test ( int );

template < typename ... >
      static __failure_type _S_test ( ... );
}; 

template < typename _MemPtr , typename _Arg , typename ... _Args > 
struct __result_of_memfun_ref 
: private __result_of_memfun_ref_impl 
{ 
typedef decltype (_S_test < _MemPtr , _Arg , _Args ... > (0)) type ; 
} ;


struct __result_of_memfun_deref_impl { 

template < typename _Fp, typename _Tp1, typename ... _Args >
      static __result_of_success < __decltype (
      ( ( * std :: declval < _Tp1 > ( ) ) .* std :: declval < _Fp > ( ) ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_memfun_deref > _S_test ( int );

template < typename ... >
      static __failure_type _S_test ( ... );
}; 

template < typename _MemPtr , typename _Arg , typename ... _Args > 
struct __result_of_memfun_deref 
: private __result_of_memfun_deref_impl 
{ 
typedef decltype (_S_test < _MemPtr , _Arg , _Args ... > (0)) type ; 
} ;


struct __result_of_memobj_ref_impl { 

template < typename _Fp, typename _Tp1 >
      static __result_of_success < __decltype (
      std :: declval < _Tp1 > ( ) .* std :: declval < _Fp > ( )
      ), __invoke_memobj_ref > _S_test ( int );

template < typename, typename >
      static __failure_type _S_test ( ... );
}; 

template < typename _MemPtr , typename _Arg > 
struct __result_of_memobj_ref 
: private __result_of_memobj_ref_impl 
{ 
typedef decltype (_S_test < _MemPtr , _Arg > (0)) type ; 
} ;


struct __result_of_memobj_deref_impl { 

template < typename _Fp, typename _Tp1 >
      static __result_of_success < __decltype (
      ( * std :: declval < _Tp1 > ( ) ) .* std :: declval < _Fp > ( )
      ), __invoke_memobj_deref > _S_test ( int );

template < typename, typename >
      static __failure_type _S_test ( ... );
}; 

template < typename _MemPtr , typename _Arg > 
struct __result_of_memobj_deref 
: private __result_of_memobj_deref_impl 
{ 
typedef decltype (_S_test < _MemPtr , _Arg > (0)) type ; 
} ;

template < typename _MemPtr, typename _Arg >
    struct __result_of_memobj;

template < typename _Res , typename _Class , typename _Arg > 
struct __result_of_memobj < _Res _Class :: * , _Arg > 
{ 
typedef __remove_cvref_t < _Arg > _Argval ; 
typedef _Res _Class :: * _MemPtr ; 
typedef typename conditional < __or_ < is_same < _Argval , _Class > , 
is_base_of < _Class , _Argval > > :: value , 
__result_of_memobj_ref < _MemPtr , _Arg > , 
__result_of_memobj_deref < _MemPtr , _Arg > 
> :: type :: type type ; 
} ;

template < typename _MemPtr, typename _Arg, typename ... _Args >
    struct __result_of_memfun;

template < typename _Res , typename _Class , typename _Arg , typename ... _Args > 
struct __result_of_memfun < _Res _Class :: * , _Arg , _Args ... > 
{ 
typedef typename remove_reference < _Arg > :: type _Argval ; 
typedef _Res _Class :: * _MemPtr ; 
typedef typename conditional < is_base_of < _Class , _Argval > :: value , 
__result_of_memfun_ref < _MemPtr , _Arg , _Args ... > , 
__result_of_memfun_deref < _MemPtr , _Arg , _Args ... > 
> :: type :: type type ; 
} ;
# 2301
template < typename _Tp , typename _Up = __remove_cvref_t < _Tp > > 
struct __inv_unwrap 
{ 
using type = _Tp ; 
} ;

template < typename _Tp , typename _Up > 
struct __inv_unwrap < _Tp , reference_wrapper < _Up > > 
{ 
using type = _Up & ; 
} ;

template < bool , bool , typename _Functor , typename ... _ArgTypes > 
struct __result_of_impl 
{ 
typedef __failure_type type ; 
} ;

template < typename _MemPtr , typename _Arg > 
struct __result_of_impl < true , false , _MemPtr , _Arg > 
: public __result_of_memobj < typename decay < _MemPtr > :: type , 
typename __inv_unwrap < _Arg > :: type > 
{ } ;

template < typename _MemPtr , typename _Arg , typename ... _Args > 
struct __result_of_impl < false , true , _MemPtr , _Arg , _Args ... > 
: public __result_of_memfun < typename decay < _MemPtr > :: type , 
typename __inv_unwrap < _Arg > :: type , _Args ... > 
{ } ;


struct __result_of_other_impl { 

template < typename _Fn, typename ... _Args >
      static __result_of_success < __decltype (
      std :: declval < _Fn > ( ) ( std :: declval < _Args > ( ) ... )
      ), __invoke_other > _S_test ( int );

template < typename ... >
      static __failure_type _S_test ( ... );
}; 

template < typename _Functor , typename ... _ArgTypes > 
struct __result_of_impl < false , false , _Functor , _ArgTypes ... > 
: private __result_of_other_impl 
{ 
typedef decltype (_S_test < _Functor , _ArgTypes ... > (0)) type ; 
} ;


template < typename _Functor , typename ... _ArgTypes > 
struct __invoke_result 
: public __result_of_impl < 
is_member_object_pointer < 
typename remove_reference < _Functor > :: type 
> :: value , 
is_member_function_pointer < 
typename remove_reference < _Functor > :: type 
> :: value , 
_Functor , _ArgTypes ... 
> :: type 
{ } ;

template < typename _Functor , typename ... _ArgTypes > 
struct result_of < _Functor (_ArgTypes ...) > 
: public __invoke_result < _Functor , _ArgTypes ... > 
{ } ;
# 2404 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < bool _Cond, typename _Tp = void >
    using __enable_if_t = typename enable_if < _Cond, _Tp > :: type;


template < typename ... > using __void_t = void;




template < typename ... > using void_t = void;



template < typename _Default , typename _AlwaysVoid , 
template < typename ... > class _Op , typename ... _Args > 
struct __detector 
{ 
using value_t = false_type ; 
using type = _Default ; 
} ;


template < typename _Default , template < typename ... > class _Op , 
typename ... _Args > 
struct __detector < _Default , __void_t < _Op < _Args ... > > , _Op , _Args ... > 
{ 
using value_t = true_type ; 
using type = _Op < _Args ... > ; 
} ;


template < typename _Default, template < typename ... > class _Op,
    typename ... _Args >
    using __detected_or = __detector < _Default, void, _Op, _Args ... >;


template < typename _Default, template < typename ... > class _Op,
    typename ... _Args >
    using __detected_or_t
      = typename __detected_or < _Default, _Op, _Args ... > :: type;
# 2461 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Tp >
    struct __is_swappable;

template < typename _Tp >
    struct __is_nothrow_swappable;

template < typename ... _Elements >
    class tuple;

template < typename > 
struct __is_tuple_like_impl : false_type 
{ } ;

template < typename ... _Tps > 
struct __is_tuple_like_impl < tuple < _Tps ... > > : true_type 
{ } ;


template < typename _Tp > 
struct __is_tuple_like 
: public __is_tuple_like_impl < __remove_cvref_t < _Tp > > :: type 
{ } ;

template < typename _Tp >
    inline
    typename enable_if < __and_ < __not_ < __is_tuple_like < _Tp > >,
         is_move_constructible < _Tp >,
         is_move_assignable < _Tp > > :: value > :: type
    swap ( _Tp &, _Tp & )
    noexcept ( __and_ < is_nothrow_move_constructible < _Tp >,
             is_nothrow_move_assignable < _Tp >> :: value );

template < typename _Tp, size_t _Nm >
    inline
    typename enable_if < __is_swappable < _Tp > :: value > :: type
    swap ( _Tp ( & __a ) [ _Nm ], _Tp ( & __b ) [ _Nm ] )
    noexcept ( __is_nothrow_swappable < _Tp > :: value );

namespace __swappable_details { 
using std::swap;

struct __do_is_swappable_impl { 

template < typename _Tp, typename
               = __decltype ( swap ( std :: declval < _Tp & > ( ), std :: declval < _Tp & > ( ) ) ) >
        static true_type __test ( int );

template < typename >
        static false_type __test ( ... );
}; 

struct __do_is_nothrow_swappable_impl { 

template < typename _Tp >
        static __bool_constant <
          noexcept ( swap ( std :: declval < _Tp & > ( ), std :: declval < _Tp & > ( ) ) )
        > __test ( int );

template < typename >
        static false_type __test ( ... );
}; 

}

template < typename _Tp > 
struct __is_swappable_impl 
: public __swappable_details :: __do_is_swappable_impl 
{ 
typedef decltype (__test < _Tp > (0)) type ; 
} ;

template < typename _Tp > 
struct __is_nothrow_swappable_impl 
: public __swappable_details :: __do_is_nothrow_swappable_impl 
{ 
typedef decltype (__test < _Tp > (0)) type ; 
} ;

template < typename _Tp > 
struct __is_swappable 
: public __is_swappable_impl < _Tp > :: type 
{ } ;

template < typename _Tp > 
struct __is_nothrow_swappable 
: public __is_nothrow_swappable_impl < _Tp > :: type 
{ } ;
# 2554
template < typename _Tp > 
struct is_swappable 
: public __is_swappable_impl < _Tp > :: type 
{ } ;


template < typename _Tp > 
struct is_nothrow_swappable 
: public __is_nothrow_swappable_impl < _Tp > :: type 
{ } ;
# 2577 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
namespace __swappable_with_details { 
using std::swap;

struct __do_is_swappable_with_impl { 

template < typename _Tp, typename _Up, typename
               = __decltype ( swap ( std :: declval < _Tp > ( ), std :: declval < _Up > ( ) ) ),
               typename
               = __decltype ( swap ( std :: declval < _Up > ( ), std :: declval < _Tp > ( ) ) ) >
        static true_type __test ( int );

template < typename, typename >
        static false_type __test ( ... );
}; 

struct __do_is_nothrow_swappable_with_impl { 

template < typename _Tp, typename _Up >
        static __bool_constant <
          noexcept ( swap ( std :: declval < _Tp > ( ), std :: declval < _Up > ( ) ) )
          &&
          noexcept ( swap ( std :: declval < _Up > ( ), std :: declval < _Tp > ( ) ) )
        > __test ( int );

template < typename, typename >
        static false_type __test ( ... );
}; 

}

template < typename _Tp , typename _Up > 
struct __is_swappable_with_impl 
: public __swappable_with_details :: __do_is_swappable_with_impl 
{ 
typedef decltype (__test < _Tp , _Up > (0)) type ; 
} ;


template < typename _Tp > 
struct __is_swappable_with_impl < _Tp & , _Tp & > 
: public __swappable_details :: __do_is_swappable_impl 
{ 
typedef decltype (__test < _Tp & > (0)) type ; 
} ;

template < typename _Tp , typename _Up > 
struct __is_nothrow_swappable_with_impl 
: public __swappable_with_details :: __do_is_nothrow_swappable_with_impl 
{ 
typedef decltype (__test < _Tp , _Up > (0)) type ; 
} ;


template < typename _Tp > 
struct __is_nothrow_swappable_with_impl < _Tp & , _Tp & > 
: public __swappable_details :: __do_is_nothrow_swappable_impl 
{ 
typedef decltype (__test < _Tp & > (0)) type ; 
} ;


template < typename _Tp , typename _Up > 
struct is_swappable_with 
: public __is_swappable_with_impl < _Tp , _Up > :: type 
{ } ;


template < typename _Tp , typename _Up > 
struct is_nothrow_swappable_with 
: public __is_nothrow_swappable_with_impl < _Tp , _Up > :: type 
{ } ;
# 2665 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
template < typename _Result , typename _Ret , typename = void > 
struct __is_invocable_impl : false_type { } ;

template < typename _Result , typename _Ret > 
struct __is_invocable_impl < _Result , _Ret , __void_t < typename _Result :: type > > 
: __or_ < is_void < _Ret > , is_convertible < typename _Result :: type , _Ret > > :: type 
{ } ;

template < typename _Fn , typename ... _ArgTypes > 
struct __is_invocable 
: __is_invocable_impl < __invoke_result < _Fn , _ArgTypes ... > , void > :: type 
{ } ;

template < typename _Fn , typename _Tp , typename ... _Args > 
constexpr bool __call_is_nt (__invoke_memfun_ref) 
{ 
using _Up = typename __inv_unwrap < _Tp > :: type ; 
return noexcept ((std :: declval < _Up > () .* std :: declval < _Fn > ()) (
std :: declval < _Args > () ...)) ; 
} 

template < typename _Fn , typename _Tp , typename ... _Args > 
constexpr bool __call_is_nt (__invoke_memfun_deref) 
{ 
return noexcept (((* std :: declval < _Tp > ()) .* std :: declval < _Fn > ()) (
std :: declval < _Args > () ...)) ; 
} 

template < typename _Fn , typename _Tp > 
constexpr bool __call_is_nt (__invoke_memobj_ref) 
{ 
using _Up = typename __inv_unwrap < _Tp > :: type ; 
return noexcept (std :: declval < _Up > () .* std :: declval < _Fn > ()) ; 
} 

template < typename _Fn , typename _Tp > 
constexpr bool __call_is_nt (__invoke_memobj_deref) 
{ 
return noexcept ((* std :: declval < _Tp > ()) .* std :: declval < _Fn > ()) ; 
} 

template < typename _Fn , typename ... _Args > 
constexpr bool __call_is_nt (__invoke_other) 
{ 
return noexcept (std :: declval < _Fn > () (std :: declval < _Args > () ...)) ; 
} 

template < typename _Result , typename _Fn , typename ... _Args > 
struct __call_is_nothrow 
: __bool_constant < 
std :: __call_is_nt < _Fn , _Args ... > (typename _Result :: __invoke_type { }) 
> 
{ } ;

template < typename _Fn, typename ... _Args >
    using __call_is_nothrow_
      = __call_is_nothrow < __invoke_result < _Fn, _Args ... >, _Fn, _Args ... >;


template < typename _Fn , typename ... _Args > 
struct __is_nothrow_invocable 
: __and_ < __is_invocable < _Fn , _Args ... > , 
__call_is_nothrow_ < _Fn , _Args ... > > :: type 
{ } ;

struct __nonesuch { 
__nonesuch() = delete;
~__nonesuch() = delete;
__nonesuch(const __nonesuch &) = delete;
void operator=(const __nonesuch &) = delete;
}; 
# 3063 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\type_traits" 3
}
# 57 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
namespace std { 
# 72 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
template < typename _Tp > 
constexpr _Tp && 
forward (typename std :: remove_reference < _Tp > :: type & __t) noexcept 
{ return static_cast < _Tp && > (__t) ; } 
# 83
template < typename _Tp > 
constexpr _Tp && 
forward (typename std :: remove_reference < _Tp > :: type && __t) noexcept 
{ 
static_assert (! std :: is_lvalue_reference < _Tp > :: value , "template argument" 
" substituting _Tp is an lvalue reference type") ; 
return static_cast < _Tp && > (__t) ; 
} 
# 97
template < typename _Tp > 
constexpr typename std :: remove_reference < _Tp > :: type && 
move (_Tp && __t) noexcept 
{ return static_cast < typename std :: remove_reference < _Tp > :: type && > (__t) ; } 


template < typename _Tp > 
struct __move_if_noexcept_cond 
: public __and_ < __not_ < is_nothrow_move_constructible < _Tp > > , 
is_copy_constructible < _Tp > > :: type { } ;
# 116 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
template < typename _Tp > 
constexpr typename 
conditional < __move_if_noexcept_cond < _Tp > :: value , const _Tp & , _Tp && > :: type 
move_if_noexcept (_Tp & __x) noexcept 
{ return std :: move (__x) ; } 
# 136 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
template < typename _Tp > 
inline _Tp * 
addressof (_Tp & __r) noexcept 
{ return std :: __addressof (__r) ; } 



template < typename _Tp > 
const _Tp * addressof (const _Tp &&) = delete ; ;


template < typename _Tp , typename _Up = _Tp > 
inline _Tp 
__exchange (_Tp & __obj , _Up && __new_val) 
{ 
_Tp __old_val = std :: move (__obj) ; 
__obj = std :: forward < _Up > (__new_val) ; 
return __old_val ; 
} 
# 176 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\move.h" 3
template < typename _Tp > 
inline 

typename enable_if < __and_ < __not_ < __is_tuple_like < _Tp > > , 
is_move_constructible < _Tp > , 
is_move_assignable < _Tp > > :: value > :: type 
swap (_Tp & __a , _Tp & __b) 
noexcept (__and_ < is_nothrow_move_constructible < _Tp > , 
is_nothrow_move_assignable < _Tp > > :: value) 




{ 



_Tp __tmp = std :: move (__a) ; 
__a = std :: move (__b) ; 
__b = std :: move (__tmp) ; 
} 




template < typename _Tp , size_t _Nm > 
inline 

typename enable_if < __is_swappable < _Tp > :: value > :: type 
swap (_Tp (& __a) [ _Nm ] , _Tp (& __b) [ _Nm ]) 
noexcept (__is_nothrow_swappable < _Tp > :: value) 




{ 
for (size_t __n = 0 ; __n < _Nm ; ++ __n) 
swap (__a [ __n ] , __b [ __n ]) ; 
} 



}
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\nested_exception.h" 3
extern "C++" {

namespace std { 
# 52
class nested_exception { 

__exception_ptr::exception_ptr _M_ptr; 


public: nested_exception() noexcept : _M_ptr(current_exception()) { } 

nested_exception(const nested_exception &) noexcept = default;

nested_exception &operator=(const nested_exception &) noexcept = default;

virtual ~nested_exception() noexcept; 



[[noreturn]] void rethrow_nested() const 
{ 
if ((_M_ptr)) 
rethrow_exception(_M_ptr);   
std::terminate(); 
} 


__exception_ptr::exception_ptr nested_ptr() const noexcept 
{ return _M_ptr; } 
}; 

template < typename _Except > 
struct _Nested_exception : public _Except , public nested_exception 
{ 
explicit _Nested_exception (const _Except & __ex) 
: _Except (__ex) 
{ } 

explicit _Nested_exception (_Except && __ex) 
: _Except (static_cast < _Except && > (__ex)) 
{ } 
} ;




template < typename _Tp > 
[ [ noreturn ] ] 
inline void 
__throw_with_nested_impl (_Tp && __t , true_type) 
{ 
using _Up = typename remove_reference < _Tp > :: type ; 
throw _Nested_exception < _Up > { std :: forward < _Tp > (__t) } ; 
} 

template < typename _Tp > 
[ [ noreturn ] ] 
inline void 
__throw_with_nested_impl (_Tp && __t , false_type) 
{ throw std :: forward < _Tp > (__t) ; } 



template < typename _Tp > 
[ [ noreturn ] ] 
inline void 
throw_with_nested (_Tp && __t) 
{ 
using _Up = typename decay < _Tp > :: type ; 
using _CopyConstructible 
= __and_ < is_copy_constructible < _Up > , is_move_constructible < _Up >> ; 
static_assert (_CopyConstructible :: value , 
"throw_with_nested argument must be CopyConstructible") ; 
using __nest = __and_ < is_class < _Up > , __bool_constant < ! __is_final (_Up) > , 
__not_ < is_base_of < nested_exception , _Up >> > ; 
std :: __throw_with_nested_impl (std :: forward < _Tp > (__t) , __nest { }) ; 
} 


template < typename _Tp >
    using __rethrow_if_nested_cond = typename enable_if <
      __and_ < is_polymorphic < _Tp >,
      __or_ < __not_ < is_base_of < nested_exception, _Tp >>,
     is_convertible < _Tp *, nested_exception * >> > :: value
    > :: type;


template < typename _Ex > 
inline __rethrow_if_nested_cond < _Ex > 
__rethrow_if_nested_impl (const _Ex * __ptr) 
{ 
if (auto __ne_ptr = dynamic_cast < const nested_exception * > (__ptr)) 
__ne_ptr -> rethrow_nested () ; 
} 



inline void __rethrow_if_nested_impl(const void *) 
{ } 


template < typename _Ex > 
inline void 
rethrow_if_nested (const _Ex & __ex) 
{ std :: __rethrow_if_nested_impl (std :: __addressof (__ex)) ; } 


}

}



#pragma GCC visibility pop
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functexcept.h" 3
namespace std { 
# 48
void __throw_bad_exception() __attribute((__noreturn__)); 



void __throw_bad_alloc() __attribute((__noreturn__)); 



void __throw_bad_cast() __attribute((__noreturn__)); 


void __throw_bad_typeid() __attribute((__noreturn__)); 



void __throw_logic_error(const char *) __attribute((__noreturn__)); 


void __throw_domain_error(const char *) __attribute((__noreturn__)); 


void __throw_invalid_argument(const char *) __attribute((__noreturn__)); 


void __throw_length_error(const char *) __attribute((__noreturn__)); 


void __throw_out_of_range(const char *) __attribute((__noreturn__)); 


void __throw_out_of_range_fmt(const char *, ...) __attribute((__noreturn__)) __attribute((__format__(__gnu_printf__, 1, 2))); 



void __throw_runtime_error(const char *) __attribute((__noreturn__)); 


void __throw_range_error(const char *) __attribute((__noreturn__)); 


void __throw_overflow_error(const char *) __attribute((__noreturn__)); 


void __throw_underflow_error(const char *) __attribute((__noreturn__)); 



void __throw_ios_failure(const char *) __attribute((__noreturn__)); 


void __throw_ios_failure(const char *, int) __attribute((__noreturn__)); 



void __throw_system_error(int) __attribute((__noreturn__)); 



void __throw_future_error(int) __attribute((__noreturn__)); 



void __throw_bad_function_call() __attribute((__noreturn__)); 


}
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cpp_type_traits.h" 3
extern "C++" {

namespace std { 



struct __true_type { }; 
struct __false_type { }; 

template < bool > 
struct __truth_type 
{ typedef __false_type __type ; } ;


template<> struct __truth_type< true>  { 
typedef __true_type __type; }; 



template < class _Sp , class _Tp > 
struct __traitor 
{ 
enum { __value = bool (_Sp :: __value) || bool (_Tp :: __value) } ; 
typedef typename __truth_type < __value > :: __type __type ; 
} ;


template < typename , typename > 
struct __are_same 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;

template < typename _Tp > 
struct __are_same < _Tp , _Tp > 
{ 
enum { __value = 1 } ; 
typedef __true_type __type ; 
} ;


template < typename _Tp > 
struct __is_void 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;


template<> struct __is_void< void>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 




template < typename _Tp > 
struct __is_integer 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;
# 138
template<> struct __is_integer< bool>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< signed char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< unsigned char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 



template<> struct __is_integer< wchar_t>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 
# 185 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cpp_type_traits.h" 3
template<> struct __is_integer< char16_t>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< char32_t>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 



template<> struct __is_integer< short>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< unsigned short>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< int>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< unsigned>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< long>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< unsigned long>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< long long>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_integer< unsigned long long>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 
# 287 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cpp_type_traits.h" 3
template < typename _Tp > 
struct __is_floating 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;



template<> struct __is_floating< float>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_floating< double>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_floating< long double>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 




template < typename _Tp > 
struct __is_pointer 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;

template < typename _Tp > 
struct __is_pointer < _Tp * > 
{ 
enum { __value = 1 } ; 
typedef __true_type __type ; 
} ;




template < typename _Tp > 
struct __is_arithmetic 
: public __traitor < __is_integer < _Tp > , __is_floating < _Tp > > 
{ } ;




template < typename _Tp > 
struct __is_scalar 
: public __traitor < __is_arithmetic < _Tp > , __is_pointer < _Tp > > 
{ } ;




template < typename _Tp > 
struct __is_char 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;


template<> struct __is_char< char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 



template<> struct __is_char< wchar_t>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template < typename _Tp > 
struct __is_byte 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;


template<> struct __is_byte< char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_byte< signed char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 


template<> struct __is_byte< unsigned char>  { 

enum { __value = 1}; 
typedef __true_type __type; 
}; 
# 417 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cpp_type_traits.h" 3
template < typename _Tp > 
struct __is_move_iterator 
{ 
enum { __value = 0 } ; 
typedef __false_type __type ; 
} ;



template < typename _Iterator > 
inline _Iterator 
__miter_base (_Iterator __it) 
{ return __it ; } 


}
}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\type_traits.h" 3
extern "C++" {

namespace __gnu_cxx { 




template < bool , typename > 
struct __enable_if 
{ } ;

template < typename _Tp > 
struct __enable_if < true , _Tp > 
{ typedef _Tp __type ; } ;



template < bool _Cond , typename _Iftrue , typename _Iffalse > 
struct __conditional_type 
{ typedef _Iftrue __type ; } ;

template < typename _Iftrue , typename _Iffalse > 
struct __conditional_type < false , _Iftrue , _Iffalse > 
{ typedef _Iffalse __type ; } ;



template < typename _Tp > 
struct __add_unsigned 
{ 
private : 
typedef __enable_if < std :: __is_integer < _Tp > :: __value , _Tp > __if_type ; 

public : 
typedef typename __if_type :: __type __type ; 
} ;


template<> struct __add_unsigned< char>  { 
typedef unsigned char __type; }; 


template<> struct __add_unsigned< signed char>  { 
typedef unsigned char __type; }; 


template<> struct __add_unsigned< short>  { 
typedef unsigned short __type; }; 


template<> struct __add_unsigned< int>  { 
typedef unsigned __type; }; 


template<> struct __add_unsigned< long>  { 
typedef unsigned long __type; }; 


template<> struct __add_unsigned< long long>  { 
typedef unsigned long long __type; }; 



template<> struct __add_unsigned< bool> ; 


template<> struct __add_unsigned< wchar_t> ; 



template < typename _Tp > 
struct __remove_unsigned 
{ 
private : 
typedef __enable_if < std :: __is_integer < _Tp > :: __value , _Tp > __if_type ; 

public : 
typedef typename __if_type :: __type __type ; 
} ;


template<> struct __remove_unsigned< char>  { 
typedef signed char __type; }; 


template<> struct __remove_unsigned< unsigned char>  { 
typedef signed char __type; }; 


template<> struct __remove_unsigned< unsigned short>  { 
typedef short __type; }; 


template<> struct __remove_unsigned< unsigned>  { 
typedef int __type; }; 


template<> struct __remove_unsigned< unsigned long>  { 
typedef long __type; }; 


template<> struct __remove_unsigned< unsigned long long>  { 
typedef long long __type; }; 



template<> struct __remove_unsigned< bool> ; 


template<> struct __remove_unsigned< wchar_t> ; 



template < typename _Type > 
inline bool 
__is_null_pointer (_Type * __ptr) 
{ return __ptr == 0 ; } 

template < typename _Type > 
inline bool 
__is_null_pointer (_Type) 
{ return false ; } 



inline bool __is_null_pointer(std::nullptr_t) 
{ return true; } 



template < typename _Tp , bool = std :: __is_integer < _Tp > :: __value > 
struct __promote 
{ typedef double __type ; } ;




template < typename _Tp > 
struct __promote < _Tp , false > 
{ } ;


template<> struct __promote< long double>  { 
typedef long double __type; }; 


template<> struct __promote< double>  { 
typedef double __type; }; 


template<> struct __promote< float>  { 
typedef float __type; }; 

template < typename _Tp , typename _Up , 
typename _Tp2 = typename __promote < _Tp > :: __type , 
typename _Up2 = typename __promote < _Up > :: __type > 
struct __promote_2 
{ 
typedef __typeof__ (_Tp2 () + _Up2 ()) __type ; 
} ;

template < typename _Tp , typename _Up , typename _Vp , 
typename _Tp2 = typename __promote < _Tp > :: __type , 
typename _Up2 = typename __promote < _Up > :: __type , 
typename _Vp2 = typename __promote < _Vp > :: __type > 
struct __promote_3 
{ 
typedef __typeof__ (_Tp2 () + _Up2 () + _Vp2 ()) __type ; 
} ;

template < typename _Tp , typename _Up , typename _Vp , typename _Wp , 
typename _Tp2 = typename __promote < _Tp > :: __type , 
typename _Up2 = typename __promote < _Up > :: __type , 
typename _Vp2 = typename __promote < _Vp > :: __type , 
typename _Wp2 = typename __promote < _Wp > :: __type > 
struct __promote_4 
{ 
typedef __typeof__ (_Tp2 () + _Up2 () + _Vp2 () + _Wp2 ()) __type ; 
} ;


}
}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\numeric_traits.h" 3
namespace __gnu_cxx { 
# 54 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\numeric_traits.h" 3
template < typename _Value > 
struct __numeric_traits_integer 
{ 

static const _Value __min = (((_Value) (- 1) < 0) ? (_Value) 1 << (sizeof (_Value) * 8 - ((_Value) (- 1) < 0)) : (_Value) 0) ; 
static const _Value __max = (((_Value) (- 1) < 0) ? (((((_Value) 1 << ((sizeof (_Value) * 8 - ((_Value) (- 1) < 0)) - 1)) - 1) << 1) + 1) : ~ (_Value) 0) ; 



static const bool __is_signed = ((_Value) (- 1) < 0) ; 
static const int __digits = (sizeof (_Value) * 8 - ((_Value) (- 1) < 0)) ; 
} ;

template < typename _Value >
    const _Value __numeric_traits_integer < _Value > :: __min;

template < typename _Value >
    const _Value __numeric_traits_integer < _Value > :: __max;

template < typename _Value >
    const bool __numeric_traits_integer < _Value > :: __is_signed;

template < typename _Value >
    const int __numeric_traits_integer < _Value > :: __digits;
# 99 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\numeric_traits.h" 3
template < typename _Value > 
struct __numeric_traits_floating 
{ 

static const int __max_digits10 = (2 + (std :: __are_same < _Value , float > :: __value ? 24 : std :: __are_same < _Value , double > :: __value ? 53 : 64) * 643L / 2136) ; 


static const bool __is_signed = true ; 
static const int __digits10 = (std :: __are_same < _Value , float > :: __value ? 6 : std :: __are_same < _Value , double > :: __value ? 15 : 18) ; 
static const int __max_exponent10 = (std :: __are_same < _Value , float > :: __value ? 38 : std :: __are_same < _Value , double > :: __value ? 308 : 4932) ; 
} ;

template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __max_digits10;

template < typename _Value >
    const bool __numeric_traits_floating < _Value > :: __is_signed;

template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __digits10;

template < typename _Value >
    const int __numeric_traits_floating < _Value > :: __max_exponent10;

template < typename _Value > 
struct __numeric_traits 
: public __conditional_type < std :: __is_integer < _Value > :: __value , 
__numeric_traits_integer < _Value > , 
__numeric_traits_floating < _Value > > :: __type 
{ } ;


}
# 65 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
namespace std { 
# 76 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
struct piecewise_construct_t { explicit piecewise_construct_t() = default;}; 


constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t(); 



template < typename ... >
    class tuple;

template < std :: size_t ... >
    struct _Index_tuple;
# 94
template < bool , typename _T1 , typename _T2 > 
struct _PCC 
{ 
template < typename _U1 , typename _U2 > 
static constexpr bool _ConstructiblePair () 
{ 
return __and_ < is_constructible < _T1 , const _U1 & > , 
is_constructible < _T2 , const _U2 & > > :: value ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _ImplicitlyConvertiblePair () 
{ 
return __and_ < is_convertible < const _U1 & , _T1 > , 
is_convertible < const _U2 & , _T2 > > :: value ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _MoveConstructiblePair () 
{ 
return __and_ < is_constructible < _T1 , _U1 && > , 
is_constructible < _T2 , _U2 && > > :: value ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _ImplicitlyMoveConvertiblePair () 
{ 
return __and_ < is_convertible < _U1 && , _T1 > , 
is_convertible < _U2 && , _T2 > > :: value ; 
} 

template < bool __implicit , typename _U1 , typename _U2 > 
static constexpr bool _CopyMovePair () 
{ 
using __do_converts = __and_ < is_convertible < const _U1 & , _T1 > , 
is_convertible < _U2 && , _T2 > > ; 
using __converts = typename conditional < __implicit , 
__do_converts , 
__not_ < __do_converts > > :: type ; 
return __and_ < is_constructible < _T1 , const _U1 & > , 
is_constructible < _T2 , _U2 && > , 
__converts 
> :: value ; 
} 

template < bool __implicit , typename _U1 , typename _U2 > 
static constexpr bool _MoveCopyPair () 
{ 
using __do_converts = __and_ < is_convertible < _U1 && , _T1 > , 
is_convertible < const _U2 & , _T2 > > ; 
using __converts = typename conditional < __implicit , 
__do_converts , 
__not_ < __do_converts > > :: type ; 
return __and_ < is_constructible < _T1 , _U1 && > , 
is_constructible < _T2 , const _U2 && > , 
__converts 
> :: value ; 
} 
} ;

template < typename _T1 , typename _T2 > 
struct _PCC < false , _T1 , _T2 > 
{ 
template < typename _U1 , typename _U2 > 
static constexpr bool _ConstructiblePair () 
{ 
return false ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _ImplicitlyConvertiblePair () 
{ 
return false ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _MoveConstructiblePair () 
{ 
return false ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool _ImplicitlyMoveConvertiblePair () 
{ 
return false ; 
} 
} ;




struct __nonesuch_no_braces : public __nonesuch { 
explicit __nonesuch_no_braces(const __nonesuch &) = delete;
}; 


template < typename _U1 , typename _U2 > class __pair_base 
{ 

template < typename _T1 , typename _T2 > friend struct pair ; 
__pair_base () = default ; 
~ __pair_base () = default ; 
__pair_base (const __pair_base &) = default ; 
__pair_base & operator = (const __pair_base &) = delete ; 

} ;
# 207
template < typename _T1 , typename _T2 > 
struct pair 
: private __pair_base < _T1 , _T2 > 
{ 
typedef _T1 first_type ; 
typedef _T2 second_type ; 

_T1 first ; 
_T2 second ; 
# 222
template < typename _U1 = _T1 , 
typename _U2 = _T2 , 
typename enable_if < __and_ < 
__is_implicitly_default_constructible < _U1 > , 
__is_implicitly_default_constructible < _U2 > > 
:: value , bool > :: type = true > 

constexpr pair () 
: first () , second () { } 


template < typename _U1 = _T1 , 
typename _U2 = _T2 , 
typename enable_if < __and_ < 
is_default_constructible < _U1 > , 
is_default_constructible < _U2 > , 
__not_ < 
__and_ < __is_implicitly_default_constructible < _U1 > , 
__is_implicitly_default_constructible < _U2 > > > > 
:: value , bool > :: type = false > 
explicit constexpr pair () 
: first () , second () { } 
# 252 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
using _PCCP = _PCC < true , _T1 , _T2 > ; 

template < typename _U1 = _T1 , typename _U2 = _T2 , typename 
enable_if < _PCCP :: template 
_ConstructiblePair < _U1 , _U2 > () 
&& _PCCP :: template 
_ImplicitlyConvertiblePair < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr pair (const _T1 & __a , const _T2 & __b) 
: first (__a) , second (__b) { } 

template < typename _U1 = _T1 , typename _U2 = _T2 , typename 
enable_if < _PCCP :: template 
_ConstructiblePair < _U1 , _U2 > () 
&& ! _PCCP :: template 
_ImplicitlyConvertiblePair < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr pair (const _T1 & __a , const _T2 & __b) 
: first (__a) , second (__b) { } 
# 280 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
template < typename _U1 , typename _U2 > 
using _PCCFP = _PCC < ! is_same < _T1 , _U1 > :: value 
|| ! is_same < _T2 , _U2 > :: value , 
_T1 , _T2 > ; 

template < typename _U1 , typename _U2 , typename 
enable_if < _PCCFP < _U1 , _U2 > :: template 
_ConstructiblePair < _U1 , _U2 > () 
&& _PCCFP < _U1 , _U2 > :: template 
_ImplicitlyConvertiblePair < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr pair (const pair < _U1 , _U2 > & __p) 
: first (__p . first) , second (__p . second) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _PCCFP < _U1 , _U2 > :: template 
_ConstructiblePair < _U1 , _U2 > () 
&& ! _PCCFP < _U1 , _U2 > :: template 
_ImplicitlyConvertiblePair < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr pair (const pair < _U1 , _U2 > & __p) 
: first (__p . first) , second (__p . second) { } 

constexpr pair (const pair &) = default ; 
constexpr pair (pair &&) = default ; 


template < typename _U1 , typename 
enable_if < _PCCP :: template 
_MoveCopyPair < true , _U1 , _T2 > () , 
bool > :: type = true > 
constexpr pair (_U1 && __x , const _T2 & __y) 
: first (std :: forward < _U1 > (__x)) , second (__y) { } 

template < typename _U1 , typename 
enable_if < _PCCP :: template 
_MoveCopyPair < false , _U1 , _T2 > () , 
bool > :: type = false > 
explicit constexpr pair (_U1 && __x , const _T2 & __y) 
: first (std :: forward < _U1 > (__x)) , second (__y) { } 

template < typename _U2 , typename 
enable_if < _PCCP :: template 
_CopyMovePair < true , _T1 , _U2 > () , 
bool > :: type = true > 
constexpr pair (const _T1 & __x , _U2 && __y) 
: first (__x) , second (std :: forward < _U2 > (__y)) { } 

template < typename _U2 , typename 
enable_if < _PCCP :: template 
_CopyMovePair < false , _T1 , _U2 > () , 
bool > :: type = false > 
explicit pair (const _T1 & __x , _U2 && __y) 
: first (__x) , second (std :: forward < _U2 > (__y)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _PCCP :: template 
_MoveConstructiblePair < _U1 , _U2 > () 
&& _PCCP :: template 
_ImplicitlyMoveConvertiblePair < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr pair (_U1 && __x , _U2 && __y) 
: first (std :: forward < _U1 > (__x)) , second (std :: forward < _U2 > (__y)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _PCCP :: template 
_MoveConstructiblePair < _U1 , _U2 > () 
&& ! _PCCP :: template 
_ImplicitlyMoveConvertiblePair < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr pair (_U1 && __x , _U2 && __y) 
: first (std :: forward < _U1 > (__x)) , second (std :: forward < _U2 > (__y)) { } 


template < typename _U1 , typename _U2 , typename 
enable_if < _PCCFP < _U1 , _U2 > :: template 
_MoveConstructiblePair < _U1 , _U2 > () 
&& _PCCFP < _U1 , _U2 > :: template 
_ImplicitlyMoveConvertiblePair < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr pair (pair < _U1 , _U2 > && __p) 
: first (std :: forward < _U1 > (__p . first)) , 
second (std :: forward < _U2 > (__p . second)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _PCCFP < _U1 , _U2 > :: template 
_MoveConstructiblePair < _U1 , _U2 > () 
&& ! _PCCFP < _U1 , _U2 > :: template 
_ImplicitlyMoveConvertiblePair < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr pair (pair < _U1 , _U2 > && __p) 
: first (std :: forward < _U1 > (__p . first)) , 
second (std :: forward < _U2 > (__p . second)) { } 

template < typename ... _Args1 , typename ... _Args2 > 
pair (piecewise_construct_t , tuple < _Args1 ... > , tuple < _Args2 ... >) ; 

pair & 
operator = (typename conditional < 
__and_ < is_copy_assignable < _T1 > , 
is_copy_assignable < _T2 > > :: value , 
const pair & , const __nonesuch_no_braces & > :: type __p) 
{ 
first = __p . first ; 
second = __p . second ; 
return * this ; 
} 

pair & 
operator = (typename conditional < 
__and_ < is_move_assignable < _T1 > , 
is_move_assignable < _T2 > > :: value , 
pair && , __nonesuch_no_braces && > :: type __p) 
noexcept (__and_ < is_nothrow_move_assignable < _T1 > , 
is_nothrow_move_assignable < _T2 > > :: value) 
{ 
first = std :: forward < first_type > (__p . first) ; 
second = std :: forward < second_type > (__p . second) ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
typename enable_if < __and_ < is_assignable < _T1 & , const _U1 & > , 
is_assignable < _T2 & , const _U2 & > > :: value , 
pair & > :: type 
operator = (const pair < _U1 , _U2 > & __p) 
{ 
first = __p . first ; 
second = __p . second ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
typename enable_if < __and_ < is_assignable < _T1 & , _U1 && > , 
is_assignable < _T2 & , _U2 && > > :: value , 
pair & > :: type 
operator = (pair < _U1 , _U2 > && __p) 
{ 
first = std :: forward < _U1 > (__p . first) ; 
second = std :: forward < _U2 > (__p . second) ; 
return * this ; 
} 

void 
swap (pair & __p) 
noexcept (__and_ < __is_nothrow_swappable < _T1 > , 
__is_nothrow_swappable < _T2 > > :: value) 
{ 
using std :: swap ; 
swap (first , __p . first) ; 
swap (second , __p . second) ; 
} 

private : 
template < typename ... _Args1 , std :: size_t ... _Indexes1 , 
typename ... _Args2 , std :: size_t ... _Indexes2 > 
pair (tuple < _Args1 ... > & , tuple < _Args2 ... > & , 
_Index_tuple < _Indexes1 ... > , _Index_tuple < _Indexes2 ... >) ; 

} ;
# 446
template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator == (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return __x . first == __y . first && __x . second == __y . second ; } 


template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator < (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return __x . first < __y . first 
|| (! (__y . first < __x . first) && __x . second < __y . second) ; } 


template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator != (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return ! (__x == __y) ; } 


template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator > (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return __y < __x ; } 


template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator <= (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return ! (__y < __x) ; } 


template < typename _T1 , typename _T2 > 
inline constexpr bool 
operator >= (const pair < _T1 , _T2 > & __x , const pair < _T1 , _T2 > & __y) 
{ return ! (__x < __y) ; } 
# 486
template < typename _T1 , typename _T2 > 
inline 


typename enable_if < __and_ < __is_swappable < _T1 > , 
__is_swappable < _T2 > > :: value > :: type 



swap (pair < _T1 , _T2 > & __x , pair < _T1 , _T2 > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 


template < typename _T1 , typename _T2 > 
typename enable_if < ! __and_ < __is_swappable < _T1 > , 
__is_swappable < _T2 > > :: value > :: type 
swap (pair < _T1 , _T2 > & , pair < _T1 , _T2 > &) = delete ; ;
# 521 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
template < typename _T1 , typename _T2 > 
constexpr pair < typename __decay_and_strip < _T1 > :: __type , 
typename __decay_and_strip < _T2 > :: __type > 
make_pair (_T1 && __x , _T2 && __y) 
{ 
typedef typename __decay_and_strip < _T1 > :: __type __ds_type1 ; 
typedef typename __decay_and_strip < _T2 > :: __type __ds_type2 ; 
typedef pair < __ds_type1 , __ds_type2 > __pair_type ; 
return __pair_type (std :: forward < _T1 > (__x) , std :: forward < _T2 > (__y)) ; 
} 
# 541 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_pair.h" 3
}
# 70 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
namespace std { 
# 89 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
struct input_iterator_tag { }; 


struct output_iterator_tag { }; 


struct forward_iterator_tag : public input_iterator_tag { }; 



struct bidirectional_iterator_tag : public forward_iterator_tag { }; 



struct random_access_iterator_tag : public bidirectional_iterator_tag { }; 
# 116 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
template < typename _Category , typename _Tp , typename _Distance = ptrdiff_t , 
typename _Pointer = _Tp * , typename _Reference = _Tp & > 
struct iterator 
{ 

typedef _Category iterator_category ; 

typedef _Tp value_type ; 

typedef _Distance difference_type ; 

typedef _Pointer pointer ; 

typedef _Reference reference ; 
} ;
# 143 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
template < typename _Iterator , typename = __void_t < > > 
struct __iterator_traits { } ;

template < typename _Iterator > 
struct __iterator_traits < _Iterator , 
__void_t < typename _Iterator :: iterator_category , 
typename _Iterator :: value_type , 
typename _Iterator :: difference_type , 
typename _Iterator :: pointer , 
typename _Iterator :: reference > > 
{ 
typedef typename _Iterator :: iterator_category iterator_category ; 
typedef typename _Iterator :: value_type value_type ; 
typedef typename _Iterator :: difference_type difference_type ; 
typedef typename _Iterator :: pointer pointer ; 
typedef typename _Iterator :: reference reference ; 
} ;

template < typename _Iterator > 
struct iterator_traits 
: public __iterator_traits < _Iterator > { } ;
# 177 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
template < typename _Tp > 
struct iterator_traits < _Tp * > 
{ 
typedef random_access_iterator_tag iterator_category ; 
typedef _Tp value_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Tp * pointer ; 
typedef _Tp & reference ; 
} ;


template < typename _Tp > 
struct iterator_traits < const _Tp * > 
{ 
typedef random_access_iterator_tag iterator_category ; 
typedef _Tp value_type ; 
typedef ptrdiff_t difference_type ; 
typedef const _Tp * pointer ; 
typedef const _Tp & reference ; 
} ;
# 202
template < typename _Iter > 
inline constexpr 
typename iterator_traits < _Iter > :: iterator_category 
__iterator_category (const _Iter &) 
{ return typename iterator_traits < _Iter > :: iterator_category () ; } 
# 231 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_types.h" 3
template < typename _InIter >
    using _RequireInputIter = typename
      enable_if < is_convertible < typename
  iterator_traits < _InIter > :: iterator_category,
          input_iterator_tag > :: value > :: type;



}
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_funcs.h" 3
namespace std { 
# 73
template < typename > struct _List_iterator;
template < typename > struct _List_const_iterator;


template < typename _InputIterator > 
inline 
typename iterator_traits < _InputIterator > :: difference_type 
__distance (_InputIterator __first , _InputIterator __last , 
input_iterator_tag) 
{ 



typename iterator_traits < _InputIterator > :: difference_type __n = 0 ; 
while (__first != __last) 
{ 
++ __first ; 
++ __n ; 
} 
return __n ; 
} 

template < typename _RandomAccessIterator > 
inline 
typename iterator_traits < _RandomAccessIterator > :: difference_type 
__distance (_RandomAccessIterator __first , _RandomAccessIterator __last , 
random_access_iterator_tag) 
{ 



return __last - __first ; 
} 



template < typename _Tp >
    ptrdiff_t
    __distance ( std :: _List_iterator < _Tp >,
        std :: _List_iterator < _Tp >,
        input_iterator_tag );

template < typename _Tp >
    ptrdiff_t
    __distance ( std :: _List_const_iterator < _Tp >,
        std :: _List_const_iterator < _Tp >,
        input_iterator_tag );
# 135 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_funcs.h" 3
template < typename _InputIterator > 
inline 
typename iterator_traits < _InputIterator > :: difference_type 
distance (_InputIterator __first , _InputIterator __last) 
{ 

return std :: __distance (__first , __last , 
std :: __iterator_category (__first)) ; 
} 

template < typename _InputIterator , typename _Distance > 
inline void 
__advance (_InputIterator & __i , _Distance __n , input_iterator_tag) 
{ 


; 
while (__n --) 
++ __i ; 
} 

template < typename _BidirectionalIterator , typename _Distance > 
inline void 
__advance (_BidirectionalIterator & __i , _Distance __n , 
bidirectional_iterator_tag) 
{ 



if (__n > 0) 
while (__n --) 
++ __i ; 
else 
while (__n ++) 
-- __i ; 
} 

template < typename _RandomAccessIterator , typename _Distance > 
inline void 
__advance (_RandomAccessIterator & __i , _Distance __n , 
random_access_iterator_tag) 
{ 



if (__builtin_constant_p (__n) && __n == 1) 
++ __i ; 
else if (__builtin_constant_p (__n) && __n == - 1) 
-- __i ; 
else 
__i += __n ; 
} 
# 200 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator_base_funcs.h" 3
template < typename _InputIterator , typename _Distance > 
inline void 
advance (_InputIterator & __i , _Distance __n) 
{ 

typename iterator_traits < _InputIterator > :: difference_type __d = __n ; 
std :: __advance (__i , __d , std :: __iterator_category (__i)) ; 
} 



template < typename _InputIterator > 
inline _InputIterator 
next (_InputIterator __x , typename 
iterator_traits < _InputIterator > :: difference_type __n = 1) 
{ 


std :: advance (__x , __n) ; 
return __x ; 
} 

template < typename _BidirectionalIterator > 
inline _BidirectionalIterator 
prev (_BidirectionalIterator __x , typename 
iterator_traits < _BidirectionalIterator > :: difference_type __n = 1) 
{ 



std :: advance (__x , - __n) ; 
return __x ; 
} 




}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ptr_traits.h" 3
namespace std { 



class __undefined; 


template < typename _Tp > 
struct __get_first_arg 
{ using type = __undefined ; } ;

template < template < typename , typename ... > class _Template , typename _Tp , 
typename ... _Types > 
struct __get_first_arg < _Template < _Tp , _Types ... > > 
{ using type = _Tp ; } ;

template < typename _Tp >
    using __get_first_arg_t = typename __get_first_arg < _Tp > :: type;


template < typename _Tp , typename _Up > 
struct __replace_first_arg 
{ } ;

template < template < typename , typename ... > class _Template , typename _Up , 
typename _Tp , typename ... _Types > 
struct __replace_first_arg < _Template < _Tp , _Types ... > , _Up > 
{ using type = _Template < _Up , _Types ... > ; } ;

template < typename _Tp, typename _Up >
    using __replace_first_arg_t = typename __replace_first_arg < _Tp, _Up > :: type;

template < typename _Tp >
    using __make_not_void
      = typename conditional < is_void < _Tp > :: value, __undefined, _Tp > :: type;
# 77
template < typename _Ptr > 
struct pointer_traits 
{ 
private : 
template < typename _Tp > 
using __element_type = typename _Tp :: element_type ; 

template < typename _Tp > 
using __difference_type = typename _Tp :: difference_type ; 

template < typename _Tp , typename _Up , typename = void > 
struct __rebind : __replace_first_arg < _Tp , _Up > { } ; 

template < typename _Tp , typename _Up > 
struct __rebind < _Tp , _Up , __void_t < typename _Tp :: template rebind < _Up > > > 
{ using type = typename _Tp :: template rebind < _Up > ; } ; 

public : 

using pointer = _Ptr ; 


using element_type 
= __detected_or_t < __get_first_arg_t < _Ptr > , __element_type , _Ptr > ; 


using difference_type 
= __detected_or_t < ptrdiff_t , __difference_type , _Ptr > ; 


template < typename _Up > 
using rebind = typename __rebind < _Ptr , _Up > :: type ; 

static _Ptr 
pointer_to (__make_not_void < element_type > & __e) 
{ return _Ptr :: pointer_to (__e) ; } 

static_assert (! is_same < element_type , __undefined > :: value , 
"pointer type defines element_type or is like SomePointer<T, Args>") ; 
} ;
# 122
template < typename _Tp > 
struct pointer_traits < _Tp * > 
{ 

typedef _Tp * pointer ; 

typedef _Tp element_type ; 

typedef ptrdiff_t difference_type ; 

template < typename _Up > 
using rebind = _Up * ; 
# 140
static pointer 
pointer_to (__make_not_void < element_type > & __r) noexcept 
{ return std :: addressof (__r) ; } 
} ;


template < typename _Ptr, typename _Tp >
    using __ptr_rebind = typename pointer_traits < _Ptr > :: template rebind < _Tp >;

template < typename _Tp > 
constexpr _Tp * 
__to_address (_Tp * __ptr) noexcept 
{ 
static_assert (! std :: is_function < _Tp > :: value , "not a function pointer") ; 
return __ptr ; 
} 


template < typename _Ptr > 
constexpr typename std :: pointer_traits < _Ptr > :: element_type * 
__to_address (const _Ptr & __ptr) 
{ return std :: __to_address (__ptr . operator -> ()) ; } 
# 199 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ptr_traits.h" 3
}
# 76 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
namespace std { 
# 104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Iterator > 
class reverse_iterator 
: public iterator < typename iterator_traits < _Iterator > :: iterator_category , 
typename iterator_traits < _Iterator > :: value_type , 
typename iterator_traits < _Iterator > :: difference_type , 
typename iterator_traits < _Iterator > :: pointer , 
typename iterator_traits < _Iterator > :: reference > 
{ 
protected : 
_Iterator current ; 

typedef iterator_traits < _Iterator > __traits_type ; 

public : 
typedef _Iterator iterator_type ; 
typedef typename __traits_type :: difference_type difference_type ; 
typedef typename __traits_type :: pointer pointer ; 
typedef typename __traits_type :: reference reference ; 
# 131 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
reverse_iterator () : current () { } 




explicit 
reverse_iterator (iterator_type __x) : current (__x) { } 
# 143
reverse_iterator (const reverse_iterator & __x) 
: current (__x . current) { } 


reverse_iterator & operator = (const reverse_iterator &) = default ; 
# 154
template < typename _Iter > 

reverse_iterator (const reverse_iterator < _Iter > & __x) 
: current (__x . base ()) { } 




iterator_type 
base () const 
{ return current ; } 
# 176 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
reference 
operator * () const 
{ 
_Iterator __tmp = current ; 
return * -- __tmp ; 
} 
# 188
pointer 
operator -> () const 
{ 


_Iterator __tmp = current ; 
-- __tmp ; 
return _S_to_pointer (__tmp) ; 
} 
# 203
reverse_iterator & 
operator ++ () 
{ 
-- current ; 
return * this ; 
} 
# 215
reverse_iterator 
operator ++ (int) 
{ 
reverse_iterator __tmp = * this ; 
-- current ; 
return __tmp ; 
} 
# 228
reverse_iterator & 
operator -- () 
{ 
++ current ; 
return * this ; 
} 
# 240
reverse_iterator 
operator -- (int) 
{ 
reverse_iterator __tmp = * this ; 
++ current ; 
return __tmp ; 
} 
# 253
reverse_iterator 
operator + (difference_type __n) const 
{ return reverse_iterator (current - __n) ; } 
# 263
reverse_iterator & 
operator += (difference_type __n) 
{ 
current -= __n ; 
return * this ; 
} 
# 275
reverse_iterator 
operator - (difference_type __n) const 
{ return reverse_iterator (current + __n) ; } 
# 285
reverse_iterator & 
operator -= (difference_type __n) 
{ 
current += __n ; 
return * this ; 
} 
# 297
reference 
operator [ ] (difference_type __n) const 
{ return * (* this + __n) ; } 

private : 
template < typename _Tp > 
static _Tp * 
_S_to_pointer (_Tp * __p) 
{ return __p ; } 

template < typename _Tp > 
static pointer 
_S_to_pointer (_Tp __t) 
{ return __t . operator -> () ; } 
} ;
# 323 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Iterator > 
inline bool 
operator == (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return __x . base () == __y . base () ; } 

template < typename _Iterator > 
inline bool 
operator < (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return __y . base () < __x . base () ; } 

template < typename _Iterator > 
inline bool 
operator != (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return ! (__x == __y) ; } 

template < typename _Iterator > 
inline bool 
operator > (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return __y < __x ; } 

template < typename _Iterator > 
inline bool 
operator <= (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return ! (__y < __x) ; } 

template < typename _Iterator > 
inline bool 
operator >= (const reverse_iterator < _Iterator > & __x , 
const reverse_iterator < _Iterator > & __y) 
{ return ! (__x < __y) ; } 



template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator == (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return __x . base () == __y . base () ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator < (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return __y . base () < __x . base () ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator != (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return ! (__x == __y) ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator > (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return __y < __x ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator <= (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return ! (__y < __x) ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator >= (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
{ return ! (__x < __y) ; } 
# 413 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _IteratorL , typename _IteratorR > 
inline auto 
operator - (const reverse_iterator < _IteratorL > & __x , 
const reverse_iterator < _IteratorR > & __y) 
-> decltype (__y . base () - __x . base ()) 
{ return __y . base () - __x . base () ; } 


template < typename _Iterator > 
inline reverse_iterator < _Iterator > 
operator + (typename reverse_iterator < _Iterator > :: difference_type __n , 
const reverse_iterator < _Iterator > & __x) 
{ return reverse_iterator < _Iterator > (__x . base () - __n) ; } 



template < typename _Iterator > 
inline reverse_iterator < _Iterator > 
__make_reverse_iterator (_Iterator __i) 
{ return reverse_iterator < _Iterator > (__i) ; } 
# 448 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Iterator > 
auto 
__niter_base (reverse_iterator < _Iterator > __it) 
-> decltype (__make_reverse_iterator (__niter_base (__it . base ()))) 
{ return __make_reverse_iterator (__niter_base (__it . base ())) ; } 

template < typename _Iterator > 
struct __is_move_iterator < reverse_iterator < _Iterator > > 
: __is_move_iterator < _Iterator > 
{ } ;

template < typename _Iterator > 
auto 
__miter_base (reverse_iterator < _Iterator > __it) 
-> decltype (__make_reverse_iterator (__miter_base (__it . base ()))) 
{ return __make_reverse_iterator (__miter_base (__it . base ())) ; } 
# 477 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container > 
class back_insert_iterator 
: public iterator < output_iterator_tag , void , void , void , void > 
{ 
protected : 
_Container * container ; 

public : 

typedef _Container container_type ; 


explicit 
back_insert_iterator (_Container & __x) 
: container (std :: __addressof (__x)) { } 
# 512 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
back_insert_iterator & 
operator = (const typename _Container :: value_type & __value) 
{ 
container -> push_back (__value) ; 
return * this ; 
} 

back_insert_iterator & 
operator = (typename _Container :: value_type && __value) 
{ 
container -> push_back (std :: move (__value)) ; 
return * this ; 
} 



back_insert_iterator & 
operator * () 
{ return * this ; } 


back_insert_iterator & 
operator ++ () 
{ return * this ; } 


back_insert_iterator 
operator ++ (int) 
{ return * this ; } 
} ;
# 554 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container > 
inline back_insert_iterator < _Container > 
back_inserter (_Container & __x) 
{ return back_insert_iterator < _Container > (__x) ; } 
# 569 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container > 
class front_insert_iterator 
: public iterator < output_iterator_tag , void , void , void , void > 
{ 
protected : 
_Container * container ; 

public : 

typedef _Container container_type ; 


explicit front_insert_iterator (_Container & __x) 
: container (std :: __addressof (__x)) { } 
# 603 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
front_insert_iterator & 
operator = (const typename _Container :: value_type & __value) 
{ 
container -> push_front (__value) ; 
return * this ; 
} 

front_insert_iterator & 
operator = (typename _Container :: value_type && __value) 
{ 
container -> push_front (std :: move (__value)) ; 
return * this ; 
} 



front_insert_iterator & 
operator * () 
{ return * this ; } 


front_insert_iterator & 
operator ++ () 
{ return * this ; } 


front_insert_iterator 
operator ++ (int) 
{ return * this ; } 
} ;
# 645 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container > 
inline front_insert_iterator < _Container > 
front_inserter (_Container & __x) 
{ return front_insert_iterator < _Container > (__x) ; } 
# 664 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container > 
class insert_iterator 
: public iterator < output_iterator_tag , void , void , void , void > 
{ 
protected : 
_Container * container ; 
typename _Container :: iterator iter ; 

public : 

typedef _Container container_type ; 
# 680
insert_iterator (_Container & __x , typename _Container :: iterator __i) 
: container (std :: __addressof (__x)) , iter (__i) { } 
# 715 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
insert_iterator & 
operator = (const typename _Container :: value_type & __value) 
{ 
iter = container -> insert (iter , __value) ; 
++ iter ; 
return * this ; 
} 

insert_iterator & 
operator = (typename _Container :: value_type && __value) 
{ 
iter = container -> insert (iter , std :: move (__value)) ; 
++ iter ; 
return * this ; 
} 



insert_iterator & 
operator * () 
{ return * this ; } 


insert_iterator & 
operator ++ () 
{ return * this ; } 


insert_iterator & 
operator ++ (int) 
{ return * this ; } 
} ;
# 760 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Container , typename _Iterator > 
inline insert_iterator < _Container > 
inserter (_Container & __x , _Iterator __i) 
{ 
return insert_iterator < _Container > (__x , 
typename _Container :: iterator (__i)) ; 
} 




}

namespace __gnu_cxx { 
# 784 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
using std::iterator_traits;
using std::iterator;
template < typename _Iterator , typename _Container > 
class __normal_iterator 
{ 
protected : 
_Iterator _M_current ; 

typedef iterator_traits < _Iterator > __traits_type ; 

public : 
typedef _Iterator iterator_type ; 
typedef typename __traits_type :: iterator_category iterator_category ; 
typedef typename __traits_type :: value_type value_type ; 
typedef typename __traits_type :: difference_type difference_type ; 
typedef typename __traits_type :: reference reference ; 
typedef typename __traits_type :: pointer pointer ; 

constexpr __normal_iterator () noexcept 
: _M_current (_Iterator ()) { } 

explicit 
__normal_iterator (const _Iterator & __i) noexcept 
: _M_current (__i) { } 


template < typename _Iter > 
__normal_iterator (const __normal_iterator < _Iter , 
typename __enable_if < 
(std :: __are_same < _Iter , typename _Container :: pointer > :: __value) , 
_Container > :: __type > & __i) noexcept 
: _M_current (__i . base ()) { } 


reference 
operator * () const noexcept 
{ return * _M_current ; } 

pointer 
operator -> () const noexcept 
{ return _M_current ; } 

__normal_iterator & 
operator ++ () noexcept 
{ 
++ _M_current ; 
return * this ; 
} 

__normal_iterator 
operator ++ (int) noexcept 
{ return __normal_iterator (_M_current ++) ; } 


__normal_iterator & 
operator -- () noexcept 
{ 
-- _M_current ; 
return * this ; 
} 

__normal_iterator 
operator -- (int) noexcept 
{ return __normal_iterator (_M_current --) ; } 


reference 
operator [ ] (difference_type __n) const noexcept 
{ return _M_current [ __n ] ; } 

__normal_iterator & 
operator += (difference_type __n) noexcept 
{ _M_current += __n ; return * this ; } 

__normal_iterator 
operator + (difference_type __n) const noexcept 
{ return __normal_iterator (_M_current + __n) ; } 

__normal_iterator & 
operator -= (difference_type __n) noexcept 
{ _M_current -= __n ; return * this ; } 

__normal_iterator 
operator - (difference_type __n) const noexcept 
{ return __normal_iterator (_M_current - __n) ; } 

const _Iterator & 
base () const noexcept 
{ return _M_current ; } 
} ;
# 884 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator == (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () == __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator == (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () == __rhs . base () ; } 

template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator != (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () != __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator != (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () != __rhs . base () ; } 


template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator < (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () < __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator < (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () < __rhs . base () ; } 

template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator > (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () > __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator > (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () > __rhs . base () ; } 

template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator <= (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () <= __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator <= (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () <= __rhs . base () ; } 

template < typename _IteratorL , typename _IteratorR , typename _Container > 
inline bool 
operator >= (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) 
noexcept 
{ return __lhs . base () >= __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline bool 
operator >= (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () >= __rhs . base () ; } 
# 973
template < typename _IteratorL , typename _IteratorR , typename _Container > 


inline auto 
operator - (const __normal_iterator < _IteratorL , _Container > & __lhs , 
const __normal_iterator < _IteratorR , _Container > & __rhs) noexcept 
-> decltype (__lhs . base () - __rhs . base ()) 
# 985
{ return __lhs . base () - __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline typename __normal_iterator < _Iterator , _Container > :: difference_type 
operator - (const __normal_iterator < _Iterator , _Container > & __lhs , 
const __normal_iterator < _Iterator , _Container > & __rhs) 
noexcept 
{ return __lhs . base () - __rhs . base () ; } 

template < typename _Iterator , typename _Container > 
inline __normal_iterator < _Iterator , _Container > 
operator + (typename __normal_iterator < _Iterator , _Container > :: difference_type 
__n , const __normal_iterator < _Iterator , _Container > & __i) 
noexcept 
{ return __normal_iterator < _Iterator , _Container > (__i . base () + __n) ; } 


}

namespace std { 



template < typename _Iterator , typename _Container > 
_Iterator 
__niter_base (__gnu_cxx :: __normal_iterator < _Iterator , _Container > __it) 
noexcept (std :: is_nothrow_copy_constructible < _Iterator > :: value) 
{ return __it . base () ; } 
# 1030 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
template < typename _Iterator > 
class move_iterator 
{ 
protected : 
_Iterator _M_current ; 

typedef iterator_traits < _Iterator > __traits_type ; 
typedef typename __traits_type :: reference __base_ref ; 

public : 
typedef _Iterator iterator_type ; 
typedef typename __traits_type :: iterator_category iterator_category ; 
typedef typename __traits_type :: value_type value_type ; 
typedef typename __traits_type :: difference_type difference_type ; 

typedef _Iterator pointer ; 


typedef typename conditional < is_reference < __base_ref > :: value , 
typename remove_reference < __base_ref > :: type && , 
__base_ref > :: type reference ; 


move_iterator () 
: _M_current () { } 

explicit 
move_iterator (iterator_type __i) 
: _M_current (__i) { } 

template < typename _Iter > 

move_iterator (const move_iterator < _Iter > & __i) 
: _M_current (__i . base ()) { } 

iterator_type 
base () const 
{ return _M_current ; } 

reference 
operator * () const 
{ return static_cast < reference > (* _M_current) ; } 

pointer 
operator -> () const 
{ return _M_current ; } 

move_iterator & 
operator ++ () 
{ 
++ _M_current ; 
return * this ; 
} 

move_iterator 
operator ++ (int) 
{ 
move_iterator __tmp = * this ; 
++ _M_current ; 
return __tmp ; 
} 

move_iterator & 
operator -- () 
{ 
-- _M_current ; 
return * this ; 
} 

move_iterator 
operator -- (int) 
{ 
move_iterator __tmp = * this ; 
-- _M_current ; 
return __tmp ; 
} 

move_iterator 
operator + (difference_type __n) const 
{ return move_iterator (_M_current + __n) ; } 

move_iterator & 
operator += (difference_type __n) 
{ 
_M_current += __n ; 
return * this ; 
} 

move_iterator 
operator - (difference_type __n) const 
{ return move_iterator (_M_current - __n) ; } 

move_iterator & 
operator -= (difference_type __n) 
{ 
_M_current -= __n ; 
return * this ; 
} 

reference 
operator [ ] (difference_type __n) const 
{ return std :: move (_M_current [ __n ]) ; } 
} ;




template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator == (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return __x . base () == __y . base () ; } 

template < typename _Iterator > 
inline bool 
operator == (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return __x . base () == __y . base () ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator != (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return ! (__x == __y) ; } 

template < typename _Iterator > 
inline bool 
operator != (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return ! (__x == __y) ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator < (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return __x . base () < __y . base () ; } 

template < typename _Iterator > 
inline bool 
operator < (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return __x . base () < __y . base () ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator <= (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return ! (__y < __x) ; } 

template < typename _Iterator > 
inline bool 
operator <= (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return ! (__y < __x) ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator > (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return __y < __x ; } 

template < typename _Iterator > 
inline bool 
operator > (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return __y < __x ; } 

template < typename _IteratorL , typename _IteratorR > 
inline bool 
operator >= (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
{ return ! (__x < __y) ; } 

template < typename _Iterator > 
inline bool 
operator >= (const move_iterator < _Iterator > & __x , 
const move_iterator < _Iterator > & __y) 
{ return ! (__x < __y) ; } 


template < typename _IteratorL , typename _IteratorR > 
inline auto 
operator - (const move_iterator < _IteratorL > & __x , 
const move_iterator < _IteratorR > & __y) 
-> decltype (__x . base () - __y . base ()) 
{ return __x . base () - __y . base () ; } 

template < typename _Iterator > 
inline move_iterator < _Iterator > 
operator + (typename move_iterator < _Iterator > :: difference_type __n , 
const move_iterator < _Iterator > & __x) 
{ return __x + __n ; } 

template < typename _Iterator > 
inline move_iterator < _Iterator > 
make_move_iterator (_Iterator __i) 
{ return move_iterator < _Iterator > (__i) ; } 

template < typename _Iterator , typename _ReturnType 
= typename conditional < __move_if_noexcept_cond 
< typename iterator_traits < _Iterator > :: value_type > :: value , 
_Iterator , move_iterator < _Iterator > > :: type > 
inline _ReturnType 
__make_move_if_noexcept_iterator (_Iterator __i) 
{ return _ReturnType (__i) ; } 



template < typename _Tp , typename _ReturnType 
= typename conditional < __move_if_noexcept_cond < _Tp > :: value , 
const _Tp * , move_iterator < _Tp * > > :: type > 
inline _ReturnType 
__make_move_if_noexcept_iterator (_Tp * __i) 
{ return _ReturnType (__i) ; } 



template < typename _Iterator > 
auto 
__niter_base (move_iterator < _Iterator > __it) 
-> decltype (make_move_iterator (__niter_base (__it . base ()))) 
{ return make_move_iterator (__niter_base (__it . base ())) ; } 

template < typename _Iterator > 
struct __is_move_iterator < move_iterator < _Iterator > > 
{ 
enum { __value = 1 } ; 
typedef __true_type __type ; 
} ;

template < typename _Iterator > 
auto 
__miter_base (move_iterator < _Iterator > __it) 
-> decltype (__miter_base (__it . base ())) 
{ return __miter_base (__it . base ()) ; } 
# 1296 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_iterator.h" 3
}
# 48 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\debug\\debug.h" 3
namespace std { 

namespace __debug { }
}




namespace __gnu_debug { 

using namespace std::__debug;
}
# 33 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\predefined_ops.h" 3
namespace __gnu_cxx { 

namespace __ops { 

struct _Iter_less_iter { 

template < typename _Iterator1 , typename _Iterator2 > 

bool 
operator () (_Iterator1 __it1 , _Iterator2 __it2) const 
{ return * __it1 < * __it2 ; } 
}; 



inline _Iter_less_iter __iter_less_iter() 
{ return _Iter_less_iter(); } 

struct _Iter_less_val { 


constexpr _Iter_less_val() = default;
# 60
explicit _Iter_less_val(_Iter_less_iter) { } 

template < typename _Iterator , typename _Value > 
bool 
operator () (_Iterator __it , _Value & __val) const 
{ return * __it < __val ; } 
}; 


inline _Iter_less_val __iter_less_val() 
{ return _Iter_less_val(); } 


inline _Iter_less_val __iter_comp_val(_Iter_less_iter) 
{ return _Iter_less_val(); } 

struct _Val_less_iter { 


constexpr _Val_less_iter() = default;
# 85
explicit _Val_less_iter(_Iter_less_iter) { } 

template < typename _Value , typename _Iterator > 
bool 
operator () (_Value & __val , _Iterator __it) const 
{ return __val < * __it ; } 
}; 


inline _Val_less_iter __val_less_iter() 
{ return _Val_less_iter(); } 


inline _Val_less_iter __val_comp_iter(_Iter_less_iter) 
{ return _Val_less_iter(); } 

struct _Iter_equal_to_iter { 

template < typename _Iterator1 , typename _Iterator2 > 
bool 
operator () (_Iterator1 __it1 , _Iterator2 __it2) const 
{ return * __it1 == * __it2 ; } 
}; 


inline _Iter_equal_to_iter __iter_equal_to_iter() 
{ return _Iter_equal_to_iter(); } 

struct _Iter_equal_to_val { 

template < typename _Iterator , typename _Value > 
bool 
operator () (_Iterator __it , _Value & __val) const 
{ return * __it == __val ; } 
}; 


inline _Iter_equal_to_val __iter_equal_to_val() 
{ return _Iter_equal_to_val(); } 


inline _Iter_equal_to_val __iter_comp_val(_Iter_equal_to_iter) 
{ return _Iter_equal_to_val(); } 

template < typename _Compare > 
struct _Iter_comp_iter 
{ 
_Compare _M_comp ; 

explicit 
_Iter_comp_iter (_Compare __comp) 
: _M_comp (std :: move (__comp)) 
{ } 

template < typename _Iterator1 , typename _Iterator2 > 

bool 
operator () (_Iterator1 __it1 , _Iterator2 __it2) 
{ return bool (_M_comp (* __it1 , * __it2)) ; } 
} ;

template < typename _Compare > 

inline _Iter_comp_iter < _Compare > 
__iter_comp_iter (_Compare __comp) 
{ return _Iter_comp_iter < _Compare > (std :: move (__comp)) ; } 

template < typename _Compare > 
struct _Iter_comp_val 
{ 
_Compare _M_comp ; 

explicit 
_Iter_comp_val (_Compare __comp) 
: _M_comp (std :: move (__comp)) 
{ } 

explicit 
_Iter_comp_val (const _Iter_comp_iter < _Compare > & __comp) 
: _M_comp (__comp . _M_comp) 
{ } 


explicit 
_Iter_comp_val (_Iter_comp_iter < _Compare > && __comp) 
: _M_comp (std :: move (__comp . _M_comp)) 
{ } 


template < typename _Iterator , typename _Value > 
bool 
operator () (_Iterator __it , _Value & __val) 
{ return bool (_M_comp (* __it , __val)) ; } 
} ;

template < typename _Compare > 
inline _Iter_comp_val < _Compare > 
__iter_comp_val (_Compare __comp) 
{ return _Iter_comp_val < _Compare > (std :: move (__comp)) ; } 

template < typename _Compare > 
inline _Iter_comp_val < _Compare > 
__iter_comp_val (_Iter_comp_iter < _Compare > __comp) 
{ return _Iter_comp_val < _Compare > (std :: move (__comp)) ; } 

template < typename _Compare > 
struct _Val_comp_iter 
{ 
_Compare _M_comp ; 

explicit 
_Val_comp_iter (_Compare __comp) 
: _M_comp (std :: move (__comp)) 
{ } 

explicit 
_Val_comp_iter (const _Iter_comp_iter < _Compare > & __comp) 
: _M_comp (__comp . _M_comp) 
{ } 


explicit 
_Val_comp_iter (_Iter_comp_iter < _Compare > && __comp) 
: _M_comp (std :: move (__comp . _M_comp)) 
{ } 


template < typename _Value , typename _Iterator > 
bool 
operator () (_Value & __val , _Iterator __it) 
{ return bool (_M_comp (__val , * __it)) ; } 
} ;

template < typename _Compare > 
inline _Val_comp_iter < _Compare > 
__val_comp_iter (_Compare __comp) 
{ return _Val_comp_iter < _Compare > (std :: move (__comp)) ; } 

template < typename _Compare > 
inline _Val_comp_iter < _Compare > 
__val_comp_iter (_Iter_comp_iter < _Compare > __comp) 
{ return _Val_comp_iter < _Compare > (std :: move (__comp)) ; } 

template < typename _Value > 
struct _Iter_equals_val 
{ 
_Value & _M_value ; 

explicit 
_Iter_equals_val (_Value & __value) 
: _M_value (__value) 
{ } 

template < typename _Iterator > 
bool 
operator () (_Iterator __it) 
{ return * __it == _M_value ; } 
} ;

template < typename _Value > 
inline _Iter_equals_val < _Value > 
__iter_equals_val (_Value & __val) 
{ return _Iter_equals_val < _Value > (__val) ; } 

template < typename _Iterator1 > 
struct _Iter_equals_iter 
{ 
_Iterator1 _M_it1 ; 

explicit 
_Iter_equals_iter (_Iterator1 __it1) 
: _M_it1 (__it1) 
{ } 

template < typename _Iterator2 > 
bool 
operator () (_Iterator2 __it2) 
{ return * __it2 == * _M_it1 ; } 
} ;

template < typename _Iterator > 
inline _Iter_equals_iter < _Iterator > 
__iter_comp_iter (_Iter_equal_to_iter , _Iterator __it) 
{ return _Iter_equals_iter < _Iterator > (__it) ; } 

template < typename _Predicate > 
struct _Iter_pred 
{ 
_Predicate _M_pred ; 

explicit 
_Iter_pred (_Predicate __pred) 
: _M_pred (std :: move (__pred)) 
{ } 

template < typename _Iterator > 
bool 
operator () (_Iterator __it) 
{ return bool (_M_pred (* __it)) ; } 
} ;

template < typename _Predicate > 
inline _Iter_pred < _Predicate > 
__pred_iter (_Predicate __pred) 
{ return _Iter_pred < _Predicate > (std :: move (__pred)) ; } 

template < typename _Compare , typename _Value > 
struct _Iter_comp_to_val 
{ 
_Compare _M_comp ; 
_Value & _M_value ; 

_Iter_comp_to_val (_Compare __comp , _Value & __value) 
: _M_comp (std :: move (__comp)) , _M_value (__value) 
{ } 

template < typename _Iterator > 
bool 
operator () (_Iterator __it) 
{ return bool (_M_comp (* __it , _M_value)) ; } 
} ;

template < typename _Compare , typename _Value > 
_Iter_comp_to_val < _Compare , _Value > 
__iter_comp_val (_Compare __comp , _Value & __val) 
{ 
return _Iter_comp_to_val < _Compare , _Value > (std :: move (__comp) , __val) ; 
} 

template < typename _Compare , typename _Iterator1 > 
struct _Iter_comp_to_iter 
{ 
_Compare _M_comp ; 
_Iterator1 _M_it1 ; 

_Iter_comp_to_iter (_Compare __comp , _Iterator1 __it1) 
: _M_comp (std :: move (__comp)) , _M_it1 (__it1) 
{ } 

template < typename _Iterator2 > 
bool 
operator () (_Iterator2 __it2) 
{ return bool (_M_comp (* __it2 , * _M_it1)) ; } 
} ;

template < typename _Compare , typename _Iterator > 
inline _Iter_comp_to_iter < _Compare , _Iterator > 
__iter_comp_iter (_Iter_comp_iter < _Compare > __comp , _Iterator __it) 
{ 
return _Iter_comp_to_iter < _Compare , _Iterator > (
std :: move (__comp . _M_comp) , __it) ; 
} 

template < typename _Predicate > 
struct _Iter_negate 
{ 
_Predicate _M_pred ; 

explicit 
_Iter_negate (_Predicate __pred) 
: _M_pred (std :: move (__pred)) 
{ } 

template < typename _Iterator > 
bool 
operator () (_Iterator __it) 
{ return ! bool (_M_pred (* __it)) ; } 
} ;

template < typename _Predicate > 
inline _Iter_negate < _Predicate > 
__negate (_Iter_pred < _Predicate > __pred) 
{ return _Iter_negate < _Predicate > (std :: move (__pred . _M_pred)) ; } 

}
}
# 76 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
namespace std { 
# 121 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 > 
inline void 
iter_swap (_ForwardIterator1 __a , _ForwardIterator2 __b) 
{ 
# 151 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
swap (* __a , * __b) ; 

} 
# 167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 > 
_ForwardIterator2 
swap_ranges (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2) 
{ 
# 177
; 

for (; __first1 != __last1 ; ++ __first1 , (void) ++ __first2) 
std :: iter_swap (__first1 , __first2) ; 
return __first2 ; 
} 
# 195 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _Tp > 

inline const _Tp & 
min (const _Tp & __a , const _Tp & __b) 
{ 



if (__b < __a) 
return __b ; 
return __a ; 
} 
# 219 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _Tp > 

inline const _Tp & 
max (const _Tp & __a , const _Tp & __b) 
{ 



if (__a < __b) 
return __b ; 
return __a ; 
} 
# 243 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _Tp , typename _Compare > 

inline const _Tp & 
min (const _Tp & __a , const _Tp & __b , _Compare __comp) 
{ 

if (__comp (__b , __a)) 
return __b ; 
return __a ; 
} 
# 265 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _Tp , typename _Compare > 

inline const _Tp & 
max (const _Tp & __a , const _Tp & __b , _Compare __comp) 
{ 

if (__comp (__a , __b)) 
return __b ; 
return __a ; 
} 



template < typename _Iterator > 
inline _Iterator 
__niter_base (_Iterator __it) 
noexcept (std :: is_nothrow_copy_constructible < _Iterator > :: value) 
{ return __it ; } 




template < typename _From , typename _To > 
inline _From 
__niter_wrap (_From __from , _To __res) 
{ return __from + (__res - std :: __niter_base (__from)) ; } 


template < typename _Iterator > 
inline _Iterator 
__niter_wrap (const _Iterator & , _Iterator __res) 
{ return __res ; } 
# 304
template < bool , bool , typename > 
struct __copy_move 
{ 
template < typename _II , typename _OI > 
static _OI 
__copy_m (_II __first , _II __last , _OI __result) 
{ 
for (; __first != __last ; ++ __result , (void) ++ __first) 
* __result = * __first ; 
return __result ; 
} 
} ;


template < typename _Category > 
struct __copy_move < true , false , _Category > 
{ 
template < typename _II , typename _OI > 
static _OI 
__copy_m (_II __first , _II __last , _OI __result) 
{ 
for (; __first != __last ; ++ __result , (void) ++ __first) 
* __result = std :: move (* __first) ; 
return __result ; 
} 
} ;



template<> struct __copy_move< false, false, random_access_iterator_tag>  { 

template < typename _II , typename _OI > 
static _OI 
__copy_m (_II __first , _II __last , _OI __result) 
{ 
typedef typename iterator_traits < _II > :: difference_type _Distance ; 
for (_Distance __n = __last - __first ; __n > 0 ; -- __n) 
{ 
* __result = * __first ; 
++ __first ; 
++ __result ; 
} 
return __result ; 
} 
}; 



template<> struct __copy_move< true, false, random_access_iterator_tag>  { 

template < typename _II , typename _OI > 
static _OI 
__copy_m (_II __first , _II __last , _OI __result) 
{ 
typedef typename iterator_traits < _II > :: difference_type _Distance ; 
for (_Distance __n = __last - __first ; __n > 0 ; -- __n) 
{ 
* __result = std :: move (* __first) ; 
++ __first ; 
++ __result ; 
} 
return __result ; 
} 
}; 


template < bool _IsMove > 
struct __copy_move < _IsMove , true , random_access_iterator_tag > 
{ 
template < typename _Tp > 
static _Tp * 
__copy_m (const _Tp * __first , const _Tp * __last , _Tp * __result) 
{ 

using __assignable = conditional < _IsMove , 
is_move_assignable < _Tp > , 
is_copy_assignable < _Tp > > ; 

static_assert (__assignable :: type :: value , "type is not assignable") ; 

const ptrdiff_t _Num = __last - __first ; 
if (_Num) 
__builtin_memmove (__result , __first , sizeof (_Tp) * _Num) ; 
return __result + _Num ; 
} 
} ;

template < bool _IsMove , typename _II , typename _OI > 
inline _OI 
__copy_move_a (_II __first , _II __last , _OI __result) 
{ 
typedef typename iterator_traits < _II > :: value_type _ValueTypeI ; 
typedef typename iterator_traits < _OI > :: value_type _ValueTypeO ; 
typedef typename iterator_traits < _II > :: iterator_category _Category ; 
const bool __simple = (__is_trivially_copyable (_ValueTypeI) 
&& __is_pointer < _II > :: __value 
&& __is_pointer < _OI > :: __value 
&& __are_same < _ValueTypeI , _ValueTypeO > :: __value) ; 

return std :: __copy_move < _IsMove , __simple , 
_Category > :: __copy_m (__first , __last , __result) ; 
} 



template < typename _CharT >
    struct char_traits;

template < typename _CharT, typename _Traits >
    class istreambuf_iterator;

template < typename _CharT, typename _Traits >
    class ostreambuf_iterator;

template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
      ostreambuf_iterator < _CharT, char_traits < _CharT > > > :: __type
    __copy_move_a2 ( _CharT *, _CharT *,
     ostreambuf_iterator < _CharT, char_traits < _CharT > > );

template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
      ostreambuf_iterator < _CharT, char_traits < _CharT > > > :: __type
    __copy_move_a2 ( const _CharT *, const _CharT *,
     ostreambuf_iterator < _CharT, char_traits < _CharT > > );

template < bool _IsMove, typename _CharT >
    typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value,
        _CharT * > :: __type
    __copy_move_a2 ( istreambuf_iterator < _CharT, char_traits < _CharT > >,
     istreambuf_iterator < _CharT, char_traits < _CharT > >, _CharT * );

template < bool _IsMove , typename _II , typename _OI > 
inline _OI 
__copy_move_a2 (_II __first , _II __last , _OI __result) 
{ 
return std :: __niter_wrap (__result , 
std :: __copy_move_a < _IsMove > (std :: __niter_base (__first) , 
std :: __niter_base (__last) , 
std :: __niter_base (__result))) ; 
} 
# 463 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _II , typename _OI > 
inline _OI 
copy (_II __first , _II __last , _OI __result) 
{ 




; 

return std :: __copy_move_a2 < __is_move_iterator < _II > :: __value > 
(std :: __miter_base (__first) , std :: __miter_base (__last) , __result) ; 
} 
# 495 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _II , typename _OI > 
inline _OI 
move (_II __first , _II __last , _OI __result) 
{ 




; 

return std :: __copy_move_a2 < true > (std :: __miter_base (__first) , 
std :: __miter_base (__last) , __result) ; 
} 
# 514
template < bool , bool , typename > 
struct __copy_move_backward 
{ 
template < typename _BI1 , typename _BI2 > 
static _BI2 
__copy_move_b (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
while (__first != __last) 
* -- __result = * -- __last ; 
return __result ; 
} 
} ;


template < typename _Category > 
struct __copy_move_backward < true , false , _Category > 
{ 
template < typename _BI1 , typename _BI2 > 
static _BI2 
__copy_move_b (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
while (__first != __last) 
* -- __result = std :: move (* -- __last) ; 
return __result ; 
} 
} ;



template<> struct __copy_move_backward< false, false, random_access_iterator_tag>  { 

template < typename _BI1 , typename _BI2 > 
static _BI2 
__copy_move_b (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
typename iterator_traits < _BI1 > :: difference_type __n ; 
for (__n = __last - __first ; __n > 0 ; -- __n) 
* -- __result = * -- __last ; 
return __result ; 
} 
}; 



template<> struct __copy_move_backward< true, false, random_access_iterator_tag>  { 

template < typename _BI1 , typename _BI2 > 
static _BI2 
__copy_move_b (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
typename iterator_traits < _BI1 > :: difference_type __n ; 
for (__n = __last - __first ; __n > 0 ; -- __n) 
* -- __result = std :: move (* -- __last) ; 
return __result ; 
} 
}; 


template < bool _IsMove > 
struct __copy_move_backward < _IsMove , true , random_access_iterator_tag > 
{ 
template < typename _Tp > 
static _Tp * 
__copy_move_b (const _Tp * __first , const _Tp * __last , _Tp * __result) 
{ 

using __assignable = conditional < _IsMove , 
is_move_assignable < _Tp > , 
is_copy_assignable < _Tp > > ; 

static_assert (__assignable :: type :: value , "type is not assignable") ; 

const ptrdiff_t _Num = __last - __first ; 
if (_Num) 
__builtin_memmove (__result - _Num , __first , sizeof (_Tp) * _Num) ; 
return __result - _Num ; 
} 
} ;

template < bool _IsMove , typename _BI1 , typename _BI2 > 
inline _BI2 
__copy_move_backward_a (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
typedef typename iterator_traits < _BI1 > :: value_type _ValueType1 ; 
typedef typename iterator_traits < _BI2 > :: value_type _ValueType2 ; 
typedef typename iterator_traits < _BI1 > :: iterator_category _Category ; 
const bool __simple = (__is_trivially_copyable (_ValueType1) 
&& __is_pointer < _BI1 > :: __value 
&& __is_pointer < _BI2 > :: __value 
&& __are_same < _ValueType1 , _ValueType2 > :: __value) ; 

return std :: __copy_move_backward < _IsMove , __simple , 
_Category > :: __copy_move_b (__first , 
__last , 
__result) ; 
} 

template < bool _IsMove , typename _BI1 , typename _BI2 > 
inline _BI2 
__copy_move_backward_a2 (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
return std :: __niter_wrap (__result , 
std :: __copy_move_backward_a < _IsMove > 
(std :: __niter_base (__first) , std :: __niter_base (__last) , 
std :: __niter_base (__result))) ; 
} 
# 639 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _BI1 , typename _BI2 > 
inline _BI2 
copy_backward (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
# 649
; 

return std :: __copy_move_backward_a2 < __is_move_iterator < _BI1 > :: __value > 
(std :: __miter_base (__first) , std :: __miter_base (__last) , __result) ; 
} 
# 674 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _BI1 , typename _BI2 > 
inline _BI2 
move_backward (_BI1 __first , _BI1 __last , _BI2 __result) 
{ 
# 684
; 

return std :: __copy_move_backward_a2 < true > (std :: __miter_base (__first) , 
std :: __miter_base (__last) , 
__result) ; 
} 
# 696
template < typename _ForwardIterator , typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < ! __is_scalar < _Tp > :: __value , void > :: __type 
__fill_a (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __value) 
{ 
for (; __first != __last ; ++ __first) 
* __first = __value ; 
} 

template < typename _ForwardIterator , typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < __is_scalar < _Tp > :: __value , void > :: __type 
__fill_a (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __value) 
{ 
const _Tp __tmp = __value ; 
for (; __first != __last ; ++ __first) 
* __first = __tmp ; 
} 


template < typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < __is_byte < _Tp > :: __value , void > :: __type 
__fill_a (_Tp * __first , _Tp * __last , const _Tp & __c) 
{ 
const _Tp __tmp = __c ; 
if (const size_t __len = __last - __first) 
__builtin_memset (__first , static_cast < unsigned char > (__tmp) , __len) ; 
} 
# 740 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline void 
fill (_ForwardIterator __first , _ForwardIterator __last , const _Tp & __value) 
{ 



; 

std :: __fill_a (std :: __niter_base (__first) , std :: __niter_base (__last) , 
__value) ; 
} 

template < typename _OutputIterator , typename _Size , typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < ! __is_scalar < _Tp > :: __value , _OutputIterator > :: __type 
__fill_n_a (_OutputIterator __first , _Size __n , const _Tp & __value) 
{ 
for (__decltype (__n + 0) __niter = __n ; 
__niter > 0 ; -- __niter , (void) ++ __first) 
* __first = __value ; 
return __first ; 
} 

template < typename _OutputIterator , typename _Size , typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < __is_scalar < _Tp > :: __value , _OutputIterator > :: __type 
__fill_n_a (_OutputIterator __first , _Size __n , const _Tp & __value) 
{ 
const _Tp __tmp = __value ; 
for (__decltype (__n + 0) __niter = __n ; 
__niter > 0 ; -- __niter , (void) ++ __first) 
* __first = __tmp ; 
return __first ; 
} 

template < typename _Size , typename _Tp > 
inline typename 
__gnu_cxx :: __enable_if < __is_byte < _Tp > :: __value , _Tp * > :: __type 
__fill_n_a (_Tp * __first , _Size __n , const _Tp & __c) 
{ 
std :: __fill_a (__first , __first + __n , __c) ; 
return __first + __n ; 
} 
# 800 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _OI , typename _Size , typename _Tp > 
inline _OI 
fill_n (_OI __first , _Size __n , const _Tp & __value) 
{ 


; 

return std :: __niter_wrap (__first , 
std :: __fill_n_a (std :: __niter_base (__first) , __n , __value)) ; 
} 

template < bool _BoolType > 
struct __equal 
{ 
template < typename _II1 , typename _II2 > 
static bool 
equal (_II1 __first1 , _II1 __last1 , _II2 __first2) 
{ 
for (; __first1 != __last1 ; ++ __first1 , (void) ++ __first2) 
if (! (* __first1 == * __first2)) 
return false ; 
return true ; 
} 
} ;


template<> struct __equal< true>  { 

template < typename _Tp > 
static bool 
equal (const _Tp * __first1 , const _Tp * __last1 , const _Tp * __first2) 
{ 
if (const size_t __len = (__last1 - __first1)) 
return ! __builtin_memcmp (__first1 , __first2 , sizeof (_Tp) * __len) ; 
return true ; 
} 
}; 

template < typename _II1 , typename _II2 > 
inline bool 
__equal_aux (_II1 __first1 , _II1 __last1 , _II2 __first2) 
{ 
typedef typename iterator_traits < _II1 > :: value_type _ValueType1 ; 
typedef typename iterator_traits < _II2 > :: value_type _ValueType2 ; 
const bool __simple = ((__is_integer < _ValueType1 > :: __value 
|| __is_pointer < _ValueType1 > :: __value) 
&& __is_pointer < _II1 > :: __value 
&& __is_pointer < _II2 > :: __value 
&& __are_same < _ValueType1 , _ValueType2 > :: __value) ; 

return std :: __equal < __simple > :: equal (__first1 , __last1 , __first2) ; 
} 

template < typename , typename > 
struct __lc_rai 
{ 
template < typename _II1 , typename _II2 > 
static _II1 
__newlast1 (_II1 , _II1 __last1 , _II2 , _II2) 
{ return __last1 ; } 

template < typename _II > 
static bool 
__cnd2 (_II __first , _II __last) 
{ return __first != __last ; } 
} ;


template<> struct __lc_rai< random_access_iterator_tag, random_access_iterator_tag>  { 

template < typename _RAI1 , typename _RAI2 > 
static _RAI1 
__newlast1 (_RAI1 __first1 , _RAI1 __last1 , 
_RAI2 __first2 , _RAI2 __last2) 
{ 
const typename iterator_traits < _RAI1 > :: difference_type 
__diff1 = __last1 - __first1 ; 
const typename iterator_traits < _RAI2 > :: difference_type 
__diff2 = __last2 - __first2 ; 
return __diff2 < __diff1 ? __first1 + __diff2 : __last1 ; 
} 

template < typename _RAI > 
static bool 
__cnd2 (_RAI , _RAI) 
{ return true ; } 
}; 

template < typename _II1 , typename _II2 , typename _Compare > 
bool 
__lexicographical_compare_impl (_II1 __first1 , _II1 __last1 , 
_II2 __first2 , _II2 __last2 , 
_Compare __comp) 
{ 
typedef typename iterator_traits < _II1 > :: iterator_category _Category1 ; 
typedef typename iterator_traits < _II2 > :: iterator_category _Category2 ; 
typedef std :: __lc_rai < _Category1 , _Category2 > __rai_type ; 

__last1 = __rai_type :: __newlast1 (__first1 , __last1 , __first2 , __last2) ; 
for (; __first1 != __last1 && __rai_type :: __cnd2 (__first2 , __last2) ; 
++ __first1 , (void) ++ __first2) 
{ 
if (__comp (__first1 , __first2)) 
return true ; 
if (__comp (__first2 , __first1)) 
return false ; 
} 
return __first1 == __last1 && __first2 != __last2 ; 
} 

template < bool _BoolType > 
struct __lexicographical_compare 
{ 
template < typename _II1 , typename _II2 > 
static bool __lc (_II1 , _II1 , _II2 , _II2) ; 
} ;

template < bool _BoolType > 
template < typename _II1 , typename _II2 > 
bool 
__lexicographical_compare < _BoolType > :: 
__lc (_II1 __first1 , _II1 __last1 , _II2 __first2 , _II2 __last2) 
{ 
return std :: __lexicographical_compare_impl (__first1 , __last1 , 
__first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 


template<> struct __lexicographical_compare< true>  { 

template < typename _Tp , typename _Up > 
static bool 
__lc (const _Tp * __first1 , const _Tp * __last1 , 
const _Up * __first2 , const _Up * __last2) 
{ 
const size_t __len1 = __last1 - __first1 ; 
const size_t __len2 = __last2 - __first2 ; 
if (const size_t __len = std :: min (__len1 , __len2)) 
if (int __result = __builtin_memcmp (__first1 , __first2 , __len)) 
return __result < 0 ; 
return __len1 < __len2 ; 
} 
}; 

template < typename _II1 , typename _II2 > 
inline bool 
__lexicographical_compare_aux (_II1 __first1 , _II1 __last1 , 
_II2 __first2 , _II2 __last2) 
{ 
typedef typename iterator_traits < _II1 > :: value_type _ValueType1 ; 
typedef typename iterator_traits < _II2 > :: value_type _ValueType2 ; 
const bool __simple = 
(__is_byte < _ValueType1 > :: __value && __is_byte < _ValueType2 > :: __value 
&& ! __gnu_cxx :: __numeric_traits < _ValueType1 > :: __is_signed 
&& ! __gnu_cxx :: __numeric_traits < _ValueType2 > :: __is_signed 
&& __is_pointer < _II1 > :: __value 
&& __is_pointer < _II2 > :: __value) ; 

return std :: __lexicographical_compare < __simple > :: __lc (__first1 , __last1 , 
__first2 , __last2) ; 
} 

template < typename _ForwardIterator , typename _Tp , typename _Compare > 
_ForwardIterator 
__lower_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: difference_type 
_DistanceType ; 

_DistanceType __len = std :: distance (__first , __last) ; 

while (__len > 0) 
{ 
_DistanceType __half = __len >> 1 ; 
_ForwardIterator __middle = __first ; 
std :: advance (__middle , __half) ; 
if (__comp (__middle , __val)) 
{ 
__first = __middle ; 
++ __first ; 
__len = __len - __half - 1 ; 
} 
else 
__len = __half ; 
} 
return __first ; 
} 
# 1002 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline _ForwardIterator 
lower_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val) 
{ 




; 

return std :: __lower_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_less_val ()) ; 
} 




constexpr int __lg(int __n) 
{ return ((int)sizeof(int) * 8 - 1) - __builtin_clz(__n); } 


constexpr unsigned __lg(unsigned __n) 
{ return ((int)sizeof(int) * 8 - 1) - __builtin_clz(__n); } 


constexpr long __lg(long __n) 
{ return ((int)sizeof(long) * 8 - 1) - __builtin_clzl(__n); } 


constexpr unsigned long __lg(unsigned long __n) 
{ return ((int)sizeof(long) * 8 - 1) - __builtin_clzl(__n); } 


constexpr long long __lg(long long __n) 
{ return ((int)sizeof(long long) * 8 - 1) - __builtin_clzll(__n); } 


constexpr unsigned long long __lg(unsigned long long __n) 
{ return ((int)sizeof(long long) * 8 - 1) - __builtin_clzll(__n); } 
# 1057 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _II1 , typename _II2 > 
inline bool 
equal (_II1 __first1 , _II1 __last1 , _II2 __first2) 
{ 
# 1067
; 

return std :: __equal_aux (std :: __niter_base (__first1) , 
std :: __niter_base (__last1) , 
std :: __niter_base (__first2)) ; 
} 
# 1089 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _IIter1 , typename _IIter2 , typename _BinaryPredicate > 
inline bool 
equal (_IIter1 __first1 , _IIter1 __last1 , 
_IIter2 __first2 , _BinaryPredicate __binary_pred) 
{ 



; 

for (; __first1 != __last1 ; ++ __first1 , (void) ++ __first2) 
if (! bool (__binary_pred (* __first1 , * __first2))) 
return false ; 
return true ; 
} 



template < typename _II1 , typename _II2 > 
inline bool 
__equal4 (_II1 __first1 , _II1 __last1 , _II2 __first2 , _II2 __last2) 
{ 
using _RATag = random_access_iterator_tag ; 
using _Cat1 = typename iterator_traits < _II1 > :: iterator_category ; 
using _Cat2 = typename iterator_traits < _II2 > :: iterator_category ; 
using _RAIters = __and_ < is_same < _Cat1 , _RATag > , is_same < _Cat2 , _RATag >> ; 
if (_RAIters ()) 
{ 
auto __d1 = std :: distance (__first1 , __last1) ; 
auto __d2 = std :: distance (__first2 , __last2) ; 
if (__d1 != __d2) 
return false ; 
return std :: equal (__first1 , __last1 , __first2) ; 
} 

for (; __first1 != __last1 && __first2 != __last2 ; 
++ __first1 , (void) ++ __first2) 
if (! (* __first1 == * __first2)) 
return false ; 
return __first1 == __last1 && __first2 == __last2 ; 
} 


template < typename _II1 , typename _II2 , typename _BinaryPredicate > 
inline bool 
__equal4 (_II1 __first1 , _II1 __last1 , _II2 __first2 , _II2 __last2 , 
_BinaryPredicate __binary_pred) 
{ 
using _RATag = random_access_iterator_tag ; 
using _Cat1 = typename iterator_traits < _II1 > :: iterator_category ; 
using _Cat2 = typename iterator_traits < _II2 > :: iterator_category ; 
using _RAIters = __and_ < is_same < _Cat1 , _RATag > , is_same < _Cat2 , _RATag >> ; 
if (_RAIters ()) 
{ 
auto __d1 = std :: distance (__first1 , __last1) ; 
auto __d2 = std :: distance (__first2 , __last2) ; 
if (__d1 != __d2) 
return false ; 
return std :: equal (__first1 , __last1 , __first2 , 
__binary_pred) ; 
} 

for (; __first1 != __last1 && __first2 != __last2 ; 
++ __first1 , (void) ++ __first2) 
if (! bool (__binary_pred (* __first1 , * __first2))) 
return false ; 
return __first1 == __last1 && __first2 == __last2 ; 
} 
# 1239 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _II1 , typename _II2 > 
inline bool 
lexicographical_compare (_II1 __first1 , _II1 __last1 , 
_II2 __first2 , _II2 __last2) 
{ 
# 1253
; 
; 

return std :: __lexicographical_compare_aux (std :: __niter_base (__first1) , 
std :: __niter_base (__last1) , 
std :: __niter_base (__first2) , 
std :: __niter_base (__last2)) ; 
} 
# 1275 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _II1 , typename _II2 , typename _Compare > 
inline bool 
lexicographical_compare (_II1 __first1 , _II1 __last1 , 
_II2 __first2 , _II2 __last2 , _Compare __comp) 
{ 



; 
; 

return std :: __lexicographical_compare_impl 
(__first1 , __last1 , __first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _BinaryPredicate > 
pair < _InputIterator1 , _InputIterator2 > 
__mismatch (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _BinaryPredicate __binary_pred) 
{ 
while (__first1 != __last1 && __binary_pred (__first1 , __first2)) 
{ 
++ __first1 ; 
++ __first2 ; 
} 
return pair < _InputIterator1 , _InputIterator2 > (__first1 , __first2) ; 
} 
# 1318 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _InputIterator1 , typename _InputIterator2 > 
inline pair < _InputIterator1 , _InputIterator2 > 
mismatch (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2) 
{ 
# 1329
; 

return std :: __mismatch (__first1 , __last1 , __first2 , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 1351 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _BinaryPredicate > 
inline pair < _InputIterator1 , _InputIterator2 > 
mismatch (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _BinaryPredicate __binary_pred) 
{ 



; 

return std :: __mismatch (__first1 , __last1 , __first2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__binary_pred)) ; 
} 
# 1453 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algobase.h" 3
}
# 47 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
namespace __gnu_cxx { 
# 61 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
template < typename _CharT > 
struct _Char_types 
{ 
typedef unsigned long int_type ; 
typedef std :: streampos pos_type ; 
typedef std :: streamoff off_type ; 
typedef std :: mbstate_t state_type ; 
} ;
# 86 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
template < typename _CharT > 
struct char_traits 
{ 
typedef _CharT char_type ; 
typedef typename _Char_types < _CharT > :: int_type int_type ; 
typedef typename _Char_types < _CharT > :: pos_type pos_type ; 
typedef typename _Char_types < _CharT > :: off_type off_type ; 
typedef typename _Char_types < _CharT > :: state_type state_type ; 

static void 
assign (char_type & __c1 , const char_type & __c2) 
{ __c1 = __c2 ; } 

static constexpr bool 
eq (const char_type & __c1 , const char_type & __c2) 
{ return __c1 == __c2 ; } 

static constexpr bool 
lt (const char_type & __c1 , const char_type & __c2) 
{ return __c1 < __c2 ; } 

static int 
compare (const char_type * __s1 , const char_type * __s2 , std :: size_t __n) ; 

static std :: size_t 
length (const char_type * __s) ; 

static const char_type * 
find (const char_type * __s , std :: size_t __n , const char_type & __a) ; 

static char_type * 
move (char_type * __s1 , const char_type * __s2 , std :: size_t __n) ; 

static char_type * 
copy (char_type * __s1 , const char_type * __s2 , std :: size_t __n) ; 

static char_type * 
assign (char_type * __s , std :: size_t __n , char_type __a) ; 

static constexpr char_type 
to_char_type (const int_type & __c) 
{ return static_cast < char_type > (__c) ; } 

static constexpr int_type 
to_int_type (const char_type & __c) 
{ return static_cast < int_type > (__c) ; } 

static constexpr bool 
eq_int_type (const int_type & __c1 , const int_type & __c2) 
{ return __c1 == __c2 ; } 

static constexpr int_type 
eof () 
{ return static_cast < int_type > (- 1) ; } 

static constexpr int_type 
not_eof (const int_type & __c) 
{ return ! eq_int_type (__c , eof ()) ? __c : to_int_type (char_type ()) ; } 
} ;

template < typename _CharT > 
int 
char_traits < _CharT > :: 
compare (const char_type * __s1 , const char_type * __s2 , std :: size_t __n) 
{ 
for (std :: size_t __i = 0 ; __i < __n ; ++ __i) 
if (lt (__s1 [ __i ] , __s2 [ __i ])) 
return - 1 ; 
else if (lt (__s2 [ __i ] , __s1 [ __i ])) 
return 1 ; 
return 0 ; 
} 

template < typename _CharT > 
std :: size_t 
char_traits < _CharT > :: 
length (const char_type * __p) 
{ 
std :: size_t __i = 0 ; 
while (! eq (__p [ __i ] , char_type ())) 
++ __i ; 
return __i ; 
} 

template < typename _CharT > 
const typename char_traits < _CharT > :: char_type * 
char_traits < _CharT > :: 
find (const char_type * __s , std :: size_t __n , const char_type & __a) 
{ 
for (std :: size_t __i = 0 ; __i < __n ; ++ __i) 
if (eq (__s [ __i ] , __a)) 
return __s + __i ; 
return 0 ; 
} 

template < typename _CharT > 
typename char_traits < _CharT > :: char_type * 
char_traits < _CharT > :: 
move (char_type * __s1 , const char_type * __s2 , std :: size_t __n) 
{ 
if (__n == 0) 
return __s1 ; 
return static_cast < _CharT * > (__builtin_memmove (__s1 , __s2 , 
__n * sizeof (char_type))) ; 
} 

template < typename _CharT > 
typename char_traits < _CharT > :: char_type * 
char_traits < _CharT > :: 
copy (char_type * __s1 , const char_type * __s2 , std :: size_t __n) 
{ 

std :: copy (__s2 , __s2 + __n , __s1) ; 
return __s1 ; 
} 

template < typename _CharT > 
typename char_traits < _CharT > :: char_type * 
char_traits < _CharT > :: 
assign (char_type * __s , std :: size_t __n , char_type __a) 
{ 

std :: fill_n (__s , __n , __a) ; 
return __s ; 
} 


}

namespace std { 
# 283 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
template < class _CharT > 
struct char_traits : public __gnu_cxx :: char_traits < _CharT > 
{ } ;




template<> struct char_traits< char>  { 

typedef char char_type; 
typedef int int_type; 
typedef streampos pos_type; 
typedef streamoff off_type; 
typedef mbstate_t state_type; 


static void assign(char_type &__c1, const char_type &__c2) noexcept 
{ __c1 = __c2; } 


static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
{ 

return (static_cast< unsigned char>(__c1) < static_cast< unsigned char>(__c2)); 

} 


static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return 0;   
# 325
return __builtin_memcmp(__s1, __s2, __n); 
} 


static size_t length(const char_type *__s) 
{ 




return __builtin_strlen(__s); 
} 


static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
{ 
if (__n == 0) 
return 0;   
# 349
return static_cast< const char_type *>(__builtin_memchr(__s, __a, __n)); 
} 


static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n)); 
} 


static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n)); 
} 


static char_type *assign(char_type *__s, size_t __n, char_type __a) 
{ 
if (__n == 0) 
return __s;   
return static_cast< char_type *>(__builtin_memset(__s, __a, __n)); 
} 


static constexpr char_type to_char_type(const int_type &__c) noexcept 
{ return static_cast< char_type>(__c); } 




static constexpr int_type to_int_type(const char_type &__c) noexcept 
{ return static_cast< int_type>(static_cast< unsigned char>(__c)); } 


static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr int_type eof() noexcept 
{ return static_cast< int_type>(-1); } 


static constexpr int_type not_eof(const int_type &__c) noexcept 
{ return (__c == eof()) ? 0 : __c; } 
}; 
# 403
template<> struct char_traits< wchar_t>  { 

typedef wchar_t char_type; 
typedef wint_t int_type; 
typedef streamoff off_type; 
typedef wstreampos pos_type; 
typedef mbstate_t state_type; 


static void assign(char_type &__c1, const char_type &__c2) noexcept 
{ __c1 = __c2; } 


static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 < __c2; } 


static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return 0;   
# 434
return wmemcmp(__s1, __s2, __n); 
} 


static size_t length(const char_type *__s) 
{ 




return wcslen(__s); 
} 


static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
{ 
if (__n == 0) 
return 0;   
# 458
return wmemchr(__s, __a, __n); 
} 


static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return wmemmove(__s1, __s2, __n); 
} 


static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return wmemcpy(__s1, __s2, __n); 
} 


static char_type *assign(char_type *__s, size_t __n, char_type __a) 
{ 
if (__n == 0) 
return __s;   
return wmemset(__s, __a, __n); 
} 


static constexpr char_type to_char_type(const int_type &__c) noexcept 
{ return (char_type)__c; } 


static constexpr int_type to_int_type(const char_type &__c) noexcept 
{ return (int_type)__c; } 


static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr int_type eof() noexcept 
{ return static_cast< int_type>((wchar_t)(0xffff)); } 


static constexpr int_type not_eof(const int_type &__c) noexcept 
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
}; 
# 617 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
}
# 58 "d:\\mingw\\mingw\\include\\stdint.h" 3
typedef signed char int8_t; 
typedef unsigned char uint8_t; 
typedef short int16_t; 
typedef unsigned short uint16_t; 
typedef int int32_t; 
typedef unsigned uint32_t; 
typedef long long int64_t; 
typedef unsigned long long uint64_t; 



typedef signed char int_least8_t; 
typedef unsigned char uint_least8_t; 
typedef short int_least16_t; 
typedef unsigned short uint_least16_t; 
typedef int int_least32_t; 
typedef unsigned uint_least32_t; 
typedef long long int_least64_t; 
typedef unsigned long long uint_least64_t; 
# 82
typedef signed char int_fast8_t; 
typedef unsigned char uint_fast8_t; 
typedef short int_fast16_t; 
typedef unsigned short uint_fast16_t; 
typedef int int_fast32_t; 
typedef unsigned uint_fast32_t; 
typedef long long int_fast64_t; 
typedef unsigned long long uint_fast64_t; 
# 118 "d:\\mingw\\mingw\\include\\stdint.h" 3
typedef unsigned __uintptr_t; 

typedef __uintptr_t uintptr_t; 
# 128
typedef long long intmax_t; 
typedef unsigned long long uintmax_t; 
# 44 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdint" 3
namespace std { 


using ::int8_t;
using ::int16_t;
using ::int32_t;
using ::int64_t;

using ::int_fast8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;

using ::int_least8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;

using ::intmax_t;
using ::intptr_t;

using ::uint8_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;

using ::uint_fast8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;

using ::uint_least8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;

using ::uintmax_t;
using ::uintptr_t;
# 87
}
# 623 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\char_traits.h" 3
namespace std { 




template<> struct char_traits< char16_t>  { 

typedef char16_t char_type; 

typedef uint_least16_t int_type; 
# 638
typedef streamoff off_type; 
typedef u16streampos pos_type; 
typedef mbstate_t state_type; 


static void assign(char_type &__c1, const char_type &__c2) noexcept 
{ __c1 = __c2; } 


static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 < __c2; } 


static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
if (lt(__s1[__i], __s2[__i])) 
return -1;  else 
if (lt(__s2[__i], __s1[__i])) 
return 1;       
return 0; 
} 


static size_t length(const char_type *__s) 
{ 
size_t __i = (0); 
while (!eq(__s[__i], char_type())) 
++__i;   
return __i; 
} 


static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
if (eq(__s[__i], __a)) 
return __s + __i;     
return 0; 
} 


static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return (static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)))); 

} 


static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return (static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type)))); 

} 


static char_type *assign(char_type *__s, size_t __n, char_type __a) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
assign(__s[__i], __a);   
return __s; 
} 


static constexpr char_type to_char_type(const int_type &__c) noexcept 
{ return (char_type)__c; } 


static constexpr int_type to_int_type(const char_type &__c) noexcept 
{ return (__c == eof()) ? (int_type)0xfffd : ((int_type)__c); } 


static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr int_type eof() noexcept 
{ return static_cast< int_type>(-1); } 


static constexpr int_type not_eof(const int_type &__c) noexcept 
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
}; 


template<> struct char_traits< char32_t>  { 

typedef char32_t char_type; 

typedef uint_least32_t int_type; 
# 741
typedef streamoff off_type; 
typedef u32streampos pos_type; 
typedef mbstate_t state_type; 


static void assign(char_type &__c1, const char_type &__c2) noexcept 
{ __c1 = __c2; } 


static constexpr bool eq(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr bool lt(const char_type &__c1, const char_type &__c2) noexcept 
{ return __c1 < __c2; } 


static int compare(const char_type *__s1, const char_type *__s2, size_t __n) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
if (lt(__s1[__i], __s2[__i])) 
return -1;  else 
if (lt(__s2[__i], __s1[__i])) 
return 1;       
return 0; 
} 


static size_t length(const char_type *__s) 
{ 
size_t __i = (0); 
while (!eq(__s[__i], char_type())) 
++__i;   
return __i; 
} 


static const char_type *find(const char_type *__s, size_t __n, const char_type &__a) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
if (eq(__s[__i], __a)) 
return __s + __i;     
return 0; 
} 


static char_type *move(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return (static_cast< char_type *>(__builtin_memmove(__s1, __s2, __n * sizeof(char_type)))); 

} 


static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n) 
{ 
if (__n == 0) 
return __s1;   
return (static_cast< char_type *>(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type)))); 

} 


static char_type *assign(char_type *__s, size_t __n, char_type __a) 
{ 
for (size_t __i = (0); __i < __n; ++__i) 
assign(__s[__i], __a);   
return __s; 
} 


static constexpr char_type to_char_type(const int_type &__c) noexcept 
{ return (char_type)__c; } 


static constexpr int_type to_int_type(const char_type &__c) noexcept 
{ return (int_type)__c; } 


static constexpr bool eq_int_type(const int_type &__c1, const int_type &__c2) noexcept 
{ return __c1 == __c2; } 


static constexpr int_type eof() noexcept 
{ return static_cast< int_type>(-1); } 


static constexpr int_type not_eof(const int_type &__c) noexcept 
{ return eq_int_type(__c, eof()) ? 0 : __c; } 
}; 


}
# 99 "d:\\mingw\\mingw\\include\\locale.h" 3
struct lconv { 
# 110 "d:\\mingw\\mingw\\include\\locale.h" 3
char *decimal_point; 
char *thousands_sep; 
char *grouping; 
char *int_curr_symbol; 
char *currency_symbol; 
char *mon_decimal_point; 
char *mon_thousands_sep; 
char *mon_grouping; 
char *positive_sign; 
char *negative_sign; 
char int_frac_digits; 
char frac_digits; 
char p_cs_precedes; 
char p_sep_by_space; 
char n_cs_precedes; 
char n_sep_by_space; 
char p_sign_posn; 
char n_sign_posn; 
}; 
# 135
extern "C" {
# 142
__attribute((__cdecl__)) __attribute((__nothrow__)) char *setlocale(int, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) lconv *localeconv(); 
# 151
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wsetlocale(int, const wchar_t *); 
# 178 "d:\\mingw\\mingw\\include\\locale.h" 3
}
# 51 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\clocale" 3
namespace std { 

using ::lconv;
using ::setlocale;
using ::localeconv;
}
# 45 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++locale.h" 3
namespace std { 



typedef int *__c_locale; 
# 56
inline int __convert_from_v(const __c_locale &, char *__out, const int 
__size __attribute((__unused__)), const char *
__fmt, ...) 
{ 
char *__old = std::setlocale(4, 0); 
char *__sav = (0); 
if (__builtin_strcmp(__old, "C")) 
{ 
const size_t __len = __builtin_strlen(__old) + 1; 
__sav = (new char [__len]); 
__builtin_memcpy(__sav, __old, __len); 
std::setlocale(4, "C"); 
}  

__builtin_va_list __args; 
__builtin_va_start(__args,__fmt); 


const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args); 




__builtin_va_end(__args); 

if (__sav) 
{ 
std::setlocale(4, __sav); 
delete [] __sav; 
}  
return __ret; 
} 


}
# 68 "d:\\mingw\\mingw\\include\\ctype.h" 3
extern "C" {

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isalnum(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isalpha(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iscntrl(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isdigit(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isgraph(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int islower(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isleadbyte(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isprint(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int ispunct(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isspace(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isupper(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isxdigit(int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isblank(int); 



__attribute((__cdecl__)) __attribute((__nothrow__)) int _isctype(int, int); 
# 95
__attribute((__cdecl__)) __attribute((__nothrow__)) int tolower(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int toupper(int); 
# 108 "d:\\mingw\\mingw\\include\\ctype.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _tolower(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _toupper(int); 
# 119 "d:\\mingw\\mingw\\include\\ctype.h" 3
__attribute((__dllimport__)) extern int __mb_cur_max; 
# 140 "d:\\mingw\\mingw\\include\\ctype.h" 3
__attribute((__dllimport__)) extern unsigned short _ctype[]; 



__attribute((__dllimport__)) extern unsigned short *_pctype; 
# 187 "d:\\mingw\\mingw\\include\\ctype.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isalnum(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & (0x103 | 0x4)) : _isctype(c, (0x103 | 0x4))); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isalpha(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x103) : _isctype(c, 0x103)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int iscntrl(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x20) : _isctype(c, 0x20)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isdigit(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x4) : _isctype(c, 0x4)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isgraph(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & ((0x10 | 0x103) | 0x4)) : _isctype(c, ((0x10 | 0x103) | 0x4))); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int islower(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x2) : _isctype(c, 0x2)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isprint(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & (((0x40 | 0x10) | 0x103) | 0x4)) : _isctype(c, (((0x40 | 0x10) | 0x103) | 0x4))); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int ispunct(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x10) : _isctype(c, 0x10)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isspace(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x8) : _isctype(c, 0x8)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isupper(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x1) : _isctype(c, 0x1)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isxdigit(int c) 
{ return ((__mb_cur_max == 1) ? (_pctype[c] & 0x80) : _isctype(c, 0x80)); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isblank(int c) 
{ return ((((__mb_cur_max == 1) ? (_pctype[c] & 0x40) : _isctype(c, 0x40)) || c == '	')); } 
# 229
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _tolower(int c) 
{ return ((c - 'A') + 'a'); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _toupper(int c) 
{ return ((c - 'a') + 'A'); } 
# 240
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int isleadbyte(int c) 
{ return (_pctype[(unsigned char)(c)] & 0x8000); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __isascii(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __toascii(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __iscsymf(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __iscsym(int); 



__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __isascii(int c) 
{ return (((c & ~0x7f) == 0)); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __toascii(int c) 
{ return (c & 0x7f); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __iscsymf(int c) 
{ return ((isalpha(c) || (c == '_'))); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int __iscsym(int c) 
{ return ((isalnum(c) || (c == '_'))); } 
# 267
__attribute((__cdecl__)) __attribute((__nothrow__)) int isascii(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int toascii(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int iscsymf(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int iscsym(int); 




}
# 62 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cctype" 3
namespace std { 

using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
# 44 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\localefwd.h" 3
namespace std { 
# 55 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\localefwd.h" 3
class locale; 

template < typename _Facet >
    bool
    has_facet ( const locale & ) throw ( );

template < typename _Facet >
    const _Facet &
    use_facet ( const locale & );


template < typename _CharT >
    bool
    isspace ( _CharT, const locale & );

template < typename _CharT >
    bool
    isprint ( _CharT, const locale & );

template < typename _CharT >
    bool
    iscntrl ( _CharT, const locale & );

template < typename _CharT >
    bool
    isupper ( _CharT, const locale & );

template < typename _CharT >
    bool
    islower ( _CharT, const locale & );

template < typename _CharT >
    bool
    isalpha ( _CharT, const locale & );

template < typename _CharT >
    bool
    isdigit ( _CharT, const locale & );

template < typename _CharT >
    bool
    ispunct ( _CharT, const locale & );

template < typename _CharT >
    bool
    isxdigit ( _CharT, const locale & );

template < typename _CharT >
    bool
    isalnum ( _CharT, const locale & );

template < typename _CharT >
    bool
    isgraph ( _CharT, const locale & );


template < typename _CharT >
    bool
    isblank ( _CharT, const locale & );


template < typename _CharT >
    _CharT
    toupper ( _CharT, const locale & );

template < typename _CharT >
    _CharT
    tolower ( _CharT, const locale & );


class ctype_base; 
template < typename _CharT >
    class ctype;
template<> class ctype< char> ; 

template<> class ctype< wchar_t> ; 

template < typename _CharT >
    class ctype_byname;


class codecvt_base; 
template < typename _InternT, typename _ExternT, typename _StateT >
    class codecvt;
template<> class codecvt< char, char, int> ; 

template<> class codecvt< wchar_t, char, int> ; 


template<> class codecvt< char16_t, char, int> ; 
template<> class codecvt< char32_t, char, int> ; 
# 151
template < typename _InternT, typename _ExternT, typename _StateT >
    class codecvt_byname;



template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class num_get;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class num_put;

inline namespace __cxx11 { 
template < typename _CharT > class numpunct;
template < typename _CharT > class numpunct_byname;
}

inline namespace __cxx11 { 

template < typename _CharT >
    class collate;
template < typename _CharT >
    class collate_byname;
}


class time_base; 
inline namespace __cxx11 { 
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class time_get;
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class time_get_byname;
}
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class time_put;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class time_put_byname;


class money_base; 
inline namespace __cxx11 { 
template < typename _CharT, typename _InIter = istreambuf_iterator < _CharT > >
    class money_get;
template < typename _CharT, typename _OutIter = ostreambuf_iterator < _CharT > >
    class money_put;
}
inline namespace __cxx11 { 
template < typename _CharT, bool _Intl = false >
    class moneypunct;
template < typename _CharT, bool _Intl = false >
    class moneypunct_byname;
}


class messages_base; 
inline namespace __cxx11 { 
template < typename _CharT >
    class messages;
template < typename _CharT >
    class messages_byname;
}


}
# 30 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr.h" 3
#pragma GCC visibility push ( default )
# 138 "d:\\mingw\\mingw\\include\\errno.h" 3
extern "C" {
# 147 "d:\\mingw\\mingw\\include\\errno.h" 3
int *_errno() __attribute((__cdecl__)) __attribute((__nothrow__)); 



}
# 339 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr-default.h" 3
extern "C" {


typedef unsigned long __gthread_key_t; 




typedef 
# 344
struct { 
int done; 
long started; 
} __gthread_once_t; 




typedef 
# 349
struct { 
long counter; 
void *sema; 
} __gthread_mutex_t; 
# 359
typedef 
# 354
struct { 
long counter; 
long depth; 
unsigned long owner; 
void *sema; 
} __gthread_recursive_mutex_t; 
# 373 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr-default.h" 3
extern int _CRT_MT; 
extern int __mingwthr_key_dtor(unsigned long, void (*)(void *)); 
# 401 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr-default.h" 3
static inline int __gthread_active_p() 
{ 

return _CRT_MT; 



} 
# 416
extern int __gthr_win32_once(__gthread_once_t *, void (*)(void)); 
extern int __gthr_win32_key_create(__gthread_key_t *, void (*)(void *)); 
extern int __gthr_win32_key_delete(__gthread_key_t); 
extern void *__gthr_win32_getspecific(__gthread_key_t); 
extern int __gthr_win32_setspecific(__gthread_key_t, const void *); 
extern void __gthr_win32_mutex_init_function(__gthread_mutex_t *); 
extern int __gthr_win32_mutex_lock(__gthread_mutex_t *); 
extern int __gthr_win32_mutex_trylock(__gthread_mutex_t *); 
extern int __gthr_win32_mutex_unlock(__gthread_mutex_t *); 

extern void __gthr_win32_recursive_mutex_init_function(__gthread_recursive_mutex_t *); 
extern int __gthr_win32_recursive_mutex_lock(__gthread_recursive_mutex_t *); 

extern int __gthr_win32_recursive_mutex_trylock(__gthread_recursive_mutex_t *); 
extern int __gthr_win32_recursive_mutex_unlock(__gthread_recursive_mutex_t *); 
extern void __gthr_win32_mutex_destroy(__gthread_mutex_t *); 

extern int __gthr_win32_recursive_mutex_destroy(__gthread_recursive_mutex_t *); 


static inline int __gthread_once(__gthread_once_t *__once, void (*__func)(void)) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_once(__once, __func);  else 

return -1;   
} 


static inline int __gthread_key_create(__gthread_key_t *__key, void (*__dtor)(void *)) 
{ 
return __gthr_win32_key_create(__key, __dtor); 
} 


static inline int __gthread_key_delete(__gthread_key_t __key) 
{ 
return __gthr_win32_key_delete(__key); 
} 


static inline void *__gthread_getspecific(__gthread_key_t __key) 
{ 
return __gthr_win32_getspecific(__key); 
} 


static inline int __gthread_setspecific(__gthread_key_t __key, const void *__ptr) 
{ 
return __gthr_win32_setspecific(__key, __ptr); 
} 


static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex) 
{ 
__gthr_win32_mutex_init_function(__mutex); 
} 


static inline void __gthread_mutex_destroy(__gthread_mutex_t *__mutex) 
{ 
__gthr_win32_mutex_destroy(__mutex); 
} 


static inline int __gthread_mutex_lock(__gthread_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_mutex_lock(__mutex);  else 

return 0;   
} 


static inline int __gthread_mutex_trylock(__gthread_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_mutex_trylock(__mutex);  else 

return 0;   
} 


static inline int __gthread_mutex_unlock(__gthread_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_mutex_unlock(__mutex);  else 

return 0;   
} 


static inline void __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *__mutex) 
{ 
__gthr_win32_recursive_mutex_init_function(__mutex); 
} 


static inline int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_recursive_mutex_lock(__mutex);  else 

return 0;   
} 


static inline int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_recursive_mutex_trylock(__mutex);  else 

return 0;   
} 


static inline int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t *__mutex) 
{ 
if (__gthread_active_p()) 
return __gthr_win32_recursive_mutex_unlock(__mutex);  else 

return 0;   
} 


static inline int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t *__mutex) 
{ 
return __gthr_win32_recursive_mutex_destroy(__mutex); 
} 
# 782 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr-default.h" 3
}
# 151 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\gthr.h" 3
#pragma GCC visibility pop
# 32 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\atomic_word.h" 3
typedef int _Atomic_word; 
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\atomicity.h" 3
namespace __gnu_cxx { 
# 48
static inline _Atomic_word __exchange_and_add(volatile _Atomic_word *__mem, int __val) 
{ return __atomic_fetch_add(__mem, __val, 4); } 


static inline void __atomic_add(volatile _Atomic_word *__mem, int __val) 
{ __atomic_fetch_add(__mem, __val, 4); } 
# 65 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\atomicity.h" 3
static inline _Atomic_word __exchange_and_add_single(_Atomic_word *__mem, int __val) 
{ 
_Atomic_word __result = *__mem; 
*__mem += __val; 
return __result; 
} 


static inline void __atomic_add_single(_Atomic_word *__mem, int __val) 
{ *__mem += __val; } 



__attribute((__unused__)) static inline _Atomic_word __exchange_and_add_dispatch(_Atomic_word *__mem, int __val) 
{ 

if (__gthread_active_p()) 
return __exchange_and_add(__mem, __val);  else 

return __exchange_and_add_single(__mem, __val);   



} 



__attribute((__unused__)) static inline void __atomic_add_dispatch(_Atomic_word *__mem, int __val) 
{ 

if (__gthread_active_p()) 
__atomic_add(__mem, __val);  else 

__atomic_add_single(__mem, __val);   



} 


}
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\new_allocator.h" 3
namespace __gnu_cxx { 



using std::size_t;
using std::ptrdiff_t;
# 57 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\new_allocator.h" 3
template < typename _Tp > 
class new_allocator 
{ 
public : 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Tp * pointer ; 
typedef const _Tp * const_pointer ; 
typedef _Tp & reference ; 
typedef const _Tp & const_reference ; 
typedef _Tp value_type ; 

template < typename _Tp1 > 
struct rebind 
{ typedef new_allocator < _Tp1 > other ; } ; 




typedef std :: true_type propagate_on_container_move_assignment ; 



new_allocator () noexcept { } 


new_allocator (const new_allocator &) noexcept { } 

template < typename _Tp1 > 

new_allocator (const new_allocator < _Tp1 > &) noexcept { } 

~ new_allocator () noexcept { } 

pointer 
address (reference __x) const noexcept 
{ return std :: __addressof (__x) ; } 

const_pointer 
address (const_reference __x) const noexcept 
{ return std :: __addressof (__x) ; } 



pointer 
allocate (size_type __n , const void * = static_cast < const void * > (0)) 
{ 
if (__n > this -> max_size ()) 
std :: __throw_bad_alloc () ; 
# 114 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\new_allocator.h" 3
return static_cast < _Tp * > (:: operator new (__n * sizeof (_Tp))) ; 
} 


void 
deallocate (pointer __p , size_type) 
{ 
# 128
:: operator delete (__p) ; 
} 

size_type 
max_size () const noexcept 
{ 

return size_t (0x7fffffff) / sizeof (_Tp) ; 



} 


template < typename _Up , typename ... _Args > 
void 
construct (_Up * __p , _Args && ... __args) 
noexcept (noexcept (:: new ((void *) __p) 
_Up (std :: forward < _Args > (__args) ...))) 
{ :: new ((void *) __p) _Up (std :: forward < _Args > (__args) ...) ; } 

template < typename _Up > 
void 
destroy (_Up * __p) 
noexcept (noexcept (__p -> ~ _Up ())) 
{ __p -> ~ _Up () ; } 
# 165 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\new_allocator.h" 3
template < typename _Up > 
friend bool 
operator == (const new_allocator & , const new_allocator < _Up > &) 
noexcept 
{ return true ; } 

template < typename _Up > 
friend bool 
operator != (const new_allocator & , const new_allocator < _Up > &) 
noexcept 
{ return false ; } 
} ;


}
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++allocator.h" 3
namespace std { 
# 47 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++allocator.h" 3
template < typename _Tp >
    using __allocator_base = __gnu_cxx :: new_allocator < _Tp >;
}
# 57 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\allocator.h" 3
namespace std { 
# 68
template<> class allocator< void>  { 


public: typedef size_t size_type; 
typedef ptrdiff_t difference_type; 
typedef void *pointer; 
typedef const void *const_pointer; 
typedef void value_type; 

template < typename _Tp1 > 
struct rebind 
{ typedef allocator < _Tp1 > other ; } ;




typedef true_type propagate_on_container_move_assignment; 

typedef true_type is_always_equal; 

template < typename _Up , typename ... _Args > 
void 
construct (_Up * __p , _Args && ... __args) 
noexcept (noexcept (:: new ((void *) __p) 
_Up (std :: forward < _Args > (__args) ...))) 
{ :: new ((void *) __p) _Up (std :: forward < _Args > (__args) ...) ; } 

template < typename _Up > 
void 
destroy (_Up * __p) 
noexcept (noexcept (__p -> ~ _Up ())) 
{ __p -> ~ _Up () ; } 

}; 
# 111 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\allocator.h" 3
template < typename _Tp > 
class allocator : public __allocator_base < _Tp > 
{ 
public : 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Tp * pointer ; 
typedef const _Tp * const_pointer ; 
typedef _Tp & reference ; 
typedef const _Tp & const_reference ; 
typedef _Tp value_type ; 

template < typename _Tp1 > 
struct rebind 
{ typedef allocator < _Tp1 > other ; } ; 




typedef true_type propagate_on_container_move_assignment ; 

typedef true_type is_always_equal ; 
# 138
allocator () noexcept { } 


allocator (const allocator & __a) noexcept 
: __allocator_base < _Tp > (__a) { } 



allocator & operator = (const allocator &) = default ; 


template < typename _Tp1 > 

allocator (const allocator < _Tp1 > &) noexcept { } 

~ allocator () noexcept { } 

friend bool 
operator == (const allocator & , const allocator &) noexcept 
{ return true ; } 

friend bool 
operator != (const allocator & , const allocator &) noexcept 
{ return false ; } 


} ;

template < typename _T1 , typename _T2 > 
inline bool 
operator == (const allocator < _T1 > & , const allocator < _T2 > &) 
noexcept 
{ return true ; } 

template < typename _T1 , typename _T2 > 
inline bool 
operator != (const allocator < _T1 > & , const allocator < _T2 > &) 
noexcept 
{ return false ; } 



template < typename _Tp > 
class allocator < const _Tp > 
{ 
public : 
typedef _Tp value_type ; 
template < typename _Up > allocator (const allocator < _Up > &) { } 
} ;

template < typename _Tp > 
class allocator < volatile _Tp > 
{ 
public : 
typedef _Tp value_type ; 
template < typename _Up > allocator (const allocator < _Up > &) { } 
} ;

template < typename _Tp > 
class allocator < const volatile _Tp > 
{ 
public : 
typedef _Tp value_type ; 
template < typename _Up > allocator (const allocator < _Up > &) { } 
} ;
# 209
extern template class allocator< char> ;
extern template class allocator< wchar_t> ;
# 217
template < typename _Alloc , bool = __is_empty (_Alloc) > 
struct __alloc_swap 
{ static void _S_do_it (_Alloc & , _Alloc &) noexcept { } } ;

template < typename _Alloc > 
struct __alloc_swap < _Alloc , false > 
{ 
static void 
_S_do_it (_Alloc & __one , _Alloc & __two) noexcept 
{ 

if (__one != __two) 
swap (__one , __two) ; 
} 
} ;


template < typename _Alloc , bool = __is_empty (_Alloc) > 
struct __alloc_neq 
{ 
static bool 
_S_do_it (const _Alloc & , const _Alloc &) 
{ return false ; } 
} ;

template < typename _Alloc > 
struct __alloc_neq < _Alloc , false > 
{ 
static bool 
_S_do_it (const _Alloc & __one , const _Alloc & __two) 
{ return __one != __two ; } 
} ;


template < typename _Tp , bool 
= __or_ < is_copy_constructible < typename _Tp :: value_type > , 
is_nothrow_move_constructible < typename _Tp :: value_type > > :: value > 
struct __shrink_to_fit_aux 
{ static bool _S_do_it (_Tp &) noexcept { return false ; } } ;

template < typename _Tp > 
struct __shrink_to_fit_aux < _Tp , true > 
{ 
static bool 
_S_do_it (_Tp & __c) noexcept 
{ 

try 
{ 
_Tp (__make_move_if_noexcept_iterator (__c . begin ()) , 
__make_move_if_noexcept_iterator (__c . end ()) , 
__c . get_allocator ()) . swap (__c) ; 
return true ; 
} 
catch (...) 
{ return false ; } 



} 
} ;



}
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\cxxabi_forced.h" 3
#pragma GCC visibility push ( default )


namespace __cxxabiv1 { 
# 48
class __forced_unwind { 

virtual ~__forced_unwind() throw(); 


virtual void __pure_dummy() = 0; 
}; 
}


#pragma GCC visibility pop
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ostream_insert.h" 3
namespace std { 



template < typename _CharT , typename _Traits > 
inline void 
__ostream_write (basic_ostream < _CharT , _Traits > & __out , 
const _CharT * __s , streamsize __n) 
{ 
typedef basic_ostream < _CharT , _Traits > __ostream_type ; 
typedef typename __ostream_type :: ios_base __ios_base ; 

const streamsize __put = __out . rdbuf () -> sputn (__s , __n) ; 
if (__put != __n) 
__out . setstate (__ios_base :: badbit) ; 
} 

template < typename _CharT , typename _Traits > 
inline void 
__ostream_fill (basic_ostream < _CharT , _Traits > & __out , streamsize __n) 
{ 
typedef basic_ostream < _CharT , _Traits > __ostream_type ; 
typedef typename __ostream_type :: ios_base __ios_base ; 

const _CharT __c = __out . fill () ; 
for (; __n > 0 ; -- __n) 
{ 
const typename _Traits :: int_type __put = __out . rdbuf () -> sputc (__c) ; 
if (_Traits :: eq_int_type (__put , _Traits :: eof ())) 
{ 
__out . setstate (__ios_base :: badbit) ; 
break ; 
} 
} 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
__ostream_insert (basic_ostream < _CharT , _Traits > & __out , 
const _CharT * __s , streamsize __n) 
{ 
typedef basic_ostream < _CharT , _Traits > __ostream_type ; 
typedef typename __ostream_type :: ios_base __ios_base ; 

typename __ostream_type :: sentry __cerb (__out) ; 
if (__cerb) 
{ 
try 
{ 
const streamsize __w = __out . width () ; 
if (__w > __n) 
{ 
const bool __left = ((__out . flags () 
& __ios_base :: adjustfield) 
== __ios_base :: left) ; 
if (! __left) 
__ostream_fill (__out , __w - __n) ; 
if (__out . good ()) 
__ostream_write (__out , __s , __n) ; 
if (__left && __out . good ()) 
__ostream_fill (__out , __w - __n) ; 
} 
else 
__ostream_write (__out , __s , __n) ; 
__out . width (0) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__out . _M_setstate (__ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __out . _M_setstate (__ios_base :: badbit) ; } 
} 
return __out ; 
} 




extern template basic_ostream< char>  &__ostream_insert(basic_ostream< char>  & __out, const char * __s, streamsize __n);


extern template basic_ostream< wchar_t>  &__ostream_insert(basic_ostream< wchar_t>  & __out, const wchar_t * __s, streamsize __n);
# 127
}
# 63 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
namespace std { 
# 104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Arg , typename _Result > 
struct unary_function 
{ 

typedef _Arg argument_type ; 


typedef _Result result_type ; 
} ;




template < typename _Arg1 , typename _Arg2 , typename _Result > 
struct binary_function 
{ 

typedef _Arg1 first_argument_type ; 


typedef _Arg2 second_argument_type ; 


typedef _Result result_type ; 
} ;
# 166 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Tp > 
struct plus : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x + __y ; } 
} ;


template < typename _Tp > 
struct minus : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x - __y ; } 
} ;


template < typename _Tp > 
struct multiplies : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x * __y ; } 
} ;


template < typename _Tp > 
struct divides : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x / __y ; } 
} ;


template < typename _Tp > 
struct modulus : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x % __y ; } 
} ;


template < typename _Tp > 
struct negate : public unary_function < _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x) const 
{ return - __x ; } 
} ;
# 350 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Tp > 
struct equal_to : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x == __y ; } 
} ;


template < typename _Tp > 
struct not_equal_to : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x != __y ; } 
} ;


template < typename _Tp > 
struct greater : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x > __y ; } 
} ;


template < typename _Tp > 
struct less : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x < __y ; } 
} ;


template < typename _Tp > 
struct greater_equal : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x >= __y ; } 
} ;


template < typename _Tp > 
struct less_equal : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x <= __y ; } 
} ;


template < typename _Tp > 
struct greater < _Tp * > : public binary_function < _Tp * , _Tp * , bool > 
{ 
bool 
operator () (_Tp * __x , _Tp * __y) const noexcept 
{ 
# 424 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
return (unsigned int) __x > (unsigned int) __y ; 
} 
} ;


template < typename _Tp > 
struct less < _Tp * > : public binary_function < _Tp * , _Tp * , bool > 
{ 
bool 
operator () (_Tp * __x , _Tp * __y) const noexcept 
{ 
# 443 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
return (unsigned int) __x < (unsigned int) __y ; 
} 
} ;


template < typename _Tp > 
struct greater_equal < _Tp * > : public binary_function < _Tp * , _Tp * , bool > 
{ 
bool 
operator () (_Tp * __x , _Tp * __y) const noexcept 
{ 
# 462 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
return (unsigned int) __x >= (unsigned int) __y ; 
} 
} ;


template < typename _Tp > 
struct less_equal < _Tp * > : public binary_function < _Tp * , _Tp * , bool > 
{ 
bool 
operator () (_Tp * __x , _Tp * __y) const noexcept 
{ 
# 481 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
return (unsigned int) __x <= (unsigned int) __y ; 
} 
} ;
# 785 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Tp > 
struct logical_and : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x && __y ; } 
} ;


template < typename _Tp > 
struct logical_or : public binary_function < _Tp , _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x || __y ; } 
} ;


template < typename _Tp > 
struct logical_not : public unary_function < _Tp , bool > 
{ 

bool 
operator () (const _Tp & __x) const 
{ return ! __x ; } 
} ;
# 878 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Tp > 
struct bit_and : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x & __y ; } 
} ;

template < typename _Tp > 
struct bit_or : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x | __y ; } 
} ;

template < typename _Tp > 
struct bit_xor : public binary_function < _Tp , _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x , const _Tp & __y) const 
{ return __x ^ __y ; } 
} ;

template < typename _Tp > 
struct bit_not : public unary_function < _Tp , _Tp > 
{ 

_Tp 
operator () (const _Tp & __x) const 
{ return ~ __x ; } 
} ;
# 1002 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Predicate > 
class unary_negate 
: public unary_function < typename _Predicate :: argument_type , bool > 
{ 
protected : 
_Predicate _M_pred ; 

public : 

explicit 
unary_negate (const _Predicate & __x) : _M_pred (__x) { } 


bool 
operator () (const typename _Predicate :: argument_type & __x) const 
{ return ! _M_pred (__x) ; } 
} ;


template < typename _Predicate > 

inline unary_negate < _Predicate > 
not1 (const _Predicate & __pred) 
{ return unary_negate < _Predicate > (__pred) ; } 


template < typename _Predicate > 
class binary_negate 
: public binary_function < typename _Predicate :: first_argument_type , 
typename _Predicate :: second_argument_type , bool > 
{ 
protected : 
_Predicate _M_pred ; 

public : 

explicit 
binary_negate (const _Predicate & __x) : _M_pred (__x) { } 


bool 
operator () (const typename _Predicate :: first_argument_type & __x , 
const typename _Predicate :: second_argument_type & __y) const 
{ return ! _M_pred (__x , __y) ; } 
} ;


template < typename _Predicate > 

inline binary_negate < _Predicate > 
not2 (const _Predicate & __pred) 
{ return binary_negate < _Predicate > (__pred) ; } 
# 1079 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Arg , typename _Result > 
class pointer_to_unary_function : public unary_function < _Arg , _Result > 
{ 
protected : 
_Result (* _M_ptr) (_Arg) ; 

public : 
pointer_to_unary_function () { } 

explicit 
pointer_to_unary_function (_Result (* __x) (_Arg)) 
: _M_ptr (__x) { } 

_Result 
operator () (_Arg __x) const 
{ return _M_ptr (__x) ; } 
} ;


template < typename _Arg , typename _Result > 
inline pointer_to_unary_function < _Arg , _Result > 
ptr_fun (_Result (* __x) (_Arg)) 
{ return pointer_to_unary_function < _Arg , _Result > (__x) ; } 


template < typename _Arg1 , typename _Arg2 , typename _Result > 
class pointer_to_binary_function 
: public binary_function < _Arg1 , _Arg2 , _Result > 
{ 
protected : 
_Result (* _M_ptr) (_Arg1 , _Arg2) ; 

public : 
pointer_to_binary_function () { } 

explicit 
pointer_to_binary_function (_Result (* __x) (_Arg1 , _Arg2)) 
: _M_ptr (__x) { } 

_Result 
operator () (_Arg1 __x , _Arg2 __y) const 
{ return _M_ptr (__x , __y) ; } 
} ;


template < typename _Arg1 , typename _Arg2 , typename _Result > 
inline pointer_to_binary_function < _Arg1 , _Arg2 , _Result > 
ptr_fun (_Result (* __x) (_Arg1 , _Arg2)) 
{ return pointer_to_binary_function < _Arg1 , _Arg2 , _Result > (__x) ; } 


template < typename _Tp > 
struct _Identity 
: public unary_function < _Tp , _Tp > 
{ 
_Tp & 
operator () (_Tp & __x) const 
{ return __x ; } 

const _Tp & 
operator () (const _Tp & __x) const 
{ return __x ; } 
} ;


template < typename _Tp > struct _Identity < const _Tp > : _Identity < _Tp > { } ;

template < typename _Pair > 
struct _Select1st 
: public unary_function < _Pair , typename _Pair :: first_type > 
{ 
typename _Pair :: first_type & 
operator () (_Pair & __x) const 
{ return __x . first ; } 

const typename _Pair :: first_type & 
operator () (const _Pair & __x) const 
{ return __x . first ; } 


template < typename _Pair2 > 
typename _Pair2 :: first_type & 
operator () (_Pair2 & __x) const 
{ return __x . first ; } 

template < typename _Pair2 > 
const typename _Pair2 :: first_type & 
operator () (const _Pair2 & __x) const 
{ return __x . first ; } 

} ;

template < typename _Pair > 
struct _Select2nd 
: public unary_function < _Pair , typename _Pair :: second_type > 
{ 
typename _Pair :: second_type & 
operator () (_Pair & __x) const 
{ return __x . second ; } 

const typename _Pair :: second_type & 
operator () (const _Pair & __x) const 
{ return __x . second ; } 
} ;
# 1202 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_function.h" 3
template < typename _Ret , typename _Tp > 
class mem_fun_t : public unary_function < _Tp * , _Ret > 
{ 
public : 
explicit 
mem_fun_t (_Ret (_Tp :: * __pf) ()) 
: _M_f (__pf) { } 

_Ret 
operator () (_Tp * __p) const 
{ return (__p ->* _M_f) () ; } 

private : 
_Ret (_Tp :: * _M_f) () ; 
} ;



template < typename _Ret , typename _Tp > 
class const_mem_fun_t : public unary_function < const _Tp * , _Ret > 
{ 
public : 
explicit 
const_mem_fun_t (_Ret (_Tp :: * __pf) () const) 
: _M_f (__pf) { } 

_Ret 
operator () (const _Tp * __p) const 
{ return (__p ->* _M_f) () ; } 

private : 
_Ret (_Tp :: * _M_f) () const ; 
} ;



template < typename _Ret , typename _Tp > 
class mem_fun_ref_t : public unary_function < _Tp , _Ret > 
{ 
public : 
explicit 
mem_fun_ref_t (_Ret (_Tp :: * __pf) ()) 
: _M_f (__pf) { } 

_Ret 
operator () (_Tp & __r) const 
{ return (__r .* _M_f) () ; } 

private : 
_Ret (_Tp :: * _M_f) () ; 
} ;



template < typename _Ret , typename _Tp > 
class const_mem_fun_ref_t : public unary_function < _Tp , _Ret > 
{ 
public : 
explicit 
const_mem_fun_ref_t (_Ret (_Tp :: * __pf) () const) 
: _M_f (__pf) { } 

_Ret 
operator () (const _Tp & __r) const 
{ return (__r .* _M_f) () ; } 

private : 
_Ret (_Tp :: * _M_f) () const ; 
} ;



template < typename _Ret , typename _Tp , typename _Arg > 
class mem_fun1_t : public binary_function < _Tp * , _Arg , _Ret > 
{ 
public : 
explicit 
mem_fun1_t (_Ret (_Tp :: * __pf) (_Arg)) 
: _M_f (__pf) { } 

_Ret 
operator () (_Tp * __p , _Arg __x) const 
{ return (__p ->* _M_f) (__x) ; } 

private : 
_Ret (_Tp :: * _M_f) (_Arg) ; 
} ;



template < typename _Ret , typename _Tp , typename _Arg > 
class const_mem_fun1_t : public binary_function < const _Tp * , _Arg , _Ret > 
{ 
public : 
explicit 
const_mem_fun1_t (_Ret (_Tp :: * __pf) (_Arg) const) 
: _M_f (__pf) { } 

_Ret 
operator () (const _Tp * __p , _Arg __x) const 
{ return (__p ->* _M_f) (__x) ; } 

private : 
_Ret (_Tp :: * _M_f) (_Arg) const ; 
} ;



template < typename _Ret , typename _Tp , typename _Arg > 
class mem_fun1_ref_t : public binary_function < _Tp , _Arg , _Ret > 
{ 
public : 
explicit 
mem_fun1_ref_t (_Ret (_Tp :: * __pf) (_Arg)) 
: _M_f (__pf) { } 

_Ret 
operator () (_Tp & __r , _Arg __x) const 
{ return (__r .* _M_f) (__x) ; } 

private : 
_Ret (_Tp :: * _M_f) (_Arg) ; 
} ;



template < typename _Ret , typename _Tp , typename _Arg > 
class const_mem_fun1_ref_t : public binary_function < _Tp , _Arg , _Ret > 
{ 
public : 
explicit 
const_mem_fun1_ref_t (_Ret (_Tp :: * __pf) (_Arg) const) 
: _M_f (__pf) { } 

_Ret 
operator () (const _Tp & __r , _Arg __x) const 
{ return (__r .* _M_f) (__x) ; } 

private : 
_Ret (_Tp :: * _M_f) (_Arg) const ; 
} ;



template < typename _Ret , typename _Tp > 
inline mem_fun_t < _Ret , _Tp > 
mem_fun (_Ret (_Tp :: * __f) ()) 
{ return mem_fun_t < _Ret , _Tp > (__f) ; } 

template < typename _Ret , typename _Tp > 
inline const_mem_fun_t < _Ret , _Tp > 
mem_fun (_Ret (_Tp :: * __f) () const) 
{ return const_mem_fun_t < _Ret , _Tp > (__f) ; } 

template < typename _Ret , typename _Tp > 
inline mem_fun_ref_t < _Ret , _Tp > 
mem_fun_ref (_Ret (_Tp :: * __f) ()) 
{ return mem_fun_ref_t < _Ret , _Tp > (__f) ; } 

template < typename _Ret , typename _Tp > 
inline const_mem_fun_ref_t < _Ret , _Tp > 
mem_fun_ref (_Ret (_Tp :: * __f) () const) 
{ return const_mem_fun_ref_t < _Ret , _Tp > (__f) ; } 

template < typename _Ret , typename _Tp , typename _Arg > 
inline mem_fun1_t < _Ret , _Tp , _Arg > 
mem_fun (_Ret (_Tp :: * __f) (_Arg)) 
{ return mem_fun1_t < _Ret , _Tp , _Arg > (__f) ; } 

template < typename _Ret , typename _Tp , typename _Arg > 
inline const_mem_fun1_t < _Ret , _Tp , _Arg > 
mem_fun (_Ret (_Tp :: * __f) (_Arg) const) 
{ return const_mem_fun1_t < _Ret , _Tp , _Arg > (__f) ; } 

template < typename _Ret , typename _Tp , typename _Arg > 
inline mem_fun1_ref_t < _Ret , _Tp , _Arg > 
mem_fun_ref (_Ret (_Tp :: * __f) (_Arg)) 
{ return mem_fun1_ref_t < _Ret , _Tp , _Arg > (__f) ; } 

template < typename _Ret , typename _Tp , typename _Arg > 
inline const_mem_fun1_ref_t < _Ret , _Tp , _Arg > 
mem_fun_ref (_Ret (_Tp :: * __f) (_Arg) const) 
{ return const_mem_fun1_ref_t < _Ret , _Tp , _Arg > (__f) ; } 




}
# 60 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\backward\\binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std { 
# 107 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\backward\\binders.h" 3
template < typename _Operation > 
class binder1st 
: public unary_function < typename _Operation :: second_argument_type , 
typename _Operation :: result_type > 
{ 
protected : 
_Operation op ; 
typename _Operation :: first_argument_type value ; 

public : 
binder1st (const _Operation & __x , 
const typename _Operation :: first_argument_type & __y) 
: op (__x) , value (__y) { } 

typename _Operation :: result_type 
operator () (const typename _Operation :: second_argument_type & __x) const 
{ return op (value , __x) ; } 



typename _Operation :: result_type 
operator () (typename _Operation :: second_argument_type & __x) const 
{ return op (value , __x) ; } 
} __attribute__ ((__deprecated__)) ;


template < typename _Operation , typename _Tp > 
inline binder1st < _Operation > 
bind1st (const _Operation & __fn , const _Tp & __x) 
{ 
typedef typename _Operation :: first_argument_type _Arg1_type ; 
return binder1st < _Operation > (__fn , _Arg1_type (__x)) ; 
} 


template < typename _Operation > 
class binder2nd 
: public unary_function < typename _Operation :: first_argument_type , 
typename _Operation :: result_type > 
{ 
protected : 
_Operation op ; 
typename _Operation :: second_argument_type value ; 

public : 
binder2nd (const _Operation & __x , 
const typename _Operation :: second_argument_type & __y) 
: op (__x) , value (__y) { } 

typename _Operation :: result_type 
operator () (const typename _Operation :: first_argument_type & __x) const 
{ return op (__x , value) ; } 



typename _Operation :: result_type 
operator () (typename _Operation :: first_argument_type & __x) const 
{ return op (__x , value) ; } 
} __attribute__ ((__deprecated__)) ;


template < typename _Operation , typename _Tp > 
inline binder2nd < _Operation > 
bind2nd (const _Operation & __fn , const _Tp & __x) 
{ 
typedef typename _Operation :: second_argument_type _Arg2_type ; 
return binder2nd < _Operation > (__fn , _Arg2_type (__x)) ; 
} 



}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\initializer_list" 3
#pragma GCC visibility push ( default )
# 180 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\backward\\binders.h" 3
#pragma GCC diagnostic pop
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\initializer_list" 3
namespace std { 


template < class _E > 
class initializer_list 
{ 
public : 
typedef _E value_type ; 
typedef const _E & reference ; 
typedef const _E & const_reference ; 
typedef size_t size_type ; 
typedef const _E * iterator ; 
typedef const _E * const_iterator ; 

private : 
iterator _M_array ; 
size_type _M_len ; 


constexpr initializer_list (const_iterator __a , size_type __l) 
: _M_array (__a) , _M_len (__l) { } 

public : 
constexpr initializer_list () noexcept 
: _M_array (0) , _M_len (0) { } 


constexpr size_type 
size () const noexcept { return _M_len ; } 


constexpr const_iterator 
begin () const noexcept { return _M_array ; } 


constexpr const_iterator 
end () const noexcept { return begin () + size () ; } 
} ;
# 87
template < class _Tp > 
constexpr const _Tp * 
begin (initializer_list < _Tp > __ils) noexcept 
{ return __ils . begin () ; } 
# 97
template < class _Tp > 
constexpr const _Tp * 
end (initializer_list < _Tp > __ils) noexcept 
{ return __ils . end () ; } 
}

#pragma GCC visibility pop
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\range_access.h" 3
namespace std { 
# 46
template < typename _Container > 
inline auto 
begin (_Container & __cont) -> decltype (__cont . begin ()) 
{ return __cont . begin () ; } 
# 56
template < typename _Container > 
inline auto 
begin (const _Container & __cont) -> decltype (__cont . begin ()) 
{ return __cont . begin () ; } 
# 66
template < typename _Container > 
inline auto 
end (_Container & __cont) -> decltype (__cont . end ()) 
{ return __cont . end () ; } 
# 76
template < typename _Container > 
inline auto 
end (const _Container & __cont) -> decltype (__cont . end ()) 
{ return __cont . end () ; } 
# 85
template < typename _Tp , size_t _Nm > 
inline _Tp * 
begin (_Tp (& __arr) [ _Nm ]) 
{ return __arr ; } 
# 95
template < typename _Tp , size_t _Nm > 
inline _Tp * 
end (_Tp (& __arr) [ _Nm ]) 
{ return __arr + _Nm ; } 
# 324 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\range_access.h" 3
}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
namespace std { 



struct __allocator_traits_base { 

template < typename _Tp , typename _Up , typename = void > 
struct __rebind : __replace_first_arg < _Tp , _Up > { } ;

template < typename _Tp , typename _Up > 
struct __rebind < _Tp , _Up , 
__void_t < typename _Tp :: template rebind < _Up > :: other > > 
{ using type = typename _Tp :: template rebind < _Up > :: other ; } ;


protected: template < typename _Tp >
      using __pointer = typename _Tp :: pointer;
template < typename _Tp >
      using __c_pointer = typename _Tp :: const_pointer;
template < typename _Tp >
      using __v_pointer = typename _Tp :: void_pointer;
template < typename _Tp >
      using __cv_pointer = typename _Tp :: const_void_pointer;
template < typename _Tp >
      using __pocca = typename _Tp :: propagate_on_container_copy_assignment;
template < typename _Tp >
      using __pocma = typename _Tp :: propagate_on_container_move_assignment;
template < typename _Tp >
      using __pocs = typename _Tp :: propagate_on_container_swap;
template < typename _Tp >
      using __equal = typename _Tp :: is_always_equal;
}; 

template < typename _Alloc, typename _Up >
    using __alloc_rebind
      = typename __allocator_traits_base :: template __rebind < _Alloc, _Up > :: type;
# 82
template < typename _Alloc > 
struct allocator_traits : __allocator_traits_base 
{ 

typedef _Alloc allocator_type ; 

typedef typename _Alloc :: value_type value_type ; 
# 95
using pointer = __detected_or_t < value_type * , __pointer , _Alloc > ; 

private : 

template < template < typename > class _Func , typename _Tp , typename = void > 
struct _Ptr 
{ 
using type = typename pointer_traits < pointer > :: template rebind < _Tp > ; 
} ; 

template < template < typename > class _Func , typename _Tp > 
struct _Ptr < _Func , _Tp , __void_t < _Func < _Alloc > > > 
{ 
using type = _Func < _Alloc > ; 
} ; 


template < typename _A2 , typename _PtrT , typename = void > 
struct _Diff 
{ using type = typename pointer_traits < _PtrT > :: difference_type ; } ; 

template < typename _A2 , typename _PtrT > 
struct _Diff < _A2 , _PtrT , __void_t < typename _A2 :: difference_type > > 
{ using type = typename _A2 :: difference_type ; } ; 


template < typename _A2 , typename _DiffT , typename = void > 
struct _Size : make_unsigned < _DiffT > { } ; 

template < typename _A2 , typename _DiffT > 
struct _Size < _A2 , _DiffT , __void_t < typename _A2 :: size_type > > 
{ using type = typename _A2 :: size_type ; } ; 

public : 
# 135
using const_pointer = typename _Ptr < __c_pointer , const value_type > :: type ; 
# 143
using void_pointer = typename _Ptr < __v_pointer , void > :: type ; 
# 151
using const_void_pointer = typename _Ptr < __cv_pointer , const void > :: type ; 
# 159
using difference_type = typename _Diff < _Alloc , pointer > :: type ; 
# 167
using size_type = typename _Size < _Alloc , difference_type > :: type ; 
# 175
using propagate_on_container_copy_assignment 
= __detected_or_t < false_type , __pocca , _Alloc > ; 
# 184
using propagate_on_container_move_assignment 
= __detected_or_t < false_type , __pocma , _Alloc > ; 
# 193
using propagate_on_container_swap 
= __detected_or_t < false_type , __pocs , _Alloc > ; 
# 202
using is_always_equal 
= __detected_or_t < typename is_empty < _Alloc > :: type , __equal , _Alloc > ; 

template < typename _Tp > 
using rebind_alloc = __alloc_rebind < _Alloc , _Tp > ; 
template < typename _Tp > 
using rebind_traits = allocator_traits < rebind_alloc < _Tp > > ; 

private : 
template < typename _Alloc2 > 
static auto 
_S_allocate (_Alloc2 & __a , size_type __n , const_void_pointer __hint , int) 
-> decltype (__a . allocate (__n , __hint)) 
{ return __a . allocate (__n , __hint) ; } 

template < typename _Alloc2 > 
static pointer 
_S_allocate (_Alloc2 & __a , size_type __n , const_void_pointer , ...) 
{ return __a . allocate (__n) ; } 

template < typename _Tp , typename ... _Args > 
struct __construct_helper 
{ 
template < typename _Alloc2 , 
typename = decltype (std :: declval < _Alloc2 * > () -> construct (
std :: declval < _Tp * > () , std :: declval < _Args > () ...)) > 
static true_type __test (int) ; 

template < typename > 
static false_type __test (...) ; 

using type = decltype (__test < _Alloc > (0)) ; 
} ; 

template < typename _Tp , typename ... _Args > 
using __has_construct 
= typename __construct_helper < _Tp , _Args ... > :: type ; 

template < typename _Tp , typename ... _Args > 
static _Require < __has_construct < _Tp , _Args ... > > 
_S_construct (_Alloc & __a , _Tp * __p , _Args && ... __args) 
noexcept (noexcept (__a . construct (__p , std :: forward < _Args > (__args) ...))) 
{ __a . construct (__p , std :: forward < _Args > (__args) ...) ; } 

template < typename _Tp , typename ... _Args > 
static 
_Require < __and_ < __not_ < __has_construct < _Tp , _Args ... > > , 
is_constructible < _Tp , _Args ... > > > 
_S_construct (_Alloc & , _Tp * __p , _Args && ... __args) 
noexcept (noexcept (:: new ((void *) __p) 
_Tp (std :: forward < _Args > (__args) ...))) 
{ :: new ((void *) __p) _Tp (std :: forward < _Args > (__args) ...) ; } 

template < typename _Alloc2 , typename _Tp > 
static auto 
_S_destroy (_Alloc2 & __a , _Tp * __p , int) 
noexcept (noexcept (__a . destroy (__p))) 
-> decltype (__a . destroy (__p)) 
{ __a . destroy (__p) ; } 

template < typename _Alloc2 , typename _Tp > 
static void 
_S_destroy (_Alloc2 & , _Tp * __p , ...) 
noexcept (noexcept (__p -> ~ _Tp ())) 
{ __p -> ~ _Tp () ; } 

template < typename _Alloc2 > 
static auto 
_S_max_size (_Alloc2 & __a , int) 
-> decltype (__a . max_size ()) 
{ return __a . max_size () ; } 

template < typename _Alloc2 > 
static size_type 
_S_max_size (_Alloc2 & , ...) 
{ 


return __gnu_cxx :: __numeric_traits < size_type > :: __max 
/ sizeof (value_type) ; 
} 

template < typename _Alloc2 > 
static auto 
_S_select (_Alloc2 & __a , int) 
-> decltype (__a . select_on_container_copy_construction ()) 
{ return __a . select_on_container_copy_construction () ; } 

template < typename _Alloc2 > 
static _Alloc2 
_S_select (_Alloc2 & __a , ...) 
{ return __a ; } 

public : 
# 304 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static pointer 
allocate (_Alloc & __a , size_type __n) 
{ return __a . allocate (__n) ; } 
# 319 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static pointer 
allocate (_Alloc & __a , size_type __n , const_void_pointer __hint) 
{ return _S_allocate (__a , __n , __hint , 0) ; } 
# 331 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static void 
deallocate (_Alloc & __a , pointer __p , size_type __n) 
{ __a . deallocate (__p , __n) ; } 
# 346 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
template < typename _Tp , typename ... _Args > 
static auto construct (_Alloc & __a , _Tp * __p , _Args && ... __args) 
noexcept (noexcept (_S_construct (__a , __p , 
std :: forward < _Args > (__args) ...))) 
-> decltype (_S_construct (__a , __p , std :: forward < _Args > (__args) ...)) 
{ _S_construct (__a , __p , std :: forward < _Args > (__args) ...) ; } 
# 361 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
template < typename _Tp > 
static void destroy (_Alloc & __a , _Tp * __p) 
noexcept (noexcept (_S_destroy (__a , __p , 0))) 
{ _S_destroy (__a , __p , 0) ; } 
# 374 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static size_type max_size (const _Alloc & __a) noexcept 
{ return _S_max_size (__a , 0) ; } 
# 385 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static _Alloc 
select_on_container_copy_construction (const _Alloc & __rhs) 
{ return _S_select (__rhs , 0) ; } 
} ;


template < typename _Tp > 
struct allocator_traits < allocator < _Tp > > 
{ 

using allocator_type = allocator < _Tp > ; 

using value_type = _Tp ; 


using pointer = _Tp * ; 


using const_pointer = const _Tp * ; 


using void_pointer = void * ; 


using const_void_pointer = const void * ; 


using difference_type = std :: ptrdiff_t ; 


using size_type = std :: size_t ; 


using propagate_on_container_copy_assignment = false_type ; 


using propagate_on_container_move_assignment = true_type ; 


using propagate_on_container_swap = false_type ; 


using is_always_equal = true_type ; 

template < typename _Up > 
using rebind_alloc = allocator < _Up > ; 

template < typename _Up > 
using rebind_traits = allocator_traits < allocator < _Up > > ; 
# 442 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static pointer 
allocate (allocator_type & __a , size_type __n) 
{ return __a . allocate (__n) ; } 
# 456 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static pointer 
allocate (allocator_type & __a , size_type __n , const_void_pointer __hint) 
{ return __a . allocate (__n , __hint) ; } 
# 468 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
static void 
deallocate (allocator_type & __a , pointer __p , size_type __n) 
{ __a . deallocate (__p , __n) ; } 
# 480 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
template < typename _Up , typename ... _Args > 
static void 
construct (allocator_type & __a , _Up * __p , _Args && ... __args) 
noexcept (noexcept (__a . construct (__p , std :: forward < _Args > (__args) ...))) 
{ __a . construct (__p , std :: forward < _Args > (__args) ...) ; } 
# 493 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\alloc_traits.h" 3
template < typename _Up > 
static void 
destroy (allocator_type & __a , _Up * __p) 
noexcept (noexcept (__a . destroy (__p))) 
{ __a . destroy (__p) ; } 
# 504
static size_type 
max_size (const allocator_type & __a) noexcept 
{ return __a . max_size () ; } 
# 513
static allocator_type 
select_on_container_copy_construction (const allocator_type & __rhs) 
{ return __rhs ; } 
} ;


template < typename _Alloc > 
inline void 
__do_alloc_on_copy (_Alloc & __one , const _Alloc & __two , true_type) 
{ __one = __two ; } 

template < typename _Alloc > 
inline void 
__do_alloc_on_copy (_Alloc & , const _Alloc & , false_type) 
{ } 

template < typename _Alloc > 
inline void __alloc_on_copy (_Alloc & __one , const _Alloc & __two) 
{ 
typedef allocator_traits < _Alloc > __traits ; 
typedef typename __traits :: propagate_on_container_copy_assignment __pocca ; 
__do_alloc_on_copy (__one , __two , __pocca ()) ; 
} 

template < typename _Alloc > 
inline _Alloc __alloc_on_copy (const _Alloc & __a) 
{ 
typedef allocator_traits < _Alloc > __traits ; 
return __traits :: select_on_container_copy_construction (__a) ; 
} 

template < typename _Alloc > 
inline void __do_alloc_on_move (_Alloc & __one , _Alloc & __two , true_type) 
{ __one = std :: move (__two) ; } 

template < typename _Alloc > 
inline void __do_alloc_on_move (_Alloc & , _Alloc & , false_type) 
{ } 

template < typename _Alloc > 
inline void __alloc_on_move (_Alloc & __one , _Alloc & __two) 
{ 
typedef allocator_traits < _Alloc > __traits ; 
typedef typename __traits :: propagate_on_container_move_assignment __pocma ; 
__do_alloc_on_move (__one , __two , __pocma ()) ; 
} 

template < typename _Alloc > 
inline void __do_alloc_on_swap (_Alloc & __one , _Alloc & __two , true_type) 
{ 
using std :: swap ; 
swap (__one , __two) ; 
} 

template < typename _Alloc > 
inline void __do_alloc_on_swap (_Alloc & , _Alloc & , false_type) 
{ } 

template < typename _Alloc > 
inline void __alloc_on_swap (_Alloc & __one , _Alloc & __two) 
{ 
typedef allocator_traits < _Alloc > __traits ; 
typedef typename __traits :: propagate_on_container_swap __pocs ; 
__do_alloc_on_swap (__one , __two , __pocs ()) ; 
} 

template < typename _Alloc , typename _Tp , 
typename _ValueT = __remove_cvref_t < typename _Alloc :: value_type > , 
typename = void > 
struct __is_alloc_insertable_impl 
: false_type 
{ } ;

template < typename _Alloc , typename _Tp , typename _ValueT > 
struct __is_alloc_insertable_impl < _Alloc , _Tp , _ValueT , 
__void_t < decltype (allocator_traits < _Alloc > :: construct (
std :: declval < _Alloc & > () , std :: declval < _ValueT * > () , 
std :: declval < _Tp > ())) > > 
: true_type 
{ } ;




template < typename _Alloc > 
struct __is_copy_insertable 
: __is_alloc_insertable_impl < _Alloc , 
typename _Alloc :: value_type const & > :: type 
{ } ;


template < typename _Tp > 
struct __is_copy_insertable < allocator < _Tp > > 
: is_copy_constructible < _Tp > 
{ } ;




template < typename _Alloc > 
struct __is_move_insertable 
: __is_alloc_insertable_impl < _Alloc , typename _Alloc :: value_type > :: type 
{ } ;


template < typename _Tp > 
struct __is_move_insertable < allocator < _Tp > > 
: is_move_constructible < _Tp > 
{ } ;


template < typename _Alloc , typename = void > 
struct __is_allocator : false_type { } ;

template < typename _Alloc > 
struct __is_allocator < _Alloc , 
__void_t < typename _Alloc :: value_type , 
decltype (std :: declval < _Alloc & > () . allocate (size_t { })) > > 
: true_type { } ;

template < typename _Alloc >
    using _RequireAllocator
      = typename enable_if < __is_allocator < _Alloc > :: value, _Alloc > :: type;

template < typename _Alloc >
    using _RequireNotAllocator
      = typename enable_if < ! __is_allocator < _Alloc > :: value, _Alloc > :: type;


}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\alloc_traits.h" 3
namespace __gnu_cxx { 
# 49
template < typename _Alloc , typename = typename _Alloc :: value_type > 
struct __alloc_traits 

: std :: allocator_traits < _Alloc > 

{ 
typedef _Alloc allocator_type ; 

typedef std :: allocator_traits < _Alloc > _Base_type ; 
typedef typename _Base_type :: value_type value_type ; 
typedef typename _Base_type :: pointer pointer ; 
typedef typename _Base_type :: const_pointer const_pointer ; 
typedef typename _Base_type :: size_type size_type ; 
typedef typename _Base_type :: difference_type difference_type ; 

typedef value_type & reference ; 
typedef const value_type & const_reference ; 
using _Base_type :: allocate ; 
using _Base_type :: deallocate ; 
using _Base_type :: construct ; 
using _Base_type :: destroy ; 
using _Base_type :: max_size ; 

private : 
template < typename _Ptr > 
using __is_custom_pointer 
= std :: __and_ < std :: is_same < pointer , _Ptr > , 
std :: __not_ < std :: is_pointer < _Ptr > > > ; 

public : 

template < typename _Ptr , typename ... _Args > 
static typename std :: enable_if < __is_custom_pointer < _Ptr > :: value > :: type 
construct (_Alloc & __a , _Ptr __p , _Args && ... __args) 
noexcept (noexcept (_Base_type :: construct (__a , std :: __to_address (__p) , 
std :: forward < _Args > (__args) ...))) 
{ 
_Base_type :: construct (__a , std :: __to_address (__p) , 
std :: forward < _Args > (__args) ...) ; 
} 


template < typename _Ptr > 
static typename std :: enable_if < __is_custom_pointer < _Ptr > :: value > :: type 
destroy (_Alloc & __a , _Ptr __p) 
noexcept (noexcept (_Base_type :: destroy (__a , std :: __to_address (__p)))) 
{ _Base_type :: destroy (__a , std :: __to_address (__p)) ; } 

static _Alloc _S_select_on_copy (const _Alloc & __a) 
{ return _Base_type :: select_on_container_copy_construction (__a) ; } 

static void _S_on_swap (_Alloc & __a , _Alloc & __b) 
{ std :: __alloc_on_swap (__a , __b) ; } 

static constexpr bool _S_propagate_on_copy_assign () 
{ return _Base_type :: propagate_on_container_copy_assignment :: value ; } 

static constexpr bool _S_propagate_on_move_assign () 
{ return _Base_type :: propagate_on_container_move_assignment :: value ; } 

static constexpr bool _S_propagate_on_swap () 
{ return _Base_type :: propagate_on_container_swap :: value ; } 

static constexpr bool _S_always_equal () 
{ return _Base_type :: is_always_equal :: value ; } 

static constexpr bool _S_nothrow_move () 
{ return _S_propagate_on_move_assign () || _S_always_equal () ; } 

template < typename _Tp > 
struct rebind 
{ typedef typename _Base_type :: template rebind_alloc < _Tp > other ; } ; 
# 161 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\alloc_traits.h" 3
} ;


}
# 52 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
namespace std { 




inline namespace __cxx11 { 
# 76 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
class basic_string 
{ 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _CharT > :: other _Char_alloc_type ; 
typedef __gnu_cxx :: __alloc_traits < _Char_alloc_type > _Alloc_traits ; 


public : 
typedef _Traits traits_type ; 
typedef typename _Traits :: char_type value_type ; 
typedef _Char_alloc_type allocator_type ; 
typedef typename _Alloc_traits :: size_type size_type ; 
typedef typename _Alloc_traits :: difference_type difference_type ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 
typedef typename _Alloc_traits :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef __gnu_cxx :: __normal_iterator < pointer , basic_string > iterator ; 
typedef __gnu_cxx :: __normal_iterator < const_pointer , basic_string > 
const_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 
typedef std :: reverse_iterator < iterator > reverse_iterator ; 


static const size_type npos = static_cast < size_type > (- 1) ; 

protected : 




typedef const_iterator __const_iterator ; 


private : 
# 150 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
struct _Alloc_hider : allocator_type 
{ 




_Alloc_hider (pointer __dat , const _Alloc & __a) 
: allocator_type (__a) , _M_p (__dat) { } 

_Alloc_hider (pointer __dat , _Alloc && __a = _Alloc ()) 
: allocator_type (std :: move (__a)) , _M_p (__dat) { } 


pointer _M_p ; 
} ; 

_Alloc_hider _M_dataplus ; 
size_type _M_string_length ; 

enum { _S_local_capacity = 15 / sizeof (_CharT) } ; 

union 
{ 
_CharT _M_local_buf [ _S_local_capacity + 1 ] ; 
size_type _M_allocated_capacity ; 
} ; 

void 
_M_data (pointer __p) 
{ _M_dataplus . _M_p = __p ; } 

void 
_M_length (size_type __length) 
{ _M_string_length = __length ; } 

pointer 
_M_data () const 
{ return _M_dataplus . _M_p ; } 

pointer 
_M_local_data () 
{ 

return std :: pointer_traits < pointer > :: pointer_to (* _M_local_buf) ; 



} 

const_pointer 
_M_local_data () const 
{ 

return std :: pointer_traits < const_pointer > :: pointer_to (* _M_local_buf) ; 



} 

void 
_M_capacity (size_type __capacity) 
{ _M_allocated_capacity = __capacity ; } 

void 
_M_set_length (size_type __n) 
{ 
_M_length (__n) ; 
traits_type :: assign (_M_data () [ __n ] , _CharT ()) ; 
} 

bool 
_M_is_local () const 
{ return _M_data () == _M_local_data () ; } 


pointer 
_M_create (size_type & , size_type) ; 

void 
_M_dispose () 
{ 
if (! _M_is_local ()) 
_M_destroy (_M_allocated_capacity) ; 
} 

void 
_M_destroy (size_type __size) throw () 
{ _Alloc_traits :: deallocate (_M_get_allocator () , _M_data () , __size + 1) ; } 



template < typename _InIterator > 
void 
_M_construct_aux (_InIterator __beg , _InIterator __end , 
std :: __false_type) 
{ 
typedef typename iterator_traits < _InIterator > :: iterator_category _Tag ; 
_M_construct (__beg , __end , _Tag ()) ; 
} 



template < typename _Integer > 
void 
_M_construct_aux (_Integer __beg , _Integer __end , std :: __true_type) 
{ _M_construct_aux_2 (static_cast < size_type > (__beg) , __end) ; } 

void 
_M_construct_aux_2 (size_type __req , _CharT __c) 
{ _M_construct (__req , __c) ; } 

template < typename _InIterator > 
void 
_M_construct (_InIterator __beg , _InIterator __end) 
{ 
typedef typename std :: __is_integer < _InIterator > :: __type _Integral ; 
_M_construct_aux (__beg , __end , _Integral ()) ; 
} 


template < typename _InIterator > 
void 
_M_construct (_InIterator __beg , _InIterator __end , 
std :: input_iterator_tag) ; 



template < typename _FwdIterator > 
void 
_M_construct (_FwdIterator __beg , _FwdIterator __end , 
std :: forward_iterator_tag) ; 

void 
_M_construct (size_type __req , _CharT __c) ; 

allocator_type & 
_M_get_allocator () 
{ return _M_dataplus ; } 

const allocator_type & 
_M_get_allocator () const 
{ return _M_dataplus ; } 

private : 
# 309 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
_M_check (size_type __pos , const char * __s) const 
{ 
if (__pos > this -> size ()) 
__throw_out_of_range_fmt (("%s: __pos (which is %zu) > " "this->size() (which is %zu)") 
, 
__s , __pos , this -> size ()) ; 
return __pos ; 
} 

void 
_M_check_length (size_type __n1 , size_type __n2 , const char * __s) const 
{ 
if (this -> max_size () - (this -> size () - __n1) < __n2) 
__throw_length_error ((__s)) ; 
} 



size_type 
_M_limit (size_type __pos , size_type __off) const noexcept 
{ 
const bool __testoff = __off < this -> size () - __pos ; 
return __testoff ? __off : this -> size () - __pos ; 
} 


bool 
_M_disjunct (const _CharT * __s) const noexcept 
{ 
return (less < const _CharT * > () (__s , _M_data ()) 
|| less < const _CharT * > () (_M_data () + this -> size () , __s)) ; 
} 



static void 
_S_copy (_CharT * __d , const _CharT * __s , size_type __n) 
{ 
if (__n == 1) 
traits_type :: assign (* __d , * __s) ; 
else 
traits_type :: copy (__d , __s , __n) ; 
} 

static void 
_S_move (_CharT * __d , const _CharT * __s , size_type __n) 
{ 
if (__n == 1) 
traits_type :: assign (* __d , * __s) ; 
else 
traits_type :: move (__d , __s , __n) ; 
} 

static void 
_S_assign (_CharT * __d , size_type __n , _CharT __c) 
{ 
if (__n == 1) 
traits_type :: assign (* __d , __c) ; 
else 
traits_type :: assign (__d , __n , __c) ; 
} 



template < class _Iterator > 
static void 
_S_copy_chars (_CharT * __p , _Iterator __k1 , _Iterator __k2) 
{ 
for (; __k1 != __k2 ; ++ __k1 , (void) ++ __p) 
traits_type :: assign (* __p , * __k1) ; 
} 

static void 
_S_copy_chars (_CharT * __p , iterator __k1 , iterator __k2) noexcept 
{ _S_copy_chars (__p , __k1 . base () , __k2 . base ()) ; } 

static void 
_S_copy_chars (_CharT * __p , const_iterator __k1 , const_iterator __k2) 
noexcept 
{ _S_copy_chars (__p , __k1 . base () , __k2 . base ()) ; } 

static void 
_S_copy_chars (_CharT * __p , _CharT * __k1 , _CharT * __k2) noexcept 
{ _S_copy (__p , __k1 , __k2 - __k1) ; } 

static void 
_S_copy_chars (_CharT * __p , const _CharT * __k1 , const _CharT * __k2) 
noexcept 
{ _S_copy (__p , __k1 , __k2 - __k1) ; } 

static int 
_S_compare (size_type __n1 , size_type __n2) noexcept 
{ 
const difference_type __d = difference_type (__n1 - __n2) ; 

if (__d > __gnu_cxx :: __numeric_traits < int > :: __max) 
return __gnu_cxx :: __numeric_traits < int > :: __max ; 
else if (__d < __gnu_cxx :: __numeric_traits < int > :: __min) 
return __gnu_cxx :: __numeric_traits < int > :: __min ; 
else 
return int (__d) ; 
} 

void 
_M_assign (const basic_string &) ; 

void 
_M_mutate (size_type __pos , size_type __len1 , const _CharT * __s , 
size_type __len2) ; 

void 
_M_erase (size_type __pos , size_type __n) ; 

public : 
# 431
basic_string () 
noexcept (is_nothrow_default_constructible < _Alloc > :: value) 
: _M_dataplus (_M_local_data ()) 
{ _M_set_length (0) ; } 




explicit 
basic_string (const _Alloc & __a) noexcept 
: _M_dataplus (_M_local_data () , __a) 
{ _M_set_length (0) ; } 
# 448
basic_string (const basic_string & __str) 
: _M_dataplus (_M_local_data () , 
_Alloc_traits :: _S_select_on_copy (__str . _M_get_allocator ())) 
{ _M_construct (__str . _M_data () , __str . _M_data () + __str . length ()) ; } 
# 461 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (const basic_string & __str , size_type __pos , 
const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ 
const _CharT * __start = __str . _M_data () 
+ __str . _M_check (__pos , "basic_string::basic_string") ; 
_M_construct (__start , __start + __str . _M_limit (__pos , npos)) ; 
} 
# 476
basic_string (const basic_string & __str , size_type __pos , 
size_type __n) 
: _M_dataplus (_M_local_data ()) 
{ 
const _CharT * __start = __str . _M_data () 
+ __str . _M_check (__pos , "basic_string::basic_string") ; 
_M_construct (__start , __start + __str . _M_limit (__pos , __n)) ; 
} 
# 492 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (const basic_string & __str , size_type __pos , 
size_type __n , const _Alloc & __a) 
: _M_dataplus (_M_local_data () , __a) 
{ 
const _CharT * __start 
= __str . _M_data () + __str . _M_check (__pos , "string::string") ; 
_M_construct (__start , __start + __str . _M_limit (__pos , __n)) ; 
} 
# 510 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (const _CharT * __s , size_type __n , 
const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__s , __s + __n) ; } 
# 525 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (const _CharT * __s , const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__s , __s ? __s + traits_type :: length (__s) : __s + npos) ; } 
# 540 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (size_type __n , _CharT __c , const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__n , __c) ; } 
# 552 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string (basic_string && __str) noexcept 
: _M_dataplus (_M_local_data () , std :: move (__str . _M_get_allocator ())) 
{ 
if (__str . _M_is_local ()) 
{ 
traits_type :: copy (_M_local_buf , __str . _M_local_buf , 
_S_local_capacity + 1) ; 
} 
else 
{ 
_M_data (__str . _M_data ()) ; 
_M_capacity (__str . _M_allocated_capacity) ; 
} 




_M_length (__str . length ()) ; 
__str . _M_data (__str . _M_local_data ()) ; 
__str . _M_set_length (0) ; 
} 
# 579
basic_string (initializer_list < _CharT > __l , const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__l . begin () , __l . end ()) ; } 

basic_string (const basic_string & __str , const _Alloc & __a) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__str . begin () , __str . end ()) ; } 

basic_string (basic_string && __str , const _Alloc & __a) 
noexcept (_Alloc_traits :: _S_always_equal ()) 
: _M_dataplus (_M_local_data () , __a) 
{ 
if (__str . _M_is_local ()) 
{ 
traits_type :: copy (_M_local_buf , __str . _M_local_buf , 
_S_local_capacity + 1) ; 
_M_length (__str . length ()) ; 
__str . _M_set_length (0) ; 
} 
else if (_Alloc_traits :: _S_always_equal () 
|| __str . get_allocator () == __a) 
{ 
_M_data (__str . _M_data ()) ; 
_M_length (__str . length ()) ; 
_M_capacity (__str . _M_allocated_capacity) ; 
__str . _M_data (__str . _M_local_buf) ; 
__str . _M_set_length (0) ; 
} 
else 
_M_construct (__str . begin () , __str . end ()) ; 
} 
# 620 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 



basic_string (_InputIterator __beg , _InputIterator __end , 
const _Alloc & __a = _Alloc ()) 
: _M_dataplus (_M_local_data () , __a) 
{ _M_construct (__beg , __end) ; } 
# 657 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
~ basic_string () 
{ _M_dispose () ; } 
# 664
basic_string & 
operator = (const basic_string & __str) 
{ 

if (_Alloc_traits :: _S_propagate_on_copy_assign ()) 
{ 
if (! _Alloc_traits :: _S_always_equal () && ! _M_is_local () 
&& _M_get_allocator () != __str . _M_get_allocator ()) 
{ 


if (__str . size () <= _S_local_capacity) 
{ 
_M_destroy (_M_allocated_capacity) ; 
_M_data (_M_local_data ()) ; 
_M_set_length (0) ; 
} 
else 
{ 
const auto __len = __str . size () ; 
auto __alloc = __str . _M_get_allocator () ; 

auto __ptr = _Alloc_traits :: allocate (__alloc , __len + 1) ; 
_M_destroy (_M_allocated_capacity) ; 
_M_data (__ptr) ; 
_M_capacity (__len) ; 
_M_set_length (__len) ; 
} 
} 
std :: __alloc_on_copy (_M_get_allocator () , __str . _M_get_allocator ()) ; 
} 

return this -> assign (__str) ; 
} 
# 703
basic_string & 
operator = (const _CharT * __s) 
{ return this -> assign (__s) ; } 
# 714 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
operator = (_CharT __c) 
{ 
this -> assign (1 , __c) ; 
return * this ; 
} 
# 731 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
operator = (basic_string && __str) 
noexcept (_Alloc_traits :: _S_nothrow_move ()) 
{ 
if (! _M_is_local () && _Alloc_traits :: _S_propagate_on_move_assign () 
&& ! _Alloc_traits :: _S_always_equal () 
&& _M_get_allocator () != __str . _M_get_allocator ()) 
{ 

_M_destroy (_M_allocated_capacity) ; 
_M_data (_M_local_data ()) ; 
_M_set_length (0) ; 
} 

std :: __alloc_on_move (_M_get_allocator () , __str . _M_get_allocator ()) ; 

if (__str . _M_is_local ()) 
{ 

if (__str . size ()) 
this -> _S_copy (_M_data () , __str . _M_data () , __str . size ()) ; 
_M_set_length (__str . size ()) ; 
} 
else if (_Alloc_traits :: _S_propagate_on_move_assign () 
|| _Alloc_traits :: _S_always_equal () 
|| _M_get_allocator () == __str . _M_get_allocator ()) 
{ 

pointer __data = nullptr ; 
size_type __capacity ; 
if (! _M_is_local ()) 
{ 
if (_Alloc_traits :: _S_always_equal ()) 
{ 

__data = _M_data () ; 
__capacity = _M_allocated_capacity ; 
} 
else 
_M_destroy (_M_allocated_capacity) ; 
} 

_M_data (__str . _M_data ()) ; 
_M_length (__str . length ()) ; 
_M_capacity (__str . _M_allocated_capacity) ; 
if (__data) 
{ 
__str . _M_data (__data) ; 
__str . _M_capacity (__capacity) ; 
} 
else 
__str . _M_data (__str . _M_local_buf) ; 
} 
else 
assign (__str) ; 
__str . clear () ; 
return * this ; 
} 
# 794
basic_string & 
operator = (initializer_list < _CharT > __l) 
{ 
this -> assign (__l . begin () , __l . size ()) ; 
return * this ; 
} 
# 825 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
begin () noexcept 
{ return iterator (_M_data ()) ; } 
# 833
const_iterator 
begin () const noexcept 
{ return const_iterator (_M_data ()) ; } 
# 841
iterator 
end () noexcept 
{ return iterator (_M_data () + this -> size ()) ; } 
# 849
const_iterator 
end () const noexcept 
{ return const_iterator (_M_data () + this -> size ()) ; } 
# 858
reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (this -> end ()) ; } 
# 867
const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (this -> end ()) ; } 
# 876
reverse_iterator 
rend () noexcept 
{ return reverse_iterator (this -> begin ()) ; } 
# 885
const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (this -> begin ()) ; } 
# 894
const_iterator 
cbegin () const noexcept 
{ return const_iterator (this -> _M_data ()) ; } 
# 902
const_iterator 
cend () const noexcept 
{ return const_iterator (this -> _M_data () + this -> size ()) ; } 
# 911
const_reverse_iterator 
crbegin () const noexcept 
{ return const_reverse_iterator (this -> end ()) ; } 
# 920
const_reverse_iterator 
crend () const noexcept 
{ return const_reverse_iterator (this -> begin ()) ; } 


public : 



size_type 
size () const noexcept 
{ return _M_string_length ; } 



size_type 
length () const noexcept 
{ return _M_string_length ; } 


size_type 
max_size () const noexcept 
{ return (_Alloc_traits :: max_size (_M_get_allocator ()) - 1) / 2 ; } 
# 954 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
void 
resize (size_type __n , _CharT __c) ; 
# 967 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
void 
resize (size_type __n) 
{ this -> resize (__n , _CharT ()) ; } 



void 
shrink_to_fit () noexcept 
{ 

if (capacity () > size ()) 
{ 
try 
{ reserve (0) ; } 
catch (...) 
{ } 
} 

} 
# 992
size_type 
capacity () const noexcept 
{ 
return _M_is_local () ? size_type (_S_local_capacity) 
: _M_allocated_capacity ; 
} 
# 1016 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
void 
reserve (size_type __res_arg = 0) ; 




void 
clear () noexcept 
{ _M_set_length (0) ; } 
# 1030
bool 
empty () const noexcept 
{ return this -> size () == 0 ; } 
# 1045 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
const_reference 
operator [ ] (size_type __pos) const noexcept 
{ 
; 
return _M_data () [ __pos ] ; 
} 
# 1062 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
reference 
operator [ ] (size_type __pos) 
{ 


; 

; 
return _M_data () [ __pos ] ; 
} 
# 1083 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
const_reference 
at (size_type __n) const 
{ 
if (__n >= this -> size ()) 
__throw_out_of_range_fmt (("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)") 

, 
__n , this -> size ()) ; 
return _M_data () [ __n ] ; 
} 
# 1104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
reference 
at (size_type __n) 
{ 
if (__n >= size ()) 
__throw_out_of_range_fmt (("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)") 

, 
__n , this -> size ()) ; 
return _M_data () [ __n ] ; 
} 
# 1120
reference 
front () noexcept 
{ 
; 
return operator [ ] (0) ; 
} 
# 1131
const_reference 
front () const noexcept 
{ 
; 
return operator [ ] (0) ; 
} 
# 1142
reference 
back () noexcept 
{ 
; 
return operator [ ] (this -> size () - 1) ; 
} 
# 1153
const_reference 
back () const noexcept 
{ 
; 
return operator [ ] (this -> size () - 1) ; 
} 
# 1167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
operator += (const basic_string & __str) 
{ return this -> append (__str) ; } 
# 1176
basic_string & 
operator += (const _CharT * __s) 
{ return this -> append (__s) ; } 
# 1185
basic_string & 
operator += (_CharT __c) 
{ 
this -> push_back (__c) ; 
return * this ; 
} 
# 1198
basic_string & 
operator += (initializer_list < _CharT > __l) 
{ return this -> append (__l . begin () , __l . size ()) ; } 
# 1220 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
append (const basic_string & __str) 
{ return _M_append (__str . _M_data () , __str . size ()) ; } 
# 1237 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
append (const basic_string & __str , size_type __pos , size_type __n = npos) 
{ return _M_append (__str . _M_data () 
+ __str . _M_check (__pos , "basic_string::append") , 
__str . _M_limit (__pos , __n)) ; } 
# 1249
basic_string & 
append (const _CharT * __s , size_type __n) 
{ 
; 
_M_check_length (size_type (0) , __n , "basic_string::append") ; 
return _M_append (__s , __n) ; 
} 
# 1262
basic_string & 
append (const _CharT * __s) 
{ 
; 
const size_type __n = traits_type :: length (__s) ; 
_M_check_length (size_type (0) , __n , "basic_string::append") ; 
return _M_append (__s , __n) ; 
} 
# 1279 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
append (size_type __n , _CharT __c) 
{ return _M_replace_aux (this -> size () , size_type (0) , __n , __c) ; } 
# 1289
basic_string & 
append (initializer_list < _CharT > __l) 
{ return this -> append (__l . begin () , __l . size ()) ; } 
# 1303 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < class _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 



basic_string & 
append (_InputIterator __first , _InputIterator __last) 
{ return this -> replace (end () , end () , __first , __last) ; } 
# 1348 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
void 
push_back (_CharT __c) 
{ 
const size_type __size = this -> size () ; 
if (__size + 1 > this -> capacity ()) 
this -> _M_mutate (__size , size_type (0) , 0 , size_type (1)) ; 
traits_type :: assign (this -> _M_data () [ __size ] , __c) ; 
this -> _M_set_length (__size + 1) ; 
} 
# 1363
basic_string & 
assign (const basic_string & __str) 
{ 
this -> _M_assign (__str) ; 
return * this ; 
} 
# 1379 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
assign (basic_string && __str) 
noexcept (_Alloc_traits :: _S_nothrow_move ()) 
{ 


return * this = std :: move (__str) ; 
} 
# 1402 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
assign (const basic_string & __str , size_type __pos , size_type __n = npos) 
{ return _M_replace (size_type (0) , this -> size () , __str . _M_data () 
+ __str . _M_check (__pos , "basic_string::assign") , 
__str . _M_limit (__pos , __n)) ; } 
# 1418 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
assign (const _CharT * __s , size_type __n) 
{ 
; 
return _M_replace (size_type (0) , this -> size () , __s , __n) ; 
} 
# 1434 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
assign (const _CharT * __s) 
{ 
; 
return _M_replace (size_type (0) , this -> size () , __s , 
traits_type :: length (__s)) ; 
} 
# 1451 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
assign (size_type __n , _CharT __c) 
{ return _M_replace_aux (size_type (0) , this -> size () , __n , __c) ; } 
# 1464 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < class _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 



basic_string & 
assign (_InputIterator __first , _InputIterator __last) 
{ return this -> replace (begin () , end () , __first , __last) ; } 
# 1479
basic_string & 
assign (initializer_list < _CharT > __l) 
{ return this -> assign (__l . begin () , __l . size ()) ; } 
# 1533 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
insert (const_iterator __p , size_type __n , _CharT __c) 
{ 
; 
const size_type __pos = __p - begin () ; 
this -> replace (__p , __p , __n , __c) ; 
return iterator (this -> _M_data () + __pos) ; 
} 
# 1575 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < class _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
iterator 
insert (const_iterator __p , _InputIterator __beg , _InputIterator __end) 
{ 
; 
const size_type __pos = __p - begin () ; 
this -> replace (__p , __p , __beg , __end) ; 
return iterator (this -> _M_data () + __pos) ; 
} 
# 1611 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
insert (const_iterator __p , initializer_list < _CharT > __l) 
{ return this -> insert (__p , __l . begin () , __l . end ()) ; } 
# 1638 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
insert (size_type __pos1 , const basic_string & __str) 
{ return this -> replace (__pos1 , size_type (0) , 
__str . _M_data () , __str . size ()) ; } 
# 1661 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
insert (size_type __pos1 , const basic_string & __str , 
size_type __pos2 , size_type __n = npos) 
{ return this -> replace (__pos1 , size_type (0) , __str . _M_data () 
+ __str . _M_check (__pos2 , "basic_string::insert") , 
__str . _M_limit (__pos2 , __n)) ; } 
# 1684 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
insert (size_type __pos , const _CharT * __s , size_type __n) 
{ return this -> replace (__pos , size_type (0) , __s , __n) ; } 
# 1703 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
insert (size_type __pos , const _CharT * __s) 
{ 
; 
return this -> replace (__pos , size_type (0) , __s , 
traits_type :: length (__s)) ; 
} 
# 1727 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
insert (size_type __pos , size_type __n , _CharT __c) 
{ return _M_replace_aux (_M_check (__pos , "basic_string::insert") , 
size_type (0) , __n , __c) ; } 
# 1745 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
insert (__const_iterator __p , _CharT __c) 
{ 
; 
const size_type __pos = __p - begin () ; 
_M_replace_aux (__pos , size_type (0) , size_type (1) , __c) ; 
return iterator (_M_data () + __pos) ; 
} 
# 1806 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
erase (size_type __pos = 0 , size_type __n = npos) 
{ 
_M_check (__pos , "basic_string::erase") ; 
if (__n == npos) 
this -> _M_set_length (__pos) ; 
else if (__n != 0) 
this -> _M_erase (__pos , _M_limit (__pos , __n)) ; 
return * this ; 
} 
# 1825 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
erase (__const_iterator __position) 
{ 

; 
const size_type __pos = __position - begin () ; 
this -> _M_erase (__pos , size_type (1)) ; 
return iterator (_M_data () + __pos) ; 
} 
# 1844 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
iterator 
erase (__const_iterator __first , __const_iterator __last) 
{ 

; 
const size_type __pos = __first - begin () ; 
if (__last == end ()) 
this -> _M_set_length (__pos) ; 
else 
this -> _M_erase (__pos , __last - __first) ; 
return iterator (this -> _M_data () + __pos) ; 
} 
# 1863
void 
pop_back () noexcept 
{ 
; 
_M_erase (size () - 1 , 1) ; 
} 
# 1888 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (size_type __pos , size_type __n , const basic_string & __str) 
{ return this -> replace (__pos , __n , __str . _M_data () , __str . size ()) ; } 
# 1910 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (size_type __pos1 , size_type __n1 , const basic_string & __str , 
size_type __pos2 , size_type __n2 = npos) 
{ return this -> replace (__pos1 , __n1 , __str . _M_data () 
+ __str . _M_check (__pos2 , "basic_string::replace") , 
__str . _M_limit (__pos2 , __n2)) ; } 
# 1935 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (size_type __pos , size_type __n1 , const _CharT * __s , 
size_type __n2) 
{ 
; 
return _M_replace (_M_check (__pos , "basic_string::replace") , 
_M_limit (__pos , __n1) , __s , __n2) ; 
} 
# 1960 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (size_type __pos , size_type __n1 , const _CharT * __s) 
{ 
; 
return this -> replace (__pos , __n1 , __s , traits_type :: length (__s)) ; 
} 
# 1984 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (size_type __pos , size_type __n1 , size_type __n2 , _CharT __c) 
{ return _M_replace_aux (_M_check (__pos , "basic_string::replace") , 
_M_limit (__pos , __n1) , __n2 , __c) ; } 
# 2002 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
const basic_string & __str) 
{ return this -> replace (__i1 , __i2 , __str . _M_data () , __str . size ()) ; } 
# 2022 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
const _CharT * __s , size_type __n) 
{ 

; 
return this -> replace (__i1 - begin () , __i2 - __i1 , __s , __n) ; 
} 
# 2044 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , const _CharT * __s) 
{ 
; 
return this -> replace (__i1 , __i2 , __s , traits_type :: length (__s)) ; 
} 
# 2065 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , size_type __n , 
_CharT __c) 
{ 

; 
return _M_replace_aux (__i1 - begin () , __i2 - __i1 , __n , __c) ; 
} 
# 2090 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < class _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
basic_string & 
replace (const_iterator __i1 , const_iterator __i2 , 
_InputIterator __k1 , _InputIterator __k2) 
{ 

; 
; 
return this -> _M_replace_dispatch (__i1 , __i2 , __k1 , __k2 , 
std :: __false_type ()) ; 
} 
# 2122 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
_CharT * __k1 , _CharT * __k2) 
{ 

; 
; 
return this -> replace (__i1 - begin () , __i2 - __i1 , 
__k1 , __k2 - __k1) ; 
} 

basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
const _CharT * __k1 , const _CharT * __k2) 
{ 

; 
; 
return this -> replace (__i1 - begin () , __i2 - __i1 , 
__k1 , __k2 - __k1) ; 
} 

basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
iterator __k1 , iterator __k2) 
{ 

; 
; 
return this -> replace (__i1 - begin () , __i2 - __i1 , 
__k1 . base () , __k2 - __k1) ; 
} 

basic_string & 
replace (__const_iterator __i1 , __const_iterator __i2 , 
const_iterator __k1 , const_iterator __k2) 
{ 

; 
; 
return this -> replace (__i1 - begin () , __i2 - __i1 , 
__k1 . base () , __k2 - __k1) ; 
} 
# 2181 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string & replace (const_iterator __i1 , const_iterator __i2 , 
initializer_list < _CharT > __l) 
{ return this -> replace (__i1 , __i2 , __l . begin () , __l . size ()) ; } 
# 2241 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
private : 
template < class _Integer > 
basic_string & 
_M_replace_dispatch (const_iterator __i1 , const_iterator __i2 , 
_Integer __n , _Integer __val , __true_type) 
{ return _M_replace_aux (__i1 - begin () , __i2 - __i1 , __n , __val) ; } 

template < class _InputIterator > 
basic_string & 
_M_replace_dispatch (const_iterator __i1 , const_iterator __i2 , 
_InputIterator __k1 , _InputIterator __k2 , 
__false_type) ; 

basic_string & 
_M_replace_aux (size_type __pos1 , size_type __n1 , size_type __n2 , 
_CharT __c) ; 

basic_string & 
_M_replace (size_type __pos , size_type __len1 , const _CharT * __s , 
const size_type __len2) ; 

basic_string & 
_M_append (const _CharT * __s , size_type __n) ; 

public : 
# 2279 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
copy (_CharT * __s , size_type __n , size_type __pos = 0) const ; 
# 2289 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
void 
swap (basic_string & __s) noexcept ; 
# 2299 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
const _CharT * 
c_str () const noexcept 
{ return _M_data () ; } 
# 2311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
const _CharT * 
data () const noexcept 
{ return _M_data () ; } 
# 2330 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
allocator_type 
get_allocator () const noexcept 
{ return _M_get_allocator () ; } 
# 2346 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept ; 
# 2360 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find (const basic_string & __str , size_type __pos = 0) const 
noexcept 
{ return this -> find (__str . data () , __pos , __str . size ()) ; } 
# 2392 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find (const _CharT * __s , size_type __pos = 0) const noexcept 
{ 
; 
return this -> find (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2409 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find (_CharT __c , size_type __pos = 0) const noexcept ; 
# 2422 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
rfind (const basic_string & __str , size_type __pos = npos) const 
noexcept 
{ return this -> rfind (__str . data () , __pos , __str . size ()) ; } 
# 2456 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
rfind (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept ; 
# 2470 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
rfind (const _CharT * __s , size_type __pos = npos) const 
{ 
; 
return this -> rfind (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2487 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
rfind (_CharT __c , size_type __pos = npos) const noexcept ; 
# 2501 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_of (const basic_string & __str , size_type __pos = 0) const 
noexcept 
{ return this -> find_first_of (__str . data () , __pos , __str . size ()) ; } 
# 2536 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept ; 
# 2550 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_of (const _CharT * __s , size_type __pos = 0) const 
noexcept 
{ 
; 
return this -> find_first_of (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2570 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_of (_CharT __c , size_type __pos = 0) const noexcept 
{ return this -> find (__c , __pos) ; } 
# 2585 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_of (const basic_string & __str , size_type __pos = npos) const 
noexcept 
{ return this -> find_last_of (__str . data () , __pos , __str . size ()) ; } 
# 2620 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept ; 
# 2634 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_of (const _CharT * __s , size_type __pos = npos) const 
noexcept 
{ 
; 
return this -> find_last_of (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2654 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_of (_CharT __c , size_type __pos = npos) const noexcept 
{ return this -> rfind (__c , __pos) ; } 
# 2668 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_not_of (const basic_string & __str , size_type __pos = 0) const 
noexcept 
{ return this -> find_first_not_of (__str . data () , __pos , __str . size ()) ; } 
# 2703 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_not_of (const _CharT * __s , size_type __pos , 
size_type __n) const noexcept ; 
# 2717 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_not_of (const _CharT * __s , size_type __pos = 0) const 
noexcept 
{ 
; 
return this -> find_first_not_of (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2735 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_first_not_of (_CharT __c , size_type __pos = 0) const 
noexcept ; 
# 2750 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_not_of (const basic_string & __str , size_type __pos = npos) const 
noexcept 
{ return this -> find_last_not_of (__str . data () , __pos , __str . size ()) ; } 
# 2785 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_not_of (const _CharT * __s , size_type __pos , 
size_type __n) const noexcept ; 
# 2799 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_not_of (const _CharT * __s , size_type __pos = npos) const 
noexcept 
{ 
; 
return this -> find_last_not_of (__s , __pos , traits_type :: length (__s)) ; 
} 
# 2817 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
size_type 
find_last_not_of (_CharT __c , size_type __pos = npos) const 
noexcept ; 
# 2833 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
basic_string 
substr (size_type __pos = 0 , size_type __n = npos) const 
{ return basic_string (* this , 
_M_check (__pos , "basic_string::substr") , __n) ; } 
# 2852 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (const basic_string & __str) const 
{ 
const size_type __size = this -> size () ; 
const size_type __osize = __str . size () ; 
const size_type __len = std :: min (__size , __osize) ; 

int __r = traits_type :: compare (_M_data () , __str . data () , __len) ; 
if (! __r) 
__r = _S_compare (__size , __osize) ; 
return __r ; 
} 
# 2945 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (size_type __pos , size_type __n , const basic_string & __str) const ; 
# 2971 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (size_type __pos1 , size_type __n1 , const basic_string & __str , 
size_type __pos2 , size_type __n2 = npos) const ; 
# 2989 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (const _CharT * __s) const noexcept ; 
# 3013 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (size_type __pos , size_type __n1 , const _CharT * __s) const ; 
# 3040 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
int 
compare (size_type __pos , size_type __n1 , const _CharT * __s , 
size_type __n2) const ; 
# 3071 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename , typename , typename > friend class basic_stringbuf ; 
} ;
}
# 6018 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > 
operator + (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ 
basic_string < _CharT , _Traits , _Alloc > __str (__lhs) ; 
__str . append (__rhs) ; 
return __str ; 
} 
# 6034
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( const _CharT * __lhs,
       const basic_string < _CharT, _Traits, _Alloc > & __rhs );
# 6045
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_string < _CharT, _Traits, _Alloc >
    operator + ( _CharT __lhs, const basic_string < _CharT, _Traits, _Alloc > & __rhs );
# 6055
template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ 
basic_string < _CharT , _Traits , _Alloc > __str (__lhs) ; 
__str . append (__rhs) ; 
return __str ; 
} 
# 6071
template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (const basic_string < _CharT , _Traits , _Alloc > & __lhs , _CharT __rhs) 
{ 
typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef typename __string_type :: size_type __size_type ; 
__string_type __str (__lhs) ; 
__str . append (__size_type (1) , __rhs) ; 
return __str ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (basic_string < _CharT , _Traits , _Alloc > && __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return std :: move (__lhs . append (__rhs)) ; } 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
basic_string < _CharT , _Traits , _Alloc > && __rhs) 
{ return std :: move (__rhs . insert (0 , __lhs)) ; } 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (basic_string < _CharT , _Traits , _Alloc > && __lhs , 
basic_string < _CharT , _Traits , _Alloc > && __rhs) 
{ 
const auto __size = __lhs . size () + __rhs . size () ; 
const bool __cond = (__size > __lhs . capacity () 
&& __size <= __rhs . capacity ()) ; 
return __cond ? std :: move (__rhs . insert (0 , __lhs)) 
: std :: move (__lhs . append (__rhs)) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (const _CharT * __lhs , 
basic_string < _CharT , _Traits , _Alloc > && __rhs) 
{ return std :: move (__rhs . insert (0 , __lhs)) ; } 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (_CharT __lhs , 
basic_string < _CharT , _Traits , _Alloc > && __rhs) 
{ return std :: move (__rhs . insert (0 , 1 , __lhs)) ; } 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (basic_string < _CharT , _Traits , _Alloc > && __lhs , 
const _CharT * __rhs) 
{ return std :: move (__lhs . append (__rhs)) ; } 

template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_string < _CharT , _Traits , _Alloc > 
operator + (basic_string < _CharT , _Traits , _Alloc > && __lhs , 
_CharT __rhs) 
{ return std :: move (__lhs . append (1 , __rhs)) ; } 
# 6139 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator == (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return __lhs . compare (__rhs) == 0 ; } 

template < typename _CharT > 
inline 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , bool > :: __type 
operator == (const basic_string < _CharT > & __lhs , 
const basic_string < _CharT > & __rhs) noexcept 
{ return (__lhs . size () == __rhs . size () 
&& ! std :: char_traits < _CharT > :: compare (__lhs . data () , __rhs . data () , 
__lhs . size ())) ; } 
# 6161
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator == (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return __rhs . compare (__lhs) == 0 ; } 
# 6173
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator == (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return __lhs . compare (__rhs) == 0 ; } 
# 6186 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator != (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return ! (__lhs == __rhs) ; } 
# 6199
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator != (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return ! (__lhs == __rhs) ; } 
# 6211
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator != (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return ! (__lhs == __rhs) ; } 
# 6224 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator < (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return __lhs . compare (__rhs) < 0 ; } 
# 6237
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator < (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return __lhs . compare (__rhs) < 0 ; } 
# 6249
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator < (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return __rhs . compare (__lhs) > 0 ; } 
# 6262 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator > (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return __lhs . compare (__rhs) > 0 ; } 
# 6275
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator > (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return __lhs . compare (__rhs) > 0 ; } 
# 6287
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator > (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return __rhs . compare (__lhs) < 0 ; } 
# 6300 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator <= (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return __lhs . compare (__rhs) <= 0 ; } 
# 6313
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator <= (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return __lhs . compare (__rhs) <= 0 ; } 
# 6325
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator <= (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return __rhs . compare (__lhs) >= 0 ; } 
# 6338 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator >= (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept 
{ return __lhs . compare (__rhs) >= 0 ; } 
# 6351
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator >= (const basic_string < _CharT , _Traits , _Alloc > & __lhs , 
const _CharT * __rhs) 
{ return __lhs . compare (__rhs) >= 0 ; } 
# 6363
template < typename _CharT , typename _Traits , typename _Alloc > 
inline bool 
operator >= (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ return __rhs . compare (__lhs) <= 0 ; } 
# 6376 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline void 
swap (basic_string < _CharT , _Traits , _Alloc > & __lhs , 
basic_string < _CharT , _Traits , _Alloc > & __rhs) 
noexcept (noexcept (__lhs . swap (__rhs))) 
{ __lhs . swap (__rhs) ; } 
# 6396 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __is,
        basic_string < _CharT, _Traits, _Alloc > & __str );



template<> basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str); 
# 6414 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , 
const basic_string < _CharT , _Traits , _Alloc > & __str) 
{ 


return __ostream_insert (__os , __str . data () , __str . size ()) ; 
} 
# 6437 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT, typename _Traits, typename _Alloc >
    basic_istream < _CharT, _Traits > &
    getline ( basic_istream < _CharT, _Traits > & __is,
     basic_string < _CharT, _Traits, _Alloc > & __str, _CharT __delim );
# 6454 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_istream < _CharT , _Traits > & 
getline (basic_istream < _CharT , _Traits > & __is , 
basic_string < _CharT , _Traits , _Alloc > & __str) 
{ return std :: getline (__is , __str , __is . widen ('\n')) ; } 



template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_istream < _CharT , _Traits > & 
getline (basic_istream < _CharT , _Traits > && __is , 
basic_string < _CharT , _Traits , _Alloc > & __str , _CharT __delim) 
{ return std :: getline (__is , __str , __delim) ; } 


template < typename _CharT , typename _Traits , typename _Alloc > 
inline basic_istream < _CharT , _Traits > & 
getline (basic_istream < _CharT , _Traits > && __is , 
basic_string < _CharT , _Traits , _Alloc > & __str) 
{ return std :: getline (__is , __str) ; } 




template<> basic_istream< char>  &getline(basic_istream< char>  & __in, __cxx11::basic_string< char>  & __str, char __delim); 
# 6484
template<> basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __in, __cxx11::basic_string< wchar_t>  & __str, wchar_t __delim); 




}
# 90 "d:\\mingw\\mingw\\include\\stdlib.h" 3
extern "C" {
# 99 "d:\\mingw\\mingw\\include\\stdlib.h" 3
extern int _argc; 
extern char **_argv; 




__attribute((__cdecl__)) __attribute((__nothrow__)) extern int *__p___argc(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern char ***__p___argv(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern wchar_t ***__p___wargv(); 
# 170 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _get_errno(int *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int _set_errno(int); 
# 187 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int _get_errno(int *__val) 
{ return (__val == __null) ? ((*_errno()) = 22) : (0 & (*__val = (*_errno()))); } 

__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int _set_errno(int __val) 
{ (*_errno()) = __val; return 0; } 




__attribute((__cdecl__)) __attribute((__nothrow__)) int *__doserrno(); 
# 204
__attribute((__cdecl__)) __attribute((__nothrow__)) extern char ***__p__environ(); 

__attribute((__cdecl__)) __attribute((__nothrow__)) extern wchar_t ***__p__wenviron(); 
# 229 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__dllimport__)) extern int _sys_nerr; 
# 254 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__dllimport__)) extern char *_sys_errlist[]; 
# 265 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) extern unsigned *__p__osver(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern unsigned *__p__winver(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern unsigned *__p__winmajor(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern unsigned *__p__winminor(); 
# 277 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__dllimport__)) extern unsigned _osver; 
__attribute((__dllimport__)) extern unsigned _winver; 
__attribute((__dllimport__)) extern unsigned _winmajor; 
__attribute((__dllimport__)) extern unsigned _winminor; 
# 316 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) char **__p__pgmptr(); 


__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t **__p__wpgmptr(); 
# 352 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__dllimport__)) extern int _fmode; 
# 362 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int atoi(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long atol(const char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) double strtod(const char *, char **); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double atof(const char *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) double _wtof(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wtoi(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long _wtol(const wchar_t *); 
# 406 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) float strtof(const char *, char **); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long double strtold(const char *, char **); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long strtol(const char *, char **, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long strtoul(const char *, char **, int); 
# 515 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t wcstombs(char *, const wchar_t *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int wctomb(char *, wchar_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int mblen(const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t mbstowcs(wchar_t *, const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int mbtowc(wchar_t *, const char *, size_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int rand(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void srand(unsigned); 
# 544 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void abort() __attribute((__noreturn__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void exit(int) __attribute((__noreturn__)); 



__attribute((__cdecl__)) __attribute((__nothrow__)) int atexit(void (*)(void)); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int system(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *getenv(const char *); 
# 56 "d:\\mingw\\mingw\\include\\alloca.h" 3
extern "C" {
# 80 "d:\\mingw\\mingw\\include\\alloca.h" 3
void *alloca(size_t); 
# 88
void *_alloca(size_t); 


}
# 562 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void *calloc(size_t, size_t) __attribute((__malloc__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void *malloc(size_t) __attribute((__malloc__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline void *realloc(void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline void free(void *); 
# 574 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void *__mingw_realloc(void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void __mingw_free(void *); 
# 585 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline void free(void *__ptr) 
{ __mingw_free(__ptr); } 


__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline void *realloc(void *__ptr, size_t __want) 
{ return __mingw_realloc(__ptr, __want); } 
# 624 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__malloc__)) void *__mingw_aligned_offset_malloc(size_t, size_t, size_t); 
# 637 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int posix_memalign(void **__p, size_t __alignment, size_t __want) 
{ if (sizeof(void *) > __alignment) __alignment = (sizeof(void *) << 1) - 1;   
*__p = __mingw_aligned_offset_malloc(__want, __alignment, (size_t)(0)); 
return (*__p == __null) ? (*_errno()) : 0; 
} 
# 649
__attribute((__cdecl__)) void *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *)); 


__attribute((__cdecl__)) void qsort(void *, size_t, size_t, int (*)(const void *, const void *)); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int abs(int) __attribute((const)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long labs(long) __attribute((const)); 
# 665 "d:\\mingw\\mingw\\include\\stdlib.h" 3
typedef struct { int quot, rem; } div_t; 
typedef struct { long quot, rem; } ldiv_t; 

__attribute((__cdecl__)) __attribute((__nothrow__)) div_t div(int, int) __attribute((const)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) ldiv_t ldiv(long, long) __attribute((const)); 
# 676
__attribute((__cdecl__)) __attribute((__nothrow__)) void _exit(int) __attribute((__noreturn__)); 
# 682
__attribute((__cdecl__)) __attribute((__nothrow__)) long long _atoi64(const char *); 
# 691 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void _beep(unsigned, unsigned) __attribute((__deprecated__)); 

__attribute((__cdecl__)) __attribute((__nothrow__)) void _seterrormode(int) __attribute((__deprecated__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void _sleep(unsigned long) __attribute((__deprecated__)); 



typedef int (*_onexit_t)(void); 
__attribute((__cdecl__)) __attribute((__nothrow__)) _onexit_t _onexit(_onexit_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _putenv(const char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) void _searchenv(const char *, const char *, char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) char *_ecvt(double, int, int *, int *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_fcvt(double, int, int *, int *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_gcvt(double, int, char *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) void _makepath(char *, const char *, const char *, const char *, const char *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) void _splitpath(const char *, char *, char *, char *, char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) char *_fullpath(char *, const char *, size_t); 

__attribute((__cdecl__)) __attribute((__nothrow__)) char *_itoa(int, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_ltoa(long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_ultoa(unsigned long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_itow(int, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_ltow(long, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_ultow(unsigned long, wchar_t *, int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) char *_i64toa(long long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_ui64toa(unsigned long long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long long _wtoi64(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_i64tow(long long, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_ui64tow(unsigned long long, wchar_t *, int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _rotl(unsigned, int) __attribute((const)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _rotr(unsigned, int) __attribute((const)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long _lrotl(unsigned long, int) __attribute((const)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long _lrotr(unsigned long, int) __attribute((const)); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _set_error_mode(int); 
# 774 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int putenv(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void searchenv(const char *, const char *, char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) char *itoa(int, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *ltoa(long, char *, int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) char *ecvt(double, int, int *, int *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *fcvt(double, int, int *, int *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *gcvt(double, int, char *); 
# 795 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline void _Exit(int) __attribute((__noreturn__)); 



__attribute((__cdecl__)) __attribute((__nothrow__)) inline void _Exit(int __status) { _exit(__status); } 


typedef struct { long long quot, rem; } lldiv_t; 
__attribute((__cdecl__)) __attribute((__nothrow__)) lldiv_t lldiv(long long, long long) __attribute((const)); 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline long long llabs(long long); 
# 812
__attribute((__cdecl__)) __attribute((__nothrow__)) inline long long llabs(long long __j) 
{ return (__j >= 0) ? __j : (-__j); } 



__attribute((__cdecl__)) __attribute((__nothrow__)) long long strtoll(const char *, char **, int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long long strtoull(const char *, char **, int); 
# 826
__attribute((__cdecl__)) __attribute((__nothrow__)) inline long long atoll(const char *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) inline long long atoll(const char *_c) { return _atoi64(_c); } 
# 872 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline long long wtoll(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline char *lltoa(long long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline char *ulltoa(unsigned long long, char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline wchar_t *lltow(long long, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline wchar_t *ulltow(unsigned long long, wchar_t *, int); 
# 883
__attribute((__cdecl__)) __attribute((__nothrow__)) inline char *lltoa(long long __n, char *__c, int __i) 
{ return _i64toa(__n, __c, __i); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline char *ulltoa(unsigned long long __n, char *__c, int __i) 
{ return _ui64toa(__n, __c, __i); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline long long wtoll(const wchar_t *__w) { return _wtoi64(__w); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline wchar_t *lltow(long long __n, wchar_t *__w, int __i) 
{ return _i64tow(__n, __w, __i); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline wchar_t *ulltow(unsigned long long __n, wchar_t *__w, int __i) 
{ return _ui64tow(__n, __w, __i); } 
# 912 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int mkstemp(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int __mingw_mkstemp(int, char *); 
# 955 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int mkstemp(char *__filename_template) 
{ return __mingw_mkstemp(0, __filename_template); } 
# 965 "d:\\mingw\\mingw\\include\\stdlib.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline char *mkdtemp(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *__mingw_mkdtemp(char *); 


__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline char *mkdtemp(char *__dirname_template) 
{ return __mingw_mkdtemp(__dirname_template); } 
# 977
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int setenv(const char *, const char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int unsetenv(const char *); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int __mingw_setenv(const char *, const char *, int); 


__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int setenv(const char *__n, const char *__v, int __f) 
{ return __mingw_setenv(__n, __v, __f); } 


__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int unsetenv(const char *__name) 
{ return __mingw_setenv(__name, __null, 1); } 




}
# 46 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_abs.h" 3
extern "C++" {

namespace std { 



using ::abs;



inline long abs(long __i) { return __builtin_labs(__i); } 




inline long long abs(long long __x) { return __builtin_llabs(__x); } 
# 71 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_abs.h" 3
constexpr double abs(double __x) 
{ return __builtin_fabs(__x); } 


constexpr float abs(float __x) 
{ return __builtin_fabsf(__x); } 


constexpr long double abs(long double __x) 
{ return __builtin_fabsl(__x); } 
# 103 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_abs.h" 3
constexpr __float128 abs(__float128 __x) 
{ return (__x < 0) ? -__x : __x; } 



}
}
# 121 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdlib" 3
extern "C++" {

namespace std { 



using ::div_t;
using ::ldiv_t;

using ::abort;



using ::atexit;
# 140
using ::atof;
using ::atoi;
using ::atol;
using ::bsearch;
using ::calloc;
using ::div;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::malloc;

using ::mblen;
using ::mbstowcs;
using ::mbtowc;

using ::qsort;
# 163
using ::rand;
using ::realloc;
using ::srand;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;

using ::wcstombs;
using ::wctomb;




inline ldiv_t div(long __i, long __j) { return ldiv(__i, __j); } 




}
# 195 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdlib" 3
namespace __gnu_cxx { 




using ::lldiv_t;
# 206
using ::_Exit;



using ::llabs;


inline lldiv_t div(long long __n, long long __d) 
{ lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; } 

using ::lldiv;
# 227 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdlib" 3
using ::atoll;
using ::strtoll;
using ::strtoull;

using ::strtof;
using ::strtold;


}

namespace std { 


using __gnu_cxx::lldiv_t;

using __gnu_cxx::_Exit;

using __gnu_cxx::llabs;
using __gnu_cxx::div;
using __gnu_cxx::lldiv;

using __gnu_cxx::atoll;
using __gnu_cxx::strtof;
using __gnu_cxx::strtoll;
using __gnu_cxx::strtoull;
using __gnu_cxx::strtold;
}



}
# 239 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__dllimport__)) extern FILE _iob[]; 
# 252 "d:\\mingw\\mingw\\include\\stdio.h" 3
extern "C" {
# 260
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *fopen(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *freopen(const char *, const char *, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fflush(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fclose(FILE *); 
# 270
__attribute((__cdecl__)) __attribute((__nothrow__)) int remove(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int rename(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *tmpfile(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *tmpnam(char *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) char *_tempnam(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _rmtmp(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _unlink(const char *); 
# 289 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) char *tempnam(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int rmtmp(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int unlink(const char *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) int setvbuf(FILE *, char *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void setbuf(FILE *, char *); 
# 342 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 2, 3))) extern int __mingw_fprintf(FILE *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 1, 2))) extern int __mingw_printf(const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 2, 3))) extern int __mingw_sprintf(char *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 3, 4))) extern int __mingw_snprintf(char *, size_t, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 2, 0))) extern int __mingw_vfprintf(FILE *, const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 1, 0))) extern int __mingw_vprintf(const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 2, 0))) extern int __mingw_vsprintf(char *, const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 3, 0))) extern int __mingw_vsnprintf(char *, size_t, const char *, __builtin_va_list); 
# 376 "d:\\mingw\\mingw\\include\\stdio.h" 3
extern unsigned _mingw_output_format_control(unsigned, unsigned); 
# 461 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int fprintf(FILE *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int printf(const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int sprintf(char *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vfprintf(FILE *, const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vprintf(const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int vsprintf(char *, const char *, __builtin_va_list); 
# 480 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) static inline int snprintf(char *__buf, size_t __len, const char *__format, ...) 
{ 
register int __retval; 
__builtin_va_list __local_argv; __builtin_va_start(__local_argv,__format); 
__retval = __mingw_vsnprintf(__buf, __len, __format, __local_argv); 
__builtin_va_end(__local_argv); 
return __retval; 
} 


__attribute((__cdecl__)) __attribute((__nothrow__)) static inline int vsnprintf(char *__buf, size_t __len, const char *__format, __builtin_va_list __local_argv) 
{ 
return __mingw_vsnprintf(__buf, __len, __format, __local_argv); 
} 
# 513 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 2, 3))) int __msvcrt_fprintf(FILE *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 1, 2))) int __msvcrt_printf(const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 2, 3))) int __msvcrt_sprintf(char *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 2, 0))) int __msvcrt_vfprintf(FILE *, const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 1, 0))) int __msvcrt_vprintf(const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__ms_printf__, 2, 0))) int __msvcrt_vsprintf(char *, const char *, __builtin_va_list); 
# 525
__attribute((__cdecl__)) __attribute((__nothrow__)) int _snprintf(char *, size_t, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _vsnprintf(char *, size_t, const char *, __builtin_va_list); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _vscprintf(const char *, __builtin_va_list); 
# 537 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 3, 4))) inline int snprintf(char *, size_t, const char *, ...); 


__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__format__(__mingw_printf__, 3, 0))) inline int vsnprintf(char *, size_t, const char *, __builtin_va_list); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int vscanf(const char *, __builtin_va_list); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int vfscanf(FILE *, const char *, __builtin_va_list); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int vsscanf(const char *, const char *, __builtin_va_list); 
# 680 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) ssize_t getdelim(char **, size_t *, int, FILE *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline ssize_t getline(char **, size_t *, FILE *); 
# 690
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline ssize_t getline(char **
__l, size_t *__n, FILE *__s) 
{ return getdelim(__l, __n, '\n', __s); } 
# 699
__attribute((__cdecl__)) __attribute((__nothrow__)) int fscanf(FILE *, const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int scanf(const char *, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int sscanf(const char *, const char *, ...); 



__attribute((__cdecl__)) __attribute((__nothrow__)) int fgetc(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *fgets(char *, int, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fputc(int, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fputs(const char *, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *gets(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int puts(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int ungetc(int, FILE *); 
# 720 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _filbuf(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _flsbuf(int, FILE *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) inline int getc(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int getc(FILE *__F) 
{ 
return (--__F->_cnt >= 0) ? (int)((unsigned char)(*((__F->_ptr)++))) : _filbuf(__F); 


} 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int putc(int, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int putc(int __c, FILE *__F) 
{ 
return (--__F->_cnt >= 0) ? (int)((unsigned char)(*((__F->_ptr)++) = (char)__c)) : _flsbuf(__c, __F); 


} 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int getchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int getchar() 
{ 
return (--(&((_iob)[0]))->_cnt >= 0) ? (int)((unsigned char)(*(((&((_iob)[0]))->_ptr)++))) : _filbuf((&((_iob)[0]))); 


} 

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int putchar(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int putchar(int __c) 
{ 
return (--(&((_iob)[1]))->_cnt >= 0) ? (int)((unsigned char)(*(((&((_iob)[1]))->_ptr)++) = (char)__c)) : _flsbuf(__c, (&((_iob)[1]))); 

} 
# 767 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t fread(void *, size_t, size_t, FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t fwrite(const void *, size_t, size_t, FILE *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) int fseek(FILE *, long, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long ftell(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void rewind(FILE *); 
# 821 "d:\\mingw\\mingw\\include\\stdio.h" 3
typedef union { long long __value; __off64_t __offset; } fpos_t; 




__attribute((__cdecl__)) __attribute((__nothrow__)) int fgetpos(FILE *, fpos_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fsetpos(FILE *, const fpos_t *); 
# 862 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int __mingw_fseeki64(FILE *, long long, int); 
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline int _fseeki64(FILE *__f, long long __o, int __w) 
{ return __mingw_fseeki64(__f, __o, __w); } 


__attribute((__cdecl__)) __attribute((__nothrow__)) long long __mingw_ftelli64(FILE *); 
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline long long _ftelli64(FILE *__file) 
{ return __mingw_ftelli64(__file); } 
# 875
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int feof(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int ferror(FILE *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) inline int feof(FILE *__F) { return __F->_flag & 0x10; } 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int ferror(FILE *__F) { return __F->_flag & 0x20; } 
# 886
__attribute((__cdecl__)) __attribute((__nothrow__)) void clearerr(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void perror(const char *); 
# 893
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_popen(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _pclose(FILE *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *popen(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int pclose(FILE *); 




__attribute((__cdecl__)) __attribute((__nothrow__)) int _flushall(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fgetchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fputchar(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_fdopen(int, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fileno(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fcloseall(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *_fsopen(const char *, const char *, int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _getmaxstdio(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _setmaxstdio(int); 
# 936 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) unsigned __mingw_get_output_format(); 
__attribute((__cdecl__)) unsigned __mingw_set_output_format(unsigned); 
# 945
__attribute((__cdecl__)) int __mingw_get_printf_count_output(); 
__attribute((__cdecl__)) int __mingw_set_printf_count_output(int); 
# 962 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) inline unsigned _get_output_format() 
{ return __mingw_get_output_format(); } 

__attribute((__always_inline__)) __attribute((__cdecl__)) inline unsigned _set_output_format(unsigned __style) 
{ return __mingw_set_output_format(__style); } 
# 987 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) inline int _get_printf_count_output() 
{ return (0) ? 1 : __mingw_get_printf_count_output(); } 

__attribute((__always_inline__)) __attribute((__cdecl__)) inline int _set_printf_count_output(int __mode) 
{ return (0) ? 1 : __mingw_set_printf_count_output(__mode); } 



__attribute((__cdecl__)) __attribute((__nothrow__)) int fgetchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fputchar(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *fdopen(int, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fileno(FILE *); 
# 1007 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__always_inline__)) inline FILE *fopen64(const char *, const char *) __attribute((__cdecl__)) __attribute((__nothrow__)); 

__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline FILE *fopen64(const char *filename, const char *mode) 
{ return fopen(filename, mode); } 

__attribute((__cdecl__)) __attribute((__nothrow__)) int fseeko64(FILE *, __off64_t, int); 
# 1028 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __off64_t ftello64(FILE *); 
# 1110 "d:\\mingw\\mingw\\include\\stdio.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) FILE *wpopen(const wchar_t *, const wchar_t *); 




__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t _fgetwchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t _fputwchar(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _getw(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _putw(int, FILE *); 




__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t fgetwchar(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wint_t fputwchar(wint_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int getw(FILE *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int putw(int, FILE *); 




}
# 96 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdio" 3
namespace std { 

using ::FILE;
using ::fpos_t;

using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::getchar;


using ::gets;

using ::perror;
using ::printf;
using ::putc;
using ::putchar;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;

using ::tmpnam;

using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;
}
# 157 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdio" 3
namespace __gnu_cxx { 
# 175 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cstdio" 3
using ::snprintf;
using ::vfscanf;
using ::vscanf;
using ::vsnprintf;
using ::vsscanf;

}

namespace std { 

using __gnu_cxx::snprintf;
using __gnu_cxx::vfscanf;
using __gnu_cxx::vscanf;
using __gnu_cxx::vsnprintf;
using __gnu_cxx::vsscanf;
}
# 46 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\string_conversions.h" 3
namespace __gnu_cxx { 




template < typename _TRet , typename _Ret = _TRet , typename _CharT , 
typename ... _Base > 
_Ret 
__stoa (_TRet (* __convf) (const _CharT * , _CharT * * , _Base ...) , 
const char * __name , const _CharT * __str , std :: size_t * __idx , 
_Base ... __base) 
{ 
_Ret __ret ; 

_CharT * __endptr ; 

struct _Save_errno { 
_Save_errno () : _M_errno ((* _errno ())) { (* _errno ()) = 0 ; } 
~ _Save_errno () { if ((* _errno ()) == 0) (* _errno ()) = _M_errno ; } 
int _M_errno ; 
} const __save_errno ; 

struct _Range_chk { 
static bool 
_S_chk (_TRet , std :: false_type) { return false ; } 

static bool 
_S_chk (_TRet __val , std :: true_type) 
{ 
return __val < _TRet (__numeric_traits < int > :: __min) 
|| __val > _TRet (__numeric_traits < int > :: __max) ; 
} 
} ; 

const _TRet __tmp = __convf (__str , & __endptr , __base ...) ; 

if (__endptr == __str) 
std :: __throw_invalid_argument (__name) ; 
else if ((* _errno ()) == 34 
|| _Range_chk :: _S_chk (__tmp , std :: is_same < _Ret , int > { })) 
std :: __throw_out_of_range (__name) ; 
else 
__ret = __tmp ; 

if (__idx) 
* __idx = __endptr - __str ; 

return __ret ; 
} 


template < typename _String , typename _CharT = typename _String :: value_type > 
_String 
__to_xstring (int (* __convf) (_CharT * , std :: size_t , const _CharT * , 
__builtin_va_list) , std :: size_t __n , 
const _CharT * __fmt , ...) 
{ 


_CharT * __s = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __n)) ; 

__builtin_va_list __args ; 
__builtin_va_start (__args , __fmt) ; 

const int __len = __convf (__s , __n , __fmt , __args) ; 

__builtin_va_end (__args) ; 

return _String (__s , __s + __len) ; 
} 


}
# 6495 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
namespace std { 


inline namespace __cxx11 { 




inline int stoi(const string &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa< long, int> (&std::strtol, "stoi", __str.c_str(), __idx, __base); 
} 


inline long stol(const string &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(), __idx, __base); 
} 


inline unsigned long stoul(const string &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(), __idx, __base); 
} 


inline long long stoll(const string &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(), __idx, __base); 
} 


inline unsigned long long stoull(const string &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(), __idx, __base); 
} 



inline float stof(const string &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); } 


inline double stod(const string &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); } 


inline long double stold(const string &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); } 
# 6546
inline string to_string(int __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(int), "%d", __val); 
} 


inline string to_string(unsigned __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(unsigned), "%u", __val); 

} 


inline string to_string(long __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(long), "%ld", __val); 
} 


inline string to_string(unsigned long __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(unsigned long), "%lu", __val); 

} 


inline string to_string(long long __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(long long), "%lld", __val); 

} 


inline string to_string(unsigned long long __val) 
{ return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, 4 * sizeof(unsigned long long), "%llu", __val); 

} 


inline string to_string(float __val) 
{ 
const int __n = (__gnu_cxx::__numeric_traits< float> ::__max_exponent10 + 20); 

return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%f", __val); 

} 


inline string to_string(double __val) 
{ 
const int __n = (__gnu_cxx::__numeric_traits< double> ::__max_exponent10 + 20); 

return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%f", __val); 

} 


inline string to_string(long double __val) 
{ 
const int __n = (__gnu_cxx::__numeric_traits< long double> ::__max_exponent10 + 20); 

return __gnu_cxx::__to_xstring< basic_string< char> > (&std::vsnprintf, __n, "%Lf", __val); 

} 




inline int stoi(const wstring &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa< long, int> (&std::wcstol, "stoi", __str.c_str(), __idx, __base); 
} 


inline long stol(const wstring &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(), __idx, __base); 
} 


inline unsigned long stoul(const wstring &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(), __idx, __base); 
} 


inline long long stoll(const wstring &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(), __idx, __base); 
} 


inline unsigned long long stoull(const wstring &__str, size_t *__idx = 0, int __base = 10) 
{ return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(), __idx, __base); 
} 



inline float stof(const wstring &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); } 


inline double stod(const wstring &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); } 


inline long double stold(const wstring &__str, size_t *__idx = 0) 
{ return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); } 
# 6711 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
}

}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functional_hash.h" 3
namespace std { 
# 49 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functional_hash.h" 3
template < typename _Result , typename _Arg > 
struct __hash_base 
{ 
typedef _Result result_type ; 
typedef _Arg argument_type ; 
} ;


template < typename _Tp >
    struct hash;

template < typename _Tp , typename = void > 
struct __poison_hash 
{ 
static constexpr bool __enable_hash_call = false ; 
private : 

__poison_hash (__poison_hash &&) ; 
~ __poison_hash () ; 
} ;

template < typename _Tp > 
struct __poison_hash < _Tp , __void_t < decltype (hash < _Tp > () (declval < _Tp > ())) > > 
{ 
static constexpr bool __enable_hash_call = true ; 
} ;


template < typename _Tp , bool = is_enum < _Tp > :: value > 
struct __hash_enum 
{ 
private : 

__hash_enum (__hash_enum &&) ; 
~ __hash_enum () ; 
} ;


template < typename _Tp > 
struct __hash_enum < _Tp , true > : public __hash_base < size_t , _Tp > 
{ 
size_t 
operator () (_Tp __val) const noexcept 
{ 
using __type = typename underlying_type < _Tp > :: type ; 
return hash < __type > { } (static_cast < __type > (__val)) ; 
} 
} ;



template < typename _Tp > 
struct hash : __hash_enum < _Tp > 
{ } ;


template < typename _Tp > 
struct hash < _Tp * > : public __hash_base < size_t , _Tp * > 
{ 
size_t 
operator () (_Tp * __p) const noexcept 
{ return reinterpret_cast < size_t > (__p) ; } 
} ;
# 124 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functional_hash.h" 3
template<> struct hash< bool>  : public __hash_base< unsigned, bool>  { size_t operator()(bool __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< char>  : public __hash_base< unsigned, char>  { size_t operator()(char __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< signed char>  : public __hash_base< unsigned, signed char>  { size_t operator()(signed char __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< unsigned char>  : public __hash_base< unsigned, unsigned char>  { size_t operator()(unsigned char __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< wchar_t>  : public __hash_base< unsigned, wchar_t>  { size_t operator()(wchar_t __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 144
template<> struct hash< char16_t>  : public __hash_base< unsigned, char16_t>  { size_t operator()(char16_t __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< char32_t>  : public __hash_base< unsigned, char32_t>  { size_t operator()(char32_t __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< short>  : public __hash_base< unsigned, short>  { size_t operator()(short __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< int>  : public __hash_base< unsigned, int>  { size_t operator()(int __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< long>  : public __hash_base< unsigned, long>  { size_t operator()(long __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< long long>  : public __hash_base< unsigned, long long>  { size_t operator()(long long __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< unsigned short>  : public __hash_base< unsigned, unsigned short>  { size_t operator()(unsigned short __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< unsigned>  : public __hash_base< unsigned, unsigned>  { size_t operator()(unsigned __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< unsigned long>  : public __hash_base< unsigned, unsigned long>  { size_t operator()(unsigned long __val) const noexcept { return static_cast< size_t>(__val); } }; 


template<> struct hash< unsigned long long>  : public __hash_base< unsigned, unsigned long long>  { size_t operator()(unsigned long long __val) const noexcept { return static_cast< size_t>(__val); } }; 
# 192 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functional_hash.h" 3
struct _Hash_impl { 


static size_t hash(const void *__ptr, size_t __clength, size_t 
__seed = static_cast< size_t>(0xc70f6907UL)) 
{ return _Hash_bytes(__ptr, __clength, __seed); } 

template < typename _Tp > 
static size_t 
hash (const _Tp & __val) 
{ return hash (& __val , sizeof (__val)) ; } 

template < typename _Tp > 
static size_t 
__hash_combine (const _Tp & __val , size_t __hash) 
{ return hash (& __val , sizeof (__val) , __hash) ; } 
}; 


struct _Fnv_hash_impl { 


static size_t hash(const void *__ptr, size_t __clength, size_t 
__seed = static_cast< size_t>(2166136261UL)) 
{ return _Fnv_hash_bytes(__ptr, __clength, __seed); } 

template < typename _Tp > 
static size_t 
hash (const _Tp & __val) 
{ return hash (& __val , sizeof (__val)) ; } 

template < typename _Tp > 
static size_t 
__hash_combine (const _Tp & __val , size_t __hash) 
{ return hash (& __val , sizeof (__val) , __hash) ; } 
}; 



template<> struct hash< float>  : public __hash_base< unsigned, float>  { 


size_t operator()(float __val) const noexcept 
{ 

return (__val != (0.0F)) ? std::_Hash_impl::hash(__val) : 0; 
} 
}; 



template<> struct hash< double>  : public __hash_base< unsigned, double>  { 


size_t operator()(double __val) const noexcept 
{ 

return (__val != (0.0)) ? std::_Hash_impl::hash(__val) : 0; 
} 
}; 



template<> struct hash< long double>  : public __hash_base< unsigned, long double>  { 



__attribute((__pure__)) size_t operator()(long double __val) const noexcept; 
}; 
# 278 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\functional_hash.h" 3
template < typename _Hash > 
struct __is_fast_hash : public std :: true_type 
{ } ;


template<> struct __is_fast_hash< hash< long double> >  : public false_type { 
}; 


}
# 6721 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
namespace std { 
# 6730
template<> struct hash< __cxx11::basic_string< char> >  : public __hash_base< unsigned, __cxx11::basic_string< char> >  { 



size_t operator()(const string &__s) const noexcept 
{ return std::_Hash_impl::hash(__s.data(), __s.length()); } 
}; 


template<> struct __is_fast_hash< hash< __cxx11::basic_string< char> > >  : public false_type { 
}; 




template<> struct hash< __cxx11::basic_string< wchar_t> >  : public __hash_base< unsigned, __cxx11::basic_string< wchar_t> >  { 



size_t operator()(const wstring &__s) const noexcept 
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(wchar_t)); 
} 
}; 


template<> struct __is_fast_hash< hash< __cxx11::basic_string< wchar_t> > >  : public false_type { 
}; 
# 6779 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
template<> struct hash< __cxx11::basic_string< char16_t> >  : public __hash_base< unsigned, __cxx11::basic_string< char16_t> >  { 



size_t operator()(const u16string &__s) const noexcept 
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char16_t)); 
} 
}; 


template<> struct __is_fast_hash< hash< __cxx11::basic_string< char16_t> > >  : public false_type { 
}; 



template<> struct hash< __cxx11::basic_string< char32_t> >  : public __hash_base< unsigned, __cxx11::basic_string< char32_t> >  { 



size_t operator()(const u32string &__s) const noexcept 
{ return std::_Hash_impl::hash(__s.data(), __s.length() * sizeof(char32_t)); 
} 
}; 


template<> struct __is_fast_hash< hash< __cxx11::basic_string< char32_t> > >  : public false_type { 
}; 
# 6869 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.h" 3
}
# 46 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.tcc" 3
namespace std { 
# 52
template < typename _CharT, typename _Traits, typename _Alloc >
    const typename basic_string < _CharT, _Traits, _Alloc > :: size_type
    basic_string < _CharT, _Traits, _Alloc > :: npos;

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
swap (basic_string & __s) noexcept 
{ 
if (this == & __s) 
return ; 

_Alloc_traits :: _S_on_swap (_M_get_allocator () , __s . _M_get_allocator ()) ; 

if (_M_is_local ()) 
if (__s . _M_is_local ()) 
{ 
if (length () && __s . length ()) 
{ 
_CharT __tmp_data [ _S_local_capacity + 1 ] ; 
traits_type :: copy (__tmp_data , __s . _M_local_buf , 
_S_local_capacity + 1) ; 
traits_type :: copy (__s . _M_local_buf , _M_local_buf , 
_S_local_capacity + 1) ; 
traits_type :: copy (_M_local_buf , __tmp_data , 
_S_local_capacity + 1) ; 
} 
else if (__s . length ()) 
{ 
traits_type :: copy (_M_local_buf , __s . _M_local_buf , 
_S_local_capacity + 1) ; 
_M_length (__s . length ()) ; 
__s . _M_set_length (0) ; 
return ; 
} 
else if (length ()) 
{ 
traits_type :: copy (__s . _M_local_buf , _M_local_buf , 
_S_local_capacity + 1) ; 
__s . _M_length (length ()) ; 
_M_set_length (0) ; 
return ; 
} 
} 
else 
{ 
const size_type __tmp_capacity = __s . _M_allocated_capacity ; 
traits_type :: copy (__s . _M_local_buf , _M_local_buf , 
_S_local_capacity + 1) ; 
_M_data (__s . _M_data ()) ; 
__s . _M_data (__s . _M_local_buf) ; 
_M_capacity (__tmp_capacity) ; 
} 
else 
{ 
const size_type __tmp_capacity = _M_allocated_capacity ; 
if (__s . _M_is_local ()) 
{ 
traits_type :: copy (_M_local_buf , __s . _M_local_buf , 
_S_local_capacity + 1) ; 
__s . _M_data (_M_data ()) ; 
_M_data (_M_local_buf) ; 
} 
else 
{ 
pointer __tmp_ptr = _M_data () ; 
_M_data (__s . _M_data ()) ; 
__s . _M_data (__tmp_ptr) ; 
_M_capacity (__s . _M_allocated_capacity) ; 
} 
__s . _M_capacity (__tmp_capacity) ; 
} 

const size_type __tmp_length = length () ; 
_M_length (__s . length ()) ; 
__s . _M_length (__tmp_length) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: pointer 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_create (size_type & __capacity , size_type __old_capacity) 
{ 


if (__capacity > max_size ()) 
std :: __throw_length_error (("basic_string::_M_create")) ; 




if (__capacity > __old_capacity && __capacity < 2 * __old_capacity) 
{ 
__capacity = 2 * __old_capacity ; 

if (__capacity > max_size ()) 
__capacity = max_size () ; 
} 



return _Alloc_traits :: allocate (_M_get_allocator () , __capacity + 1) ; 
} 
# 160
template < typename _CharT , typename _Traits , typename _Alloc > 
template < typename _InIterator > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_construct (_InIterator __beg , _InIterator __end , 
std :: input_iterator_tag) 
{ 
size_type __len = 0 ; 
size_type __capacity = size_type (_S_local_capacity) ; 

while (__beg != __end && __len < __capacity) 
{ 
_M_data () [ __len ++ ] = * __beg ; 
++ __beg ; 
} 

try 
{ 
while (__beg != __end) 
{ 
if (__len == __capacity) 
{ 

__capacity = __len + 1 ; 
pointer __another = _M_create (__capacity , __len) ; 
this -> _S_copy (__another , _M_data () , __len) ; 
_M_dispose () ; 
_M_data (__another) ; 
_M_capacity (__capacity) ; 
} 
_M_data () [ __len ++ ] = * __beg ; 
++ __beg ; 
} 
} 
catch (...) 
{ 
_M_dispose () ; 
throw ; 
} 

_M_set_length (__len) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
template < typename _InIterator > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_construct (_InIterator __beg , _InIterator __end , 
std :: forward_iterator_tag) 
{ 

if (__gnu_cxx :: __is_null_pointer (__beg) && __beg != __end) 
std :: __throw_logic_error (("basic_string::" "_M_construct null not valid")
) ; 

size_type __dnew = static_cast < size_type > (std :: distance (__beg , __end)) ; 

if (__dnew > size_type (_S_local_capacity)) 
{ 
_M_data (_M_create (__dnew , size_type (0))) ; 
_M_capacity (__dnew) ; 
} 


try 
{ this -> _S_copy_chars (_M_data () , __beg , __end) ; } 
catch (...) 
{ 
_M_dispose () ; 
throw ; 
} 

_M_set_length (__dnew) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_construct (size_type __n , _CharT __c) 
{ 
if (__n > size_type (_S_local_capacity)) 
{ 
_M_data (_M_create (__n , size_type (0))) ; 
_M_capacity (__n) ; 
} 

if (__n) 
this -> _S_assign (_M_data () , __n , __c) ; 

_M_set_length (__n) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_assign (const basic_string & __str) 
{ 
if (this != & __str) 
{ 
const size_type __rsize = __str . length () ; 
const size_type __capacity = capacity () ; 

if (__rsize > __capacity) 
{ 
size_type __new_capacity = __rsize ; 
pointer __tmp = _M_create (__new_capacity , __capacity) ; 
_M_dispose () ; 
_M_data (__tmp) ; 
_M_capacity (__new_capacity) ; 
} 

if (__rsize) 
this -> _S_copy (_M_data () , __str . _M_data () , __rsize) ; 

_M_set_length (__rsize) ; 
} 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
reserve (size_type __res) 
{ 

if (__res < length ()) 
__res = length () ; 

const size_type __capacity = capacity () ; 
if (__res != __capacity) 
{ 
if (__res > __capacity 
|| __res > size_type (_S_local_capacity)) 
{ 
pointer __tmp = _M_create (__res , __capacity) ; 
this -> _S_copy (__tmp , _M_data () , length () + 1) ; 
_M_dispose () ; 
_M_data (__tmp) ; 
_M_capacity (__res) ; 
} 
else if (! _M_is_local ()) 
{ 
this -> _S_copy (_M_local_data () , _M_data () , length () + 1) ; 
_M_destroy (__capacity) ; 
_M_data (_M_local_data ()) ; 
} 
} 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_mutate (size_type __pos , size_type __len1 , const _CharT * __s , 
size_type __len2) 
{ 
const size_type __how_much = length () - __pos - __len1 ; 

size_type __new_capacity = length () + __len2 - __len1 ; 
pointer __r = _M_create (__new_capacity , capacity ()) ; 

if (__pos) 
this -> _S_copy (__r , _M_data () , __pos) ; 
if (__s && __len2) 
this -> _S_copy (__r + __pos , __s , __len2) ; 
if (__how_much) 
this -> _S_copy (__r + __pos + __len2 , 
_M_data () + __pos + __len1 , __how_much) ; 

_M_dispose () ; 
_M_data (__r) ; 
_M_capacity (__new_capacity) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_erase (size_type __pos , size_type __n) 
{ 
const size_type __how_much = length () - __pos - __n ; 

if (__how_much && __n) 
this -> _S_move (_M_data () + __pos , _M_data () + __pos + __n , __how_much) ; 

_M_set_length (length () - __n) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
void 
basic_string < _CharT , _Traits , _Alloc > :: 
resize (size_type __n , _CharT __c) 
{ 
const size_type __size = this -> size () ; 
if (__size < __n) 
this -> append (__n - __size , __c) ; 
else if (__n < __size) 
this -> _M_set_length (__n) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > & 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_append (const _CharT * __s , size_type __n) 
{ 
const size_type __len = __n + this -> size () ; 

if (__len <= this -> capacity ()) 
{ 
if (__n) 
this -> _S_copy (this -> _M_data () + this -> size () , __s , __n) ; 
} 
else 
this -> _M_mutate (this -> size () , size_type (0) , __s , __n) ; 

this -> _M_set_length (__len) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
template < typename _InputIterator > 
basic_string < _CharT , _Traits , _Alloc > & 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_replace_dispatch (const_iterator __i1 , const_iterator __i2 , 
_InputIterator __k1 , _InputIterator __k2 , 
std :: __false_type) 
{ 
const basic_string __s (__k1 , __k2) ; 
const size_type __n1 = __i2 - __i1 ; 
return _M_replace (__i1 - begin () , __n1 , __s . _M_data () , 
__s . size ()) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > & 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_replace_aux (size_type __pos1 , size_type __n1 , size_type __n2 , 
_CharT __c) 
{ 
_M_check_length (__n1 , __n2 , "basic_string::_M_replace_aux") ; 

const size_type __old_size = this -> size () ; 
const size_type __new_size = __old_size + __n2 - __n1 ; 

if (__new_size <= this -> capacity ()) 
{ 
pointer __p = this -> _M_data () + __pos1 ; 

const size_type __how_much = __old_size - __pos1 - __n1 ; 
if (__how_much && __n1 != __n2) 
this -> _S_move (__p + __n2 , __p + __n1 , __how_much) ; 
} 
else 
this -> _M_mutate (__pos1 , __n1 , 0 , __n2) ; 

if (__n2) 
this -> _S_assign (this -> _M_data () + __pos1 , __n2 , __c) ; 

this -> _M_set_length (__new_size) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > & 
basic_string < _CharT , _Traits , _Alloc > :: 
_M_replace (size_type __pos , size_type __len1 , const _CharT * __s , 
const size_type __len2) 
{ 
_M_check_length (__len1 , __len2 , "basic_string::_M_replace") ; 

const size_type __old_size = this -> size () ; 
const size_type __new_size = __old_size + __len2 - __len1 ; 

if (__new_size <= this -> capacity ()) 
{ 
pointer __p = this -> _M_data () + __pos ; 

const size_type __how_much = __old_size - __pos - __len1 ; 
if (_M_disjunct (__s)) 
{ 
if (__how_much && __len1 != __len2) 
this -> _S_move (__p + __len2 , __p + __len1 , __how_much) ; 
if (__len2) 
this -> _S_copy (__p , __s , __len2) ; 
} 
else 
{ 

if (__len2 && __len2 <= __len1) 
this -> _S_move (__p , __s , __len2) ; 
if (__how_much && __len1 != __len2) 
this -> _S_move (__p + __len2 , __p + __len1 , __how_much) ; 
if (__len2 > __len1) 
{ 
if (__s + __len2 <= __p + __len1) 
this -> _S_move (__p , __s , __len2) ; 
else if (__s >= __p + __len1) 
this -> _S_copy (__p , __s + __len2 - __len1 , __len2) ; 
else 
{ 
const size_type __nleft = (__p + __len1) - __s ; 
this -> _S_move (__p , __s , __nleft) ; 
this -> _S_copy (__p + __nleft , __p + __len2 , 
__len2 - __nleft) ; 
} 
} 
} 
} 
else 
this -> _M_mutate (__pos , __len1 , __s , __len2) ; 

this -> _M_set_length (__new_size) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
copy (_CharT * __s , size_type __n , size_type __pos) const 
{ 
_M_check (__pos , "basic_string::copy") ; 
__n = _M_limit (__pos , __n) ; 
; 
if (__n) 
_S_copy (__s , _M_data () + __pos , __n) ; 

return __n ; 
} 
# 1156 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.tcc" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > 
operator + (const _CharT * __lhs , 
const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ 
; 
typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef typename __string_type :: size_type __size_type ; 
const __size_type __len = _Traits :: length (__lhs) ; 
__string_type __str ; 
__str . reserve (__len + __rhs . size ()) ; 
__str . append (__lhs , __len) ; 
__str . append (__rhs) ; 
return __str ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
basic_string < _CharT , _Traits , _Alloc > 
operator + (_CharT __lhs , const basic_string < _CharT , _Traits , _Alloc > & __rhs) 
{ 
typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef typename __string_type :: size_type __size_type ; 
__string_type __str ; 
const __size_type __len = __rhs . size () ; 
__str . reserve (__len + 1) ; 
__str . append (__size_type (1) , __lhs) ; 
__str . append (__rhs) ; 
return __str ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
const size_type __size = this -> size () ; 

if (__n == 0) 
return __pos <= __size ? __pos : npos ; 
if (__pos >= __size) 
return npos ; 

const _CharT __elem0 = __s [ 0 ] ; 
const _CharT * const __data = data () ; 
const _CharT * __first = __data + __pos ; 
const _CharT * const __last = __data + __size ; 
size_type __len = __size - __pos ; 

while (__len >= __n) 
{ 

__first = traits_type :: find (__first , __len - __n + 1 , __elem0) ; 
if (! __first) 
return npos ; 



if (traits_type :: compare (__first , __s , __n) == 0) 
return __first - __data ; 
__len = __last - ++ __first ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find (_CharT __c , size_type __pos) const noexcept 
{ 
size_type __ret = npos ; 
const size_type __size = this -> size () ; 
if (__pos < __size) 
{ 
const _CharT * __data = _M_data () ; 
const size_type __n = __size - __pos ; 
const _CharT * __p = traits_type :: find (__data + __pos , __n , __c) ; 
if (__p) 
__ret = __p - __data ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
rfind (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
const size_type __size = this -> size () ; 
if (__n <= __size) 
{ 
__pos = std :: min (size_type (__size - __n) , __pos) ; 
const _CharT * __data = _M_data () ; 
do 
{ 
if (traits_type :: compare (__data + __pos , __s , __n) == 0) 
return __pos ; 
} 
while (__pos -- > 0) ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
rfind (_CharT __c , size_type __pos) const noexcept 
{ 
size_type __size = this -> size () ; 
if (__size) 
{ 
if (-- __size > __pos) 
__size = __pos ; 
for (++ __size ; __size -- > 0 ;) 
if (traits_type :: eq (_M_data () [ __size ] , __c)) 
return __size ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_first_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
for (; __n && __pos < this -> size () ; ++ __pos) 
{ 
const _CharT * __p = traits_type :: find (__s , __n , _M_data () [ __pos ]) ; 
if (__p) 
return __pos ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_last_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
size_type __size = this -> size () ; 
if (__size && __n) 
{ 
if (-- __size > __pos) 
__size = __pos ; 
do 
{ 
if (traits_type :: find (__s , __n , _M_data () [ __size ])) 
return __size ; 
} 
while (__size -- != 0) ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_first_not_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
for (; __pos < this -> size () ; ++ __pos) 
if (! traits_type :: find (__s , __n , _M_data () [ __pos ])) 
return __pos ; 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_first_not_of (_CharT __c , size_type __pos) const noexcept 
{ 
for (; __pos < this -> size () ; ++ __pos) 
if (! traits_type :: eq (_M_data () [ __pos ] , __c)) 
return __pos ; 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_last_not_of (const _CharT * __s , size_type __pos , size_type __n) const 
noexcept 
{ 
; 
size_type __size = this -> size () ; 
if (__size) 
{ 
if (-- __size > __pos) 
__size = __pos ; 
do 
{ 
if (! traits_type :: find (__s , __n , _M_data () [ __size ])) 
return __size ; 
} 
while (__size --) ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
typename basic_string < _CharT , _Traits , _Alloc > :: size_type 
basic_string < _CharT , _Traits , _Alloc > :: 
find_last_not_of (_CharT __c , size_type __pos) const noexcept 
{ 
size_type __size = this -> size () ; 
if (__size) 
{ 
if (-- __size > __pos) 
__size = __pos ; 
do 
{ 
if (! traits_type :: eq (_M_data () [ __size ] , __c)) 
return __size ; 
} 
while (__size --) ; 
} 
return npos ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
int 
basic_string < _CharT , _Traits , _Alloc > :: 
compare (size_type __pos , size_type __n , const basic_string & __str) const 
{ 
_M_check (__pos , "basic_string::compare") ; 
__n = _M_limit (__pos , __n) ; 
const size_type __osize = __str . size () ; 
const size_type __len = std :: min (__n , __osize) ; 
int __r = traits_type :: compare (_M_data () + __pos , __str . data () , __len) ; 
if (! __r) 
__r = _S_compare (__n , __osize) ; 
return __r ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
int 
basic_string < _CharT , _Traits , _Alloc > :: 
compare (size_type __pos1 , size_type __n1 , const basic_string & __str , 
size_type __pos2 , size_type __n2) const 
{ 
_M_check (__pos1 , "basic_string::compare") ; 
__str . _M_check (__pos2 , "basic_string::compare") ; 
__n1 = _M_limit (__pos1 , __n1) ; 
__n2 = __str . _M_limit (__pos2 , __n2) ; 
const size_type __len = std :: min (__n1 , __n2) ; 
int __r = traits_type :: compare (_M_data () + __pos1 , 
__str . data () + __pos2 , __len) ; 
if (! __r) 
__r = _S_compare (__n1 , __n2) ; 
return __r ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
int 
basic_string < _CharT , _Traits , _Alloc > :: 
compare (const _CharT * __s) const noexcept 
{ 
; 
const size_type __size = this -> size () ; 
const size_type __osize = traits_type :: length (__s) ; 
const size_type __len = std :: min (__size , __osize) ; 
int __r = traits_type :: compare (_M_data () , __s , __len) ; 
if (! __r) 
__r = _S_compare (__size , __osize) ; 
return __r ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
int 
basic_string < _CharT , _Traits , _Alloc > :: 
compare (size_type __pos , size_type __n1 , const _CharT * __s) const 
{ 
; 
_M_check (__pos , "basic_string::compare") ; 
__n1 = _M_limit (__pos , __n1) ; 
const size_type __osize = traits_type :: length (__s) ; 
const size_type __len = std :: min (__n1 , __osize) ; 
int __r = traits_type :: compare (_M_data () + __pos , __s , __len) ; 
if (! __r) 
__r = _S_compare (__n1 , __osize) ; 
return __r ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
int 
basic_string < _CharT , _Traits , _Alloc > :: 
compare (size_type __pos , size_type __n1 , const _CharT * __s , 
size_type __n2) const 
{ 
; 
_M_check (__pos , "basic_string::compare") ; 
__n1 = _M_limit (__pos , __n1) ; 
const size_type __len = std :: min (__n1 , __n2) ; 
int __r = traits_type :: compare (_M_data () + __pos , __s , __len) ; 
if (! __r) 
__r = _S_compare (__n1 , __n2) ; 
return __r ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc > 
basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __in , 
basic_string < _CharT , _Traits , _Alloc > & __str) 
{ 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef typename __istream_type :: ios_base __ios_base ; 
typedef typename __istream_type :: int_type __int_type ; 
typedef typename __string_type :: size_type __size_type ; 
typedef ctype < _CharT > __ctype_type ; 
typedef typename __ctype_type :: ctype_base __ctype_base ; 

__size_type __extracted = 0 ; 
typename __ios_base :: iostate __err = __ios_base :: goodbit ; 
typename __istream_type :: sentry __cerb (__in , false) ; 
if (__cerb) 
{ 
try 
{ 

__str . erase () ; 
_CharT __buf [ 128 ] ; 
__size_type __len = 0 ; 
const streamsize __w = __in . width () ; 
const __size_type __n = __w > 0 ? static_cast < __size_type > (__w) 
: __str . max_size () ; 
const __ctype_type & __ct = use_facet < __ctype_type > (__in . getloc ()) ; 
const __int_type __eof = _Traits :: eof () ; 
__int_type __c = __in . rdbuf () -> sgetc () ; 

while (__extracted < __n 
&& ! _Traits :: eq_int_type (__c , __eof) 
&& ! __ct . is (__ctype_base :: space , 
_Traits :: to_char_type (__c))) 
{ 
if (__len == sizeof (__buf) / sizeof (_CharT)) 
{ 
__str . append (__buf , sizeof (__buf) / sizeof (_CharT)) ; 
__len = 0 ; 
} 
__buf [ __len ++ ] = _Traits :: to_char_type (__c) ; 
++ __extracted ; 
__c = __in . rdbuf () -> snextc () ; 
} 
__str . append (__buf , __len) ; 

if (_Traits :: eq_int_type (__c , __eof)) 
__err |= __ios_base :: eofbit ; 
__in . width (0) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__in . _M_setstate (__ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ 



__in . _M_setstate (__ios_base :: badbit) ; 
} 
} 

if (! __extracted) 
__err |= __ios_base :: failbit ; 
if (__err) 
__in . setstate (__err) ; 
return __in ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
basic_istream < _CharT , _Traits > & 
getline (basic_istream < _CharT , _Traits > & __in , 
basic_string < _CharT , _Traits , _Alloc > & __str , _CharT __delim) 
{ 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef typename __istream_type :: ios_base __ios_base ; 
typedef typename __istream_type :: int_type __int_type ; 
typedef typename __string_type :: size_type __size_type ; 

__size_type __extracted = 0 ; 
const __size_type __n = __str . max_size () ; 
typename __ios_base :: iostate __err = __ios_base :: goodbit ; 
typename __istream_type :: sentry __cerb (__in , true) ; 
if (__cerb) 
{ 
try 
{ 
__str . erase () ; 
const __int_type __idelim = _Traits :: to_int_type (__delim) ; 
const __int_type __eof = _Traits :: eof () ; 
__int_type __c = __in . rdbuf () -> sgetc () ; 

while (__extracted < __n 
&& ! _Traits :: eq_int_type (__c , __eof) 
&& ! _Traits :: eq_int_type (__c , __idelim)) 
{ 
__str += _Traits :: to_char_type (__c) ; 
++ __extracted ; 
__c = __in . rdbuf () -> snextc () ; 
} 

if (_Traits :: eq_int_type (__c , __eof)) 
__err |= __ios_base :: eofbit ; 
else if (_Traits :: eq_int_type (__c , __idelim)) 
{ 
++ __extracted ; 
__in . rdbuf () -> sbumpc () ; 
} 
else 
__err |= __ios_base :: failbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__in . _M_setstate (__ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ 



__in . _M_setstate (__ios_base :: badbit) ; 
} 
} 
if (! __extracted) 
__err |= __ios_base :: failbit ; 
if (__err) 
__in . setstate (__err) ; 
return __in ; 
} 
# 1608 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_string.tcc" 3
extern template class __cxx11::basic_string< char> ;
# 1616
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str);


extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, const __cxx11::basic_string< char>  & __str);


extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str, char __delim);


extern template basic_istream< char>  &getline(basic_istream< char>  & __is, __cxx11::basic_string< char>  & __str);
# 1631
extern template class __cxx11::basic_string< wchar_t> ;
# 1637
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str);


extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, const __cxx11::basic_string< wchar_t>  & __str);


extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str, wchar_t __delim);


extern template basic_istream< wchar_t>  &getline(basic_istream< wchar_t>  & __is, __cxx11::basic_string< wchar_t>  & __str);
# 1653
}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
namespace std { 
# 62 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
class locale { 




public: typedef int category; 


class facet; 
class id; 
class _Impl; 

friend class facet; 
friend class _Impl; 

template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );

template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );

template < typename _Cache >
      friend struct __use_cache;
# 98 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
static const category none = 0; 
static const category ctype = (1L << 0); 
static const category numeric = (1L << 1); 
static const category collate = (1L << 2); 
static const category time = (1L << 3); 
static const category monetary = (1L << 4); 
static const category messages = (1L << 5); 
static const category all = (((((ctype | numeric) | collate) | time) | monetary) | messages); 
# 117 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
locale() throw(); 
# 126 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
locale(const locale & __other) throw(); 
# 137 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
explicit locale(const char * __s); 
# 151 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
locale(const locale & __base, const char * __s, category __cat); 
# 163 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
explicit locale(const string &__s) : locale(__s.c_str()) { } 
# 177 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
locale(const locale &__base, const string &__s, category __cat) : locale(__base, __s.c_str(), __cat) 
{ } 
# 192 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
locale(const locale & __base, const locale & __add, category __cat); 
# 205 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
template < typename _Facet >
      locale ( const locale & __other, _Facet * __f );


~locale() throw(); 
# 220 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
const locale &operator=(const locale & __other) throw(); 
# 234 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
template < typename _Facet >
      locale
      combine ( const locale & __other ) const;
# 245
__attribute((__abi_tag__("cxx11"))) string name() const; 
# 255 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
bool operator==(const locale & __other) const throw(); 
# 264
bool operator!=(const locale &__other) const throw() 
{ return !(this->operator==(__other)); } 
# 282 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
template < typename _Char, typename _Traits, typename _Alloc >
      bool
      operator ( ) ( const basic_string < _Char, _Traits, _Alloc > & __s1,
   const basic_string < _Char, _Traits, _Alloc > & __s2 ) const;
# 299 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
static locale global(const locale & __loc); 
# 305
static const locale &classic(); 



private: _Impl *_M_impl; 


static _Impl *_S_classic; 


static _Impl *_S_global; 
# 321
static const char *const *const _S_categories; 
# 333 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
enum { _S_categories_size = (6 + 0)}; 


static __gthread_once_t _S_once; 



explicit locale(_Impl *) throw(); 


static void _S_initialize(); 


static void _S_initialize_once() throw(); 


static category _S_normalize_category(category); 


void _M_coalesce(const locale & __base, const locale & __add, category __cat); 


static const id *const _S_twinned_facets[]; 

}; 
# 371 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
class locale::facet { 


friend class locale; 
friend class _Impl; 

mutable _Atomic_word _M_refcount; 


static __c_locale _S_c_locale; 


static const char _S_c_name[2]; 


static __gthread_once_t _S_once; 



static void _S_initialize_once(); 
# 403 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
protected: explicit facet(size_t __refs = 0) throw() : _M_refcount((__refs) ? 1 : 0) 
{ } 



virtual ~facet(); 


static void _S_create_c_locale(__c_locale & __cloc, const char * __s, __c_locale __old = 0); 



static __c_locale _S_clone_c_locale(__c_locale & __cloc) throw(); 


static void _S_destroy_c_locale(__c_locale & __cloc); 


static __c_locale _S_lc_ctype_c_locale(__c_locale __cloc, const char * __s); 




static __c_locale _S_get_c_locale(); 


__attribute((const)) static const char *_S_get_c_name() throw(); 
# 438 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
facet(const facet &) = delete;


facet &operator=(const facet &) = delete;




private: void _M_add_reference() const throw() 
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 


void _M_remove_reference() const throw() 
{ 

; 
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
{ 
; 
try 
{ delete this; } 
catch (...) 
{ }  
}  
} 

const facet *_M_sso_shim(const id *) const; 
const facet *_M_cow_shim(const id *) const; 


protected: class __shim; 
}; 
# 483 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
class locale::id { 


friend class locale; 
friend class _Impl; 

template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );

template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );




mutable size_t _M_index; 


static _Atomic_word _S_refcount; 


void operator=(const id &); 

id(const id &); 
# 514
public: id() { } 


size_t _M_id() const throw(); 
}; 



class locale::_Impl { 



friend class locale; 
friend class facet; 

template < typename _Facet >
      friend bool
      has_facet ( const locale & ) throw ( );

template < typename _Facet >
      friend const _Facet &
      use_facet ( const locale & );

template < typename _Cache >
      friend struct __use_cache;



_Atomic_word _M_refcount; 
const facet **_M_facets; 
size_t _M_facets_size; 
const facet **_M_caches; 
char **_M_names; 
static const id *const _S_id_ctype[]; 
static const id *const _S_id_numeric[]; 
static const id *const _S_id_collate[]; 
static const id *const _S_id_time[]; 
static const id *const _S_id_monetary[]; 
static const id *const _S_id_messages[]; 
static const id *const *const _S_facet_categories[]; 


void _M_add_reference() throw() 
{ __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 


void _M_remove_reference() throw() 
{ 

; 
if (__gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1) == 1) 
{ 
; 
try 
{ delete this; } 
catch (...) 
{ }  
}  
} 

_Impl(const _Impl &, size_t); 
_Impl(const char *, size_t); 
_Impl(size_t) throw(); 

~_Impl() throw(); 

_Impl(const _Impl &); 


void operator=(const _Impl &); 


bool _M_check_same_name() 
{ 
bool __ret = true; 
if (_M_names[1]) 

for (size_t __i = (0); __ret && __i < (_S_categories_size) - 1; ++__i) 
__ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;     
return __ret; 
} 


void _M_replace_categories(const _Impl *, category); 


void _M_replace_category(const _Impl *, const id *const *); 


void _M_replace_facet(const _Impl *, const id *); 


void _M_install_facet(const id *, const facet *); 

template < typename _Facet > 
void 
_M_init_facet (_Facet * __facet) 
{ _M_install_facet (& _Facet :: id , __facet) ; } 

template < typename _Facet > 
void 
_M_init_facet_unchecked (_Facet * __facet) 
{ 
__facet -> _M_add_reference () ; 
_M_facets [ _Facet :: id . _M_id () ] = __facet ; 
} 


void _M_install_cache(const facet *, size_t); 

void _M_init_extra(facet **); 
void _M_init_extra(void *, void *, const char *, const char *); 
}; 
# 641 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
template < typename _CharT > 
class __cxx11 :: collate : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 


protected : 


__c_locale _M_c_locale_collate ; 

public : 

static locale :: id id ; 
# 668 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
explicit 
collate (size_t __refs = 0) 
: facet (__refs) , _M_c_locale_collate (_S_get_c_locale ()) 
{ } 
# 682 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
explicit 
collate (__c_locale __cloc , size_t __refs = 0) 
: facet (__refs) , _M_c_locale_collate (_S_clone_c_locale (__cloc)) 
{ } 
# 699 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
int 
compare (const _CharT * __lo1 , const _CharT * __hi1 , 
const _CharT * __lo2 , const _CharT * __hi2) const 
{ return this -> do_compare (__lo1 , __hi1 , __lo2 , __hi2) ; } 
# 718 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
string_type 
transform (const _CharT * __lo , const _CharT * __hi) const 
{ return this -> do_transform (__lo , __hi) ; } 
# 732 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
long 
hash (const _CharT * __lo , const _CharT * __hi) const 
{ return this -> do_hash (__lo , __hi) ; } 


int 
_M_compare (const _CharT * , const _CharT *) const throw () ; 

size_t 
_M_transform (_CharT * , const _CharT * , size_t) const throw () ; 

protected : 

virtual 
~ collate () 
{ _S_destroy_c_locale (_M_c_locale_collate) ; } 
# 761 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
virtual int 
do_compare (const _CharT * __lo1 , const _CharT * __hi1 , 
const _CharT * __lo2 , const _CharT * __hi2) const ; 
# 775 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
virtual string_type 
do_transform (const _CharT * __lo , const _CharT * __hi) const ; 
# 788 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.h" 3
virtual long 
do_hash (const _CharT * __lo , const _CharT * __hi) const ; 
} ;

template < typename _CharT >
    locale :: id collate < _CharT > :: id;




template<> int collate< char> ::_M_compare(const char *, const char *) const throw(); 



template<> size_t collate< char> ::_M_transform(char *, const char *, size_t) const throw(); 




template<> int collate< wchar_t> ::_M_compare(const wchar_t *, const wchar_t *) const throw(); 



template<> size_t collate< wchar_t> ::_M_transform(wchar_t *, const wchar_t *, size_t) const throw(); 



template < typename _CharT > 
class __cxx11 :: collate_byname : public collate < _CharT > 
{ 
public : 


typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 


explicit 
collate_byname (const char * __s , size_t __refs = 0) 
: collate < _CharT > (__refs) 
{ 
if (__builtin_strcmp (__s , "C") != 0 
&& __builtin_strcmp (__s , "POSIX") != 0) 
{ 
this -> _S_destroy_c_locale (this -> _M_c_locale_collate) ; 
this -> _S_create_c_locale (this -> _M_c_locale_collate , __s) ; 
} 
} 


explicit 
collate_byname (const string & __s , size_t __refs = 0) 
: collate_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ collate_byname () { } 
} ;


}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.tcc" 3
namespace std { 



template < typename _Facet > 
locale :: 
locale (const locale & __other , _Facet * __f) 
{ 
_M_impl = new _Impl (* __other . _M_impl , 1) ; 

try 
{ _M_impl -> _M_install_facet (& _Facet :: id , __f) ; } 
catch (...) 
{ 
_M_impl -> _M_remove_reference () ; 
throw ; 
} 
delete [ ] _M_impl -> _M_names [ 0 ] ; 
_M_impl -> _M_names [ 0 ] = 0 ; 
} 

template < typename _Facet > 
locale 
locale :: 
combine (const locale & __other) const 
{ 
_Impl * __tmp = new _Impl (* _M_impl , 1) ; 
try 
{ 
__tmp -> _M_replace_facet (__other . _M_impl , & _Facet :: id) ; 
} 
catch (...) 
{ 
__tmp -> _M_remove_reference () ; 
throw ; 
} 
return locale (__tmp) ; 
} 

template < typename _CharT , typename _Traits , typename _Alloc > 
bool 
locale :: 
operator () (const basic_string < _CharT , _Traits , _Alloc > & __s1 , 
const basic_string < _CharT , _Traits , _Alloc > & __s2) const 
{ 
typedef std :: collate < _CharT > __collate_type ; 
const __collate_type & __collate = use_facet < __collate_type > (* this) ; 
return (__collate . compare (__s1 . data () , __s1 . data () + __s1 . length () , 
__s2 . data () , __s2 . data () + __s2 . length ()) < 0) ; 
} 
# 102 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.tcc" 3
template < typename _Facet > 
bool 
has_facet (const locale & __loc) throw () 
{ 
const size_t __i = _Facet :: id . _M_id () ; 
const locale :: facet * * __facets = __loc . _M_impl -> _M_facets ; 
return (__i < __loc . _M_impl -> _M_facets_size 

&& dynamic_cast < const _Facet * > (__facets [ __i ])) ; 



} 
# 130 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_classes.tcc" 3
template < typename _Facet > 
const _Facet & 
use_facet (const locale & __loc) 
{ 
const size_t __i = _Facet :: id . _M_id () ; 
const locale :: facet * * __facets = __loc . _M_impl -> _M_facets ; 
if (__i >= __loc . _M_impl -> _M_facets_size || ! __facets [ __i ]) 
__throw_bad_cast () ; 

return dynamic_cast < const _Facet & > (* __facets [ __i ]) ; 



} 



template < typename _CharT > 
int 
collate < _CharT > :: _M_compare (const _CharT * , const _CharT *) const throw () 
{ return 0 ; } 


template < typename _CharT > 
size_t 
collate < _CharT > :: _M_transform (_CharT * , const _CharT * , size_t) const throw () 
{ return 0 ; } 

template < typename _CharT > 
int 
collate < _CharT > :: 
do_compare (const _CharT * __lo1 , const _CharT * __hi1 , 
const _CharT * __lo2 , const _CharT * __hi2) const 
{ 


const string_type __one (__lo1 , __hi1) ; 
const string_type __two (__lo2 , __hi2) ; 

const _CharT * __p = __one . c_str () ; 
const _CharT * __pend = __one . data () + __one . length () ; 
const _CharT * __q = __two . c_str () ; 
const _CharT * __qend = __two . data () + __two . length () ; 




for (; ;) 
{ 
const int __res = _M_compare (__p , __q) ; 
if (__res) 
return __res ; 

__p += char_traits < _CharT > :: length (__p) ; 
__q += char_traits < _CharT > :: length (__q) ; 
if (__p == __pend && __q == __qend) 
return 0 ; 
else if (__p == __pend) 
return - 1 ; 
else if (__q == __qend) 
return 1 ; 

__p ++ ; 
__q ++ ; 
} 
} 

template < typename _CharT > 
typename collate < _CharT > :: string_type 
collate < _CharT > :: 
do_transform (const _CharT * __lo , const _CharT * __hi) const 
{ 
string_type __ret ; 


const string_type __str (__lo , __hi) ; 

const _CharT * __p = __str . c_str () ; 
const _CharT * __pend = __str . data () + __str . length () ; 

size_t __len = (__hi - __lo) * 2 ; 

_CharT * __c = new _CharT [ __len ] ; 

try 
{ 



for (; ;) 
{ 

size_t __res = _M_transform (__c , __p , __len) ; 


if (__res >= __len) 
{ 
__len = __res + 1 ; 
delete [ ] __c , __c = 0 ; 
__c = new _CharT [ __len ] ; 
__res = _M_transform (__c , __p , __len) ; 
} 

__ret . append (__c , __res) ; 
__p += char_traits < _CharT > :: length (__p) ; 
if (__p == __pend) 
break ; 

__p ++ ; 
__ret . push_back (_CharT ()) ; 
} 
} 
catch (...) 
{ 
delete [ ] __c ; 
throw ; 
} 

delete [ ] __c ; 

return __ret ; 
} 

template < typename _CharT > 
long 
collate < _CharT > :: 
do_hash (const _CharT * __lo , const _CharT * __hi) const 
{ 
unsigned long __val = 0 ; 
for (; __lo < __hi ; ++ __lo) 
__val = 
* __lo + ((__val << 7) 
| (__val >> (__gnu_cxx :: __numeric_traits < unsigned long > :: 
__digits - 7))) ; 
return static_cast < long > (__val) ; 
} 




extern template class __cxx11::collate< char> ;
extern template class __cxx11::collate_byname< char> ;

extern template const __cxx11::collate< char>  &use_facet< __cxx11::collate< char> > (const locale &);



extern template bool has_facet< __cxx11::collate< char> > (const locale &) throw();




extern template class __cxx11::collate< wchar_t> ;
extern template class __cxx11::collate_byname< wchar_t> ;

extern template const __cxx11::collate< wchar_t>  &use_facet< __cxx11::collate< wchar_t> > (const locale &);



extern template bool has_facet< __cxx11::collate< wchar_t> > (const locale &) throw();
# 296
}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\error_constants.h" 3
namespace std { 
# 49
enum class errc { 
# 55
argument_list_too_long = 7, 
argument_out_of_domain = 33, 
bad_address = 14, 
bad_file_descriptor = 9, 

broken_pipe = 32, 
# 67
device_or_resource_busy = 16, 
directory_not_empty = 41, 
executable_format_error = 8, 
file_exists = 17, 
file_too_large = 27, 
filename_too_long = 38, 
function_not_supported = 40, 


illegal_byte_sequence = 42, 
inappropriate_io_control_operation = 25, 
interrupted = 4, 
invalid_argument = 22, 
invalid_seek = 29, 
io_error = 5, 
is_a_directory = 21, 
# 89
no_child_process = 10, 


no_lock_available = 39, 




no_space_on_device = 28, 


no_such_device_or_address = 6, 
no_such_device = 19, 
no_such_file_or_directory = 2, 
no_such_process, 
not_a_directory = 20, 



not_enough_memory = 12, 



not_supported = 40, 




operation_not_permitted = 1, 
# 124
permission_denied = 13, 


read_only_file_system = 30, 
resource_deadlock_would_occur = 36, 
resource_unavailable_try_again = 11, 
result_out_of_range = 34, 
# 137
too_many_files_open_in_system = 23, 
too_many_files_open, 
too_many_links = 31, 
too_many_symbolic_link_levels = 2000, 


value_too_large


}; 


}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\stdexcept" 3
namespace std { 
# 48
struct __cow_string { 

union { 
const char *_M_p; 
char _M_bytes[sizeof(const char *)]; 
}; 

__cow_string(); 
__cow_string(const string &); 
__cow_string(const char *, size_t); 
__cow_string(const __cow_string &) noexcept; 
__cow_string &operator=(const __cow_string &) noexcept; 
~__cow_string(); 

__cow_string(__cow_string &&) noexcept; 
__cow_string &operator=(__cow_string &&) noexcept; 

}; 

typedef __cxx11::basic_string< char>  __sso_string; 
# 113 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\stdexcept" 3
class logic_error : public exception { 

__cow_string _M_msg; 




public: explicit logic_error(const string & __arg); 



explicit logic_error(const char *); 

logic_error(logic_error &&) noexcept; 
logic_error &operator=(logic_error &&) noexcept; 



logic_error(const logic_error &) noexcept; 
logic_error &operator=(const logic_error &) noexcept; 
# 138
virtual ~logic_error() noexcept; 




virtual const char *what() const noexcept; 
# 149
}; 



class domain_error : public logic_error { 


public: explicit domain_error(const string & __arg); 

explicit domain_error(const char *); 
domain_error(const domain_error &) = default;
domain_error &operator=(const domain_error &) = default;
domain_error(domain_error &&) = default;
domain_error &operator=(domain_error &&) = default;

virtual ~domain_error() noexcept; 
}; 


class invalid_argument : public logic_error { 


public: explicit invalid_argument(const string & __arg); 

explicit invalid_argument(const char *); 
invalid_argument(const invalid_argument &) = default;
invalid_argument &operator=(const invalid_argument &) = default;
invalid_argument(invalid_argument &&) = default;
invalid_argument &operator=(invalid_argument &&) = default;

virtual ~invalid_argument() noexcept; 
}; 



class length_error : public logic_error { 


public: explicit length_error(const string & __arg); 

explicit length_error(const char *); 
length_error(const length_error &) = default;
length_error &operator=(const length_error &) = default;
length_error(length_error &&) = default;
length_error &operator=(length_error &&) = default;

virtual ~length_error() noexcept; 
}; 



class out_of_range : public logic_error { 


public: explicit out_of_range(const string & __arg); 

explicit out_of_range(const char *); 
out_of_range(const out_of_range &) = default;
out_of_range &operator=(const out_of_range &) = default;
out_of_range(out_of_range &&) = default;
out_of_range &operator=(out_of_range &&) = default;

virtual ~out_of_range() noexcept; 
}; 
# 219
class runtime_error : public exception { 

__cow_string _M_msg; 




public: explicit runtime_error(const string & __arg); 



explicit runtime_error(const char *); 

runtime_error(runtime_error &&) noexcept; 
runtime_error &operator=(runtime_error &&) noexcept; 



runtime_error(const runtime_error &) noexcept; 
runtime_error &operator=(const runtime_error &) noexcept; 
# 244
virtual ~runtime_error() noexcept; 




virtual const char *what() const noexcept; 
# 255
}; 


class range_error : public runtime_error { 


public: explicit range_error(const string & __arg); 

explicit range_error(const char *); 
range_error(const range_error &) = default;
range_error &operator=(const range_error &) = default;
range_error(range_error &&) = default;
range_error &operator=(range_error &&) = default;

virtual ~range_error() noexcept; 
}; 


class overflow_error : public runtime_error { 


public: explicit overflow_error(const string & __arg); 

explicit overflow_error(const char *); 
overflow_error(const overflow_error &) = default;
overflow_error &operator=(const overflow_error &) = default;
overflow_error(overflow_error &&) = default;
overflow_error &operator=(overflow_error &&) = default;

virtual ~overflow_error() noexcept; 
}; 


class underflow_error : public runtime_error { 


public: explicit underflow_error(const string & __arg); 

explicit underflow_error(const char *); 
underflow_error(const underflow_error &) = default;
underflow_error &operator=(const underflow_error &) = default;
underflow_error(underflow_error &&) = default;
underflow_error &operator=(underflow_error &&) = default;

virtual ~underflow_error() noexcept; 
}; 




}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\system_error" 3
namespace std { 



class error_code; 
class error_condition; 
class system_error; 


template < typename _Tp > 
struct is_error_code_enum : public false_type { } ;


template < typename _Tp > 
struct is_error_condition_enum : public false_type { } ;


template<> struct is_error_condition_enum< errc>  : public true_type { 
}; 
# 71 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\system_error" 3
inline namespace _V2 { 


class error_category { 


public: constexpr error_category() noexcept = default;

virtual ~error_category(); 

error_category(const error_category &) = delete;
error_category &operator=(const error_category &) = delete;


virtual const char *name() const noexcept = 0; 
# 95
private: __attribute((__abi_tag__("cxx11"))) virtual __cow_string _M_message(int) const; 




public: __attribute((__abi_tag__("cxx11"))) virtual string message(int) const = 0; 
# 112 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\system_error" 3
virtual error_condition default_error_condition(int __i) const noexcept; 


virtual bool equivalent(int __i, const error_condition & __cond) const noexcept; 


virtual bool equivalent(const error_code & __code, int __i) const noexcept; 


bool operator<(const error_category &__other) const noexcept 
{ return less< const error_category *> ()(this, &__other); } 


bool operator==(const error_category &__other) const noexcept 
{ return this == &__other; } 


bool operator!=(const error_category &__other) const noexcept 
{ return this != &__other; } 
}; 


__attribute((const)) const error_category &system_category() noexcept; 
__attribute((const)) const error_category &generic_category() noexcept; 

}

inline error_code make_error_code(errc) noexcept; 

template < typename _Tp >
    struct hash;



struct error_code { 

error_code() noexcept : _M_value(0), _M_cat(&system_category()) 
{ } 

error_code(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
{ } 

template < typename _ErrorCodeEnum , typename = typename 
enable_if < is_error_code_enum < _ErrorCodeEnum > :: value > :: type > 
error_code (_ErrorCodeEnum __e) noexcept 
{ * this = make_error_code (__e) ; } 


void assign(int __v, const _V2::error_category &__cat) noexcept 
{ 
_M_value = __v; 
_M_cat = &__cat; 
} 


void clear() noexcept 
{ this->assign(0, system_category()); } 


template < typename _ErrorCodeEnum > 
typename enable_if < is_error_code_enum < _ErrorCodeEnum > :: value , 
error_code & > :: type 
operator = (_ErrorCodeEnum __e) noexcept 
{ return * this = make_error_code (__e) ; } 


int value() const noexcept { return _M_value; } 


const _V2::error_category &category() const noexcept { return *(_M_cat); } 


error_condition default_error_condition() const noexcept; 



__attribute((__abi_tag__("cxx11"))) string message() const 
{ return this->category().message(this->value()); } 

explicit operator bool() const noexcept 
{ return _M_value != 0; } 



friend struct hash< error_code> ; 

private: int _M_value; 
const _V2::error_category *_M_cat; 
}; 



inline error_code make_error_code(errc __e) noexcept 
{ return error_code(static_cast< int>(__e), generic_category()); } 


inline bool operator<(const error_code &__lhs, const error_code &__rhs) noexcept 
{ 
return ((__lhs.category() < __rhs.category()) || ((__lhs.category() == __rhs.category()) && __lhs.value() < __rhs.value())); 


} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , const error_code & __e) 
{ return (__os << __e . category () . name () << ':' << __e . value ()) ; } 

inline error_condition make_error_condition(errc) noexcept; 



struct error_condition { 

error_condition() noexcept : _M_value(0), _M_cat(&generic_category()) 
{ } 

error_condition(int __v, const _V2::error_category &__cat) noexcept : _M_value(__v), _M_cat(&__cat) 
{ } 

template < typename _ErrorConditionEnum , typename = typename 
enable_if < is_error_condition_enum < _ErrorConditionEnum > :: value > :: type > 
error_condition (_ErrorConditionEnum __e) noexcept 
{ * this = make_error_condition (__e) ; } 


void assign(int __v, const _V2::error_category &__cat) noexcept 
{ 
_M_value = __v; 
_M_cat = &__cat; 
} 


template < typename _ErrorConditionEnum > 
typename enable_if < is_error_condition_enum 
< _ErrorConditionEnum > :: value , error_condition & > :: type 
operator = (_ErrorConditionEnum __e) noexcept 
{ return * this = make_error_condition (__e) ; } 


void clear() noexcept 
{ this->assign(0, generic_category()); } 



int value() const noexcept { return _M_value; } 


const _V2::error_category &category() const noexcept { return *(_M_cat); } 



__attribute((__abi_tag__("cxx11"))) string message() const 
{ return this->category().message(this->value()); } 

explicit operator bool() const noexcept 
{ return _M_value != 0; } 



private: int _M_value; 
const _V2::error_category *_M_cat; 
}; 



inline error_condition make_error_condition(errc __e) noexcept 
{ return error_condition(static_cast< int>(__e), generic_category()); } 


inline bool operator<(const error_condition &__lhs, const error_condition &
__rhs) noexcept 
{ 
return ((__lhs.category() < __rhs.category()) || ((__lhs.category() == __rhs.category()) && __lhs.value() < __rhs.value())); 


} 



inline bool operator==(const error_code &__lhs, const error_code &__rhs) noexcept 
{ return ((__lhs.category() == __rhs.category()) && __lhs.value() == __rhs.value()); 
} 


inline bool operator==(const error_code &__lhs, const error_condition &__rhs) noexcept 
{ 
return (__lhs.category().equivalent(__lhs.value(), __rhs) || __rhs.category().equivalent(__lhs, __rhs.value())); 

} 


inline bool operator==(const error_condition &__lhs, const error_code &__rhs) noexcept 
{ 
return (__rhs.category().equivalent(__rhs.value(), __lhs) || __lhs.category().equivalent(__rhs, __lhs.value())); 

} 


inline bool operator==(const error_condition &__lhs, const error_condition &
__rhs) noexcept 
{ 
return ((__lhs.category() == __rhs.category()) && __lhs.value() == __rhs.value()); 

} 


inline bool operator!=(const error_code &__lhs, const error_code &__rhs) noexcept 
{ return !((__lhs == __rhs)); } 


inline bool operator!=(const error_code &__lhs, const error_condition &__rhs) noexcept 
{ return !((__lhs == __rhs)); } 


inline bool operator!=(const error_condition &__lhs, const error_code &__rhs) noexcept 
{ return !((__lhs == __rhs)); } 


inline bool operator!=(const error_condition &__lhs, const error_condition &
__rhs) noexcept 
{ return !((__lhs == __rhs)); } 
# 341
class system_error : public runtime_error { 


error_code _M_code; 


public: system_error(error_code __ec = error_code()) : runtime_error(__ec.message()), _M_code(__ec) 
{ } 

system_error(error_code __ec, const string &__what) : runtime_error(((__what + (": ")) + __ec.message())), _M_code(__ec) 
{ } 

system_error(error_code __ec, const char *__what) : runtime_error((__what + (((": ") + __ec.message())))), _M_code(__ec) 
{ } 

system_error(int __v, const _V2::error_category &__ecat, const char *__what) : system_error(error_code(__v, __ecat), __what) 
{ } 

system_error(int __v, const _V2::error_category &__ecat) : runtime_error(error_code(__v, __ecat).message()), _M_code(__v, __ecat) 

{ } 

system_error(int __v, const _V2::error_category &__ecat, const string &__what) : runtime_error(((__what + (": ")) + error_code(__v, __ecat).message())), _M_code(__v, __ecat) 

{ } 


system_error(const system_error &) = default;
system_error &operator=(const system_error &) = default;


virtual ~system_error() noexcept; 


const error_code &code() const noexcept { return _M_code; } 
}; 


}



namespace std { 
# 391
template<> struct hash< error_code>  : public __hash_base< unsigned, error_code>  { 



size_t operator()(const error_code &__e) const noexcept 
{ 
const size_t __tmp = std::_Hash_impl::hash(__e._M_value); 
return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp); 
} 
}; 
# 420 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\system_error" 3
}
# 49 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
namespace std { 
# 57
enum _Ios_Fmtflags { 

_S_boolalpha = (1L << 0), 
_S_dec, 
_S_fixed = (1L << 2), 
_S_hex = (1L << 3), 
_S_internal = (1L << 4), 
_S_left = (1L << 5), 
_S_oct = (1L << 6), 
_S_right = (1L << 7), 
_S_scientific = (1L << 8), 
_S_showbase = (1L << 9), 
_S_showpoint = (1L << 10), 
_S_showpos = (1L << 11), 
_S_skipws = (1L << 12), 
_S_unitbuf = (1L << 13), 
_S_uppercase = (1L << 14), 
_S_adjustfield = ((_S_left | _S_right) | _S_internal), 
_S_basefield = ((_S_dec | _S_oct) | _S_hex), 
_S_floatfield = (_S_scientific | _S_fixed), 
_S_ios_fmtflags_end = (1L << 16), 
_S_ios_fmtflags_max = 0x7fffffff, 
_S_ios_fmtflags_min = (~0x7fffffff)
}; 


constexpr _Ios_Fmtflags operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
{ return (_Ios_Fmtflags)(static_cast< int>(__a) & static_cast< int>(__b)); } 


constexpr _Ios_Fmtflags operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
{ return (_Ios_Fmtflags)(static_cast< int>(__a) | static_cast< int>(__b)); } 


constexpr _Ios_Fmtflags operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b) 
{ return (_Ios_Fmtflags)(static_cast< int>(__a) ^ static_cast< int>(__b)); } 


constexpr _Ios_Fmtflags operator~(_Ios_Fmtflags __a) 
{ return (_Ios_Fmtflags)(~(static_cast< int>(__a))); } 


inline const _Ios_Fmtflags &operator|=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
{ return __a = (__a | __b); } 


inline const _Ios_Fmtflags &operator&=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
{ return __a = (__a & __b); } 


inline const _Ios_Fmtflags &operator^=(_Ios_Fmtflags &__a, _Ios_Fmtflags __b) 
{ return __a = (__a ^ __b); } 


enum _Ios_Openmode { 

_S_app = (1L << 0), 
_S_ate, 
_S_bin = (1L << 2), 
_S_in = (1L << 3), 
_S_out = (1L << 4), 
_S_trunc = (1L << 5), 
_S_ios_openmode_end = (1L << 16), 
_S_ios_openmode_max = 0x7fffffff, 
_S_ios_openmode_min = (~0x7fffffff)
}; 


constexpr _Ios_Openmode operator&(_Ios_Openmode __a, _Ios_Openmode __b) 
{ return (_Ios_Openmode)(static_cast< int>(__a) & static_cast< int>(__b)); } 


constexpr _Ios_Openmode operator|(_Ios_Openmode __a, _Ios_Openmode __b) 
{ return (_Ios_Openmode)(static_cast< int>(__a) | static_cast< int>(__b)); } 


constexpr _Ios_Openmode operator^(_Ios_Openmode __a, _Ios_Openmode __b) 
{ return (_Ios_Openmode)(static_cast< int>(__a) ^ static_cast< int>(__b)); } 


constexpr _Ios_Openmode operator~(_Ios_Openmode __a) 
{ return (_Ios_Openmode)(~(static_cast< int>(__a))); } 


inline const _Ios_Openmode &operator|=(_Ios_Openmode &__a, _Ios_Openmode __b) 
{ return __a = (__a | __b); } 


inline const _Ios_Openmode &operator&=(_Ios_Openmode &__a, _Ios_Openmode __b) 
{ return __a = (__a & __b); } 


inline const _Ios_Openmode &operator^=(_Ios_Openmode &__a, _Ios_Openmode __b) 
{ return __a = (__a ^ __b); } 


enum _Ios_Iostate { 

_S_goodbit, 
_S_badbit, 
_S_eofbit, 
_S_failbit = (1L << 2), 
_S_ios_iostate_end = (1L << 16), 
_S_ios_iostate_max = 0x7fffffff, 
_S_ios_iostate_min = (~0x7fffffff)
}; 


constexpr _Ios_Iostate operator&(_Ios_Iostate __a, _Ios_Iostate __b) 
{ return (_Ios_Iostate)(static_cast< int>(__a) & static_cast< int>(__b)); } 


constexpr _Ios_Iostate operator|(_Ios_Iostate __a, _Ios_Iostate __b) 
{ return (_Ios_Iostate)(static_cast< int>(__a) | static_cast< int>(__b)); } 


constexpr _Ios_Iostate operator^(_Ios_Iostate __a, _Ios_Iostate __b) 
{ return (_Ios_Iostate)(static_cast< int>(__a) ^ static_cast< int>(__b)); } 


constexpr _Ios_Iostate operator~(_Ios_Iostate __a) 
{ return (_Ios_Iostate)(~(static_cast< int>(__a))); } 


inline const _Ios_Iostate &operator|=(_Ios_Iostate &__a, _Ios_Iostate __b) 
{ return __a = (__a | __b); } 


inline const _Ios_Iostate &operator&=(_Ios_Iostate &__a, _Ios_Iostate __b) 
{ return __a = (__a & __b); } 


inline const _Ios_Iostate &operator^=(_Ios_Iostate &__a, _Ios_Iostate __b) 
{ return __a = (__a ^ __b); } 


enum _Ios_Seekdir { 

_S_beg, 
_S_cur, 
_S_end, 
_S_ios_seekdir_end = (1L << 16)
}; 



enum class io_errc { stream = 1}; 

template<> struct is_error_code_enum< io_errc>  : public true_type { }; 

const _V2::error_category &iostream_category() noexcept; 


inline error_code make_error_code(io_errc __e) noexcept 
{ return error_code(static_cast< int>(__e), iostream_category()); } 


inline error_condition make_error_condition(io_errc __e) noexcept 
{ return error_condition(static_cast< int>(__e), iostream_category()); } 
# 228 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
class ios_base { 
# 255 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
public: class __attribute((__abi_tag__("cxx11"))) failure : public system_error { 



public: explicit failure(const string & __str); 



explicit failure(const string &, const error_code &); 


explicit failure(const char *, const error_code & = io_errc::stream); 



virtual ~failure() throw(); 


virtual const char *what() const throw(); 
}; 
# 323 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
typedef _Ios_Fmtflags fmtflags; 


static const fmtflags boolalpha = _S_boolalpha; 


static const fmtflags dec = _S_dec; 


static const fmtflags fixed = _S_fixed; 


static const fmtflags hex = _S_hex; 




static const fmtflags internal = _S_internal; 



static const fmtflags left = _S_left; 


static const fmtflags oct = _S_oct; 



static const fmtflags right = _S_right; 


static const fmtflags scientific = _S_scientific; 



static const fmtflags showbase = _S_showbase; 



static const fmtflags showpoint = _S_showpoint; 


static const fmtflags showpos = _S_showpos; 


static const fmtflags skipws = _S_skipws; 


static const fmtflags unitbuf = _S_unitbuf; 



static const fmtflags uppercase = _S_uppercase; 


static const fmtflags adjustfield = _S_adjustfield; 


static const fmtflags basefield = _S_basefield; 


static const fmtflags floatfield = _S_floatfield; 
# 398 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
typedef _Ios_Iostate iostate; 



static const iostate badbit = _S_badbit; 


static const iostate eofbit = _S_eofbit; 




static const iostate failbit = _S_failbit; 


static const iostate goodbit = _S_goodbit; 
# 429 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
typedef _Ios_Openmode openmode; 


static const openmode app = _S_app; 


static const openmode ate = _S_ate; 




static const openmode binary = _S_bin; 


static const openmode in = _S_in; 


static const openmode out = _S_out; 


static const openmode trunc = _S_trunc; 
# 461 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
typedef _Ios_Seekdir seekdir; 


static const seekdir beg = _S_beg; 


static const seekdir cur = _S_cur; 


static const seekdir end = _S_end; 



typedef int io_state; 
typedef int open_mode; 
typedef int seek_dir; 

typedef std::streampos streampos; 
typedef std::streamoff streamoff; 
# 489 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
enum event { 

erase_event, 
imbue_event, 
copyfmt_event
}; 
# 506 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
typedef void (*event_callback)(event __e, ios_base & __b, int __i); 
# 519 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
void register_callback(event_callback __fn, int __index); 


protected: streamsize _M_precision; 
streamsize _M_width; 
fmtflags _M_flags; 
iostate _M_exception; 
iostate _M_streambuf_state; 



struct _Callback_list { 


_Callback_list *_M_next; 
event_callback _M_fn; 
int _M_index; 
_Atomic_word _M_refcount; 

_Callback_list(event_callback __fn, int __index, _Callback_list *
__cb) : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) 
{ } 


void _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&(_M_refcount), 1); } 



int _M_remove_reference() 
{ 

; 
int __res = __gnu_cxx::__exchange_and_add_dispatch(&(_M_refcount), -1); 
if (__res == 0) 
{ 
; 
}  
return __res; 
} 
}; 

_Callback_list *_M_callbacks; 


void _M_call_callbacks(event __ev) throw(); 


void _M_dispose_callbacks() throw(); 


struct _Words { 

void *_M_pword; 
long _M_iword; 
_Words() : _M_pword((0)), _M_iword((0)) { } 
}; 


_Words _M_word_zero; 



enum { _S_local_word_size = 8}; 
_Words _M_local_word[_S_local_word_size]; 


int _M_word_size; 
_Words *_M_word; 


_Words &_M_grow_words(int __index, bool __iword); 


locale _M_ios_locale; 


void _M_init() throw(); 
# 603
public: class Init { 

friend class ios_base; 

public: Init(); 
~Init(); 


Init(const Init &) = default;
Init &operator=(const Init &) = default;



private: static _Atomic_word _S_refcount; 
static bool _S_synced_with_stdio; 
}; 
# 626
fmtflags flags() const 
{ return _M_flags; } 
# 637 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
fmtflags flags(fmtflags __fmtfl) 
{ 
fmtflags __old = _M_flags; 
_M_flags = __fmtfl; 
return __old; 
} 
# 653 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
fmtflags setf(fmtflags __fmtfl) 
{ 
fmtflags __old = _M_flags; 
(_M_flags |= __fmtfl); 
return __old; 
} 
# 670 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
fmtflags setf(fmtflags __fmtfl, fmtflags __mask) 
{ 
fmtflags __old = _M_flags; 
(_M_flags &= (~__mask)); 
(_M_flags |= ((__fmtfl & __mask))); 
return __old; 
} 
# 685
void unsetf(fmtflags __mask) 
{ (_M_flags &= (~__mask)); } 
# 696 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
streamsize precision() const 
{ return _M_precision; } 
# 705
streamsize precision(streamsize __prec) 
{ 
streamsize __old = _M_precision; 
_M_precision = __prec; 
return __old; 
} 
# 719
streamsize width() const 
{ return _M_width; } 
# 728
streamsize width(streamsize __wide) 
{ 
streamsize __old = _M_width; 
_M_width = __wide; 
return __old; 
} 
# 747 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
static bool sync_with_stdio(bool __sync = true); 
# 759 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
locale imbue(const locale & __loc) throw(); 
# 770 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
locale getloc() const 
{ return _M_ios_locale; } 
# 781 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
const locale &_M_getloc() const 
{ return _M_ios_locale; } 
# 800 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
static int xalloc() throw(); 
# 816 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
long &iword(int __ix) 
{ 
_Words &__word = ((unsigned)__ix < (unsigned)(_M_word_size)) ? _M_word[__ix] : this->_M_grow_words(__ix, true); 

return __word._M_iword; 
} 
# 837 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
void *&pword(int __ix) 
{ 
_Words &__word = ((unsigned)__ix < (unsigned)(_M_word_size)) ? _M_word[__ix] : this->_M_grow_words(__ix, false); 

return __word._M_pword; 
} 
# 853 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
virtual ~ios_base(); 


protected: ios_base() throw(); 
# 868 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ios_base.h" 3
public: ios_base(const ios_base &) = delete;


ios_base &operator=(const ios_base &) = delete;



protected: void _M_move(ios_base &) noexcept; 


void _M_swap(ios_base & __rhs) noexcept; 

}; 




inline ios_base &boolalpha(ios_base &__base) 
{ 
__base.setf(ios_base::boolalpha); 
return __base; 
} 



inline ios_base &noboolalpha(ios_base &__base) 
{ 
__base.unsetf(ios_base::boolalpha); 
return __base; 
} 



inline ios_base &showbase(ios_base &__base) 
{ 
__base.setf(ios_base::showbase); 
return __base; 
} 



inline ios_base &noshowbase(ios_base &__base) 
{ 
__base.unsetf(ios_base::showbase); 
return __base; 
} 



inline ios_base &showpoint(ios_base &__base) 
{ 
__base.setf(ios_base::showpoint); 
return __base; 
} 



inline ios_base &noshowpoint(ios_base &__base) 
{ 
__base.unsetf(ios_base::showpoint); 
return __base; 
} 



inline ios_base &showpos(ios_base &__base) 
{ 
__base.setf(ios_base::showpos); 
return __base; 
} 



inline ios_base &noshowpos(ios_base &__base) 
{ 
__base.unsetf(ios_base::showpos); 
return __base; 
} 



inline ios_base &skipws(ios_base &__base) 
{ 
__base.setf(ios_base::skipws); 
return __base; 
} 



inline ios_base &noskipws(ios_base &__base) 
{ 
__base.unsetf(ios_base::skipws); 
return __base; 
} 



inline ios_base &uppercase(ios_base &__base) 
{ 
__base.setf(ios_base::uppercase); 
return __base; 
} 



inline ios_base &nouppercase(ios_base &__base) 
{ 
__base.unsetf(ios_base::uppercase); 
return __base; 
} 



inline ios_base &unitbuf(ios_base &__base) 
{ 
__base.setf(ios_base::unitbuf); 
return __base; 
} 



inline ios_base &nounitbuf(ios_base &__base) 
{ 
__base.unsetf(ios_base::unitbuf); 
return __base; 
} 




inline ios_base &internal(ios_base &__base) 
{ 
__base.setf(ios_base::internal, ios_base::adjustfield); 
return __base; 
} 



inline ios_base &left(ios_base &__base) 
{ 
__base.setf(ios_base::left, ios_base::adjustfield); 
return __base; 
} 



inline ios_base &right(ios_base &__base) 
{ 
__base.setf(ios_base::right, ios_base::adjustfield); 
return __base; 
} 




inline ios_base &dec(ios_base &__base) 
{ 
__base.setf(ios_base::dec, ios_base::basefield); 
return __base; 
} 



inline ios_base &hex(ios_base &__base) 
{ 
__base.setf(ios_base::hex, ios_base::basefield); 
return __base; 
} 



inline ios_base &oct(ios_base &__base) 
{ 
__base.setf(ios_base::oct, ios_base::basefield); 
return __base; 
} 




inline ios_base &fixed(ios_base &__base) 
{ 
__base.setf(ios_base::fixed, ios_base::floatfield); 
return __base; 
} 



inline ios_base &scientific(ios_base &__base) 
{ 
__base.setf(ios_base::scientific, ios_base::floatfield); 
return __base; 
} 
# 1068
inline ios_base &hexfloat(ios_base &__base) 
{ 
__base.setf((ios_base::fixed | ios_base::scientific), ios_base::floatfield); 
return __base; 
} 



inline ios_base &defaultfloat(ios_base &__base) 
{ 
__base.unsetf(ios_base::floatfield); 
return __base; 
} 



}
# 45 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
namespace std { 
# 51
template < typename _CharT, typename _Traits >
    streamsize
    __copy_streambufs_eof ( basic_streambuf < _CharT, _Traits > *,
     basic_streambuf < _CharT, _Traits > *, bool & );
# 121 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
template < typename _CharT , typename _Traits > 
class basic_streambuf 
{ 
public : 
# 131
typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 




typedef basic_streambuf < char_type , traits_type > __streambuf_type ; 


friend class basic_ios < char_type , traits_type > ; 
friend class basic_istream < char_type , traits_type > ; 
friend class basic_ostream < char_type , traits_type > ; 
friend class istreambuf_iterator < char_type , traits_type > ; 
friend class ostreambuf_iterator < char_type , traits_type > ; 

friend streamsize 
__copy_streambufs_eof < > (basic_streambuf * , basic_streambuf * , bool &) ; 

template < bool _IsMove , typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
_CharT2 * > :: __type 
__copy_move_a2 (istreambuf_iterator < _CharT2 > , 
istreambuf_iterator < _CharT2 > , _CharT2 *) ; 

template < typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
istreambuf_iterator < _CharT2 > > :: __type 
find (istreambuf_iterator < _CharT2 > , istreambuf_iterator < _CharT2 > , 
const _CharT2 &) ; 

template < typename _CharT2 , typename _Distance > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
void > :: __type 
advance (istreambuf_iterator < _CharT2 > & , _Distance) ; 

template < typename _CharT2 , typename _Traits2 > 
friend basic_istream < _CharT2 , _Traits2 > & 
operator >> (basic_istream < _CharT2 , _Traits2 > & , _CharT2 *) ; 

template < typename _CharT2 , typename _Traits2 , typename _Alloc > 
friend basic_istream < _CharT2 , _Traits2 > & 
operator >> (basic_istream < _CharT2 , _Traits2 > & , 
basic_string < _CharT2 , _Traits2 , _Alloc > &) ; 

template < typename _CharT2 , typename _Traits2 , typename _Alloc > 
friend basic_istream < _CharT2 , _Traits2 > & 
getline (basic_istream < _CharT2 , _Traits2 > & , 
basic_string < _CharT2 , _Traits2 , _Alloc > & , _CharT2) ; 

protected : 
# 191
char_type * _M_in_beg ; 
char_type * _M_in_cur ; 
char_type * _M_in_end ; 
char_type * _M_out_beg ; 
char_type * _M_out_cur ; 
char_type * _M_out_end ; 


locale _M_buf_locale ; 

public : 

virtual 
~ basic_streambuf () 
{ } 
# 215 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
locale 
pubimbue (const locale & __loc) 
{ 
locale __tmp (this -> getloc ()) ; 
this -> imbue (__loc) ; 
_M_buf_locale = __loc ; 
return __tmp ; 
} 
# 232 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
locale 
getloc () const 
{ return _M_buf_locale ; } 
# 245 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
basic_streambuf * 
pubsetbuf (char_type * __s , streamsize __n) 
{ return this -> setbuf (__s , __n) ; } 
# 257 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
pos_type 
pubseekoff (off_type __off , ios_base :: seekdir __way , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
{ return this -> seekoff (__off , __way , __mode) ; } 
# 269 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
pos_type 
pubseekpos (pos_type __sp , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
{ return this -> seekpos (__sp , __mode) ; } 




int 
pubsync () { return this -> sync () ; } 
# 290 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
streamsize 
in_avail () 
{ 
const streamsize __ret = this -> egptr () - this -> gptr () ; 
return __ret ? __ret : this -> showmanyc () ; 
} 
# 304 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
snextc () 
{ 
int_type __ret = traits_type :: eof () ; 
if (__builtin_expect (! traits_type :: eq_int_type (this -> sbumpc () , 
__ret) , true)) 
__ret = this -> sgetc () ; 
return __ret ; 
} 
# 322 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
sbumpc () 
{ 
int_type __ret ; 
if (__builtin_expect (this -> gptr () < this -> egptr () , true)) 
{ 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
this -> gbump (1) ; 
} 
else 
__ret = this -> uflow () ; 
return __ret ; 
} 
# 344 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
sgetc () 
{ 
int_type __ret ; 
if (__builtin_expect (this -> gptr () < this -> egptr () , true)) 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
else 
__ret = this -> underflow () ; 
return __ret ; 
} 
# 363 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
streamsize 
sgetn (char_type * __s , streamsize __n) 
{ return this -> xsgetn (__s , __n) ; } 
# 378 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
sputbackc (char_type __c) 
{ 
int_type __ret ; 
const bool __testpos = this -> eback () < this -> gptr () ; 
if (__builtin_expect (! __testpos || 
! traits_type :: eq (__c , this -> gptr () [ - 1 ]) , false)) 
__ret = this -> pbackfail (traits_type :: to_int_type (__c)) ; 
else 
{ 
this -> gbump (- 1) ; 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
} 
return __ret ; 
} 
# 403 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
sungetc () 
{ 
int_type __ret ; 
if (__builtin_expect (this -> eback () < this -> gptr () , true)) 
{ 
this -> gbump (- 1) ; 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
} 
else 
__ret = this -> pbackfail () ; 
return __ret ; 
} 
# 430 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
int_type 
sputc (char_type __c) 
{ 
int_type __ret ; 
if (__builtin_expect (this -> pptr () < this -> epptr () , true)) 
{ 
* this -> pptr () = __c ; 
this -> pbump (1) ; 
__ret = traits_type :: to_int_type (__c) ; 
} 
else 
__ret = this -> overflow (traits_type :: to_int_type (__c)) ; 
return __ret ; 
} 
# 456 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
streamsize 
sputn (const char_type * __s , streamsize __n) 
{ return this -> xsputn (__s , __n) ; } 

protected : 
# 470 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
basic_streambuf () 
: _M_in_beg (0) , _M_in_cur (0) , _M_in_end (0) , 
_M_out_beg (0) , _M_out_cur (0) , _M_out_end (0) , 
_M_buf_locale (locale ()) 
{ } 
# 488 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
char_type * 
eback () const { return _M_in_beg ; } 

char_type * 
gptr () const { return _M_in_cur ; } 

char_type * 
egptr () const { return _M_in_end ; } 
# 504 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
void 
gbump (int __n) { _M_in_cur += __n ; } 
# 515 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
void 
setg (char_type * __gbeg , char_type * __gnext , char_type * __gend) 
{ 
_M_in_beg = __gbeg ; 
_M_in_cur = __gnext ; 
_M_in_end = __gend ; 
} 
# 535 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
char_type * 
pbase () const { return _M_out_beg ; } 

char_type * 
pptr () const { return _M_out_cur ; } 

char_type * 
epptr () const { return _M_out_end ; } 
# 551 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
void 
pbump (int __n) { _M_out_cur += __n ; } 
# 561 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
void 
setp (char_type * __pbeg , char_type * __pend) 
{ 
_M_out_beg = _M_out_cur = __pbeg ; 
_M_out_end = __pend ; 
} 
# 582 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual void 
imbue (const locale & __loc __attribute__ ((__unused__))) 
{ } 
# 597 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual basic_streambuf < char_type , _Traits > * 
setbuf (char_type * , streamsize) 
{ return this ; } 
# 608 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual pos_type 
seekoff (off_type , ios_base :: seekdir , 
ios_base :: openmode = ios_base :: in | ios_base :: out) 
{ return pos_type (off_type (- 1)) ; } 
# 620 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual pos_type 
seekpos (pos_type , 
ios_base :: openmode = ios_base :: in | ios_base :: out) 
{ return pos_type (off_type (- 1)) ; } 
# 633 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual int 
sync () { return 0 ; } 
# 655 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual streamsize 
showmanyc () { return 0 ; } 
# 671 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual streamsize 
xsgetn (char_type * __s , streamsize __n) ; 
# 693 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual int_type 
underflow () 
{ return traits_type :: eof () ; } 
# 706 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual int_type 
uflow () 
{ 
int_type __ret = traits_type :: eof () ; 
const bool __testeof = traits_type :: eq_int_type (this -> underflow () , 
__ret) ; 
if (! __testeof) 
{ 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
this -> gbump (1) ; 
} 
return __ret ; 
} 
# 730 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual int_type 
pbackfail (int_type __c __attribute__ ((__unused__)) = traits_type :: eof ()) 
{ return traits_type :: eof () ; } 
# 748 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual streamsize 
xsputn (const char_type * __s , streamsize __n) ; 
# 774 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
virtual int_type 
overflow (int_type __c __attribute__ ((__unused__)) = traits_type :: eof ()) 
{ return traits_type :: eof () ; } 



public : 
# 790 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\streambuf" 3
[ [ __deprecated__ ("stossc is deprecated, use sbumpc instead") ] ] 

void 
stossc () 
{ 
if (this -> gptr () < this -> egptr ()) 
this -> gbump (1) ; 
else 
this -> uflow () ; 
} 



void 
__safe_gbump (streamsize __n) { _M_in_cur += __n ; } 

void 
__safe_pbump (streamsize __n) { _M_out_cur += __n ; } 




protected : 

basic_streambuf (const basic_streambuf &) ; 

basic_streambuf & 
operator = (const basic_streambuf &) ; 


void 
swap (basic_streambuf & __sb) 
{ 
std :: swap (_M_in_beg , __sb . _M_in_beg) ; 
std :: swap (_M_in_cur , __sb . _M_in_cur) ; 
std :: swap (_M_in_end , __sb . _M_in_end) ; 
std :: swap (_M_out_beg , __sb . _M_out_beg) ; 
std :: swap (_M_out_cur , __sb . _M_out_cur) ; 
std :: swap (_M_out_end , __sb . _M_out_end) ; 
std :: swap (_M_buf_locale , __sb . _M_buf_locale) ; 
} 

} ;


template < typename _CharT , typename _Traits > 
std :: basic_streambuf < _CharT , _Traits > :: 
basic_streambuf (const basic_streambuf &) = default ; 

template < typename _CharT , typename _Traits > 
std :: basic_streambuf < _CharT , _Traits > & 
std :: basic_streambuf < _CharT , _Traits > :: 
operator = (const basic_streambuf &) = default ; 
# 848
template<> streamsize __copy_streambufs_eof(basic_streambuf< char>  * __sbin, basic_streambuf< char>  * __sbout, bool & __ineof); 




template<> streamsize __copy_streambufs_eof(basic_streambuf< wchar_t>  * __sbin, basic_streambuf< wchar_t>  * __sbout, bool & __ineof); 
# 860
}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\streambuf.tcc" 3
namespace std { 



template < typename _CharT , typename _Traits > 
streamsize 
basic_streambuf < _CharT , _Traits > :: 
xsgetn (char_type * __s , streamsize __n) 
{ 
streamsize __ret = 0 ; 
while (__ret < __n) 
{ 
const streamsize __buf_len = this -> egptr () - this -> gptr () ; 
if (__buf_len) 
{ 
const streamsize __remaining = __n - __ret ; 
const streamsize __len = std :: min (__buf_len , __remaining) ; 
traits_type :: copy (__s , this -> gptr () , __len) ; 
__ret += __len ; 
__s += __len ; 
this -> __safe_gbump (__len) ; 
} 

if (__ret < __n) 
{ 
const int_type __c = this -> uflow () ; 
if (! traits_type :: eq_int_type (__c , traits_type :: eof ())) 
{ 
traits_type :: assign (* __s ++ , traits_type :: to_char_type (__c)) ; 
++ __ret ; 
} 
else 
break ; 
} 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
streamsize 
basic_streambuf < _CharT , _Traits > :: 
xsputn (const char_type * __s , streamsize __n) 
{ 
streamsize __ret = 0 ; 
while (__ret < __n) 
{ 
const streamsize __buf_len = this -> epptr () - this -> pptr () ; 
if (__buf_len) 
{ 
const streamsize __remaining = __n - __ret ; 
const streamsize __len = std :: min (__buf_len , __remaining) ; 
traits_type :: copy (this -> pptr () , __s , __len) ; 
__ret += __len ; 
__s += __len ; 
this -> __safe_pbump (__len) ; 
} 

if (__ret < __n) 
{ 
int_type __c = this -> overflow (traits_type :: to_int_type (* __s)) ; 
if (! traits_type :: eq_int_type (__c , traits_type :: eof ())) 
{ 
++ __ret ; 
++ __s ; 
} 
else 
break ; 
} 
} 
return __ret ; 
} 




template < typename _CharT , typename _Traits > 
streamsize 
__copy_streambufs_eof (basic_streambuf < _CharT , _Traits > * __sbin , 
basic_streambuf < _CharT , _Traits > * __sbout , 
bool & __ineof) 
{ 
streamsize __ret = 0 ; 
__ineof = true ; 
typename _Traits :: int_type __c = __sbin -> sgetc () ; 
while (! _Traits :: eq_int_type (__c , _Traits :: eof ())) 
{ 
__c = __sbout -> sputc (_Traits :: to_char_type (__c)) ; 
if (_Traits :: eq_int_type (__c , _Traits :: eof ())) 
{ 
__ineof = false ; 
break ; 
} 
++ __ret ; 
__c = __sbin -> snextc () ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
inline streamsize 
__copy_streambufs (basic_streambuf < _CharT , _Traits > * __sbin , 
basic_streambuf < _CharT , _Traits > * __sbout) 
{ 
bool __ineof ; 
return __copy_streambufs_eof (__sbin , __sbout , __ineof) ; 
} 




extern template class basic_streambuf< char> ;
extern template streamsize __copy_streambufs(basic_streambuf< char>  * __sbin, basic_streambuf< char>  * __sbout);



extern template streamsize __copy_streambufs_eof<> (basic_streambuf< char>  *, basic_streambuf< char>  *, bool &);
# 160
extern template class basic_streambuf< wchar_t> ;
extern template streamsize __copy_streambufs(basic_streambuf< wchar_t>  * __sbin, basic_streambuf< wchar_t>  * __sbout);



extern template streamsize __copy_streambufs_eof<> (basic_streambuf< wchar_t>  *, basic_streambuf< wchar_t>  *, bool &);
# 173
}
# 80 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cwctype" 3
namespace std { 

using ::wctrans_t;
using ::wctype_t;


using ::iswalnum;
using ::iswalpha;

using ::iswblank;

using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctype;
}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\ctype_base.h" 3
namespace std { 




struct ctype_base { 


typedef const int *__to_type; 



typedef unsigned short mask; 
static const mask upper = (1 << 0); 
static const mask lower = (1 << 1); 
static const mask alpha = (1 << 2); 
static const mask digit = (1 << 3); 
static const mask xdigit = (1 << 4); 
static const mask space = (1 << 5); 
static const mask print = (1 << 6); 
static const mask graph = (((1 << 2) | (1 << 3)) | (1 << 9)); 
static const mask cntrl = (1 << 8); 
static const mask punct = (1 << 9); 
static const mask alnum = ((1 << 2) | (1 << 3)); 

static const mask blank = (1 << 10); 

}; 


}
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\streambuf_iterator.h" 3
namespace std { 
# 49 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\streambuf_iterator.h" 3
template < typename _CharT , typename _Traits > 
class istreambuf_iterator 
: public iterator < input_iterator_tag , _CharT , typename _Traits :: off_type , 
_CharT * , 


_CharT > 



{ 
public : 



typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef basic_streambuf < _CharT , _Traits > streambuf_type ; 
typedef basic_istream < _CharT , _Traits > istream_type ; 


template < typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
ostreambuf_iterator < _CharT2 > > :: __type 
copy (istreambuf_iterator < _CharT2 > , istreambuf_iterator < _CharT2 > , 
ostreambuf_iterator < _CharT2 >) ; 

template < bool _IsMove , typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
_CharT2 * > :: __type 
__copy_move_a2 (istreambuf_iterator < _CharT2 > , 
istreambuf_iterator < _CharT2 > , _CharT2 *) ; 

template < typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
istreambuf_iterator < _CharT2 > > :: __type 
find (istreambuf_iterator < _CharT2 > , istreambuf_iterator < _CharT2 > , 
const _CharT2 &) ; 

template < typename _CharT2 , typename _Distance > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
void > :: __type 
advance (istreambuf_iterator < _CharT2 > & , _Distance) ; 

private : 
# 102
mutable streambuf_type * _M_sbuf ; 
int_type _M_c ; 

public : 

constexpr istreambuf_iterator () noexcept 
: _M_sbuf (0) , _M_c (traits_type :: eof ()) { } 


istreambuf_iterator (const istreambuf_iterator &) noexcept = default ; 

~ istreambuf_iterator () = default ; 



istreambuf_iterator (istream_type & __s) noexcept 
: _M_sbuf (__s . rdbuf ()) , _M_c (traits_type :: eof ()) { } 


istreambuf_iterator (streambuf_type * __s) noexcept 
: _M_sbuf (__s) , _M_c (traits_type :: eof ()) { } 


istreambuf_iterator & 
operator = (const istreambuf_iterator &) noexcept = default ; 
# 132
char_type 
operator * () const 
{ 
int_type __c = _M_get () ; 
# 144 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\streambuf_iterator.h" 3
return traits_type :: to_char_type (__c) ; 
} 


istreambuf_iterator & 
operator ++ () 
{ 



; 

_M_sbuf -> sbumpc () ; 
_M_c = traits_type :: eof () ; 
return * this ; 
} 


istreambuf_iterator 
operator ++ (int) 
{ 



; 

istreambuf_iterator __old = * this ; 
__old . _M_c = _M_sbuf -> sbumpc () ; 
_M_c = traits_type :: eof () ; 
return __old ; 
} 
# 180
bool 
equal (const istreambuf_iterator & __b) const 
{ return _M_at_eof () == __b . _M_at_eof () ; } 

private : 
int_type 
_M_get () const 
{ 
int_type __ret = _M_c ; 
if (_M_sbuf && _S_is_eof (__ret) && _S_is_eof (__ret = _M_sbuf -> sgetc ())) 
_M_sbuf = 0 ; 
return __ret ; 
} 

bool 
_M_at_eof () const 
{ return _S_is_eof (_M_get ()) ; } 

static bool 
_S_is_eof (int_type __c) 
{ 
const int_type __eof = traits_type :: eof () ; 
return traits_type :: eq_int_type (__c , __eof) ; 
} 
} ;

template < typename _CharT , typename _Traits > 
inline bool 
operator == (const istreambuf_iterator < _CharT , _Traits > & __a , 
const istreambuf_iterator < _CharT , _Traits > & __b) 
{ return __a . equal (__b) ; } 

template < typename _CharT , typename _Traits > 
inline bool 
operator != (const istreambuf_iterator < _CharT , _Traits > & __a , 
const istreambuf_iterator < _CharT , _Traits > & __b) 
{ return ! __a . equal (__b) ; } 


template < typename _CharT , typename _Traits > 
class ostreambuf_iterator 
: public iterator < output_iterator_tag , void , void , void , void > 
{ 
public : 



typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef basic_streambuf < _CharT , _Traits > streambuf_type ; 
typedef basic_ostream < _CharT , _Traits > ostream_type ; 


template < typename _CharT2 > 
friend typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , 
ostreambuf_iterator < _CharT2 > > :: __type 
copy (istreambuf_iterator < _CharT2 > , istreambuf_iterator < _CharT2 > , 
ostreambuf_iterator < _CharT2 >) ; 

private : 
streambuf_type * _M_sbuf ; 
bool _M_failed ; 

public : 

ostreambuf_iterator (ostream_type & __s) noexcept 
: _M_sbuf (__s . rdbuf ()) , _M_failed (! _M_sbuf) { } 


ostreambuf_iterator (streambuf_type * __s) noexcept 
: _M_sbuf (__s) , _M_failed (! _M_sbuf) { } 


ostreambuf_iterator & 
operator = (_CharT __c) 
{ 
if (! _M_failed && 
_Traits :: eq_int_type (_M_sbuf -> sputc (__c) , _Traits :: eof ())) 
_M_failed = true ; 
return * this ; 
} 


ostreambuf_iterator & 
operator * () 
{ return * this ; } 


ostreambuf_iterator & 
operator ++ (int) 
{ return * this ; } 


ostreambuf_iterator & 
operator ++ () 
{ return * this ; } 


bool 
failed () const noexcept 
{ return _M_failed ; } 

ostreambuf_iterator & 
_M_put (const _CharT * __ws , streamsize __len) 
{ 
if (__builtin_expect (! _M_failed , true) 
&& __builtin_expect (this -> _M_sbuf -> sputn (__ws , __len) != __len , 
false)) 
_M_failed = true ; 
return * this ; 
} 
} ;


template < typename _CharT > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
ostreambuf_iterator < _CharT > > :: __type 
copy (istreambuf_iterator < _CharT > __first , 
istreambuf_iterator < _CharT > __last , 
ostreambuf_iterator < _CharT > __result) 
{ 
if (__first . _M_sbuf && ! __last . _M_sbuf && ! __result . _M_failed) 
{ 
bool __ineof ; 
__copy_streambufs_eof (__first . _M_sbuf , __result . _M_sbuf , __ineof) ; 
if (! __ineof) 
__result . _M_failed = true ; 
} 
return __result ; 
} 

template < bool _IsMove , typename _CharT > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
ostreambuf_iterator < _CharT > > :: __type 
__copy_move_a2 (_CharT * __first , _CharT * __last , 
ostreambuf_iterator < _CharT > __result) 
{ 
const streamsize __num = __last - __first ; 
if (__num > 0) 
__result . _M_put (__first , __num) ; 
return __result ; 
} 

template < bool _IsMove , typename _CharT > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
ostreambuf_iterator < _CharT > > :: __type 
__copy_move_a2 (const _CharT * __first , const _CharT * __last , 
ostreambuf_iterator < _CharT > __result) 
{ 
const streamsize __num = __last - __first ; 
if (__num > 0) 
__result . _M_put (__first , __num) ; 
return __result ; 
} 

template < bool _IsMove , typename _CharT > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
_CharT * > :: __type 
__copy_move_a2 (istreambuf_iterator < _CharT > __first , 
istreambuf_iterator < _CharT > __last , _CharT * __result) 
{ 
typedef istreambuf_iterator < _CharT > __is_iterator_type ; 
typedef typename __is_iterator_type :: traits_type traits_type ; 
typedef typename __is_iterator_type :: streambuf_type streambuf_type ; 
typedef typename traits_type :: int_type int_type ; 

if (__first . _M_sbuf && ! __last . _M_sbuf) 
{ 
streambuf_type * __sb = __first . _M_sbuf ; 
int_type __c = __sb -> sgetc () ; 
while (! traits_type :: eq_int_type (__c , traits_type :: eof ())) 
{ 
const streamsize __n = __sb -> egptr () - __sb -> gptr () ; 
if (__n > 1) 
{ 
traits_type :: copy (__result , __sb -> gptr () , __n) ; 
__sb -> __safe_gbump (__n) ; 
__result += __n ; 
__c = __sb -> underflow () ; 
} 
else 
{ 
* __result ++ = traits_type :: to_char_type (__c) ; 
__c = __sb -> snextc () ; 
} 
} 
} 
return __result ; 
} 

template < typename _CharT > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
istreambuf_iterator < _CharT > > :: __type 
find (istreambuf_iterator < _CharT > __first , 
istreambuf_iterator < _CharT > __last , const _CharT & __val) 
{ 
typedef istreambuf_iterator < _CharT > __is_iterator_type ; 
typedef typename __is_iterator_type :: traits_type traits_type ; 
typedef typename __is_iterator_type :: streambuf_type streambuf_type ; 
typedef typename traits_type :: int_type int_type ; 
const int_type __eof = traits_type :: eof () ; 

if (__first . _M_sbuf && ! __last . _M_sbuf) 
{ 
const int_type __ival = traits_type :: to_int_type (__val) ; 
streambuf_type * __sb = __first . _M_sbuf ; 
int_type __c = __sb -> sgetc () ; 
while (! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __ival)) 
{ 
streamsize __n = __sb -> egptr () - __sb -> gptr () ; 
if (__n > 1) 
{ 
const _CharT * __p = traits_type :: find (__sb -> gptr () , 
__n , __val) ; 
if (__p) 
__n = __p - __sb -> gptr () ; 
__sb -> __safe_gbump (__n) ; 
__c = __sb -> sgetc () ; 
} 
else 
__c = __sb -> snextc () ; 
} 

__first . _M_c = __eof ; 
} 

return __first ; 
} 

template < typename _CharT , typename _Distance > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT > :: __value , 
void > :: __type 
advance (istreambuf_iterator < _CharT > & __i , _Distance __n) 
{ 
if (__n == 0) 
return ; 

; 


; 

typedef istreambuf_iterator < _CharT > __is_iterator_type ; 
typedef typename __is_iterator_type :: traits_type traits_type ; 
typedef typename __is_iterator_type :: streambuf_type streambuf_type ; 
typedef typename traits_type :: int_type int_type ; 
const int_type __eof = traits_type :: eof () ; 

streambuf_type * __sb = __i . _M_sbuf ; 
while (__n > 0) 
{ 
streamsize __size = __sb -> egptr () - __sb -> gptr () ; 
if (__size > __n) 
{ 
__sb -> __safe_gbump (__n) ; 
break ; 
} 

__sb -> __safe_gbump (__size) ; 
__n -= __size ; 
if (traits_type :: eq_int_type (__sb -> underflow () , __eof)) 
{ 


; 
break ; 
} 
} 

__i . _M_c = __eof ; 
} 




}
# 50 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
namespace std { 
# 71 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _Tp >
    void
    __convert_to_v ( const char *, _Tp &, ios_base :: iostate &,
     const __c_locale & ) throw ( );




template<> void __convert_to_v(const char *, float &, ios_base::iostate &, const __c_locale &) throw(); 




template<> void __convert_to_v(const char *, double &, ios_base::iostate &, const __c_locale &) throw(); 




template<> void __convert_to_v(const char *, long double &, ios_base::iostate &, const __c_locale &) throw(); 




template < typename _CharT , typename _Traits > 
struct __pad 
{ 
static void 
_S_pad (ios_base & __io , _CharT __fill , _CharT * __news , 
const _CharT * __olds , streamsize __newlen , streamsize __oldlen) ; 
} ;
# 107
template < typename _CharT >
    _CharT *
    __add_grouping ( _CharT * __s, _CharT __sep,
     const char * __gbeg, size_t __gsize,
     const _CharT * __first, const _CharT * __last );




template < typename _CharT > 
inline 
ostreambuf_iterator < _CharT > 
__write (ostreambuf_iterator < _CharT > __s , const _CharT * __ws , int __len) 
{ 
__s . _M_put (__ws , __len) ; 
return __s ; 
} 


template < typename _CharT , typename _OutIter > 
inline 
_OutIter 
__write (_OutIter __s , const _CharT * __ws , int __len) 
{ 
for (int __j = 0 ; __j < __len ; __j ++ , ++ __s) 
* __s = __ws [ __j ] ; 
return __s ; 
} 
# 149 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _CharT > 
class __ctype_abstract_base : public locale :: facet , public ctype_base 
{ 
public : 


typedef _CharT char_type ; 
# 168 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
bool 
is (mask __m , char_type __c) const 
{ return this -> do_is (__m , __c) ; } 
# 185 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
is (const char_type * __lo , const char_type * __hi , mask * __vec) const 
{ return this -> do_is (__lo , __hi , __vec) ; } 
# 201 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
scan_is (mask __m , const char_type * __lo , const char_type * __hi) const 
{ return this -> do_scan_is (__m , __lo , __hi) ; } 
# 217 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
scan_not (mask __m , const char_type * __lo , const char_type * __hi) const 
{ return this -> do_scan_not (__m , __lo , __hi) ; } 
# 231 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type 
toupper (char_type __c) const 
{ return this -> do_toupper (__c) ; } 
# 246 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
toupper (char_type * __lo , const char_type * __hi) const 
{ return this -> do_toupper (__lo , __hi) ; } 
# 260 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type 
tolower (char_type __c) const 
{ return this -> do_tolower (__c) ; } 
# 275 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
tolower (char_type * __lo , const char_type * __hi) const 
{ return this -> do_tolower (__lo , __hi) ; } 
# 292 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type 
widen (char __c) const 
{ return this -> do_widen (__c) ; } 
# 311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char * 
widen (const char * __lo , const char * __hi , char_type * __to) const 
{ return this -> do_widen (__lo , __hi , __to) ; } 
# 330 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char 
narrow (char_type __c , char __dfault) const 
{ return this -> do_narrow (__c , __dfault) ; } 
# 352 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type * 
narrow (const char_type * __lo , const char_type * __hi , 
char __dfault , char * __to) const 
{ return this -> do_narrow (__lo , __hi , __dfault , __to) ; } 

protected : 
explicit 
__ctype_abstract_base (size_t __refs = 0) : facet (__refs) { } 

virtual 
~ __ctype_abstract_base () { } 
# 377 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual bool 
do_is (mask __m , char_type __c) const = 0 ; 
# 396 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_is (const char_type * __lo , const char_type * __hi , 
mask * __vec) const = 0 ; 
# 415 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_scan_is (mask __m , const char_type * __lo , 
const char_type * __hi) const = 0 ; 
# 434 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_scan_not (mask __m , const char_type * __lo , 
const char_type * __hi) const = 0 ; 
# 452 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type 
do_toupper (char_type __c) const = 0 ; 
# 469 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_toupper (char_type * __lo , const char_type * __hi) const = 0 ; 
# 485 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type 
do_tolower (char_type __c) const = 0 ; 
# 502 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_tolower (char_type * __lo , const char_type * __hi) const = 0 ; 
# 521 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type 
do_widen (char __c) const = 0 ; 
# 542 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char * 
do_widen (const char * __lo , const char * __hi , char_type * __to) const = 0 ; 
# 563 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char 
do_narrow (char_type __c , char __dfault) const = 0 ; 
# 588 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type * 
do_narrow (const char_type * __lo , const char_type * __hi , 
char __dfault , char * __to) const = 0 ; 
} ;
# 611 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _CharT > 
class ctype : public __ctype_abstract_base < _CharT > 
{ 
public : 

typedef _CharT char_type ; 
typedef typename __ctype_abstract_base < _CharT > :: mask mask ; 


static locale :: id id ; 

explicit 
ctype (size_t __refs = 0) : __ctype_abstract_base < _CharT > (__refs) { } 

protected : 
virtual 
~ ctype () ; 

virtual bool 
do_is (mask __m , char_type __c) const ; 

virtual const char_type * 
do_is (const char_type * __lo , const char_type * __hi , mask * __vec) const ; 

virtual const char_type * 
do_scan_is (mask __m , const char_type * __lo , const char_type * __hi) const ; 

virtual const char_type * 
do_scan_not (mask __m , const char_type * __lo , 
const char_type * __hi) const ; 

virtual char_type 
do_toupper (char_type __c) const ; 

virtual const char_type * 
do_toupper (char_type * __lo , const char_type * __hi) const ; 

virtual char_type 
do_tolower (char_type __c) const ; 

virtual const char_type * 
do_tolower (char_type * __lo , const char_type * __hi) const ; 

virtual char_type 
do_widen (char __c) const ; 

virtual const char * 
do_widen (const char * __lo , const char * __hi , char_type * __dest) const ; 

virtual char 
do_narrow (char_type , char __dfault) const ; 

virtual const char_type * 
do_narrow (const char_type * __lo , const char_type * __hi , 
char __dfault , char * __to) const ; 
} ;

template < typename _CharT >
    locale :: id ctype < _CharT > :: id;
# 681 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template<> class ctype< char>  : public locale::facet, public ctype_base { 




public: typedef char char_type; 



protected: __c_locale _M_c_locale_ctype; 
bool _M_del; 
__to_type _M_toupper; 
__to_type _M_tolower; 
const mask *_M_table; 
mutable char _M_widen_ok; 
mutable char _M_widen[1 + static_cast< unsigned char>(-1)]; 
mutable char _M_narrow[1 + static_cast< unsigned char>(-1)]; 
mutable char _M_narrow_ok; 




public: static locale::id id; 

static const size_t table_size = (1 + static_cast< unsigned char>(-1)); 
# 718 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit ctype(const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 731 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit ctype(__c_locale __cloc, const mask * __table = 0, bool __del = false, size_t __refs = 0); 
# 744 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
inline bool is(mask __m, char __c) const; 
# 759 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
inline const char *is(const char * __lo, const char * __hi, mask * __vec) const; 
# 773 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
inline const char *scan_is(mask __m, const char * __lo, const char * __hi) const; 
# 787 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
inline const char *scan_not(mask __m, const char * __lo, const char * __hi) const; 
# 802 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type toupper(char_type __c) const 
{ return this->do_toupper(__c); } 
# 819 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type *toupper(char_type *__lo, const char_type *__hi) const 
{ return this->do_toupper(__lo, __hi); } 
# 835 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type tolower(char_type __c) const 
{ return this->do_tolower(__c); } 
# 852 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type *tolower(char_type *__lo, const char_type *__hi) const 
{ return this->do_tolower(__lo, __hi); } 
# 872 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type widen(char __c) const 
{ 
if (_M_widen_ok) 
return (_M_widen)[static_cast< unsigned char>(__c)];   
this->_M_widen_init(); 
return this->do_widen(__c); 
} 
# 899 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char *widen(const char *__lo, const char *__hi, char_type *__to) const 
{ 
if (_M_widen_ok == 1) 
{ 
if (__builtin_expect(__hi != __lo, true)) 
__builtin_memcpy(__to, __lo, __hi - __lo);   
return __hi; 
}  
if (!_M_widen_ok) 
this->_M_widen_init();   
return this->do_widen(__lo, __hi, __to); 
} 
# 931 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char narrow(char_type __c, char __dfault) const 
{ 
if ((_M_narrow)[static_cast< unsigned char>(__c)]) 
return (_M_narrow)[static_cast< unsigned char>(__c)];   
const char __t = this->do_narrow(__c, __dfault); 
if (__t != __dfault) 
(_M_narrow)[static_cast< unsigned char>(__c)] = __t;   
return __t; 
} 
# 964 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
const char_type *narrow(const char_type *__lo, const char_type *__hi, char 
__dfault, char *__to) const 
{ 
if (__builtin_expect(_M_narrow_ok == 1, true)) 
{ 
if (__builtin_expect(__hi != __lo, true)) 
__builtin_memcpy(__to, __lo, __hi - __lo);   
return __hi; 
}  
if (!_M_narrow_ok) 
this->_M_narrow_init();   
return this->do_narrow(__lo, __hi, __dfault, __to); 
} 
# 983
const mask *table() const throw() 
{ return _M_table; } 



static const mask *classic_table() throw(); 
# 998
protected: virtual ~ctype(); 
# 1014 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1031 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1047 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1064 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1084 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_widen(char __c) const 
{ return __c; } 
# 1107 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char *do_widen(const char *__lo, const char *__hi, char_type *__to) const 
{ 
if (__builtin_expect(__hi != __lo, true)) 
__builtin_memcpy(__to, __lo, __hi - __lo);   
return __hi; 
} 
# 1134 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault __attribute((__unused__))) const 
{ return __c; } 
# 1160 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_narrow(const char_type *__lo, const char_type *__hi, char 
__dfault __attribute((__unused__)), char *__to) const 
{ 
if (__builtin_expect(__hi != __lo, true)) 
__builtin_memcpy(__to, __lo, __hi - __lo);   
return __hi; 
} 


private: void _M_narrow_init() const; 
void _M_widen_init() const; 
}; 
# 1186 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template<> class ctype< wchar_t>  : public __ctype_abstract_base< wchar_t>  { 




public: typedef wchar_t char_type; 
typedef wctype_t __wmask_type; 


protected: __c_locale _M_c_locale_ctype; 


bool _M_narrow_ok; 
char _M_narrow[128]; 
wint_t _M_widen[1 + static_cast< unsigned char>(-1)]; 


mask _M_bit[16]; 
__wmask_type _M_wmask[16]; 




public: static locale::id id; 
# 1219 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit ctype(size_t __refs = 0); 
# 1230 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit ctype(__c_locale __cloc, size_t __refs = 0); 



protected: __wmask_type _M_convert_to_wmask(const mask __m) const throw(); 



virtual ~ctype(); 
# 1254 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual bool do_is(mask __m, char_type __c) const; 
# 1273 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_is(const char_type * __lo, const char_type * __hi, mask * __vec) const; 
# 1291 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_scan_is(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1309 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_scan_not(mask __m, const char_type * __lo, const char_type * __hi) const; 
# 1326 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_toupper(char_type __c) const; 
# 1343 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_toupper(char_type * __lo, const char_type * __hi) const; 
# 1359 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_tolower(char_type __c) const; 
# 1376 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_tolower(char_type * __lo, const char_type * __hi) const; 
# 1396 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type do_widen(char __c) const; 
# 1418 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char *do_widen(const char * __lo, const char * __hi, char_type * __to) const; 
# 1441 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char do_narrow(char_type __c, char __dfault) const; 
# 1467 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual const char_type *do_narrow(const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const; 




void _M_initialize_ctype() throw(); 
}; 



template < typename _CharT > 
class ctype_byname : public ctype < _CharT > 
{ 
public : 
typedef typename ctype < _CharT > :: mask mask ; 

explicit 
ctype_byname (const char * __s , size_t __refs = 0) ; 


explicit 
ctype_byname (const string & __s , size_t __refs = 0) 
: ctype_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ ctype_byname () { } 
} ;



template<> class ctype_byname< char>  : public ctype< char>  { 



public: explicit ctype_byname(const char * __s, size_t __refs = 0); 



explicit ctype_byname(const string & __s, size_t __refs = 0); 




protected: virtual ~ctype_byname(); 
}; 



template<> class ctype_byname< wchar_t>  : public ctype< wchar_t>  { 



public: explicit ctype_byname(const char * __s, size_t __refs = 0); 



explicit ctype_byname(const string & __s, size_t __refs = 0); 




protected: virtual ~ctype_byname(); 
}; 



}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\ctype_inline.h" 3
namespace std { 
# 43
inline bool ctype< char> ::is(mask __m, char __c) const 
{ return ((_M_table[static_cast< unsigned char>(__c)] & __m)); } 




inline const char *ctype< char> ::is(const char *__low, const char *__high, mask *__vec) const 
{ 
while (__low < __high) 
*(__vec++) = _M_table[static_cast< unsigned char>(*(__low++))];   
return __high; 
} 



inline const char *ctype< char> ::scan_is(mask __m, const char *__low, const char *__high) const 
{ 
while (__low < __high && !this->is(__m, *__low)) 
++__low;   
return __low; 
} 



inline const char *ctype< char> ::scan_not(mask __m, const char *__low, const char *__high) const 
{ 
while (__low < __high && this->is(__m, *__low) != 0) 
++__low;   
return __low; 
} 


}
# 1540 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
namespace std { 




class __num_base { 
# 1551
public: enum { 
_S_ominus, 
_S_oplus, 
_S_ox, 
_S_oX, 
_S_odigits, 
_S_odigits_end = (_S_odigits + 16), 
_S_oudigits = _S_odigits_end, 
_S_oudigits_end = (_S_oudigits + 16), 
_S_oe = (_S_odigits + 14), 
_S_oE = (_S_oudigits + 14), 
_S_oend = _S_oudigits_end
}; 
# 1570
static const char *_S_atoms_out; 



static const char *_S_atoms_in; 


enum { 
_S_iminus, 
_S_iplus, 
_S_ix, 
_S_iX, 
_S_izero, 
_S_ie = (_S_izero + 14), 
_S_iE = (_S_izero + 20), 
_S_iend = 26
}; 




static void _S_format_float(const ios_base & __io, char * __fptr, char __mod) throw(); 
}; 

template < typename _CharT > 
struct __numpunct_cache : public locale :: facet 
{ 
const char * _M_grouping ; 
size_t _M_grouping_size ; 
bool _M_use_grouping ; 
const _CharT * _M_truename ; 
size_t _M_truename_size ; 
const _CharT * _M_falsename ; 
size_t _M_falsename_size ; 
_CharT _M_decimal_point ; 
_CharT _M_thousands_sep ; 
# 1611
_CharT _M_atoms_out [ __num_base :: _S_oend ] ; 
# 1617
_CharT _M_atoms_in [ __num_base :: _S_iend ] ; 

bool _M_allocated ; 

__numpunct_cache (size_t __refs = 0) 
: facet (__refs) , _M_grouping (0) , _M_grouping_size (0) , 
_M_use_grouping (false) , 
_M_truename (0) , _M_truename_size (0) , _M_falsename (0) , 
_M_falsename_size (0) , _M_decimal_point (_CharT ()) , 
_M_thousands_sep (_CharT ()) , _M_allocated (false) 
{ } 

~ __numpunct_cache () ; 

void 
_M_cache (const locale & __loc) ; 

private : 
__numpunct_cache & 
operator = (const __numpunct_cache &) ; 

explicit 
__numpunct_cache (const __numpunct_cache &) ; 
} ;

template < typename _CharT > 
__numpunct_cache < _CharT > :: ~ __numpunct_cache () 
{ 
if (_M_allocated) 
{ 
delete [ ] _M_grouping ; 
delete [ ] _M_truename ; 
delete [ ] _M_falsename ; 
} 
} 

inline namespace __cxx11 { 
# 1669 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _CharT > 
class numpunct : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 

typedef __numpunct_cache < _CharT > __cache_type ; 

protected : 
__cache_type * _M_data ; 

public : 

static locale :: id id ; 
# 1693
explicit 
numpunct (size_t __refs = 0) 
: facet (__refs) , _M_data (0) 
{ _M_initialize_numpunct () ; } 
# 1707 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit 
numpunct (__cache_type * __cache , size_t __refs = 0) 
: facet (__refs) , _M_data (__cache) 
{ _M_initialize_numpunct () ; } 
# 1721 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit 
numpunct (__c_locale __cloc , size_t __refs = 0) 
: facet (__refs) , _M_data (0) 
{ _M_initialize_numpunct (__cloc) ; } 
# 1735 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type 
decimal_point () const 
{ return this -> do_decimal_point () ; } 
# 1748 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
char_type 
thousands_sep () const 
{ return this -> do_thousands_sep () ; } 
# 1779 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
string 
grouping () const 
{ return this -> do_grouping () ; } 
# 1792 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
string_type 
truename () const 
{ return this -> do_truename () ; } 
# 1805 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
string_type 
falsename () const 
{ return this -> do_falsename () ; } 

protected : 

virtual 
~ numpunct () ; 
# 1822 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type 
do_decimal_point () const 
{ return _M_data -> _M_decimal_point ; } 
# 1834 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual char_type 
do_thousands_sep () const 
{ return _M_data -> _M_thousands_sep ; } 
# 1847 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual string 
do_grouping () const 
{ return _M_data -> _M_grouping ; } 
# 1860 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual string_type 
do_truename () const 
{ return _M_data -> _M_truename ; } 
# 1873 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual string_type 
do_falsename () const 
{ return _M_data -> _M_falsename ; } 


void 
_M_initialize_numpunct (__c_locale __cloc = 0) ; 
} ;

template < typename _CharT >
    locale :: id numpunct < _CharT > :: id;


template<> numpunct< char> ::~numpunct(); 



template<> void numpunct< char> ::_M_initialize_numpunct(__c_locale __cloc); 



template<> numpunct< wchar_t> ::~numpunct(); 



template<> void numpunct< wchar_t> ::_M_initialize_numpunct(__c_locale __cloc); 



template < typename _CharT > 
class numpunct_byname : public numpunct < _CharT > 
{ 
public : 
typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 

explicit 
numpunct_byname (const char * __s , size_t __refs = 0) 
: numpunct < _CharT > (__refs) 
{ 
if (__builtin_strcmp (__s , "C") != 0 
&& __builtin_strcmp (__s , "POSIX") != 0) 
{ 
__c_locale __tmp ; 
this -> _S_create_c_locale (__tmp , __s) ; 
this -> _M_initialize_numpunct (__tmp) ; 
this -> _S_destroy_c_locale (__tmp) ; 
} 
} 


explicit 
numpunct_byname (const string & __s , size_t __refs = 0) 
: numpunct_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ numpunct_byname () { } 
} ;

}
# 1951 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _CharT , typename _InIter > 
class num_get : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef _InIter iter_type ; 



static locale :: id id ; 
# 1972 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit 
num_get (size_t __refs = 0) : facet (__refs) { } 
# 1998 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , bool & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 
# 2035 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned short & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned int & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned long & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 


iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long long & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned long long & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 
# 2095 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , float & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , double & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long double & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 
# 2138 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
get (iter_type __in , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , void * & __v) const 
{ return this -> do_get (__in , __end , __io , __err , __v) ; } 

protected : 

virtual ~ num_get () { } 

__attribute ((__abi_tag__ ("cxx11"))) 
iter_type 
_M_extract_float (iter_type , iter_type , ios_base & , ios_base :: iostate & , 
string &) const ; 

template < typename _ValueT > 
__attribute ((__abi_tag__ ("cxx11"))) 
iter_type 
_M_extract_int (iter_type , iter_type , ios_base & , ios_base :: iostate & , 
_ValueT &) const ; 

template < typename _CharT2 > 
typename __gnu_cxx :: __enable_if < __is_char < _CharT2 > :: __value , int > :: __type 
_M_find (const _CharT2 * , size_t __len , _CharT2 __c) const 
{ 
int __ret = - 1 ; 
if (__len <= 10) 
{ 
if (__c >= _CharT2 ('0') && __c < _CharT2 (_CharT2 ('0') + __len)) 
__ret = __c - _CharT2 ('0') ; 
} 
else 
{ 
if (__c >= _CharT2 ('0') && __c <= _CharT2 ('9')) 
__ret = __c - _CharT2 ('0') ; 
else if (__c >= _CharT2 ('a') && __c <= _CharT2 ('f')) 
__ret = 10 + (__c - _CharT2 ('a')) ; 
else if (__c >= _CharT2 ('A') && __c <= _CharT2 ('F')) 
__ret = 10 + (__c - _CharT2 ('A')) ; 
} 
return __ret ; 
} 

template < typename _CharT2 > 
typename __gnu_cxx :: __enable_if < ! __is_char < _CharT2 > :: __value , 
int > :: __type 
_M_find (const _CharT2 * __zero , size_t __len , _CharT2 __c) const 
{ 
int __ret = - 1 ; 
const char_type * __q = char_traits < _CharT2 > :: find (__zero , __len , __c) ; 
if (__q) 
{ 
__ret = __q - __zero ; 
if (__ret > 15) 
__ret -= 6 ; 
} 
return __ret ; 
} 
# 2211 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual iter_type 
do_get (iter_type , iter_type , ios_base & , ios_base :: iostate & , bool &) const ; 

virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 

virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned short & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 

virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned int & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 

virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned long & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 


virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long long & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 

virtual iter_type 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , unsigned long long & __v) const 
{ return _M_extract_int (__beg , __end , __io , __err , __v) ; } 


virtual iter_type 
do_get (iter_type , iter_type , ios_base & , ios_base :: iostate & , float &) const ; 

virtual iter_type 
do_get (iter_type , iter_type , ios_base & , ios_base :: iostate & , 
double &) const ; 
# 2259
virtual iter_type 
do_get (iter_type , iter_type , ios_base & , ios_base :: iostate & , 
long double &) const ; 


virtual iter_type 
do_get (iter_type , iter_type , ios_base & , ios_base :: iostate & , void * &) const ; 
# 2274 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
} ;

template < typename _CharT, typename _InIter >
    locale :: id num_get < _CharT, _InIter > :: id;
# 2292 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
template < typename _CharT , typename _OutIter > 
class num_put : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef _OutIter iter_type ; 



static locale :: id id ; 
# 2313 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
explicit 
num_put (size_t __refs = 0) : facet (__refs) { } 
# 2331 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , bool __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 
# 2373 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , long __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 

iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , 
unsigned long __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 


iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , long long __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 

iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , 
unsigned long long __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 
# 2436 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , double __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 

iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , 
long double __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 
# 2461 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , 
const void * __v) const 
{ return this -> do_put (__s , __io , __fill , __v) ; } 

protected : 
template < typename _ValueT > 
iter_type 
_M_insert_float (iter_type , ios_base & __io , char_type __fill , 
char __mod , _ValueT __v) const ; 

void 
_M_group_float (const char * __grouping , size_t __grouping_size , 
char_type __sep , const char_type * __p , char_type * __new , 
char_type * __cs , int & __len) const ; 

template < typename _ValueT > 
iter_type 
_M_insert_int (iter_type , ios_base & __io , char_type __fill , 
_ValueT __v) const ; 

void 
_M_group_int (const char * __grouping , size_t __grouping_size , 
char_type __sep , ios_base & __io , char_type * __new , 
char_type * __cs , int & __len) const ; 

void 
_M_pad (char_type __fill , streamsize __w , ios_base & __io , 
char_type * __new , const char_type * __cs , int & __len) const ; 


virtual 
~ num_put () { } 
# 2509 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.h" 3
virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , bool __v) const ; 

virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , long __v) const 
{ return _M_insert_int (__s , __io , __fill , __v) ; } 

virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , 
unsigned long __v) const 
{ return _M_insert_int (__s , __io , __fill , __v) ; } 


virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , 
long long __v) const 
{ return _M_insert_int (__s , __io , __fill , __v) ; } 

virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , 
unsigned long long __v) const 
{ return _M_insert_int (__s , __io , __fill , __v) ; } 


virtual iter_type 
do_put (iter_type , ios_base & , char_type , double) const ; 
# 2541
virtual iter_type 
do_put (iter_type , ios_base & , char_type , long double) const ; 


virtual iter_type 
do_put (iter_type , ios_base & , char_type , const void *) const ; 
# 2554
} ;

template < typename _CharT, typename _OutIter >
    locale :: id num_put < _CharT, _OutIter > :: id;
# 2567
template < typename _CharT > 
inline bool 
isspace (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: space , __c) ; } 


template < typename _CharT > 
inline bool 
isprint (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: print , __c) ; } 


template < typename _CharT > 
inline bool 
iscntrl (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: cntrl , __c) ; } 


template < typename _CharT > 
inline bool 
isupper (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: upper , __c) ; } 


template < typename _CharT > 
inline bool 
islower (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: lower , __c) ; } 


template < typename _CharT > 
inline bool 
isalpha (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: alpha , __c) ; } 


template < typename _CharT > 
inline bool 
isdigit (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: digit , __c) ; } 


template < typename _CharT > 
inline bool 
ispunct (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: punct , __c) ; } 


template < typename _CharT > 
inline bool 
isxdigit (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: xdigit , __c) ; } 


template < typename _CharT > 
inline bool 
isalnum (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: alnum , __c) ; } 


template < typename _CharT > 
inline bool 
isgraph (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: graph , __c) ; } 



template < typename _CharT > 
inline bool 
isblank (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . is (ctype_base :: blank , __c) ; } 



template < typename _CharT > 
inline _CharT 
toupper (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . toupper (__c) ; } 


template < typename _CharT > 
inline _CharT 
tolower (_CharT __c , const locale & __loc) 
{ return use_facet < ctype < _CharT > > (__loc) . tolower (__c) ; } 


}
# 35 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
namespace std { 
# 41
template < typename _Facet > 
struct __use_cache 
{ 
const _Facet * 
operator () (const locale & __loc) const ; 
} ;


template < typename _CharT > 
struct __use_cache < __numpunct_cache < _CharT > > 
{ 
const __numpunct_cache < _CharT > * 
operator () (const locale & __loc) const 
{ 
const size_t __i = numpunct < _CharT > :: id . _M_id () ; 
const locale :: facet * * __caches = __loc . _M_impl -> _M_caches ; 
if (! __caches [ __i ]) 
{ 
__numpunct_cache < _CharT > * __tmp = 0 ; 
try 
{ 
__tmp = new __numpunct_cache < _CharT > ; 
__tmp -> _M_cache (__loc) ; 
} 
catch (...) 
{ 
delete __tmp ; 
throw ; 
} 
__loc . _M_impl -> _M_install_cache (__tmp , __i) ; 
} 
return static_cast < const __numpunct_cache < _CharT > * > (__caches [ __i ]) ; 
} 
} ;

template < typename _CharT > 
void 
__numpunct_cache < _CharT > :: _M_cache (const locale & __loc) 
{ 
const numpunct < _CharT > & __np = use_facet < numpunct < _CharT > > (__loc) ; 

char * __grouping = 0 ; 
_CharT * __truename = 0 ; 
_CharT * __falsename = 0 ; 
try 
{ 
const string & __g = __np . grouping () ; 
_M_grouping_size = __g . size () ; 
__grouping = new char [ _M_grouping_size ] ; 
__g . copy (__grouping , _M_grouping_size) ; 
_M_use_grouping = (_M_grouping_size 
&& static_cast < signed char > (__grouping [ 0 ]) > 0 
&& (__grouping [ 0 ] 
!= __gnu_cxx :: __numeric_traits < char > :: __max)) ; 

const basic_string < _CharT > & __tn = __np . truename () ; 
_M_truename_size = __tn . size () ; 
__truename = new _CharT [ _M_truename_size ] ; 
__tn . copy (__truename , _M_truename_size) ; 

const basic_string < _CharT > & __fn = __np . falsename () ; 
_M_falsename_size = __fn . size () ; 
__falsename = new _CharT [ _M_falsename_size ] ; 
__fn . copy (__falsename , _M_falsename_size) ; 

_M_decimal_point = __np . decimal_point () ; 
_M_thousands_sep = __np . thousands_sep () ; 

const ctype < _CharT > & __ct = use_facet < ctype < _CharT > > (__loc) ; 
__ct . widen (__num_base :: _S_atoms_out , 
__num_base :: _S_atoms_out 
+ __num_base :: _S_oend , _M_atoms_out) ; 
__ct . widen (__num_base :: _S_atoms_in , 
__num_base :: _S_atoms_in 
+ __num_base :: _S_iend , _M_atoms_in) ; 

_M_grouping = __grouping ; 
_M_truename = __truename ; 
_M_falsename = __falsename ; 
_M_allocated = true ; 
} 
catch (...) 
{ 
delete [ ] __grouping ; 
delete [ ] __truename ; 
delete [ ] __falsename ; 
throw ; 
} 
} 
# 140 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
__attribute((__pure__)) bool __verify_grouping(const char * __grouping, size_t __grouping_size, const string & __grouping_tmp) throw(); 




template < typename _CharT , typename _InIter > 
__attribute ((__abi_tag__ ("cxx11"))) 
_InIter 
num_get < _CharT , _InIter > :: 
_M_extract_float (_InIter __beg , _InIter __end , ios_base & __io , 
ios_base :: iostate & __err , string & __xtrc) const 
{ 
typedef char_traits < _CharT > __traits_type ; 
typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 
const _CharT * __lit = __lc -> _M_atoms_in ; 
char_type __c = char_type () ; 


bool __testeof = __beg == __end ; 


if (! __testeof) 
{ 
__c = * __beg ; 
const bool __plus = __c == __lit [ __num_base :: _S_iplus ] ; 
if ((__plus || __c == __lit [ __num_base :: _S_iminus ]) 
&& ! (__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
&& ! (__c == __lc -> _M_decimal_point)) 
{ 
__xtrc += __plus ? '+' : '-' ; 
if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 
} 


bool __found_mantissa = false ; 
int __sep_pos = 0 ; 
while (! __testeof) 
{ 
if ((__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
|| __c == __lc -> _M_decimal_point) 
break ; 
else if (__c == __lit [ __num_base :: _S_izero ]) 
{ 
if (! __found_mantissa) 
{ 
__xtrc += '0' ; 
__found_mantissa = true ; 
} 
++ __sep_pos ; 

if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 
else 
break ; 
} 


bool __found_dec = false ; 
bool __found_sci = false ; 
string __found_grouping ; 
if (__lc -> _M_use_grouping) 
__found_grouping . reserve (32) ; 
const char_type * __lit_zero = __lit + __num_base :: _S_izero ; 

if (! __lc -> _M_allocated) 

while (! __testeof) 
{ 
const int __digit = _M_find (__lit_zero , 10 , __c) ; 
if (__digit != - 1) 
{ 
__xtrc += '0' + __digit ; 
__found_mantissa = true ; 
} 
else if (__c == __lc -> _M_decimal_point 
&& ! __found_dec && ! __found_sci) 
{ 
__xtrc += '.' ; 
__found_dec = true ; 
} 
else if ((__c == __lit [ __num_base :: _S_ie ] 
|| __c == __lit [ __num_base :: _S_iE ]) 
&& ! __found_sci && __found_mantissa) 
{ 

__xtrc += 'e' ; 
__found_sci = true ; 


if (++ __beg != __end) 
{ 
__c = * __beg ; 
const bool __plus = __c == __lit [ __num_base :: _S_iplus ] ; 
if (__plus || __c == __lit [ __num_base :: _S_iminus ]) 
__xtrc += __plus ? '+' : '-' ; 
else 
continue ; 
} 
else 
{ 
__testeof = true ; 
break ; 
} 
} 
else 
break ; 

if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 
else 
while (! __testeof) 
{ 


if (__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
{ 
if (! __found_dec && ! __found_sci) 
{ 


if (__sep_pos) 
{ 
__found_grouping += static_cast < char > (__sep_pos) ; 
__sep_pos = 0 ; 
} 
else 
{ 


__xtrc . clear () ; 
break ; 
} 
} 
else 
break ; 
} 
else if (__c == __lc -> _M_decimal_point) 
{ 
if (! __found_dec && ! __found_sci) 
{ 



if (__found_grouping . size ()) 
__found_grouping += static_cast < char > (__sep_pos) ; 
__xtrc += '.' ; 
__found_dec = true ; 
} 
else 
break ; 
} 
else 
{ 
const char_type * __q = 
__traits_type :: find (__lit_zero , 10 , __c) ; 
if (__q) 
{ 
__xtrc += '0' + (__q - __lit_zero) ; 
__found_mantissa = true ; 
++ __sep_pos ; 
} 
else if ((__c == __lit [ __num_base :: _S_ie ] 
|| __c == __lit [ __num_base :: _S_iE ]) 
&& ! __found_sci && __found_mantissa) 
{ 

if (__found_grouping . size () && ! __found_dec) 
__found_grouping += static_cast < char > (__sep_pos) ; 
__xtrc += 'e' ; 
__found_sci = true ; 


if (++ __beg != __end) 
{ 
__c = * __beg ; 
const bool __plus = __c == __lit [ __num_base :: _S_iplus ] ; 
if ((__plus || __c == __lit [ __num_base :: _S_iminus ]) 
&& ! (__lc -> _M_use_grouping 
&& __c == __lc -> _M_thousands_sep) 
&& ! (__c == __lc -> _M_decimal_point)) 
__xtrc += __plus ? '+' : '-' ; 
else 
continue ; 
} 
else 
{ 
__testeof = true ; 
break ; 
} 
} 
else 
break ; 
} 

if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 



if (__found_grouping . size ()) 
{ 

if (! __found_dec && ! __found_sci) 
__found_grouping += static_cast < char > (__sep_pos) ; 

if (! std :: __verify_grouping (__lc -> _M_grouping , 
__lc -> _M_grouping_size , 
__found_grouping)) 
__err = ios_base :: failbit ; 
} 

return __beg ; 
} 

template < typename _CharT , typename _InIter > 
template < typename _ValueT > 
__attribute ((__abi_tag__ ("cxx11"))) 
_InIter 
num_get < _CharT , _InIter > :: 
_M_extract_int (_InIter __beg , _InIter __end , ios_base & __io , 
ios_base :: iostate & __err , _ValueT & __v) const 
{ 
typedef char_traits < _CharT > __traits_type ; 
using __gnu_cxx :: __add_unsigned ; 
typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type ; 
typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 
const _CharT * __lit = __lc -> _M_atoms_in ; 
char_type __c = char_type () ; 


const ios_base :: fmtflags __basefield = __io . flags () 
& ios_base :: basefield ; 
const bool __oct = __basefield == ios_base :: oct ; 
int __base = __oct ? 8 : (__basefield == ios_base :: hex ? 16 : 10) ; 


bool __testeof = __beg == __end ; 


bool __negative = false ; 
if (! __testeof) 
{ 
__c = * __beg ; 
__negative = __c == __lit [ __num_base :: _S_iminus ] ; 
if ((__negative || __c == __lit [ __num_base :: _S_iplus ]) 
&& ! (__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
&& ! (__c == __lc -> _M_decimal_point)) 
{ 
if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 
} 



bool __found_zero = false ; 
int __sep_pos = 0 ; 
while (! __testeof) 
{ 
if ((__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
|| __c == __lc -> _M_decimal_point) 
break ; 
else if (__c == __lit [ __num_base :: _S_izero ] 
&& (! __found_zero || __base == 10)) 
{ 
__found_zero = true ; 
++ __sep_pos ; 
if (__basefield == 0) 
__base = 8 ; 
if (__base == 8) 
__sep_pos = 0 ; 
} 
else if (__found_zero 
&& (__c == __lit [ __num_base :: _S_ix ] 
|| __c == __lit [ __num_base :: _S_iX ])) 
{ 
if (__basefield == 0) 
__base = 16 ; 
if (__base == 16) 
{ 
__found_zero = false ; 
__sep_pos = 0 ; 
} 
else 
break ; 
} 
else 
break ; 

if (++ __beg != __end) 
{ 
__c = * __beg ; 
if (! __found_zero) 
break ; 
} 
else 
__testeof = true ; 
} 



const size_t __len = (__base == 16 ? __num_base :: _S_iend 
- __num_base :: _S_izero : __base) ; 


typedef __gnu_cxx :: __numeric_traits < _ValueT > __num_traits ; 
string __found_grouping ; 
if (__lc -> _M_use_grouping) 
__found_grouping . reserve (32) ; 
bool __testfail = false ; 
bool __testoverflow = false ; 
const __unsigned_type __max = 
(__negative && __num_traits :: __is_signed) 
? - static_cast < __unsigned_type > (__num_traits :: __min) 
: __num_traits :: __max ; 
const __unsigned_type __smax = __max / __base ; 
__unsigned_type __result = 0 ; 
int __digit = 0 ; 
const char_type * __lit_zero = __lit + __num_base :: _S_izero ; 

if (! __lc -> _M_allocated) 

while (! __testeof) 
{ 
__digit = _M_find (__lit_zero , __len , __c) ; 
if (__digit == - 1) 
break ; 

if (__result > __smax) 
__testoverflow = true ; 
else 
{ 
__result *= __base ; 
__testoverflow |= __result > __max - __digit ; 
__result += __digit ; 
++ __sep_pos ; 
} 

if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 
else 
while (! __testeof) 
{ 


if (__lc -> _M_use_grouping && __c == __lc -> _M_thousands_sep) 
{ 


if (__sep_pos) 
{ 
__found_grouping += static_cast < char > (__sep_pos) ; 
__sep_pos = 0 ; 
} 
else 
{ 
__testfail = true ; 
break ; 
} 
} 
else if (__c == __lc -> _M_decimal_point) 
break ; 
else 
{ 
const char_type * __q = 
__traits_type :: find (__lit_zero , __len , __c) ; 
if (! __q) 
break ; 

__digit = __q - __lit_zero ; 
if (__digit > 15) 
__digit -= 6 ; 
if (__result > __smax) 
__testoverflow = true ; 
else 
{ 
__result *= __base ; 
__testoverflow |= __result > __max - __digit ; 
__result += __digit ; 
++ __sep_pos ; 
} 
} 

if (++ __beg != __end) 
__c = * __beg ; 
else 
__testeof = true ; 
} 



if (__found_grouping . size ()) 
{ 

__found_grouping += static_cast < char > (__sep_pos) ; 

if (! std :: __verify_grouping (__lc -> _M_grouping , 
__lc -> _M_grouping_size , 
__found_grouping)) 
__err = ios_base :: failbit ; 
} 



if ((! __sep_pos && ! __found_zero && ! __found_grouping . size ()) 
|| __testfail) 
{ 
__v = 0 ; 
__err = ios_base :: failbit ; 
} 
else if (__testoverflow) 
{ 
if (__negative && __num_traits :: __is_signed) 
__v = __num_traits :: __min ; 
else 
__v = __num_traits :: __max ; 
__err = ios_base :: failbit ; 
} 
else 
__v = __negative ? - __result : __result ; 

if (__testeof) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 



template < typename _CharT , typename _InIter > 
_InIter 
num_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , bool & __v) const 
{ 
if (! (__io . flags () & ios_base :: boolalpha)) 
{ 



long __l = - 1 ; 
__beg = _M_extract_int (__beg , __end , __io , __err , __l) ; 
if (__l == 0 || __l == 1) 
__v = bool (__l) ; 
else 
{ 


__v = true ; 
__err = ios_base :: failbit ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
} 
} 
else 
{ 

typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 

bool __testf = true ; 
bool __testt = true ; 
bool __donef = __lc -> _M_falsename_size == 0 ; 
bool __donet = __lc -> _M_truename_size == 0 ; 
bool __testeof = false ; 
size_t __n = 0 ; 
while (! __donef || ! __donet) 
{ 
if (__beg == __end) 
{ 
__testeof = true ; 
break ; 
} 

const char_type __c = * __beg ; 

if (! __donef) 
__testf = __c == __lc -> _M_falsename [ __n ] ; 

if (! __testf && __donet) 
break ; 

if (! __donet) 
__testt = __c == __lc -> _M_truename [ __n ] ; 

if (! __testt && __donef) 
break ; 

if (! __testt && ! __testf) 
break ; 

++ __n ; 
++ __beg ; 

__donef = ! __testf || __n >= __lc -> _M_falsename_size ; 
__donet = ! __testt || __n >= __lc -> _M_truename_size ; 
} 
if (__testf && __n == __lc -> _M_falsename_size && __n) 
{ 
__v = false ; 
if (__testt && __n == __lc -> _M_truename_size) 
__err = ios_base :: failbit ; 
else 
__err = __testeof ? ios_base :: eofbit : ios_base :: goodbit ; 
} 
else if (__testt && __n == __lc -> _M_truename_size && __n) 
{ 
__v = true ; 
__err = __testeof ? ios_base :: eofbit : ios_base :: goodbit ; 
} 
else 
{ 


__v = false ; 
__err = ios_base :: failbit ; 
if (__testeof) 
__err |= ios_base :: eofbit ; 
} 
} 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
num_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , float & __v) const 
{ 
string __xtrc ; 
__xtrc . reserve (32) ; 
__beg = _M_extract_float (__beg , __end , __io , __err , __xtrc) ; 
std :: __convert_to_v (__xtrc . c_str () , __v , __err , _S_get_c_locale ()) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
num_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , double & __v) const 
{ 
string __xtrc ; 
__xtrc . reserve (32) ; 
__beg = _M_extract_float (__beg , __end , __io , __err , __xtrc) ; 
std :: __convert_to_v (__xtrc . c_str () , __v , __err , _S_get_c_locale ()) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 
# 735 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
template < typename _CharT , typename _InIter > 
_InIter 
num_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , long double & __v) const 
{ 
string __xtrc ; 
__xtrc . reserve (32) ; 
__beg = _M_extract_float (__beg , __end , __io , __err , __xtrc) ; 
std :: __convert_to_v (__xtrc . c_str () , __v , __err , _S_get_c_locale ()) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
num_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , void * & __v) const 
{ 

typedef ios_base :: fmtflags fmtflags ; 
const fmtflags __fmt = __io . flags () ; 
__io . flags ((__fmt & ~ ios_base :: basefield) | ios_base :: hex) ; 

typedef __gnu_cxx :: __conditional_type < (sizeof (void *) 
<= sizeof (unsigned long)) , 
unsigned long , unsigned long long > :: __type _UIntPtrType ; 

_UIntPtrType __ul ; 
__beg = _M_extract_int (__beg , __end , __io , __err , __ul) ; 


__io . flags (__fmt) ; 

__v = reinterpret_cast < void * > (__ul) ; 
return __beg ; 
} 



template < typename _CharT , typename _OutIter > 
void 
num_put < _CharT , _OutIter > :: 
_M_pad (_CharT __fill , streamsize __w , ios_base & __io , 
_CharT * __new , const _CharT * __cs , int & __len) const 
{ 


__pad < _CharT , char_traits < _CharT > > :: _S_pad (__io , __fill , __new , 
__cs , __w , __len) ; 
__len = static_cast < int > (__w) ; 
} 



template < typename _CharT , typename _ValueT > 
int 
__int_to_char (_CharT * __bufend , _ValueT __v , const _CharT * __lit , 
ios_base :: fmtflags __flags , bool __dec) 
{ 
_CharT * __buf = __bufend ; 
if (__builtin_expect (__dec , true)) 
{ 

do 
{ 
* -- __buf = __lit [ (__v % 10) + __num_base :: _S_odigits ] ; 
__v /= 10 ; 
} 
while (__v != 0) ; 
} 
else if ((__flags & ios_base :: basefield) == ios_base :: oct) 
{ 

do 
{ 
* -- __buf = __lit [ (__v & 0x7) + __num_base :: _S_odigits ] ; 
__v >>= 3 ; 
} 
while (__v != 0) ; 
} 
else 
{ 

const bool __uppercase = __flags & ios_base :: uppercase ; 
const int __case_offset = __uppercase ? __num_base :: _S_oudigits 
: __num_base :: _S_odigits ; 
do 
{ 
* -- __buf = __lit [ (__v & 0xf) + __case_offset ] ; 
__v >>= 4 ; 
} 
while (__v != 0) ; 
} 
return __bufend - __buf ; 
} 



template < typename _CharT , typename _OutIter > 
void 
num_put < _CharT , _OutIter > :: 
_M_group_int (const char * __grouping , size_t __grouping_size , _CharT __sep , 
ios_base & , _CharT * __new , _CharT * __cs , int & __len) const 
{ 
_CharT * __p = std :: __add_grouping (__new , __sep , __grouping , 
__grouping_size , __cs , __cs + __len) ; 
__len = __p - __new ; 
} 

template < typename _CharT , typename _OutIter > 
template < typename _ValueT > 
_OutIter 
num_put < _CharT , _OutIter > :: 
_M_insert_int (_OutIter __s , ios_base & __io , _CharT __fill , 
_ValueT __v) const 
{ 
using __gnu_cxx :: __add_unsigned ; 
typedef typename __add_unsigned < _ValueT > :: __type __unsigned_type ; 
typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 
const _CharT * __lit = __lc -> _M_atoms_out ; 
const ios_base :: fmtflags __flags = __io . flags () ; 


const int __ilen = 5 * sizeof (_ValueT) ; 
_CharT * __cs = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __ilen)) ; 



const ios_base :: fmtflags __basefield = __flags & ios_base :: basefield ; 
const bool __dec = (__basefield != ios_base :: oct 
&& __basefield != ios_base :: hex) ; 
const __unsigned_type __u = ((__v > 0 || ! __dec) 
? __unsigned_type (__v) 
: - __unsigned_type (__v)) ; 
int __len = __int_to_char (__cs + __ilen , __u , __lit , __flags , __dec) ; 
__cs += __ilen - __len ; 


if (__lc -> _M_use_grouping) 
{ 


_CharT * __cs2 = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* (__len + 1) 
* 2)) ; 
_M_group_int (__lc -> _M_grouping , __lc -> _M_grouping_size , 
__lc -> _M_thousands_sep , __io , __cs2 + 2 , __cs , __len) ; 
__cs = __cs2 + 2 ; 
} 


if (__builtin_expect (__dec , true)) 
{ 

if (__v >= 0) 
{ 
if (bool (__flags & ios_base :: showpos) 
&& __gnu_cxx :: __numeric_traits < _ValueT > :: __is_signed) 
* -- __cs = __lit [ __num_base :: _S_oplus ] , ++ __len ; 
} 
else 
* -- __cs = __lit [ __num_base :: _S_ominus ] , ++ __len ; 
} 
else if (bool (__flags & ios_base :: showbase) && __v) 
{ 
if (__basefield == ios_base :: oct) 
* -- __cs = __lit [ __num_base :: _S_odigits ] , ++ __len ; 
else 
{ 

const bool __uppercase = __flags & ios_base :: uppercase ; 
* -- __cs = __lit [ __num_base :: _S_ox + __uppercase ] ; 

* -- __cs = __lit [ __num_base :: _S_odigits ] ; 
__len += 2 ; 
} 
} 


const streamsize __w = __io . width () ; 
if (__w > static_cast < streamsize > (__len)) 
{ 
_CharT * __cs3 = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __w)) ; 
_M_pad (__fill , __w , __io , __cs3 , __cs , __len) ; 
__cs = __cs3 ; 
} 
__io . width (0) ; 



return std :: __write (__s , __cs , __len) ; 
} 

template < typename _CharT , typename _OutIter > 
void 
num_put < _CharT , _OutIter > :: 
_M_group_float (const char * __grouping , size_t __grouping_size , 
_CharT __sep , const _CharT * __p , _CharT * __new , 
_CharT * __cs , int & __len) const 
{ 



const int __declen = __p ? __p - __cs : __len ; 
_CharT * __p2 = std :: __add_grouping (__new , __sep , __grouping , 
__grouping_size , 
__cs , __cs + __declen) ; 


int __newlen = __p2 - __new ; 
if (__p) 
{ 
char_traits < _CharT > :: copy (__p2 , __p , __len - __declen) ; 
__newlen += __len - __declen ; 
} 
__len = __newlen ; 
} 
# 971 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
template < typename _CharT , typename _OutIter > 
template < typename _ValueT > 
_OutIter 
num_put < _CharT , _OutIter > :: 
_M_insert_float (_OutIter __s , ios_base & __io , _CharT __fill , char __mod , 
_ValueT __v) const 
{ 
typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 


const streamsize __prec = __io . precision () < 0 ? 6 : __io . precision () ; 

const int __max_digits = 
__gnu_cxx :: __numeric_traits < _ValueT > :: __digits10 ; 


int __len ; 

char __fbuf [ 16 ] ; 
__num_base :: _S_format_float (__io , __fbuf , __mod) ; 



const bool __use_prec = 
(__io . flags () & ios_base :: floatfield) != ios_base :: floatfield ; 



int __cs_size = __max_digits * 3 ; 
char * __cs = static_cast < char * > (__builtin_alloca (__cs_size)) ; 
if (__use_prec) 
__len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
__fbuf , __prec , __v) ; 
else 
__len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
__fbuf , __v) ; 


if (__len >= __cs_size) 
{ 
__cs_size = __len + 1 ; 
__cs = static_cast < char * > (__builtin_alloca (__cs_size)) ; 
if (__use_prec) 
__len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
__fbuf , __prec , __v) ; 
else 
__len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
__fbuf , __v) ; 
} 
# 1044 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

_CharT * __ws = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __len)) ; 
__ctype . widen (__cs , __cs + __len , __ws) ; 


_CharT * __wp = 0 ; 
const char * __p = char_traits < char > :: find (__cs , __len , '.') ; 
if (__p) 
{ 
__wp = __ws + (__p - __cs) ; 
* __wp = __lc -> _M_decimal_point ; 
} 




if (__lc -> _M_use_grouping 
&& (__wp || __len < 3 || (__cs [ 1 ] <= '9' && __cs [ 2 ] <= '9' 
&& __cs [ 1 ] >= '0' && __cs [ 2 ] >= '0'))) 
{ 


_CharT * __ws2 = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __len * 2)) ; 

streamsize __off = 0 ; 
if (__cs [ 0 ] == '-' || __cs [ 0 ] == '+') 
{ 
__off = 1 ; 
__ws2 [ 0 ] = __ws [ 0 ] ; 
__len -= 1 ; 
} 

_M_group_float (__lc -> _M_grouping , __lc -> _M_grouping_size , 
__lc -> _M_thousands_sep , __wp , __ws2 + __off , 
__ws + __off , __len) ; 
__len += __off ; 

__ws = __ws2 ; 
} 


const streamsize __w = __io . width () ; 
if (__w > static_cast < streamsize > (__len)) 
{ 
_CharT * __ws3 = static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __w)) ; 
_M_pad (__fill , __w , __io , __ws3 , __ws , __len) ; 
__ws = __ws3 ; 
} 
__io . width (0) ; 



return std :: __write (__s , __ws , __len) ; 
} 

template < typename _CharT , typename _OutIter > 
_OutIter 
num_put < _CharT , _OutIter > :: 
do_put (iter_type __s , ios_base & __io , char_type __fill , bool __v) const 
{ 
const ios_base :: fmtflags __flags = __io . flags () ; 
if ((__flags & ios_base :: boolalpha) == 0) 
{ 
const long __l = __v ; 
__s = _M_insert_int (__s , __io , __fill , __l) ; 
} 
else 
{ 
typedef __numpunct_cache < _CharT > __cache_type ; 
__use_cache < __cache_type > __uc ; 
const locale & __loc = __io . _M_getloc () ; 
const __cache_type * __lc = __uc (__loc) ; 

const _CharT * __name = __v ? __lc -> _M_truename 
: __lc -> _M_falsename ; 
int __len = __v ? __lc -> _M_truename_size 
: __lc -> _M_falsename_size ; 

const streamsize __w = __io . width () ; 
if (__w > static_cast < streamsize > (__len)) 
{ 
const streamsize __plen = __w - __len ; 
_CharT * __ps 
= static_cast < _CharT * > (__builtin_alloca (sizeof (_CharT) 
* __plen)) ; 

char_traits < _CharT > :: assign (__ps , __plen , __fill) ; 
__io . width (0) ; 

if ((__flags & ios_base :: adjustfield) == ios_base :: left) 
{ 
__s = std :: __write (__s , __name , __len) ; 
__s = std :: __write (__s , __ps , __plen) ; 
} 
else 
{ 
__s = std :: __write (__s , __ps , __plen) ; 
__s = std :: __write (__s , __name , __len) ; 
} 
return __s ; 
} 
__io . width (0) ; 
__s = std :: __write (__s , __name , __len) ; 
} 
return __s ; 
} 

template < typename _CharT , typename _OutIter > 
_OutIter 
num_put < _CharT , _OutIter > :: 
do_put (iter_type __s , ios_base & __io , char_type __fill , double __v) const 
{ return _M_insert_float (__s , __io , __fill , char () , __v) ; } 
# 1169 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
template < typename _CharT , typename _OutIter > 
_OutIter 
num_put < _CharT , _OutIter > :: 
do_put (iter_type __s , ios_base & __io , char_type __fill , 
long double __v) const 
{ return _M_insert_float (__s , __io , __fill , 'L' , __v) ; } 

template < typename _CharT , typename _OutIter > 
_OutIter 
num_put < _CharT , _OutIter > :: 
do_put (iter_type __s , ios_base & __io , char_type __fill , 
const void * __v) const 
{ 
const ios_base :: fmtflags __flags = __io . flags () ; 
const ios_base :: fmtflags __fmt = ~ (ios_base :: basefield 
| ios_base :: uppercase) ; 
__io . flags ((__flags & __fmt) | (ios_base :: hex | ios_base :: showbase)) ; 

typedef __gnu_cxx :: __conditional_type < (sizeof (const void *) 
<= sizeof (unsigned long)) , 
unsigned long , unsigned long long > :: __type _UIntPtrType ; 

__s = _M_insert_int (__s , __io , __fill , 
reinterpret_cast < _UIntPtrType > (__v)) ; 
__io . flags (__flags) ; 
return __s ; 
} 
# 1206 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets.tcc" 3
template < typename _CharT , typename _Traits > 
void 
__pad < _CharT , _Traits > :: _S_pad (ios_base & __io , _CharT __fill , 
_CharT * __news , const _CharT * __olds , 
streamsize __newlen , streamsize __oldlen) 
{ 
const size_t __plen = static_cast < size_t > (__newlen - __oldlen) ; 
const ios_base :: fmtflags __adjust = __io . flags () & ios_base :: adjustfield ; 


if (__adjust == ios_base :: left) 
{ 
_Traits :: copy (__news , __olds , __oldlen) ; 
_Traits :: assign (__news + __oldlen , __plen , __fill) ; 
return ; 
} 

size_t __mod = 0 ; 
if (__adjust == ios_base :: internal) 
{ 



const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

if (__ctype . widen ('-') == __olds [ 0 ] 
|| __ctype . widen ('+') == __olds [ 0 ]) 
{ 
__news [ 0 ] = __olds [ 0 ] ; 
__mod = 1 ; 
++ __news ; 
} 
else if (__ctype . widen ('0') == __olds [ 0 ] 
&& __oldlen > 1 
&& (__ctype . widen ('x') == __olds [ 1 ] 
|| __ctype . widen ('X') == __olds [ 1 ])) 
{ 
__news [ 0 ] = __olds [ 0 ] ; 
__news [ 1 ] = __olds [ 1 ] ; 
__mod = 2 ; 
__news += 2 ; 
} 

} 
_Traits :: assign (__news , __plen , __fill) ; 
_Traits :: copy (__news + __plen , __olds + __mod , __oldlen - __mod) ; 
} 

template < typename _CharT > 
_CharT * 
__add_grouping (_CharT * __s , _CharT __sep , 
const char * __gbeg , size_t __gsize , 
const _CharT * __first , const _CharT * __last) 
{ 
size_t __idx = 0 ; 
size_t __ctr = 0 ; 

while (__last - __first > __gbeg [ __idx ] 
&& static_cast < signed char > (__gbeg [ __idx ]) > 0 
&& __gbeg [ __idx ] != __gnu_cxx :: __numeric_traits < char > :: __max) 
{ 
__last -= __gbeg [ __idx ] ; 
__idx < __gsize - 1 ? ++ __idx : ++ __ctr ; 
} 

while (__first != __last) 
* __s ++ = * __first ++ ; 

while (__ctr --) 
{ 
* __s ++ = __sep ; 
for (char __i = __gbeg [ __idx ] ; __i > 0 ; -- __i) 
* __s ++ = * __first ++ ; 
} 

while (__idx --) 
{ 
* __s ++ = __sep ; 
for (char __i = __gbeg [ __idx ] ; __i > 0 ; -- __i) 
* __s ++ = * __first ++ ; 
} 

return __s ; 
} 




extern template class __cxx11::numpunct< char> ;
extern template class __cxx11::numpunct_byname< char> ;
extern template class num_get< char> ;
extern template class num_put< char> ;


extern template const ctype< char>  &use_facet< ctype< char> > (const locale &);



extern template const __cxx11::numpunct< char>  &use_facet< __cxx11::numpunct< char> > (const locale &);



extern template const num_put< char>  &use_facet< num_put< char> > (const locale &);



extern template const num_get< char>  &use_facet< num_get< char> > (const locale &);



extern template bool has_facet< ctype< char> > (const locale &) throw();



extern template bool has_facet< __cxx11::numpunct< char> > (const locale &) throw();



extern template bool has_facet< num_put< char> > (const locale &) throw();



extern template bool has_facet< num_get< char> > (const locale &) throw();




extern template class __cxx11::numpunct< wchar_t> ;
extern template class __cxx11::numpunct_byname< wchar_t> ;
extern template class num_get< wchar_t> ;
extern template class num_put< wchar_t> ;


extern template const ctype< wchar_t>  &use_facet< ctype< wchar_t> > (const locale &);



extern template const __cxx11::numpunct< wchar_t>  &use_facet< __cxx11::numpunct< wchar_t> > (const locale &);



extern template const num_put< wchar_t>  &use_facet< num_put< wchar_t> > (const locale &);



extern template const num_get< wchar_t>  &use_facet< num_get< wchar_t> > (const locale &);



extern template bool has_facet< ctype< wchar_t> > (const locale &) throw();



extern template bool has_facet< __cxx11::numpunct< wchar_t> > (const locale &) throw();



extern template bool has_facet< num_put< wchar_t> > (const locale &) throw();



extern template bool has_facet< num_get< wchar_t> > (const locale &) throw();
# 1375
}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
namespace std { 



template < typename _Facet > 
inline const _Facet & 
__check_facet (const _Facet * __f) 
{ 
if (! __f) 
__throw_bad_cast () ; 
return * __f ; 
} 
# 66 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
template < typename _CharT , typename _Traits > 
class basic_ios : public ios_base 
{ 
public : 
# 76
typedef _CharT char_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef typename _Traits :: pos_type pos_type ; 
typedef typename _Traits :: off_type off_type ; 
typedef _Traits traits_type ; 
# 87
typedef ctype < _CharT > __ctype_type ; 
typedef num_put < _CharT , ostreambuf_iterator < _CharT , _Traits > > 
__num_put_type ; 
typedef num_get < _CharT , istreambuf_iterator < _CharT , _Traits > > 
__num_get_type ; 



protected : 
basic_ostream < _CharT , _Traits > * _M_tie ; 
mutable char_type _M_fill ; 
mutable bool _M_fill_init ; 
basic_streambuf < _CharT , _Traits > * _M_streambuf ; 


const __ctype_type * _M_ctype ; 

const __num_put_type * _M_num_put ; 

const __num_get_type * _M_num_get ; 

public : 
# 117 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
explicit operator bool () const 
{ return ! this -> fail () ; } 
# 124
bool 
operator ! () const 
{ return this -> fail () ; } 
# 136 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
iostate 
rdstate () const 
{ return _M_streambuf_state ; } 
# 147 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
void 
clear (iostate __state = goodbit) ; 
# 156
void 
setstate (iostate __state) 
{ this -> clear (this -> rdstate () | __state) ; } 




void 
_M_setstate (iostate __state) 
{ 


_M_streambuf_state |= __state ; 
if (this -> exceptions () & __state) 
throw ; 
} 
# 179
bool 
good () const 
{ return this -> rdstate () == 0 ; } 
# 189
bool 
eof () const 
{ return (this -> rdstate () & eofbit) != 0 ; } 
# 200 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
bool 
fail () const 
{ return (this -> rdstate () & (badbit | failbit)) != 0 ; } 
# 210
bool 
bad () const 
{ return (this -> rdstate () & badbit) != 0 ; } 
# 221 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
iostate 
exceptions () const 
{ return _M_exception ; } 
# 256 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
void 
exceptions (iostate __except) 
{ 
_M_exception = __except ; 
this -> clear (_M_streambuf_state) ; 
} 
# 269
explicit 
basic_ios (basic_streambuf < _CharT , _Traits > * __sb) 
: ios_base () , _M_tie (0) , _M_fill () , _M_fill_init (false) , _M_streambuf (0) , 
_M_ctype (0) , _M_num_put (0) , _M_num_get (0) 
{ this -> init (__sb) ; } 
# 281
virtual 
~ basic_ios () { } 
# 294 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
basic_ostream < _CharT , _Traits > * 
tie () const 
{ return _M_tie ; } 
# 306 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
basic_ostream < _CharT , _Traits > * 
tie (basic_ostream < _CharT , _Traits > * __tiestr) 
{ 
basic_ostream < _CharT , _Traits > * __old = _M_tie ; 
_M_tie = __tiestr ; 
return __old ; 
} 
# 320
basic_streambuf < _CharT , _Traits > * 
rdbuf () const 
{ return _M_streambuf ; } 
# 346 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
basic_streambuf < _CharT , _Traits > * 
rdbuf (basic_streambuf < _CharT , _Traits > * __sb) ; 
# 360 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
basic_ios & 
copyfmt (const basic_ios & __rhs) ; 
# 369
char_type 
fill () const 
{ 
if (! _M_fill_init) 
{ 
_M_fill = this -> widen (' ') ; 
_M_fill_init = true ; 
} 
return _M_fill ; 
} 
# 389 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
char_type 
fill (char_type __ch) 
{ 
char_type __old = this -> fill () ; 
_M_fill = __ch ; 
return __old ; 
} 
# 409 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
locale 
imbue (const locale & __loc) ; 
# 429 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
char 
narrow (char_type __c , char __dfault) const 
{ return __check_facet (_M_ctype) . narrow (__c , __dfault) ; } 
# 448 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.h" 3
char_type 
widen (char __c) const 
{ return __check_facet (_M_ctype) . widen (__c) ; } 

protected : 
# 460
basic_ios () 
: ios_base () , _M_tie (0) , _M_fill (char_type ()) , _M_fill_init (false) , 
_M_streambuf (0) , _M_ctype (0) , _M_num_put (0) , _M_num_get (0) 
{ } 
# 471
void 
init (basic_streambuf < _CharT , _Traits > * __sb) ; 


basic_ios (const basic_ios &) = delete ; 
basic_ios & operator = (const basic_ios &) = delete ; 

void 
move (basic_ios & __rhs) 
{ 
ios_base :: _M_move (__rhs) ; 
_M_cache_locale (_M_ios_locale) ; 
this -> tie (__rhs . tie (nullptr)) ; 
_M_fill = __rhs . _M_fill ; 
_M_fill_init = __rhs . _M_fill_init ; 
_M_streambuf = nullptr ; 
} 

void 
move (basic_ios && __rhs) 
{ this -> move (__rhs) ; } 

void 
swap (basic_ios & __rhs) noexcept 
{ 
ios_base :: _M_swap (__rhs) ; 
_M_cache_locale (_M_ios_locale) ; 
__rhs . _M_cache_locale (__rhs . _M_ios_locale) ; 
std :: swap (_M_tie , __rhs . _M_tie) ; 
std :: swap (_M_fill , __rhs . _M_fill) ; 
std :: swap (_M_fill_init , __rhs . _M_fill_init) ; 
} 

void 
set_rdbuf (basic_streambuf < _CharT , _Traits > * __sb) 
{ _M_streambuf = __sb ; } 


void 
_M_cache_locale (const locale & __loc) ; 
} ;


}
# 35 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.tcc" 3
namespace std { 



template < typename _CharT , typename _Traits > 
void 
basic_ios < _CharT , _Traits > :: clear (iostate __state) 
{ 
if (this -> rdbuf ()) 
_M_streambuf_state = __state ; 
else 
_M_streambuf_state = __state | badbit ; 
if (this -> exceptions () & this -> rdstate ()) 
__throw_ios_failure (("basic_ios::clear")) ; 
} 

template < typename _CharT , typename _Traits > 
basic_streambuf < _CharT , _Traits > * 
basic_ios < _CharT , _Traits > :: rdbuf (basic_streambuf < _CharT , _Traits > * __sb) 
{ 
basic_streambuf < _CharT , _Traits > * __old = _M_streambuf ; 
_M_streambuf = __sb ; 
this -> clear () ; 
return __old ; 
} 

template < typename _CharT , typename _Traits > 
basic_ios < _CharT , _Traits > & 
basic_ios < _CharT , _Traits > :: copyfmt (const basic_ios & __rhs) 
{ 


if (this != & __rhs) 
{ 




_Words * __words = (__rhs . _M_word_size <= _S_local_word_size) ? 
_M_local_word : new _Words [ __rhs . _M_word_size ] ; 


_Callback_list * __cb = __rhs . _M_callbacks ; 
if (__cb) 
__cb -> _M_add_reference () ; 
_M_call_callbacks (erase_event) ; 
if (_M_word != _M_local_word) 
{ 
delete [ ] _M_word ; 
_M_word = 0 ; 
} 
_M_dispose_callbacks () ; 


_M_callbacks = __cb ; 
for (int __i = 0 ; __i < __rhs . _M_word_size ; ++ __i) 
__words [ __i ] = __rhs . _M_word [ __i ] ; 
_M_word = __words ; 
_M_word_size = __rhs . _M_word_size ; 

this -> flags (__rhs . flags ()) ; 
this -> width (__rhs . width ()) ; 
this -> precision (__rhs . precision ()) ; 
this -> tie (__rhs . tie ()) ; 
this -> fill (__rhs . fill ()) ; 
_M_ios_locale = __rhs . getloc () ; 
_M_cache_locale (_M_ios_locale) ; 

_M_call_callbacks (copyfmt_event) ; 


this -> exceptions (__rhs . exceptions ()) ; 
} 
return * this ; 
} 


template < typename _CharT , typename _Traits > 
locale 
basic_ios < _CharT , _Traits > :: imbue (const locale & __loc) 
{ 
locale __old (this -> getloc ()) ; 
ios_base :: imbue (__loc) ; 
_M_cache_locale (__loc) ; 
if (this -> rdbuf () != 0) 
this -> rdbuf () -> pubimbue (__loc) ; 
return __old ; 
} 

template < typename _CharT , typename _Traits > 
void 
basic_ios < _CharT , _Traits > :: init (basic_streambuf < _CharT , _Traits > * __sb) 
{ 

ios_base :: _M_init () ; 


_M_cache_locale (_M_ios_locale) ; 
# 146 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\basic_ios.tcc" 3
_M_fill = _CharT () ; 
_M_fill_init = false ; 

_M_tie = 0 ; 
_M_exception = goodbit ; 
_M_streambuf = __sb ; 
_M_streambuf_state = __sb ? goodbit : badbit ; 
} 

template < typename _CharT , typename _Traits > 
void 
basic_ios < _CharT , _Traits > :: _M_cache_locale (const locale & __loc) 
{ 
if (__builtin_expect (has_facet < __ctype_type > (__loc) , true)) 
_M_ctype = std :: __addressof (use_facet < __ctype_type > (__loc)) ; 
else 
_M_ctype = 0 ; 

if (__builtin_expect (has_facet < __num_put_type > (__loc) , true)) 
_M_num_put = std :: __addressof (use_facet < __num_put_type > (__loc)) ; 
else 
_M_num_put = 0 ; 

if (__builtin_expect (has_facet < __num_get_type > (__loc) , true)) 
_M_num_get = std :: __addressof (use_facet < __num_get_type > (__loc)) ; 
else 
_M_num_get = 0 ; 
} 




extern template class basic_ios< char> ;


extern template class basic_ios< wchar_t> ;




}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
namespace std { 
# 57 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT , typename _Traits > 
class basic_ostream : virtual public basic_ios < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef typename _Traits :: pos_type pos_type ; 
typedef typename _Traits :: off_type off_type ; 
typedef _Traits traits_type ; 


typedef basic_streambuf < _CharT , _Traits > __streambuf_type ; 
typedef basic_ios < _CharT , _Traits > __ios_type ; 
typedef basic_ostream < _CharT , _Traits > __ostream_type ; 
typedef num_put < _CharT , ostreambuf_iterator < _CharT , _Traits > > 
__num_put_type ; 
typedef ctype < _CharT > __ctype_type ; 
# 83 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
explicit 
basic_ostream (__streambuf_type * __sb) 
{ this -> init (__sb) ; } 
# 92
virtual 
~ basic_ostream () { } 


class sentry ; 
friend class sentry ; 
# 107 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
operator << (__ostream_type & (* __pf) (__ostream_type &)) 
{ 



return __pf (* this) ; 
} 

__ostream_type & 
operator << (__ios_type & (* __pf) (__ios_type &)) 
{ 



__pf (* this) ; 
return * this ; 
} 

__ostream_type & 
operator << (ios_base & (* __pf) (ios_base &)) 
{ 



__pf (* this) ; 
return * this ; 
} 
# 165 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
operator << (long __n) 
{ return _M_insert (__n) ; } 

__ostream_type & 
operator << (unsigned long __n) 
{ return _M_insert (__n) ; } 

__ostream_type & 
operator << (bool __n) 
{ return _M_insert (__n) ; } 

__ostream_type & 
operator << (short __n) ; 

__ostream_type & 
operator << (unsigned short __n) 
{ 


return _M_insert (static_cast < unsigned long > (__n)) ; 
} 

__ostream_type & 
operator << (int __n) ; 

__ostream_type & 
operator << (unsigned int __n) 
{ 


return _M_insert (static_cast < unsigned long > (__n)) ; 
} 


__ostream_type & 
operator << (long long __n) 
{ return _M_insert (__n) ; } 

__ostream_type & 
operator << (unsigned long long __n) 
{ return _M_insert (__n) ; } 
# 219 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
operator << (double __f) 
{ return _M_insert (__f) ; } 

__ostream_type & 
operator << (float __f) 
{ 


return _M_insert (static_cast < double > (__f)) ; 
} 

__ostream_type & 
operator << (long double __f) 
{ return _M_insert (__f) ; } 
# 244 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
operator << (const void * __p) 
{ return _M_insert (__p) ; } 
# 275 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
operator << (__streambuf_type * __sb) ; 
# 308 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
put (char_type __c) ; 
# 316
void 
_M_write (const char_type * __s , streamsize __n) 
{ 
const streamsize __put = this -> rdbuf () -> sputn (__s , __n) ; 
if (__put != __n) 
this -> setstate (ios_base :: badbit) ; 
} 
# 340 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
write (const char_type * __s , streamsize __n) ; 
# 353 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
flush () ; 
# 363 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
pos_type 
tellp () ; 
# 374 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
seekp (pos_type) ; 
# 386 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
__ostream_type & 
seekp (off_type , ios_base :: seekdir) ; 

protected : 
basic_ostream () 
{ this -> init (0) ; } 



basic_ostream (basic_iostream < _CharT , _Traits > &) { } 

basic_ostream (const basic_ostream &) = delete ; 

basic_ostream (basic_ostream && __rhs) 
: __ios_type () 
{ __ios_type :: move (__rhs) ; } 



basic_ostream & operator = (const basic_ostream &) = delete ; 

basic_ostream & 
operator = (basic_ostream && __rhs) 
{ 
swap (__rhs) ; 
return * this ; 
} 

void 
swap (basic_ostream & __rhs) 
{ __ios_type :: swap (__rhs) ; } 


template < typename _ValueT > 
__ostream_type & 
_M_insert (_ValueT __v) ; 
} ;
# 431 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT, typename _Traits >
    class basic_ostream < _CharT, _Traits > :: sentry
    {

      bool _M_ok;
      basic_ostream < _CharT, _Traits > & _M_os;

    public :

      explicit
      sentry ( basic_ostream < _CharT, _Traits > & __os );

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~ sentry ( )
      {

 if ( bool ( _M_os . flags ( ) & ios_base :: unitbuf ) && ! uncaught_exception ( ) )
   {

     if ( _M_os . rdbuf ( ) && _M_os . rdbuf ( ) -> pubsync ( ) == - 1 )
       _M_os . setstate ( ios_base :: badbit );
   }
      }
#pragma GCC diagnostic pop

      explicit

      operator bool ( ) const
      { return _M_ok; }
    };
# 504 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __out , _CharT __c) 
{ return __ostream_insert (__out , & __c , 1) ; } 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __out , char __c) 
{ return (__out << __out . widen (__c)) ; } 


template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , char __c) 
{ return __ostream_insert (__out , & __c , 1) ; } 


template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , signed char __c) 
{ return (__out << static_cast < char > (__c)) ; } 

template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , unsigned char __c) 
{ return (__out << static_cast < char > (__c)) ; } 
# 546 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __out , const _CharT * __s) 
{ 
if (! __s) 
__out . setstate (ios_base :: badbit) ; 
else 
__ostream_insert (__out , __s , 
static_cast < streamsize > (_Traits :: length (__s))) ; 
return __out ; 
} 

template < typename _CharT, typename _Traits >
    basic_ostream < _CharT, _Traits > &
    operator << ( basic_ostream < _CharT, _Traits > & __out, const char * __s );


template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , const char * __s) 
{ 
if (! __s) 
__out . setstate (ios_base :: badbit) ; 
else 
__ostream_insert (__out , __s , 
static_cast < streamsize > (_Traits :: length (__s))) ; 
return __out ; 
} 


template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , const signed char * __s) 
{ return (__out << reinterpret_cast < const char * > (__s)) ; } 

template < class _Traits > 
inline basic_ostream < char , _Traits > & 
operator << (basic_ostream < char , _Traits > & __out , const unsigned char * __s) 
{ return (__out << reinterpret_cast < const char * > (__s)) ; } 
# 597 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
endl (basic_ostream < _CharT , _Traits > & __os) 
{ return flush (__os . put (__os . widen ('\n'))) ; } 
# 609 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
ends (basic_ostream < _CharT , _Traits > & __os) 
{ return __os . put (_CharT ()) ; } 
# 619
template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
flush (basic_ostream < _CharT , _Traits > & __os) 
{ return __os . flush () ; } 


template < typename _Ch, typename _Up >
    basic_ostream < _Ch, _Up > &
    __is_convertible_to_basic_ostream_test ( basic_ostream < _Ch, _Up > * );

template < typename _Tp , typename = void > 
struct __is_convertible_to_basic_ostream_impl 
{ 
using __ostream_type = void ; 
} ;

template < typename _Tp >
    using __do_is_convertible_to_basic_ostream_impl =
    __decltype ( __is_convertible_to_basic_ostream_test
      ( declval < typename remove_reference < _Tp > :: type * > ( ) ) );

template < typename _Tp > 
struct __is_convertible_to_basic_ostream_impl 
< _Tp , 
__void_t < __do_is_convertible_to_basic_ostream_impl < _Tp > > > 
{ 
using __ostream_type = 
__do_is_convertible_to_basic_ostream_impl < _Tp > ; 
} ;

template < typename _Tp > 
struct __is_convertible_to_basic_ostream 
: __is_convertible_to_basic_ostream_impl < _Tp > 
{ 
public : 
using type = __not_ < is_void < 
typename __is_convertible_to_basic_ostream_impl < _Tp > :: __ostream_type > > ; 
constexpr static bool value = type :: value ; 
} ;

template < typename _Ostream , typename _Tp , typename = void > 
struct __is_insertable : false_type { } ;

template < typename _Ostream , typename _Tp > 
struct __is_insertable < _Ostream , _Tp , 
__void_t < decltype (declval < _Ostream & > () 
<< declval < const _Tp & > ()) > > 
: true_type { } ;

template < typename _Ostream >
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream <
 _Ostream > :: __ostream_type;
# 683 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ostream" 3
template < typename _Ostream , typename _Tp > 
inline 
typename enable_if < __and_ < __not_ < is_lvalue_reference < _Ostream > > , 
__is_convertible_to_basic_ostream < _Ostream > , 
__is_insertable < 
__rvalue_ostream_type < _Ostream > , 
const _Tp & > > :: value , 
__rvalue_ostream_type < _Ostream > > :: type 
operator << (_Ostream && __os , const _Tp & __x) 
{ 
__rvalue_ostream_type < _Ostream > __ret_os = __os ; 
__ret_os << __x ; 
return __ret_os ; 
} 



}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\ostream.tcc" 3
namespace std { 



template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > :: sentry :: 
sentry (basic_ostream < _CharT , _Traits > & __os) 
: _M_ok (false) , _M_os (__os) 
{ 

if (__os . tie () && __os . good ()) 
__os . tie () -> flush () ; 

if (__os . good ()) 
_M_ok = true ; 
else 
__os . setstate (ios_base :: failbit) ; 
} 

template < typename _CharT , typename _Traits > 
template < typename _ValueT > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
_M_insert (_ValueT __v) 
{ 
sentry __cerb (* this) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const __num_put_type & __np = __check_facet (this -> _M_num_put) ; 
if (__np . put (* this , * this , this -> fill () , __v) . failed ()) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
operator << (short __n) 
{ 


const ios_base :: fmtflags __fmt = this -> flags () & ios_base :: basefield ; 
if (__fmt == ios_base :: oct || __fmt == ios_base :: hex) 
return _M_insert (static_cast < long > (static_cast < unsigned short > (__n))) ; 
else 
return _M_insert (static_cast < long > (__n)) ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
operator << (int __n) 
{ 


const ios_base :: fmtflags __fmt = this -> flags () & ios_base :: basefield ; 
if (__fmt == ios_base :: oct || __fmt == ios_base :: hex) 
return _M_insert (static_cast < long > (static_cast < unsigned int > (__n))) ; 
else 
return _M_insert (static_cast < long > (__n)) ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
operator << (__streambuf_type * __sbin) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this) ; 
if (__cerb && __sbin) 
{ 
try 
{ 
if (! __copy_streambufs (__sbin , this -> rdbuf ())) 
__err |= ios_base :: failbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: failbit) ; } 
} 
else if (! __sbin) 
__err |= ios_base :: badbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
put (char_type __c) 
{ 
# 157
sentry __cerb (* this) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __put = this -> rdbuf () -> sputc (__c) ; 
if (traits_type :: eq_int_type (__put , traits_type :: eof ())) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
write (const _CharT * __s , streamsize __n) 
{ 
# 192
sentry __cerb (* this) ; 
if (__cerb) 
{ 
try 
{ _M_write (__s , __n) ; } 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
flush () 
{ 



ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
if (this -> rdbuf () && this -> rdbuf () -> pubsync () == - 1) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_ostream < _CharT , _Traits > :: pos_type 
basic_ostream < _CharT , _Traits > :: 
tellp () 
{ 
pos_type __ret = pos_type (- 1) ; 
try 
{ 
if (! this -> fail ()) 
__ret = this -> rdbuf () -> pubseekoff (0 , ios_base :: cur , ios_base :: out) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
seekp (pos_type __pos) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
if (! this -> fail ()) 
{ 


const pos_type __p = this -> rdbuf () -> pubseekpos (__pos , 
ios_base :: out) ; 


if (__p == pos_type (off_type (- 1))) 
__err |= ios_base :: failbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
basic_ostream < _CharT , _Traits > :: 
seekp (off_type __off , ios_base :: seekdir __dir) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
if (! this -> fail ()) 
{ 


const pos_type __p = this -> rdbuf () -> pubseekoff (__off , __dir , 
ios_base :: out) ; 


if (__p == pos_type (off_type (- 1))) 
__err |= ios_base :: failbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __out , const char * __s) 
{ 
if (! __s) 
__out . setstate (ios_base :: badbit) ; 
else 
{ 


const size_t __clen = char_traits < char > :: length (__s) ; 
try 
{ 
struct __ptr_guard 
{ 
_CharT * __p ; 
__ptr_guard (_CharT * __ip) : __p (__ip) { } 
~ __ptr_guard () { delete [ ] __p ; } 
_CharT * __get () { return __p ; } 
} __pg (new _CharT [ __clen ]) ; 

_CharT * __ws = __pg . __get () ; 
for (size_t __i = 0 ; __i < __clen ; ++ __i) 
__ws [ __i ] = __out . widen (__s [ __i ]) ; 
__ostream_insert (__out , __ws , __clen) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__out . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __out . _M_setstate (ios_base :: badbit) ; } 
} 
return __out ; 
} 




extern template class basic_ostream< char> ;
extern template basic_ostream< char>  &endl(basic_ostream< char>  & __os);
extern template basic_ostream< char>  &ends(basic_ostream< char>  & __os);
extern template basic_ostream< char>  &flush(basic_ostream< char>  & __os);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, char __c);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, unsigned char __c);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, signed char __c);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const char * __s);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const unsigned char * __s);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __out, const signed char * __s);

extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long __v);
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(unsigned long __v);
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(bool __v);

extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long long __v);
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(unsigned long long __v);

extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(double __v);
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(long double __v);
extern template basic_ostream< char> ::__ostream_type &basic_ostream< char> ::_M_insert(const void * __v);


extern template class basic_ostream< wchar_t> ;
extern template basic_ostream< wchar_t>  &endl(basic_ostream< wchar_t>  & __os);
extern template basic_ostream< wchar_t>  &ends(basic_ostream< wchar_t>  & __os);
extern template basic_ostream< wchar_t>  &flush(basic_ostream< wchar_t>  & __os);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, wchar_t __c);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, char __c);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, const wchar_t * __s);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __out, const char * __s);

extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long __v);
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(unsigned long __v);
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(bool __v);

extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long long __v);
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(unsigned long long __v);

extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(double __v);
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(long double __v);
extern template basic_ostream< wchar_t> ::__ostream_type &basic_ostream< wchar_t> ::_M_insert(const void * __v);




}
# 63 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_construct.h" 3
namespace std { 
# 72
template < typename _T1 , typename ... _Args > 
inline void 
_Construct (_T1 * __p , _Args && ... __args) 
{ :: new (static_cast < void * > (__p)) _T1 (std :: forward < _Args > (__args) ...) ; } 
# 87 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_construct.h" 3
template < typename _T1 > 
inline void 
_Construct_novalue (_T1 * __p) 
{ :: new (static_cast < void * > (__p)) _T1 ; } 




template < typename _Tp > 
inline void 
_Destroy (_Tp * __pointer) 
{ __pointer -> ~ _Tp () ; } 

template < bool > 
struct _Destroy_aux 
{ 
template < typename _ForwardIterator > 
static void 
__destroy (_ForwardIterator __first , _ForwardIterator __last) 
{ 
for (; __first != __last ; ++ __first) 
std :: _Destroy (std :: __addressof (* __first)) ; 
} 
} ;


template<> struct _Destroy_aux< true>  { 

template < typename _ForwardIterator > 
static void 
__destroy (_ForwardIterator , _ForwardIterator) { } 
}; 
# 125
template < typename _ForwardIterator > 
inline void 
_Destroy (_ForwardIterator __first , _ForwardIterator __last) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_Value_type ; 


static_assert (is_destructible < _Value_type > :: value , 
"value type is destructible") ; 

std :: _Destroy_aux < __has_trivial_destructor (_Value_type) > :: 
__destroy (__first , __last) ; 
} 

template < bool > 
struct _Destroy_n_aux 
{ 
template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__destroy_n (_ForwardIterator __first , _Size __count) 
{ 
for (; __count > 0 ; (void) ++ __first , -- __count) 
std :: _Destroy (std :: __addressof (* __first)) ; 
return __first ; 
} 
} ;


template<> struct _Destroy_n_aux< true>  { 

template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__destroy_n (_ForwardIterator __first , _Size __count) 
{ 
std :: advance (__first , __count) ; 
return __first ; 
} 
}; 
# 170
template < typename _ForwardIterator , typename _Size > 
inline _ForwardIterator 
_Destroy_n (_ForwardIterator __first , _Size __count) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_Value_type ; 


static_assert (is_destructible < _Value_type > :: value , 
"value type is destructible") ; 

return std :: _Destroy_n_aux < __has_trivial_destructor (_Value_type) > :: 
__destroy_n (__first , __count) ; 
} 
# 191
template < typename _ForwardIterator , typename _Allocator > 
void 
_Destroy (_ForwardIterator __first , _ForwardIterator __last , 
_Allocator & __alloc) 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __first != __last ; ++ __first) 
__traits :: destroy (__alloc , std :: __addressof (* __first)) ; 
} 

template < typename _ForwardIterator , typename _Tp > 
inline void 
_Destroy (_ForwardIterator __first , _ForwardIterator __last , 
allocator < _Tp > &) 
{ 
_Destroy (__first , __last) ; 
} 
# 233 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_construct.h" 3
}
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
namespace std { 



template < bool _TrivialValueTypes > 
struct __uninitialized_copy 
{ 
template < typename _InputIterator , typename _ForwardIterator > 
static _ForwardIterator 
__uninit_copy (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result) 
{ 
_ForwardIterator __cur = __result ; 
try 
{ 
for (; __first != __last ; ++ __first , (void) ++ __cur) 
std :: _Construct (std :: __addressof (* __cur) , * __first) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_copy< true>  { 

template < typename _InputIterator , typename _ForwardIterator > 
static _ForwardIterator 
__uninit_copy (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result) 
{ return std :: copy (__first , __last , __result) ; } 
}; 
# 113 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _InputIterator , typename _ForwardIterator > 
inline _ForwardIterator 
uninitialized_copy (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result) 
{ 
typedef typename iterator_traits < _InputIterator > :: value_type 
_ValueType1 ; 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType2 ; 




typedef typename iterator_traits < _InputIterator > :: reference _RefType1 ; 
typedef typename iterator_traits < _ForwardIterator > :: reference _RefType2 ; 
const bool __assignable = is_assignable < _RefType2 , _RefType1 > :: value ; 


return std :: __uninitialized_copy < __is_trivial (_ValueType1) 
&& __is_trivial (_ValueType2) 
&& __assignable > :: 
__uninit_copy (__first , __last , __result) ; 
} 


template < bool _TrivialValueType > 
struct __uninitialized_fill 
{ 
template < typename _ForwardIterator , typename _Tp > 
static void 
__uninit_fill (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __x) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __cur != __last ; ++ __cur) 
std :: _Construct (std :: __addressof (* __cur) , __x) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_fill< true>  { 

template < typename _ForwardIterator , typename _Tp > 
static void 
__uninit_fill (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __x) 
{ std :: fill (__first , __last , __x) ; } 
}; 
# 179 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline void 
uninitialized_fill (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __x) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 




const bool __assignable = is_copy_assignable < _ValueType > :: value ; 


std :: __uninitialized_fill < __is_trivial (_ValueType) && __assignable > :: 
__uninit_fill (__first , __last , __x) ; 
} 


template < bool _TrivialValueType > 
struct __uninitialized_fill_n 
{ 
template < typename _ForwardIterator , typename _Size , typename _Tp > 
static _ForwardIterator 
__uninit_fill_n (_ForwardIterator __first , _Size __n , 
const _Tp & __x) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __n > 0 ; -- __n , (void) ++ __cur) 
std :: _Construct (std :: __addressof (* __cur) , __x) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_fill_n< true>  { 

template < typename _ForwardIterator , typename _Size , typename _Tp > 
static _ForwardIterator 
__uninit_fill_n (_ForwardIterator __first , _Size __n , 
const _Tp & __x) 
{ return std :: fill_n (__first , __n , __x) ; } 
}; 
# 242 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _ForwardIterator , typename _Size , typename _Tp > 
inline _ForwardIterator 
uninitialized_fill_n (_ForwardIterator __first , _Size __n , const _Tp & __x) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 




const bool __assignable = is_copy_assignable < _ValueType > :: value ; 

return __uninitialized_fill_n < __is_trivial (_ValueType) && __assignable > :: 
__uninit_fill_n (__first , __n , __x) ; 
} 
# 264
template < typename _InputIterator , typename _ForwardIterator , 
typename _Allocator > 
_ForwardIterator 
__uninitialized_copy_a (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , _Allocator & __alloc) 
{ 
_ForwardIterator __cur = __result ; 
try 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __first != __last ; ++ __first , (void) ++ __cur) 
__traits :: construct (__alloc , std :: __addressof (* __cur) , * __first) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __cur , __alloc) ; 
throw ; 
} 
} 

template < typename _InputIterator , typename _ForwardIterator , typename _Tp > 
inline _ForwardIterator 
__uninitialized_copy_a (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , allocator < _Tp > &) 
{ return std :: uninitialized_copy (__first , __last , __result) ; } 

template < typename _InputIterator , typename _ForwardIterator , 
typename _Allocator > 
inline _ForwardIterator 
__uninitialized_move_a (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , _Allocator & __alloc) 
{ 
return std :: __uninitialized_copy_a (std :: make_move_iterator (__first) , 
std :: make_move_iterator (__last) , 
__result , __alloc) ; 
} 

template < typename _InputIterator , typename _ForwardIterator , 
typename _Allocator > 
inline _ForwardIterator 
__uninitialized_move_if_noexcept_a (_InputIterator __first , 
_InputIterator __last , 
_ForwardIterator __result , 
_Allocator & __alloc) 
{ 
return std :: __uninitialized_copy_a 
(std :: __make_move_if_noexcept_iterator (__first) , 
std :: __make_move_if_noexcept_iterator (__last) , __result , __alloc) ; 
} 

template < typename _ForwardIterator , typename _Tp , typename _Allocator > 
void 
__uninitialized_fill_a (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __x , _Allocator & __alloc) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __cur != __last ; ++ __cur) 
__traits :: construct (__alloc , std :: __addressof (* __cur) , __x) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur , __alloc) ; 
throw ; 
} 
} 

template < typename _ForwardIterator , typename _Tp , typename _Tp2 > 
inline void 
__uninitialized_fill_a (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __x , allocator < _Tp2 > &) 
{ std :: uninitialized_fill (__first , __last , __x) ; } 

template < typename _ForwardIterator , typename _Size , typename _Tp , 
typename _Allocator > 
_ForwardIterator 
__uninitialized_fill_n_a (_ForwardIterator __first , _Size __n , 
const _Tp & __x , _Allocator & __alloc) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __n > 0 ; -- __n , (void) ++ __cur) 
__traits :: construct (__alloc , std :: __addressof (* __cur) , __x) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur , __alloc) ; 
throw ; 
} 
} 

template < typename _ForwardIterator , typename _Size , typename _Tp , 
typename _Tp2 > 
inline _ForwardIterator 
__uninitialized_fill_n_a (_ForwardIterator __first , _Size __n , 
const _Tp & __x , allocator < _Tp2 > &) 
{ return std :: uninitialized_fill_n (__first , __n , __x) ; } 
# 378 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _ForwardIterator , typename _Allocator > 
inline _ForwardIterator 
__uninitialized_copy_move (_InputIterator1 __first1 , 
_InputIterator1 __last1 , 
_InputIterator2 __first2 , 
_InputIterator2 __last2 , 
_ForwardIterator __result , 
_Allocator & __alloc) 
{ 
_ForwardIterator __mid = std :: __uninitialized_copy_a (__first1 , __last1 , 
__result , 
__alloc) ; 
try 
{ 
return std :: __uninitialized_move_a (__first2 , __last2 , __mid , __alloc) ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __mid , __alloc) ; 
throw ; 
} 
} 
# 406
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _ForwardIterator , typename _Allocator > 
inline _ForwardIterator 
__uninitialized_move_copy (_InputIterator1 __first1 , 
_InputIterator1 __last1 , 
_InputIterator2 __first2 , 
_InputIterator2 __last2 , 
_ForwardIterator __result , 
_Allocator & __alloc) 
{ 
_ForwardIterator __mid = std :: __uninitialized_move_a (__first1 , __last1 , 
__result , 
__alloc) ; 
try 
{ 
return std :: __uninitialized_copy_a (__first2 , __last2 , __mid , __alloc) ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __mid , __alloc) ; 
throw ; 
} 
} 




template < typename _ForwardIterator , typename _Tp , typename _InputIterator , 
typename _Allocator > 
inline _ForwardIterator 
__uninitialized_fill_move (_ForwardIterator __result , _ForwardIterator __mid , 
const _Tp & __x , _InputIterator __first , 
_InputIterator __last , _Allocator & __alloc) 
{ 
std :: __uninitialized_fill_a (__result , __mid , __x , __alloc) ; 
try 
{ 
return std :: __uninitialized_move_a (__first , __last , __mid , __alloc) ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __mid , __alloc) ; 
throw ; 
} 
} 




template < typename _InputIterator , typename _ForwardIterator , typename _Tp , 
typename _Allocator > 
inline void 
__uninitialized_move_fill (_InputIterator __first1 , _InputIterator __last1 , 
_ForwardIterator __first2 , 
_ForwardIterator __last2 , const _Tp & __x , 
_Allocator & __alloc) 
{ 
_ForwardIterator __mid2 = std :: __uninitialized_move_a (__first1 , __last1 , 
__first2 , 
__alloc) ; 
try 
{ 
std :: __uninitialized_fill_a (__mid2 , __last2 , __x , __alloc) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first2 , __mid2 , __alloc) ; 
throw ; 
} 
} 
# 481
template < bool _TrivialValueType > 
struct __uninitialized_default_1 
{ 
template < typename _ForwardIterator > 
static void 
__uninit_default (_ForwardIterator __first , _ForwardIterator __last) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __cur != __last ; ++ __cur) 
std :: _Construct (std :: __addressof (* __cur)) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_default_1< true>  { 

template < typename _ForwardIterator > 
static void 
__uninit_default (_ForwardIterator __first , _ForwardIterator __last) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

std :: fill (__first , __last , _ValueType ()) ; 
} 
}; 

template < bool _TrivialValueType > 
struct __uninitialized_default_n_1 
{ 
template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__uninit_default_n (_ForwardIterator __first , _Size __n) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __n > 0 ; -- __n , (void) ++ __cur) 
std :: _Construct (std :: __addressof (* __cur)) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_default_n_1< true>  { 

template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__uninit_default_n (_ForwardIterator __first , _Size __n) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

return std :: fill_n (__first , __n , _ValueType ()) ; 
} 
}; 




template < typename _ForwardIterator > 
inline void 
__uninitialized_default (_ForwardIterator __first , 
_ForwardIterator __last) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

const bool __assignable = is_copy_assignable < _ValueType > :: value ; 

std :: __uninitialized_default_1 < __is_trivial (_ValueType) 
&& __assignable > :: 
__uninit_default (__first , __last) ; 
} 



template < typename _ForwardIterator , typename _Size > 
inline _ForwardIterator 
__uninitialized_default_n (_ForwardIterator __first , _Size __n) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

const bool __assignable = is_copy_assignable < _ValueType > :: value ; 

return __uninitialized_default_n_1 < __is_trivial (_ValueType) 
&& __assignable > :: 
__uninit_default_n (__first , __n) ; 
} 
# 590
template < typename _ForwardIterator , typename _Allocator > 
void 
__uninitialized_default_a (_ForwardIterator __first , 
_ForwardIterator __last , 
_Allocator & __alloc) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __cur != __last ; ++ __cur) 
__traits :: construct (__alloc , std :: __addressof (* __cur)) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur , __alloc) ; 
throw ; 
} 
} 

template < typename _ForwardIterator , typename _Tp > 
inline void 
__uninitialized_default_a (_ForwardIterator __first , 
_ForwardIterator __last , 
allocator < _Tp > &) 
{ std :: __uninitialized_default (__first , __last) ; } 
# 621
template < typename _ForwardIterator , typename _Size , typename _Allocator > 
_ForwardIterator 
__uninitialized_default_n_a (_ForwardIterator __first , _Size __n , 
_Allocator & __alloc) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
typedef __gnu_cxx :: __alloc_traits < _Allocator > __traits ; 
for (; __n > 0 ; -- __n , (void) ++ __cur) 
__traits :: construct (__alloc , std :: __addressof (* __cur)) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur , __alloc) ; 
throw ; 
} 
} 

template < typename _ForwardIterator , typename _Size , typename _Tp > 
inline _ForwardIterator 
__uninitialized_default_n_a (_ForwardIterator __first , _Size __n , 
allocator < _Tp > &) 
{ return std :: __uninitialized_default_n (__first , __n) ; } 

template < bool _TrivialValueType > 
struct __uninitialized_default_novalue_1 
{ 
template < typename _ForwardIterator > 
static void 
__uninit_default_novalue (_ForwardIterator __first , 
_ForwardIterator __last) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __cur != __last ; ++ __cur) 
std :: _Construct_novalue (std :: __addressof (* __cur)) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_default_novalue_1< true>  { 

template < typename _ForwardIterator > 
static void 
__uninit_default_novalue (_ForwardIterator __first , 
_ForwardIterator __last) 
{ 
} 
}; 

template < bool _TrivialValueType > 
struct __uninitialized_default_novalue_n_1 
{ 
template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__uninit_default_novalue_n (_ForwardIterator __first , _Size __n) 
{ 
_ForwardIterator __cur = __first ; 
try 
{ 
for (; __n > 0 ; -- __n , (void) ++ __cur) 
std :: _Construct_novalue (std :: __addressof (* __cur)) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_default_novalue_n_1< true>  { 

template < typename _ForwardIterator , typename _Size > 
static _ForwardIterator 
__uninit_default_novalue_n (_ForwardIterator __first , _Size __n) 
{ return std :: next (__first , __n) ; } 
}; 




template < typename _ForwardIterator > 
inline void 
__uninitialized_default_novalue (_ForwardIterator __first , 
_ForwardIterator __last) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

std :: __uninitialized_default_novalue_1 < 
is_trivially_default_constructible < _ValueType > :: value > :: 
__uninit_default_novalue (__first , __last) ; 
} 



template < typename _ForwardIterator , typename _Size > 
inline _ForwardIterator 
__uninitialized_default_novalue_n (_ForwardIterator __first , _Size __n) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 

return __uninitialized_default_novalue_n_1 < 
is_trivially_default_constructible < _ValueType > :: value > :: 
__uninit_default_novalue_n (__first , __n) ; 
} 

template < typename _InputIterator , typename _Size , 
typename _ForwardIterator > 
_ForwardIterator 
__uninitialized_copy_n (_InputIterator __first , _Size __n , 
_ForwardIterator __result , input_iterator_tag) 
{ 
_ForwardIterator __cur = __result ; 
try 
{ 
for (; __n > 0 ; -- __n , (void) ++ __first , ++ __cur) 
std :: _Construct (std :: __addressof (* __cur) , * __first) ; 
return __cur ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __cur) ; 
throw ; 
} 
} 

template < typename _RandomAccessIterator , typename _Size , 
typename _ForwardIterator > 
inline _ForwardIterator 
__uninitialized_copy_n (_RandomAccessIterator __first , _Size __n , 
_ForwardIterator __result , 
random_access_iterator_tag) 
{ return std :: uninitialized_copy (__first , __first + __n , __result) ; } 

template < typename _InputIterator , typename _Size , 
typename _ForwardIterator > 
pair < _InputIterator , _ForwardIterator > 
__uninitialized_copy_n_pair (_InputIterator __first , _Size __n , 
_ForwardIterator __result , input_iterator_tag) 
{ 
_ForwardIterator __cur = __result ; 
try 
{ 
for (; __n > 0 ; -- __n , (void) ++ __first , ++ __cur) 
std :: _Construct (std :: __addressof (* __cur) , * __first) ; 
return { __first , __cur } ; 
} 
catch (...) 
{ 
std :: _Destroy (__result , __cur) ; 
throw ; 
} 
} 

template < typename _RandomAccessIterator , typename _Size , 
typename _ForwardIterator > 
inline pair < _RandomAccessIterator , _ForwardIterator > 
__uninitialized_copy_n_pair (_RandomAccessIterator __first , _Size __n , 
_ForwardIterator __result , 
random_access_iterator_tag) 
{ 
auto __second_res = uninitialized_copy (__first , __first + __n , __result) ; 
auto __first_res = std :: next (__first , __n) ; 
return { __first_res , __second_res } ; 
} 
# 810 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _InputIterator , typename _Size , typename _ForwardIterator > 
inline _ForwardIterator 
uninitialized_copy_n (_InputIterator __first , _Size __n , 
_ForwardIterator __result) 
{ return std :: __uninitialized_copy_n (__first , __n , __result , 
std :: __iterator_category (__first)) ; } 

template < typename _InputIterator , typename _Size , typename _ForwardIterator > 
inline pair < _InputIterator , _ForwardIterator > 
__uninitialized_copy_n_pair (_InputIterator __first , _Size __n , 
_ForwardIterator __result) 
{ 
return 
std :: __uninitialized_copy_n_pair (__first , __n , __result , 
std :: __iterator_category (__first)) ; 
} 
# 885 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_uninitialized.h" 3
template < typename _Tp , typename _Up , typename _Allocator > 
inline void 
__relocate_object_a (_Tp * __dest , _Up * __orig , _Allocator & __alloc) 
noexcept (noexcept (std :: allocator_traits < _Allocator > :: construct (__alloc , 
__dest , std :: move (* __orig))) 
&& noexcept (std :: allocator_traits < _Allocator > :: destroy (
__alloc , std :: __addressof (* __orig)))) 
{ 
typedef std :: allocator_traits < _Allocator > __traits ; 
__traits :: construct (__alloc , __dest , std :: move (* __orig)) ; 
__traits :: destroy (__alloc , std :: __addressof (* __orig)) ; 
} 



template < typename _Tp , typename = void > 
struct __is_bitwise_relocatable 
: is_trivial < _Tp > { } ;

template < typename _Tp , typename _Up > 
inline __enable_if_t < std :: __is_bitwise_relocatable < _Tp > :: value , _Tp * > 
__relocate_a_1 (_Tp * __first , _Tp * __last , 
_Tp * __result , allocator < _Up > &) noexcept 
{ 
ptrdiff_t __count = __last - __first ; 
if (__count > 0) 
__builtin_memmove (__result , __first , __count * sizeof (_Tp)) ; 
return __result + __count ; 
} 

template < typename _InputIterator , typename _ForwardIterator , 
typename _Allocator > 
inline _ForwardIterator 
__relocate_a_1 (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , _Allocator & __alloc) 
noexcept (noexcept (std :: __relocate_object_a (std :: addressof (* __result) , 
std :: addressof (* __first) , 
__alloc))) 
{ 
typedef typename iterator_traits < _InputIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType2 ; 
static_assert (std :: is_same < _ValueType , _ValueType2 > :: value , 
"relocation is only possible for values of the same type") ; 
_ForwardIterator __cur = __result ; 
for (; __first != __last ; ++ __first , (void) ++ __cur) 
std :: __relocate_object_a (std :: __addressof (* __cur) , 
std :: __addressof (* __first) , __alloc) ; 
return __cur ; 
} 

template < typename _InputIterator , typename _ForwardIterator , 
typename _Allocator > 
inline _ForwardIterator 
__relocate_a (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , _Allocator & __alloc) 
noexcept (noexcept (__relocate_a_1 (std :: __niter_base (__first) , 
std :: __niter_base (__last) , 
std :: __niter_base (__result) , __alloc))) 
{ 
return __relocate_a_1 (std :: __niter_base (__first) , 
std :: __niter_base (__last) , 
std :: __niter_base (__result) , __alloc) ; 
} 



}
# 74 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
namespace std { 
# 80
template < typename _Tp , typename _Alloc > 
struct _Vector_base 
{ 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Tp > :: other _Tp_alloc_type ; 
typedef typename __gnu_cxx :: __alloc_traits < _Tp_alloc_type > :: pointer 
pointer ; 

struct _Vector_impl_data 
{ 
pointer _M_start ; 
pointer _M_finish ; 
pointer _M_end_of_storage ; 

_Vector_impl_data () noexcept 
: _M_start () , _M_finish () , _M_end_of_storage () 
{ } 


_Vector_impl_data (_Vector_impl_data && __x) noexcept 
: _M_start (__x . _M_start) , _M_finish (__x . _M_finish) , 
_M_end_of_storage (__x . _M_end_of_storage) 
{ __x . _M_start = __x . _M_finish = __x . _M_end_of_storage = pointer () ; } 


void 
_M_copy_data (_Vector_impl_data const & __x) noexcept 
{ 
_M_start = __x . _M_start ; 
_M_finish = __x . _M_finish ; 
_M_end_of_storage = __x . _M_end_of_storage ; 
} 

void 
_M_swap_data (_Vector_impl_data & __x) noexcept 
{ 


_Vector_impl_data __tmp ; 
__tmp . _M_copy_data (* this) ; 
_M_copy_data (__x) ; 
__x . _M_copy_data (__tmp) ; 
} 
} ; 

struct _Vector_impl 
: public _Tp_alloc_type , public _Vector_impl_data 
{ 
_Vector_impl () noexcept (is_nothrow_default_constructible < _Tp_alloc_type > :: value) 

: _Tp_alloc_type () 
{ } 

_Vector_impl (_Tp_alloc_type const & __a) noexcept 
: _Tp_alloc_type (__a) 
{ } 




_Vector_impl (_Vector_impl && __x) noexcept 
: _Tp_alloc_type (std :: move (__x)) , _Vector_impl_data (std :: move (__x)) 
{ } 

_Vector_impl (_Tp_alloc_type && __a) noexcept 
: _Tp_alloc_type (std :: move (__a)) 
{ } 

_Vector_impl (_Tp_alloc_type && __a , _Vector_impl && __rv) noexcept 
: _Tp_alloc_type (std :: move (__a)) , _Vector_impl_data (std :: move (__rv)) 
{ } 
# 267 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
} ; 

public : 
typedef _Alloc allocator_type ; 

_Tp_alloc_type & 
_M_get_Tp_allocator () noexcept 
{ return this -> _M_impl ; } 

const _Tp_alloc_type & 
_M_get_Tp_allocator () const noexcept 
{ return this -> _M_impl ; } 

allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_get_Tp_allocator ()) ; } 


_Vector_base () = default ; 




_Vector_base (const allocator_type & __a) noexcept 
: _M_impl (__a) { } 



_Vector_base (size_t __n) 
: _M_impl () 
{ _M_create_storage (__n) ; } 


_Vector_base (size_t __n , const allocator_type & __a) 
: _M_impl (__a) 
{ _M_create_storage (__n) ; } 


_Vector_base (_Vector_base &&) = default ; 



_Vector_base (_Tp_alloc_type && __a) noexcept 
: _M_impl (std :: move (__a)) { } 

_Vector_base (_Vector_base && __x , const allocator_type & __a) 
: _M_impl (__a) 
{ 
if (__x . get_allocator () == __a) 
this -> _M_impl . _M_swap_data (__x . _M_impl) ; 
else 
{ 
size_t __n = __x . _M_impl . _M_finish - __x . _M_impl . _M_start ; 
_M_create_storage (__n) ; 
} 
} 


_Vector_base (const allocator_type & __a , _Vector_base && __x) 
: _M_impl (_Tp_alloc_type (__a) , std :: move (__x . _M_impl)) 
{ } 


~ _Vector_base () noexcept 
{ 
_M_deallocate (_M_impl . _M_start , 
_M_impl . _M_end_of_storage - _M_impl . _M_start) ; 
} 

public : 
_Vector_impl _M_impl ; 

pointer 
_M_allocate (size_t __n) 
{ 
typedef __gnu_cxx :: __alloc_traits < _Tp_alloc_type > _Tr ; 
return __n != 0 ? _Tr :: allocate (_M_impl , __n) : pointer () ; 
} 

void 
_M_deallocate (pointer __p , size_t __n) 
{ 
typedef __gnu_cxx :: __alloc_traits < _Tp_alloc_type > _Tr ; 
if (__p) 
_Tr :: deallocate (_M_impl , __p , __n) ; 
} 

protected : 
void 
_M_create_storage (size_t __n) 
{ 
this -> _M_impl . _M_start = this -> _M_allocate (__n) ; 
this -> _M_impl . _M_finish = this -> _M_impl . _M_start ; 
this -> _M_impl . _M_end_of_storage = this -> _M_impl . _M_start + __n ; 
} 
} ;
# 385 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _Tp , typename _Alloc = std :: allocator < _Tp > > 
class vector : protected _Vector_base < _Tp , _Alloc > 
{ 
# 398 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
static_assert (is_same < typename remove_cv < _Tp > :: type , _Tp > :: value , 
"std::vector must have a non-const, non-volatile value_type") ; 
# 406
typedef _Vector_base < _Tp , _Alloc > _Base ; 
typedef typename _Base :: _Tp_alloc_type _Tp_alloc_type ; 
typedef __gnu_cxx :: __alloc_traits < _Tp_alloc_type > _Alloc_traits ; 

public : 
typedef _Tp value_type ; 
typedef typename _Base :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 
typedef __gnu_cxx :: __normal_iterator < pointer , vector > iterator ; 
typedef __gnu_cxx :: __normal_iterator < const_pointer , vector > 
const_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 
typedef std :: reverse_iterator < iterator > reverse_iterator ; 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Alloc allocator_type ; 

private : 

static constexpr bool 
_S_nothrow_relocate (true_type) 
{ 
return noexcept (std :: __relocate_a (std :: declval < pointer > () , 
std :: declval < pointer > () , 
std :: declval < pointer > () , 
std :: declval < _Tp_alloc_type & > ())) ; 
} 

static constexpr bool 
_S_nothrow_relocate (false_type) 
{ return false ; } 

static constexpr bool 
_S_use_relocate () 
{ 



return _S_nothrow_relocate (__is_move_insertable < _Tp_alloc_type > { }) ; 
} 

static pointer 
_S_do_relocate (pointer __first , pointer __last , pointer __result , 
_Tp_alloc_type & __alloc , true_type) noexcept 
{ 
return std :: __relocate_a (__first , __last , __result , __alloc) ; 
} 

static pointer 
_S_do_relocate (pointer , pointer , pointer __result , 
_Tp_alloc_type & , false_type) noexcept 
{ return __result ; } 

static pointer 
_S_relocate (pointer __first , pointer __last , pointer __result , 
_Tp_alloc_type & __alloc) noexcept 
{ 
using __do_it = __bool_constant < _S_use_relocate () > ; 
return _S_do_relocate (__first , __last , __result , __alloc , __do_it { }) ; 
} 


protected : 
using _Base :: _M_allocate ; 
using _Base :: _M_deallocate ; 
using _Base :: _M_impl ; 
using _Base :: _M_get_Tp_allocator ; 

public : 
# 484
vector () = default ; 
# 493 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
explicit 
vector (const allocator_type & __a) noexcept 
: _Base (__a) { } 
# 506 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
explicit 
vector (size_type __n , const allocator_type & __a = allocator_type ()) 
: _Base (_S_check_init_len (__n , __a) , __a) 
{ _M_default_initialize (__n) ; } 
# 519 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector (size_type __n , const value_type & __value , 
const allocator_type & __a = allocator_type ()) 
: _Base (_S_check_init_len (__n , __a) , __a) 
{ _M_fill_initialize (__n , __value) ; } 
# 550 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector (const vector & __x) 
: _Base (__x . size () , 
_Alloc_traits :: _S_select_on_copy (__x . _M_get_Tp_allocator ())) 
{ 
this -> _M_impl . _M_finish = 
std :: __uninitialized_copy_a (__x . begin () , __x . end () , 
this -> _M_impl . _M_start , 
_M_get_Tp_allocator ()) ; 
} 
# 569 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector (vector &&) noexcept = default ; 


vector (const vector & __x , const allocator_type & __a) 
: _Base (__x . size () , __a) 
{ 
this -> _M_impl . _M_finish = 
std :: __uninitialized_copy_a (__x . begin () , __x . end () , 
this -> _M_impl . _M_start , 
_M_get_Tp_allocator ()) ; 
} 

private : 
vector (vector && __rv , const allocator_type & __m , true_type) noexcept 
: _Base (__m , std :: move (__rv)) 
{ } 

vector (vector && __rv , const allocator_type & __m , false_type) 
: _Base (__m) 
{ 
if (__rv . get_allocator () == __m) 
this -> _M_impl . _M_swap_data (__rv . _M_impl) ; 
else if (! __rv . empty ()) 
{ 
this -> _M_create_storage (__rv . size ()) ; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_move_a (__rv . begin () , __rv . end () , 
this -> _M_impl . _M_start , 
_M_get_Tp_allocator ()) ; 
__rv . clear () ; 
} 
} 

public : 

vector (vector && __rv , const allocator_type & __m) 
noexcept (noexcept (
vector (std :: declval < vector && > () , std :: declval < const allocator_type & > () , 
std :: declval < typename _Alloc_traits :: is_always_equal > ()))) 
: vector (std :: move (__rv) , __m , typename _Alloc_traits :: is_always_equal { }) 
{ } 
# 622 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector (initializer_list < value_type > __l , 
const allocator_type & __a = allocator_type ()) 
: _Base (__a) 
{ 
_M_range_initialize (__l . begin () , __l . end () , 
random_access_iterator_tag ()) ; 
} 
# 648 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
vector (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a = allocator_type ()) 
: _Base (__a) 
{ 
_M_range_initialize (__first , __last , 
std :: __iterator_category (__first)) ; 
} 
# 675 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
~ vector () noexcept 
{ 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
; 
} 
# 691 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector & 
operator = (const vector & __x) ; 
# 705 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector & 
operator = (vector && __x) noexcept (_Alloc_traits :: _S_nothrow_move ()) 
{ 
constexpr bool __move_storage = 
_Alloc_traits :: _S_propagate_on_move_assign () 
|| _Alloc_traits :: _S_always_equal () ; 
_M_move_assign (std :: move (__x) , __bool_constant < __move_storage > ()) ; 
return * this ; 
} 
# 726 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
vector & 
operator = (initializer_list < value_type > __l) 
{ 
this -> _M_assign_aux (__l . begin () , __l . end () , 
random_access_iterator_tag ()) ; 
return * this ; 
} 
# 745 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
assign (size_type __n , const value_type & __val) 
{ _M_fill_assign (__n , __val) ; } 
# 762 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
void 
assign (_InputIterator __first , _InputIterator __last) 
{ _M_assign_dispatch (__first , __last , __false_type ()) ; } 
# 790 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
assign (initializer_list < value_type > __l) 
{ 
this -> _M_assign_aux (__l . begin () , __l . end () , 
random_access_iterator_tag ()) ; 
} 



using _Base :: get_allocator ; 
# 807
iterator 
begin () noexcept 
{ return iterator (this -> _M_impl . _M_start) ; } 
# 816
const_iterator 
begin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_start) ; } 
# 825
iterator 
end () noexcept 
{ return iterator (this -> _M_impl . _M_finish) ; } 
# 834
const_iterator 
end () const noexcept 
{ return const_iterator (this -> _M_impl . _M_finish) ; } 
# 843
reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (end ()) ; } 
# 852
const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 
# 861
reverse_iterator 
rend () noexcept 
{ return reverse_iterator (begin ()) ; } 
# 870
const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 
# 880
const_iterator 
cbegin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_start) ; } 
# 889
const_iterator 
cend () const noexcept 
{ return const_iterator (this -> _M_impl . _M_finish) ; } 
# 898
const_reverse_iterator 
crbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 
# 907
const_reverse_iterator 
crend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 




size_type 
size () const noexcept 
{ return size_type (this -> _M_impl . _M_finish - this -> _M_impl . _M_start) ; } 


size_type 
max_size () const noexcept 
{ return _S_max_size (_M_get_Tp_allocator ()) ; } 
# 933 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
resize (size_type __new_size) 
{ 
if (__new_size > size ()) 
_M_default_append (__new_size - size ()) ; 
else if (__new_size < size ()) 
_M_erase_at_end (this -> _M_impl . _M_start + __new_size) ; 
} 
# 953 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
resize (size_type __new_size , const value_type & __x) 
{ 
if (__new_size > size ()) 
_M_fill_insert (end () , __new_size - size () , __x) ; 
else if (__new_size < size ()) 
_M_erase_at_end (this -> _M_impl . _M_start + __new_size) ; 
} 
# 985 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
shrink_to_fit () 
{ _M_shrink_to_fit () ; } 
# 994
size_type 
capacity () const noexcept 
{ return size_type (this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; } 
# 1003
bool 
empty () const noexcept 
{ return begin () == end () ; } 
# 1024 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
reserve (size_type __n) ; 
# 1039 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
reference 
operator [ ] (size_type __n) noexcept 
{ 
; 
return * (this -> _M_impl . _M_start + __n) ; 
} 
# 1057 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
const_reference 
operator [ ] (size_type __n) const noexcept 
{ 
; 
return * (this -> _M_impl . _M_start + __n) ; 
} 

protected : 

void 
_M_range_check (size_type __n) const 
{ 
if (__n >= this -> size ()) 
__throw_out_of_range_fmt (("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)") 

, 
__n , this -> size ()) ; 
} 

public : 
# 1088 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
reference 
at (size_type __n) 
{ 
_M_range_check (__n) ; 
return (* this) [ __n ] ; 
} 
# 1106 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
const_reference 
at (size_type __n) const 
{ 
_M_range_check (__n) ; 
return (* this) [ __n ] ; 
} 
# 1117
reference 
front () noexcept 
{ 
; 
return * begin () ; 
} 
# 1128
const_reference 
front () const noexcept 
{ 
; 
return * begin () ; 
} 
# 1139
reference 
back () noexcept 
{ 
; 
return * (end () - 1) ; 
} 
# 1150
const_reference 
back () const noexcept 
{ 
; 
return * (end () - 1) ; 
} 
# 1164 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
_Tp * 
data () noexcept 
{ return _M_data_ptr (this -> _M_impl . _M_start) ; } 

const _Tp * 
data () const noexcept 
{ return _M_data_ptr (this -> _M_impl . _M_start) ; } 
# 1183 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
push_back (const value_type & __x) 
{ 
if (this -> _M_impl . _M_finish != this -> _M_impl . _M_end_of_storage) 
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
__x) ; 
++ this -> _M_impl . _M_finish ; 
; 
} 
else 
_M_realloc_insert (end () , __x) ; 
} 


void 
push_back (value_type && __x) 
{ emplace_back (std :: move (__x)) ; } 

template < typename ... _Args > 



void 

emplace_back (_Args && ... __args) ; 
# 1221 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
pop_back () noexcept 
{ 
; 
-- this -> _M_impl . _M_finish ; 
_Alloc_traits :: destroy (this -> _M_impl , this -> _M_impl . _M_finish) ; 
; 
} 
# 1243 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename ... _Args > 
iterator 
emplace (const_iterator __position , _Args && ... __args) 
{ return _M_emplace_aux (__position , std :: forward < _Args > (__args) ...) ; } 
# 1259 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 
insert (const_iterator __position , const value_type & __x) ; 
# 1289 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 
insert (const_iterator __position , value_type && __x) 
{ return _M_insert_rval (__position , std :: move (__x)) ; } 
# 1306 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 
insert (const_iterator __position , initializer_list < value_type > __l) 
{ 
auto __offset = __position - cbegin () ; 
_M_range_insert (begin () + __offset , __l . begin () , __l . end () , 
std :: random_access_iterator_tag ()) ; 
return begin () + __offset ; 
} 
# 1331 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 
insert (const_iterator __position , size_type __n , const value_type & __x) 
{ 
difference_type __offset = __position - cbegin () ; 
_M_fill_insert (begin () + __offset , __n , __x) ; 
return begin () + __offset ; 
} 
# 1373 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
iterator 
insert (const_iterator __position , _InputIterator __first , 
_InputIterator __last) 
{ 
difference_type __offset = __position - cbegin () ; 
_M_insert_dispatch (begin () + __offset , 
__first , __last , __false_type ()) ; 
return begin () + __offset ; 
} 
# 1425 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 

erase (const_iterator __position) 
{ return _M_erase (begin () + (__position - cbegin ())) ; } 
# 1452 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
iterator 

erase (const_iterator __first , const_iterator __last) 
{ 
const auto __beg = begin () ; 
const auto __cbeg = cbegin () ; 
return _M_erase (__beg + (__first - __cbeg) , __beg + (__last - __cbeg)) ; 
} 
# 1476 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
void 
swap (vector & __x) noexcept 
{ 


; 

this -> _M_impl . _M_swap_data (__x . _M_impl) ; 
_Alloc_traits :: _S_on_swap (_M_get_Tp_allocator () , 
__x . _M_get_Tp_allocator ()) ; 
} 
# 1494
void 
clear () noexcept 
{ _M_erase_at_end (this -> _M_impl . _M_start) ; } 

protected : 




template < typename _ForwardIterator > 
pointer 
_M_allocate_and_copy (size_type __n , 
_ForwardIterator __first , _ForwardIterator __last) 
{ 
pointer __result = this -> _M_allocate (__n) ; 
try 
{ 
std :: __uninitialized_copy_a (__first , __last , __result , 
_M_get_Tp_allocator ()) ; 
return __result ; 
} 
catch (...) 
{ 
_M_deallocate (__result , __n) ; 
throw ; 
} 
} 
# 1553 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _InputIterator > 
void 
_M_range_initialize (_InputIterator __first , _InputIterator __last , 
std :: input_iterator_tag) 
{ 
try { 
for (; __first != __last ; ++ __first) 

emplace_back (* __first) ; 



} catch (...) { 
clear () ; 
throw ; 
} 
} 


template < typename _ForwardIterator > 
void 
_M_range_initialize (_ForwardIterator __first , _ForwardIterator __last , 
std :: forward_iterator_tag) 
{ 
const size_type __n = std :: distance (__first , __last) ; 
this -> _M_impl . _M_start 
= this -> _M_allocate (_S_check_init_len (__n , _M_get_Tp_allocator ())) ; 
this -> _M_impl . _M_end_of_storage = this -> _M_impl . _M_start + __n ; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_copy_a (__first , __last , 
this -> _M_impl . _M_start , 
_M_get_Tp_allocator ()) ; 
} 



void 
_M_fill_initialize (size_type __n , const value_type & __value) 
{ 
this -> _M_impl . _M_finish = 
std :: __uninitialized_fill_n_a (this -> _M_impl . _M_start , __n , __value , 
_M_get_Tp_allocator ()) ; 
} 



void 
_M_default_initialize (size_type __n) 
{ 
this -> _M_impl . _M_finish = 
std :: __uninitialized_default_n_a (this -> _M_impl . _M_start , __n , 
_M_get_Tp_allocator ()) ; 
} 
# 1615 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _Integer > 
void 
_M_assign_dispatch (_Integer __n , _Integer __val , __true_type) 
{ _M_fill_assign (__n , __val) ; } 


template < typename _InputIterator > 
void 
_M_assign_dispatch (_InputIterator __first , _InputIterator __last , 
__false_type) 
{ _M_assign_aux (__first , __last , std :: __iterator_category (__first)) ; } 


template < typename _InputIterator > 
void 
_M_assign_aux (_InputIterator __first , _InputIterator __last , 
std :: input_iterator_tag) ; 


template < typename _ForwardIterator > 
void 
_M_assign_aux (_ForwardIterator __first , _ForwardIterator __last , 
std :: forward_iterator_tag) ; 



void 
_M_fill_assign (size_type __n , const value_type & __val) ; 
# 1650
template < typename _Integer > 
void 
_M_insert_dispatch (iterator __pos , _Integer __n , _Integer __val , 
__true_type) 
{ _M_fill_insert (__pos , __n , __val) ; } 


template < typename _InputIterator > 
void 
_M_insert_dispatch (iterator __pos , _InputIterator __first , 
_InputIterator __last , __false_type) 
{ 
_M_range_insert (__pos , __first , __last , 
std :: __iterator_category (__first)) ; 
} 


template < typename _InputIterator > 
void 
_M_range_insert (iterator __pos , _InputIterator __first , 
_InputIterator __last , std :: input_iterator_tag) ; 


template < typename _ForwardIterator > 
void 
_M_range_insert (iterator __pos , _ForwardIterator __first , 
_ForwardIterator __last , std :: forward_iterator_tag) ; 



void 
_M_fill_insert (iterator __pos , size_type __n , const value_type & __x) ; 



void 
_M_default_append (size_type __n) ; 

bool 
_M_shrink_to_fit () ; 
# 1702 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
struct _Temporary_value 
{ 
template < typename ... _Args > 
explicit 
_Temporary_value (vector * __vec , _Args && ... __args) : _M_this (__vec) 
{ 
_Alloc_traits :: construct (_M_this -> _M_impl , _M_ptr () , 
std :: forward < _Args > (__args) ...) ; 
} 

~ _Temporary_value () 
{ _Alloc_traits :: destroy (_M_this -> _M_impl , _M_ptr ()) ; } 

value_type & 
_M_val () { return * _M_ptr () ; } 

private : 
_Tp * 
_M_ptr () { return reinterpret_cast < _Tp * > (& __buf) ; } 

vector * _M_this ; 
typename aligned_storage < sizeof (_Tp) , alignof (_Tp) > :: type __buf ; 
} ; 



template < typename _Arg > 
void 
_M_insert_aux (iterator __position , _Arg && __arg) ; 

template < typename ... _Args > 
void 
_M_realloc_insert (iterator __position , _Args && ... __args) ; 


iterator 
_M_insert_rval (const_iterator __position , value_type && __v) ; 


template < typename ... _Args > 
iterator 
_M_emplace_aux (const_iterator __position , _Args && ... __args) ; 


iterator 
_M_emplace_aux (const_iterator __position , value_type && __v) 
{ return _M_insert_rval (__position , std :: move (__v)) ; } 



size_type 
_M_check_len (size_type __n , const char * __s) const 
{ 
if (max_size () - size () < __n) 
__throw_length_error ((__s)) ; 

const size_type __len = size () + (std :: max) (size () , __n) ; 
return (__len < size () || __len > max_size ()) ? max_size () : __len ; 
} 


static size_type 
_S_check_init_len (size_type __n , const allocator_type & __a) 
{ 
if (__n > _S_max_size (_Tp_alloc_type (__a))) 
__throw_length_error (
("cannot create std::vector larger than max_size()")) ; 
return __n ; 
} 

static size_type 
_S_max_size (const _Tp_alloc_type & __a) noexcept 
{ 



const size_t __diffmax 
= __gnu_cxx :: __numeric_traits < ptrdiff_t > :: __max / sizeof (_Tp) ; 
const size_t __allocmax = _Alloc_traits :: max_size (__a) ; 
return (std :: min) (__diffmax , __allocmax) ; 
} 
# 1788
void 
_M_erase_at_end (pointer __pos) noexcept 
{ 
if (size_type __n = this -> _M_impl . _M_finish - __pos) 
{ 
std :: _Destroy (__pos , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish = __pos ; 
; 
} 
} 

iterator 
_M_erase (iterator __position) ; 

iterator 
_M_erase (iterator __first , iterator __last) ; 


private : 



void 
_M_move_assign (vector && __x , true_type) noexcept 
{ 
vector __tmp (get_allocator ()) ; 
this -> _M_impl . _M_swap_data (__x . _M_impl) ; 
__tmp . _M_impl . _M_swap_data (__x . _M_impl) ; 
std :: __alloc_on_move (_M_get_Tp_allocator () , __x . _M_get_Tp_allocator ()) ; 
} 



void 
_M_move_assign (vector && __x , false_type) 
{ 
if (__x . _M_get_Tp_allocator () == this -> _M_get_Tp_allocator ()) 
_M_move_assign (std :: move (__x) , true_type ()) ; 
else 
{ 


this -> assign (std :: __make_move_if_noexcept_iterator (__x . begin ()) , 
std :: __make_move_if_noexcept_iterator (__x . end ())) ; 
__x . clear () ; 
} 
} 


template < typename _Up > 
_Up * 
_M_data_ptr (_Up * __ptr) const noexcept 
{ return __ptr ; } 


template < typename _Ptr > 
typename std :: pointer_traits < _Ptr > :: element_type * 
_M_data_ptr (_Ptr __ptr) const 
{ return empty () ? nullptr : std :: __to_address (__ptr) ; } 
# 1864 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
} ;
# 1886 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _Tp , typename _Alloc > 
inline bool 
operator == (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return (__x . size () == __y . size () 
&& std :: equal (__x . begin () , __x . end () , __y . begin ())) ; } 
# 1903 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
template < typename _Tp , typename _Alloc > 
inline bool 
operator < (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return std :: lexicographical_compare (__x . begin () , __x . end () , 
__y . begin () , __y . end ()) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator != (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator > (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator <= (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator >= (const vector < _Tp , _Alloc > & __x , const vector < _Tp , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Tp , typename _Alloc > 
inline void 
swap (vector < _Tp , _Alloc > & __x , vector < _Tp , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 1957 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_vector.h" 3
}
# 64 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
namespace std { 




typedef unsigned long _Bit_type; 
enum { _S_word_bit = ((int)(8 * sizeof(_Bit_type)))}; 

struct _Bit_reference { 

_Bit_type *_M_p; 
_Bit_type _M_mask; 

_Bit_reference(_Bit_type *__x, _Bit_type __y) : _M_p(__x), _M_mask(__y) 
{ } 

_Bit_reference() noexcept : _M_p((0)), _M_mask((0)) { } 


_Bit_reference(const _Bit_reference &) = default;


operator bool() const noexcept 
{ return !(!(*(_M_p) & _M_mask)); } 


_Bit_reference &operator=(bool __x) noexcept 
{ 
if (__x) 
*(_M_p) |= _M_mask;  else 

*(_M_p) &= ~_M_mask;   
return *this; 
} 


_Bit_reference &operator=(const _Bit_reference &__x) noexcept 
{ return (*this = (bool)__x); } 


bool operator==(const _Bit_reference &__x) const 
{ return (bool)(*this) == (bool)__x; } 


bool operator<(const _Bit_reference &__x) const 
{ return !((bool)(*this)) && (bool)__x; } 


void flip() noexcept 
{ *(_M_p) ^= _M_mask; } 
}; 



inline void swap(_Bit_reference __x, _Bit_reference __y) noexcept 
{ 
bool __tmp = __x; 
(__x = __y); 
(__y = __tmp); 
} 


inline void swap(_Bit_reference __x, bool &__y) noexcept 
{ 
bool __tmp = __x; 
(__x = __y); 
__y = __tmp; 
} 


inline void swap(bool &__x, _Bit_reference __y) noexcept 
{ 
bool __tmp = __x; 
__x = __y; 
(__y = __tmp); 
} 


struct _Bit_iterator_base : public iterator< random_access_iterator_tag, bool>  { 


_Bit_type *_M_p; 
unsigned _M_offset; 

_Bit_iterator_base(_Bit_type *__x, unsigned __y) : _M_p(__x), _M_offset(__y) 
{ } 


void _M_bump_up() 
{ 
if ((_M_offset)++ == (int)_S_word_bit - 1) 
{ 
_M_offset = 0; 
++_M_p; 
}  
} 


void _M_bump_down() 
{ 
if ((_M_offset)-- == 0) 
{ 
_M_offset = (int)_S_word_bit - 1; 
--_M_p; 
}  
} 


void _M_incr(ptrdiff_t __i) 
{ 
difference_type __n = __i + _M_offset; 
_M_p += __n / (int)_S_word_bit; 
__n = __n % (int)_S_word_bit; 
if (__n < 0) 
{ 
__n += (int)_S_word_bit; 
--_M_p; 
}  
_M_offset = static_cast< unsigned>(__n); 
} 


bool operator==(const _Bit_iterator_base &__i) const 
{ return _M_p == __i._M_p && _M_offset == __i._M_offset; } 


bool operator<(const _Bit_iterator_base &__i) const 
{ 
return _M_p < __i._M_p || (_M_p == __i._M_p && _M_offset < __i._M_offset); 

} 


bool operator!=(const _Bit_iterator_base &__i) const 
{ return !((*this == __i)); } 


bool operator>(const _Bit_iterator_base &__i) const 
{ return (__i < *this); } 


bool operator<=(const _Bit_iterator_base &__i) const 
{ return !((__i < *this)); } 


bool operator>=(const _Bit_iterator_base &__i) const 
{ return !((*this < __i)); } 
}; 


inline ptrdiff_t operator-(const _Bit_iterator_base &__x, const _Bit_iterator_base &__y) 
{ 
return ((((int)_S_word_bit * (__x._M_p - __y._M_p) + __x._M_offset) - __y._M_offset)); 

} 

struct _Bit_iterator : public _Bit_iterator_base { 

typedef _Bit_reference reference; 
typedef _Bit_reference *pointer; 
typedef _Bit_iterator iterator; 

_Bit_iterator() : _Bit_iterator_base(0, 0) { } 

_Bit_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
{ } 


iterator _M_const_cast() const 
{ return *this; } 


reference operator*() const 
{ return reference(_M_p, 1UL << _M_offset); } 


iterator &operator++() 
{ 
this->_M_bump_up(); 
return *this; 
} 


iterator operator++(int) 
{ 
iterator __tmp = *this; 
this->_M_bump_up(); 
return __tmp; 
} 


iterator &operator--() 
{ 
this->_M_bump_down(); 
return *this; 
} 


iterator operator--(int) 
{ 
iterator __tmp = *this; 
this->_M_bump_down(); 
return __tmp; 
} 


iterator &operator+=(difference_type __i) 
{ 
this->_M_incr(__i); 
return *this; 
} 


iterator &operator-=(difference_type __i) 
{ 
(*this += -__i); 
return *this; 
} 


iterator operator+(difference_type __i) const 
{ 
iterator __tmp = *this; 
return (__tmp += __i); 
} 


iterator operator-(difference_type __i) const 
{ 
iterator __tmp = *this; 
return (__tmp -= __i); 
} 


reference operator[](difference_type __i) const 
{ return (*((*this + __i))); } 
}; 


inline _Bit_iterator operator+(ptrdiff_t __n, const _Bit_iterator &__x) 
{ return (__x + __n); } 

struct _Bit_const_iterator : public _Bit_iterator_base { 

typedef bool reference; 
typedef bool const_reference; 
typedef const bool *pointer; 
typedef _Bit_const_iterator const_iterator; 

_Bit_const_iterator() : _Bit_iterator_base(0, 0) { } 

_Bit_const_iterator(_Bit_type *__x, unsigned __y) : _Bit_iterator_base(__x, __y) 
{ } 

_Bit_const_iterator(const _Bit_iterator &__x) : _Bit_iterator_base(__x._M_p, __x._M_offset) 
{ } 


_Bit_iterator _M_const_cast() const 
{ return _Bit_iterator(_M_p, _M_offset); } 


const_reference operator*() const 
{ return _Bit_reference(_M_p, 1UL << _M_offset); } 


const_iterator &operator++() 
{ 
this->_M_bump_up(); 
return *this; 
} 


const_iterator operator++(int) 
{ 
const_iterator __tmp = *this; 
this->_M_bump_up(); 
return __tmp; 
} 


const_iterator &operator--() 
{ 
this->_M_bump_down(); 
return *this; 
} 


const_iterator operator--(int) 
{ 
const_iterator __tmp = *this; 
this->_M_bump_down(); 
return __tmp; 
} 


const_iterator &operator+=(difference_type __i) 
{ 
this->_M_incr(__i); 
return *this; 
} 


const_iterator &operator-=(difference_type __i) 
{ 
(*this += -__i); 
return *this; 
} 


const_iterator operator+(difference_type __i) const 
{ 
const_iterator __tmp = *this; 
return (__tmp += __i); 
} 


const_iterator operator-(difference_type __i) const 
{ 
const_iterator __tmp = *this; 
return (__tmp -= __i); 
} 


const_reference operator[](difference_type __i) const 
{ return (*((*this + __i))); } 
}; 


inline _Bit_const_iterator operator+(ptrdiff_t __n, const _Bit_const_iterator &__x) 
{ return (__x + __n); } 


inline void __fill_bvector(_Bit_type *__v, unsigned 
__first, unsigned __last, bool __x) 
{ 
const _Bit_type __fmask = ~0UL << __first; 
const _Bit_type __lmask = ~0UL >> ((_S_word_bit) - __last); 
const _Bit_type __mask = __fmask & __lmask; 

if (__x) 
*__v |= __mask;  else 

*__v &= ~__mask;   
} 


inline void fill(_Bit_iterator __first, _Bit_iterator __last, const bool &__x) 
{ 
if (__first._M_p != __last._M_p) 
{ 
_Bit_type *__first_p = __first._M_p; 
if (__first._M_offset != 0) 
__fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);   

__builtin_memset(__first_p, __x ? ~0 : 0, (__last._M_p - __first_p) * sizeof(_Bit_type)); 


if (__last._M_offset != 0) 
__fill_bvector(__last._M_p, 0, __last._M_offset, __x);   
} else 
if (__first._M_offset != __last._M_offset) 
__fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);     
} 

template < typename _Alloc > 
struct _Bvector_base 
{ 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Bit_type > :: other _Bit_alloc_type ; 
typedef typename __gnu_cxx :: __alloc_traits < _Bit_alloc_type > 
_Bit_alloc_traits ; 
typedef typename _Bit_alloc_traits :: pointer _Bit_pointer ; 

struct _Bvector_impl_data 
{ 
_Bit_iterator _M_start ; 
_Bit_iterator _M_finish ; 
_Bit_pointer _M_end_of_storage ; 

_Bvector_impl_data () noexcept 
: _M_start () , _M_finish () , _M_end_of_storage () 
{ } 


_Bvector_impl_data (_Bvector_impl_data && __x) noexcept 
: _M_start (__x . _M_start) , _M_finish (__x . _M_finish) 
, _M_end_of_storage (__x . _M_end_of_storage) 
{ __x . _M_reset () ; } 

void 
_M_move_data (_Bvector_impl_data && __x) noexcept 
{ 
this -> _M_start = __x . _M_start ; 
this -> _M_finish = __x . _M_finish ; 
this -> _M_end_of_storage = __x . _M_end_of_storage ; 
__x . _M_reset () ; 
} 


void 
_M_reset () noexcept 
{ 
_M_start = _M_finish = _Bit_iterator () ; 
_M_end_of_storage = _Bit_pointer () ; 
} 
} ; 

struct _Bvector_impl 
: public _Bit_alloc_type , public _Bvector_impl_data 
{ 
public : 
_Bvector_impl () noexcept (is_nothrow_default_constructible < _Bit_alloc_type > :: value) 

: _Bit_alloc_type () 
{ } 

_Bvector_impl (const _Bit_alloc_type & __a) noexcept 
: _Bit_alloc_type (__a) 
{ } 


_Bvector_impl (_Bvector_impl &&) = default ; 


_Bit_type * 
_M_end_addr () const noexcept 
{ 
if (this -> _M_end_of_storage) 
return std :: __addressof (this -> _M_end_of_storage [ - 1 ]) + 1 ; 
return 0 ; 
} 
} ; 

public : 
typedef _Alloc allocator_type ; 

_Bit_alloc_type & 
_M_get_Bit_allocator () noexcept 
{ return this -> _M_impl ; } 

const _Bit_alloc_type & 
_M_get_Bit_allocator () const noexcept 
{ return this -> _M_impl ; } 

allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_get_Bit_allocator ()) ; } 


_Bvector_base () = default ; 




_Bvector_base (const allocator_type & __a) 
: _M_impl (__a) { } 


_Bvector_base (_Bvector_base &&) = default ; 


~ _Bvector_base () 
{ this -> _M_deallocate () ; } 

protected : 
_Bvector_impl _M_impl ; 

_Bit_pointer 
_M_allocate (size_t __n) 
{ return _Bit_alloc_traits :: allocate (_M_impl , _S_nword (__n)) ; } 

void 
_M_deallocate () 
{ 
if (_M_impl . _M_start . _M_p) 
{ 
const size_t __n = _M_impl . _M_end_addr () - _M_impl . _M_start . _M_p ; 
_Bit_alloc_traits :: deallocate (_M_impl , 
_M_impl . _M_end_of_storage - __n , 
__n) ; 
_M_impl . _M_reset () ; 
} 
} 


void 
_M_move_data (_Bvector_base && __x) noexcept 
{ _M_impl . _M_move_data (std :: move (__x . _M_impl)) ; } 


static size_t 
_S_nword (size_t __n) 
{ return (__n + int (_S_word_bit) - 1) / int (_S_word_bit) ; } 
} ;



}




namespace std { 
# 591 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
template < typename _Alloc > 
class vector < bool , _Alloc > : protected _Bvector_base < _Alloc > 
{ 
typedef _Bvector_base < _Alloc > _Base ; 
typedef typename _Base :: _Bit_pointer _Bit_pointer ; 
typedef typename _Base :: _Bit_alloc_traits _Bit_alloc_traits ; 


friend struct std :: hash < vector > ; 


public : 
typedef bool value_type ; 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Bit_reference reference ; 
typedef bool const_reference ; 
typedef _Bit_reference * pointer ; 
typedef const bool * const_pointer ; 
typedef _Bit_iterator iterator ; 
typedef _Bit_const_iterator const_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 
typedef std :: reverse_iterator < iterator > reverse_iterator ; 
typedef _Alloc allocator_type ; 

allocator_type 
get_allocator () const 
{ return _Base :: get_allocator () ; } 

protected : 
using _Base :: _M_allocate ; 
using _Base :: _M_deallocate ; 
using _Base :: _S_nword ; 
using _Base :: _M_get_Bit_allocator ; 

public : 

vector () = default ; 




explicit 
vector (const allocator_type & __a) 
: _Base (__a) { } 


explicit 
vector (size_type __n , const allocator_type & __a = allocator_type ()) 
: vector (__n , false , __a) 
{ } 

vector (size_type __n , const bool & __value , 
const allocator_type & __a = allocator_type ()) 
# 650
: _Base (__a) 
{ 
_M_initialize (__n) ; 
_M_initialize_value (__value) ; 
} 

vector (const vector & __x) 
: _Base (_Bit_alloc_traits :: _S_select_on_copy (__x . _M_get_Bit_allocator ())) 
{ 
_M_initialize (__x . size ()) ; 
_M_copy_aligned (__x . begin () , __x . end () , this -> _M_impl . _M_start) ; 
} 


vector (vector &&) = default ; 

vector (vector && __x , const allocator_type & __a) 
noexcept (_Bit_alloc_traits :: _S_always_equal ()) 
: _Base (__a) 
{ 
if (__x . get_allocator () == __a) 
this -> _M_move_data (std :: move (__x)) ; 
else 
{ 
_M_initialize (__x . size ()) ; 
_M_copy_aligned (__x . begin () , __x . end () , begin ()) ; 
__x . clear () ; 
} 
} 

vector (const vector & __x , const allocator_type & __a) 
: _Base (__a) 
{ 
_M_initialize (__x . size ()) ; 
_M_copy_aligned (__x . begin () , __x . end () , this -> _M_impl . _M_start) ; 
} 

vector (initializer_list < bool > __l , 
const allocator_type & __a = allocator_type ()) 
: _Base (__a) 
{ 
_M_initialize_range (__l . begin () , __l . end () , 
random_access_iterator_tag ()) ; 
} 



template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
vector (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a = allocator_type ()) 
: _Base (__a) 
{ _M_initialize_dispatch (__first , __last , __false_type ()) ; } 
# 714 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
~ vector () noexcept { } 

vector & 
operator = (const vector & __x) 
{ 
if (& __x == this) 
return * this ; 

if (_Bit_alloc_traits :: _S_propagate_on_copy_assign ()) 
{ 
if (this -> _M_get_Bit_allocator () != __x . _M_get_Bit_allocator ()) 
{ 
this -> _M_deallocate () ; 
std :: __alloc_on_copy (_M_get_Bit_allocator () , 
__x . _M_get_Bit_allocator ()) ; 
_M_initialize (__x . size ()) ; 
} 
else 
std :: __alloc_on_copy (_M_get_Bit_allocator () , 
__x . _M_get_Bit_allocator ()) ; 
} 

if (__x . size () > capacity ()) 
{ 
this -> _M_deallocate () ; 
_M_initialize (__x . size ()) ; 
} 
this -> _M_impl . _M_finish = _M_copy_aligned (__x . begin () , __x . end () , 
begin ()) ; 
return * this ; 
} 


vector & 
operator = (vector && __x) noexcept (_Bit_alloc_traits :: _S_nothrow_move ()) 
{ 
if (_Bit_alloc_traits :: _S_propagate_on_move_assign () 
|| this -> _M_get_Bit_allocator () == __x . _M_get_Bit_allocator ()) 
{ 
this -> _M_deallocate () ; 
this -> _M_move_data (std :: move (__x)) ; 
std :: __alloc_on_move (_M_get_Bit_allocator () , 
__x . _M_get_Bit_allocator ()) ; 
} 
else 
{ 
if (__x . size () > capacity ()) 
{ 
this -> _M_deallocate () ; 
_M_initialize (__x . size ()) ; 
} 
this -> _M_impl . _M_finish = _M_copy_aligned (__x . begin () , __x . end () , 
begin ()) ; 
__x . clear () ; 
} 
return * this ; 
} 

vector & 
operator = (initializer_list < bool > __l) 
{ 
this -> assign (__l . begin () , __l . end ()) ; 
return * this ; 
} 
# 784
void 
assign (size_type __n , const bool & __x) 
{ _M_fill_assign (__n , __x) ; } 


template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
void 
assign (_InputIterator __first , _InputIterator __last) 
{ _M_assign_aux (__first , __last , std :: __iterator_category (__first)) ; } 
# 805 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
void 
assign (initializer_list < bool > __l) 
{ _M_assign_aux (__l . begin () , __l . end () , random_access_iterator_tag ()) ; } 


iterator 
begin () noexcept 
{ return iterator (this -> _M_impl . _M_start . _M_p , 0) ; } 

const_iterator 
begin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_start . _M_p , 0) ; } 

iterator 
end () noexcept 
{ return this -> _M_impl . _M_finish ; } 

const_iterator 
end () const noexcept 
{ return this -> _M_impl . _M_finish ; } 

reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (end ()) ; } 

const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 

reverse_iterator 
rend () noexcept 
{ return reverse_iterator (begin ()) ; } 

const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 


const_iterator 
cbegin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_start . _M_p , 0) ; } 

const_iterator 
cend () const noexcept 
{ return this -> _M_impl . _M_finish ; } 

const_reverse_iterator 
crbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 

const_reverse_iterator 
crend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 


size_type 
size () const noexcept 
{ return size_type (end () - begin ()) ; } 

size_type 
max_size () const noexcept 
{ 
const size_type __isize = 
__gnu_cxx :: __numeric_traits < difference_type > :: __max 
- int (_S_word_bit) + 1 ; 
const size_type __asize 
= _Bit_alloc_traits :: max_size (_M_get_Bit_allocator ()) ; 
return (__asize <= __isize / int (_S_word_bit) 
? __asize * int (_S_word_bit) : __isize) ; 
} 

size_type 
capacity () const noexcept 
{ return size_type (const_iterator (this -> _M_impl . _M_end_addr () , 0) 
- begin ()) ; } 

bool 
empty () const noexcept 
{ return begin () == end () ; } 

reference 
operator [ ] (size_type __n) 
{ 
return * iterator (this -> _M_impl . _M_start . _M_p 
+ __n / int (_S_word_bit) , __n % int (_S_word_bit)) ; 
} 

const_reference 
operator [ ] (size_type __n) const 
{ 
return * const_iterator (this -> _M_impl . _M_start . _M_p 
+ __n / int (_S_word_bit) , __n % int (_S_word_bit)) ; 
} 

protected : 
void 
_M_range_check (size_type __n) const 
{ 
if (__n >= this -> size ()) 
__throw_out_of_range_fmt (("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)") 

, 
__n , this -> size ()) ; 
} 

public : 
reference 
at (size_type __n) 
{ _M_range_check (__n) ; return (* this) [ __n ] ; } 

const_reference 
at (size_type __n) const 
{ _M_range_check (__n) ; return (* this) [ __n ] ; } 

void 
reserve (size_type __n) 
{ 
if (__n > max_size ()) 
__throw_length_error (("vector::reserve")) ; 
if (capacity () < __n) 
_M_reallocate (__n) ; 
} 

reference 
front () 
{ return * begin () ; } 

const_reference 
front () const 
{ return * begin () ; } 

reference 
back () 
{ return * (end () - 1) ; } 

const_reference 
back () const 
{ return * (end () - 1) ; } 
# 949
void 
data () noexcept { } 

void 
push_back (bool __x) 
{ 
if (this -> _M_impl . _M_finish . _M_p != this -> _M_impl . _M_end_addr ()) 
* this -> _M_impl . _M_finish ++ = __x ; 
else 
_M_insert_aux (end () , __x) ; 
} 

void 
swap (vector & __x) noexcept 
{ 
std :: swap (this -> _M_impl . _M_start , __x . _M_impl . _M_start) ; 
std :: swap (this -> _M_impl . _M_finish , __x . _M_impl . _M_finish) ; 
std :: swap (this -> _M_impl . _M_end_of_storage , 
__x . _M_impl . _M_end_of_storage) ; 
_Bit_alloc_traits :: _S_on_swap (_M_get_Bit_allocator () , 
__x . _M_get_Bit_allocator ()) ; 
} 


static void 
swap (reference __x , reference __y) noexcept 
{ 
bool __tmp = __x ; 
__x = __y ; 
__y = __tmp ; 
} 

iterator 

insert (const_iterator __position , const bool & __x = bool ()) 



{ 
const difference_type __n = __position - begin () ; 
if (this -> _M_impl . _M_finish . _M_p != this -> _M_impl . _M_end_addr () 
&& __position == end ()) 
* this -> _M_impl . _M_finish ++ = __x ; 
else 
_M_insert_aux (__position . _M_const_cast () , __x) ; 
return begin () + __n ; 
} 


template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
iterator 
insert (const_iterator __position , 
_InputIterator __first , _InputIterator __last) 
{ 
difference_type __offset = __position - cbegin () ; 
_M_insert_dispatch (__position . _M_const_cast () , 
__first , __last , __false_type ()) ; 
return begin () + __offset ; 
} 
# 1021 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
iterator 
insert (const_iterator __position , size_type __n , const bool & __x) 
{ 
difference_type __offset = __position - cbegin () ; 
_M_fill_insert (__position . _M_const_cast () , __n , __x) ; 
return begin () + __offset ; 
} 
# 1035
iterator 
insert (const_iterator __p , initializer_list < bool > __l) 
{ return this -> insert (__p , __l . begin () , __l . end ()) ; } 


void 
pop_back () 
{ -- this -> _M_impl . _M_finish ; } 

iterator 

erase (const_iterator __position) 



{ return _M_erase (__position . _M_const_cast ()) ; } 

iterator 

erase (const_iterator __first , const_iterator __last) 



{ return _M_erase (__first . _M_const_cast () , __last . _M_const_cast ()) ; } 

void 
resize (size_type __new_size , bool __x = bool ()) 
{ 
if (__new_size < size ()) 
_M_erase_at_end (begin () + difference_type (__new_size)) ; 
else 
insert (end () , __new_size - size () , __x) ; 
} 


void 
shrink_to_fit () 
{ _M_shrink_to_fit () ; } 


void 
flip () noexcept 
{ 
_Bit_type * const __end = this -> _M_impl . _M_end_addr () ; 
for (_Bit_type * __p = this -> _M_impl . _M_start . _M_p ; __p != __end ; ++ __p) 
* __p = ~ * __p ; 
} 

void 
clear () noexcept 
{ _M_erase_at_end (begin ()) ; } 


template < typename ... _Args > 



void 

emplace_back (_Args && ... __args) 
{ 
push_back (bool (__args ...)) ; 



} 

template < typename ... _Args > 
iterator 
emplace (const_iterator __pos , _Args && ... __args) 
{ return insert (__pos , bool (__args ...)) ; } 


protected : 

iterator 
_M_copy_aligned (const_iterator __first , const_iterator __last , 
iterator __result) 
{ 
_Bit_type * __q = std :: copy (__first . _M_p , __last . _M_p , __result . _M_p) ; 
return std :: copy (const_iterator (__last . _M_p , 0) , __last , 
iterator (__q , 0)) ; 
} 

void 
_M_initialize (size_type __n) 
{ 
if (__n) 
{ 
_Bit_pointer __q = this -> _M_allocate (__n) ; 
this -> _M_impl . _M_end_of_storage = __q + _S_nword (__n) ; 
this -> _M_impl . _M_start = iterator (std :: __addressof (* __q) , 0) ; 
} 
else 
{ 
this -> _M_impl . _M_end_of_storage = _Bit_pointer () ; 
this -> _M_impl . _M_start = iterator (0 , 0) ; 
} 
this -> _M_impl . _M_finish = this -> _M_impl . _M_start + difference_type (__n) ; 

} 

void 
_M_initialize_value (bool __x) 
{ 
if (_Bit_type * __p = this -> _M_impl . _M_start . _M_p) 
__builtin_memset (__p , __x ? ~ 0 : 0 , 
(this -> _M_impl . _M_end_addr () - __p) 
* sizeof (_Bit_type)) ; 
} 

void 
_M_reallocate (size_type __n) ; 


bool 
_M_shrink_to_fit () ; 
# 1158
template < typename _Integer > 
void 
_M_initialize_dispatch (_Integer __n , _Integer __x , __true_type) 
{ 
_M_initialize (static_cast < size_type > (__n)) ; 
_M_initialize_value (__x) ; 
} 

template < typename _InputIterator > 
void 
_M_initialize_dispatch (_InputIterator __first , _InputIterator __last , 
__false_type) 
{ _M_initialize_range (__first , __last , 
std :: __iterator_category (__first)) ; } 

template < typename _InputIterator > 
void 
_M_initialize_range (_InputIterator __first , _InputIterator __last , 
std :: input_iterator_tag) 
{ 
for (; __first != __last ; ++ __first) 
push_back (* __first) ; 
} 

template < typename _ForwardIterator > 
void 
_M_initialize_range (_ForwardIterator __first , _ForwardIterator __last , 
std :: forward_iterator_tag) 
{ 
const size_type __n = std :: distance (__first , __last) ; 
_M_initialize (__n) ; 
std :: copy (__first , __last , this -> _M_impl . _M_start) ; 
} 
# 1207 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_bvector.h" 3
void 
_M_fill_assign (size_t __n , bool __x) 
{ 
if (__n > size ()) 
{ 
_M_initialize_value (__x) ; 
insert (end () , __n - size () , __x) ; 
} 
else 
{ 
_M_erase_at_end (begin () + __n) ; 
_M_initialize_value (__x) ; 
} 
} 

template < typename _InputIterator > 
void 
_M_assign_aux (_InputIterator __first , _InputIterator __last , 
std :: input_iterator_tag) 
{ 
iterator __cur = begin () ; 
for (; __first != __last && __cur != end () ; ++ __cur , (void) ++ __first) 
* __cur = * __first ; 
if (__first == __last) 
_M_erase_at_end (__cur) ; 
else 
insert (end () , __first , __last) ; 
} 

template < typename _ForwardIterator > 
void 
_M_assign_aux (_ForwardIterator __first , _ForwardIterator __last , 
std :: forward_iterator_tag) 
{ 
const size_type __len = std :: distance (__first , __last) ; 
if (__len < size ()) 
_M_erase_at_end (std :: copy (__first , __last , begin ())) ; 
else 
{ 
_ForwardIterator __mid = __first ; 
std :: advance (__mid , size ()) ; 
std :: copy (__first , __mid , begin ()) ; 
insert (end () , __mid , __last) ; 
} 
} 
# 1257
template < typename _Integer > 
void 
_M_insert_dispatch (iterator __pos , _Integer __n , _Integer __x , 
__true_type) 
{ _M_fill_insert (__pos , __n , __x) ; } 

template < typename _InputIterator > 
void 
_M_insert_dispatch (iterator __pos , 
_InputIterator __first , _InputIterator __last , 
__false_type) 
{ _M_insert_range (__pos , __first , __last , 
std :: __iterator_category (__first)) ; } 

void 
_M_fill_insert (iterator __position , size_type __n , bool __x) ; 

template < typename _InputIterator > 
void 
_M_insert_range (iterator __pos , _InputIterator __first , 
_InputIterator __last , std :: input_iterator_tag) 
{ 
for (; __first != __last ; ++ __first) 
{ 
__pos = insert (__pos , * __first) ; 
++ __pos ; 
} 
} 

template < typename _ForwardIterator > 
void 
_M_insert_range (iterator __position , _ForwardIterator __first , 
_ForwardIterator __last , std :: forward_iterator_tag) ; 

void 
_M_insert_aux (iterator __position , bool __x) ; 

size_type 
_M_check_len (size_type __n , const char * __s) const 
{ 
if (max_size () - size () < __n) 
__throw_length_error ((__s)) ; 

const size_type __len = size () + std :: max (size () , __n) ; 
return (__len < size () || __len > max_size ()) ? max_size () : __len ; 
} 

void 
_M_erase_at_end (iterator __pos) 
{ this -> _M_impl . _M_finish = __pos ; } 

iterator 
_M_erase (iterator __pos) ; 

iterator 
_M_erase (iterator __first , iterator __last) ; 
} ;



}



namespace std { 
# 1327
template < typename _Alloc > 
struct hash < std :: vector < bool , _Alloc > > 
: public __hash_base < size_t , std :: vector < bool , _Alloc > > 
{ 
size_t 
operator () (const std :: vector < bool , _Alloc > &) const noexcept ; 
} ;


}
# 59 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\vector.tcc" 3
namespace std { 




template < typename _Tp , typename _Alloc > 
void 
vector < _Tp , _Alloc > :: 
reserve (size_type __n) 
{ 
if (__n > this -> max_size ()) 
__throw_length_error (("vector::reserve")) ; 
if (this -> capacity () < __n) 
{ 
const size_type __old_size = size () ; 
pointer __tmp ; 

if (_S_use_relocate ()) 
{ 
__tmp = this -> _M_allocate (__n) ; 
_S_relocate (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
__tmp , _M_get_Tp_allocator ()) ; 
} 
else 

{ 
__tmp = _M_allocate_and_copy (__n , 
std :: __make_move_if_noexcept_iterator (this -> _M_impl . _M_start) , 
std :: __make_move_if_noexcept_iterator (this -> _M_impl . _M_finish)) ; 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
} 
; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __tmp ; 
this -> _M_impl . _M_finish = __tmp + __old_size ; 
this -> _M_impl . _M_end_of_storage = this -> _M_impl . _M_start + __n ; 
} 
} 


template < typename _Tp , typename _Alloc > 
template < typename ... _Args > 



void 

vector < _Tp , _Alloc > :: 
emplace_back (_Args && ... __args) 
{ 
if (this -> _M_impl . _M_finish != this -> _M_impl . _M_end_of_storage) 
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
std :: forward < _Args > (__args) ...) ; 
++ this -> _M_impl . _M_finish ; 
; 
} 
else 
_M_realloc_insert (end () , std :: forward < _Args > (__args) ...) ; 



} 


template < typename _Tp , typename _Alloc > 
typename vector < _Tp , _Alloc > :: iterator 
vector < _Tp , _Alloc > :: 

insert (const_iterator __position , const value_type & __x) 



{ 
const size_type __n = __position - begin () ; 
if (this -> _M_impl . _M_finish != this -> _M_impl . _M_end_of_storage) 
if (__position == end ()) 
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
__x) ; 
++ this -> _M_impl . _M_finish ; 
; 
} 
else 
{ 

const auto __pos = begin () + (__position - cbegin ()) ; 


_Temporary_value __x_copy (this , __x) ; 
_M_insert_aux (__pos , std :: move (__x_copy . _M_val ())) ; 



} 
else 

_M_realloc_insert (begin () + (__position - cbegin ()) , __x) ; 




return iterator (this -> _M_impl . _M_start + __n) ; 
} 

template < typename _Tp , typename _Alloc > 
typename vector < _Tp , _Alloc > :: iterator 
vector < _Tp , _Alloc > :: 
_M_erase (iterator __position) 
{ 
if (__position + 1 != end ()) 
std :: move (__position + 1 , end () , __position) ; 
-- this -> _M_impl . _M_finish ; 
_Alloc_traits :: destroy (this -> _M_impl , this -> _M_impl . _M_finish) ; 
; 
return __position ; 
} 

template < typename _Tp , typename _Alloc > 
typename vector < _Tp , _Alloc > :: iterator 
vector < _Tp , _Alloc > :: 
_M_erase (iterator __first , iterator __last) 
{ 
if (__first != __last) 
{ 
if (__last != end ()) 
std :: move (__last , end () , __first) ; 
_M_erase_at_end (__first . base () + (end () - __last)) ; 
} 
return __first ; 
} 

template < typename _Tp , typename _Alloc > 
vector < _Tp , _Alloc > & 
vector < _Tp , _Alloc > :: 
operator = (const vector < _Tp , _Alloc > & __x) 
{ 
if (& __x != this) 
{ 
; 

if (_Alloc_traits :: _S_propagate_on_copy_assign ()) 
{ 
if (! _Alloc_traits :: _S_always_equal () 
&& _M_get_Tp_allocator () != __x . _M_get_Tp_allocator ()) 
{ 

this -> clear () ; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = nullptr ; 
this -> _M_impl . _M_finish = nullptr ; 
this -> _M_impl . _M_end_of_storage = nullptr ; 
} 
std :: __alloc_on_copy (_M_get_Tp_allocator () , 
__x . _M_get_Tp_allocator ()) ; 
} 

const size_type __xlen = __x . size () ; 
if (__xlen > capacity ()) 
{ 
pointer __tmp = _M_allocate_and_copy (__xlen , __x . begin () , 
__x . end ()) ; 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __tmp ; 
this -> _M_impl . _M_end_of_storage = this -> _M_impl . _M_start + __xlen ; 
} 
else if (size () >= __xlen) 
{ 
std :: _Destroy (std :: copy (__x . begin () , __x . end () , begin ()) , 
end () , _M_get_Tp_allocator ()) ; 
} 
else 
{ 
std :: copy (__x . _M_impl . _M_start , __x . _M_impl . _M_start + size () , 
this -> _M_impl . _M_start) ; 
std :: __uninitialized_copy_a (__x . _M_impl . _M_start + size () , 
__x . _M_impl . _M_finish , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
} 
this -> _M_impl . _M_finish = this -> _M_impl . _M_start + __xlen ; 
} 
return * this ; 
} 

template < typename _Tp , typename _Alloc > 
void 
vector < _Tp , _Alloc > :: 
_M_fill_assign (size_t __n , const value_type & __val) 
{ 
if (__n > capacity ()) 
{ 
vector __tmp (__n , __val , _M_get_Tp_allocator ()) ; 
__tmp . _M_impl . _M_swap_data (this -> _M_impl) ; 
} 
else if (__n > size ()) 
{ 
std :: fill (begin () , end () , __val) ; 
const size_type __add = __n - size () ; 
; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_fill_n_a (this -> _M_impl . _M_finish , 
__add , __val , _M_get_Tp_allocator ()) ; 
; 
} 
else 
_M_erase_at_end (std :: fill_n (this -> _M_impl . _M_start , __n , __val)) ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _InputIterator > 
void 
vector < _Tp , _Alloc > :: 
_M_assign_aux (_InputIterator __first , _InputIterator __last , 
std :: input_iterator_tag) 
{ 
pointer __cur (this -> _M_impl . _M_start) ; 
for (; __first != __last && __cur != this -> _M_impl . _M_finish ; 
++ __cur , (void) ++ __first) 
* __cur = * __first ; 
if (__first == __last) 
_M_erase_at_end (__cur) ; 
else 
_M_range_insert (end () , __first , __last , 
std :: __iterator_category (__first)) ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _ForwardIterator > 
void 
vector < _Tp , _Alloc > :: 
_M_assign_aux (_ForwardIterator __first , _ForwardIterator __last , 
std :: forward_iterator_tag) 
{ 
const size_type __len = std :: distance (__first , __last) ; 

if (__len > capacity ()) 
{ 
_S_check_init_len (__len , _M_get_Tp_allocator ()) ; 
pointer __tmp (_M_allocate_and_copy (__len , __first , __last)) ; 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __tmp ; 
this -> _M_impl . _M_finish = this -> _M_impl . _M_start + __len ; 
this -> _M_impl . _M_end_of_storage = this -> _M_impl . _M_finish ; 
} 
else if (size () >= __len) 
_M_erase_at_end (std :: copy (__first , __last , this -> _M_impl . _M_start)) ; 
else 
{ 
_ForwardIterator __mid = __first ; 
std :: advance (__mid , size ()) ; 
std :: copy (__first , __mid , this -> _M_impl . _M_start) ; 
const size_type __attribute__ ((__unused__)) __n = __len - size () ; 
; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_copy_a (__mid , __last , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
; 
} 
} 


template < typename _Tp , typename _Alloc > 
auto 
vector < _Tp , _Alloc > :: 
_M_insert_rval (const_iterator __position , value_type && __v) -> iterator 
{ 
const auto __n = __position - cbegin () ; 
if (this -> _M_impl . _M_finish != this -> _M_impl . _M_end_of_storage) 
if (__position == cend ()) 
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
std :: move (__v)) ; 
++ this -> _M_impl . _M_finish ; 
; 
} 
else 
_M_insert_aux (begin () + __n , std :: move (__v)) ; 
else 
_M_realloc_insert (begin () + __n , std :: move (__v)) ; 

return iterator (this -> _M_impl . _M_start + __n) ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename ... _Args > 
auto 
vector < _Tp , _Alloc > :: 
_M_emplace_aux (const_iterator __position , _Args && ... __args) 
-> iterator 
{ 
const auto __n = __position - cbegin () ; 
if (this -> _M_impl . _M_finish != this -> _M_impl . _M_end_of_storage) 
if (__position == cend ()) 
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
std :: forward < _Args > (__args) ...) ; 
++ this -> _M_impl . _M_finish ; 
; 
} 
else 
{ 



_Temporary_value __tmp (this , std :: forward < _Args > (__args) ...) ; 
_M_insert_aux (begin () + __n , std :: move (__tmp . _M_val ())) ; 
} 
else 
_M_realloc_insert (begin () + __n , std :: forward < _Args > (__args) ...) ; 

return iterator (this -> _M_impl . _M_start + __n) ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _Arg > 
void 
vector < _Tp , _Alloc > :: 
_M_insert_aux (iterator __position , _Arg && __arg) 
# 403
{ 
; 
_Alloc_traits :: construct (this -> _M_impl , this -> _M_impl . _M_finish , 
std :: move (* (this -> _M_impl . _M_finish - 1))) ; 
++ this -> _M_impl . _M_finish ; 
; 



std :: move_backward (__position . base () , this -> _M_impl . _M_finish - 2 , this -> _M_impl . _M_finish - 1) 

; 



* __position = std :: forward < _Arg > (__arg) ; 

} 


template < typename _Tp , typename _Alloc > 
template < typename ... _Args > 
void 
vector < _Tp , _Alloc > :: 
_M_realloc_insert (iterator __position , _Args && ... __args) 
# 434
{ 
const size_type __len = 
_M_check_len (size_type (1) , "vector::_M_realloc_insert") ; 
pointer __old_start = this -> _M_impl . _M_start ; 
pointer __old_finish = this -> _M_impl . _M_finish ; 
const size_type __elems_before = __position - begin () ; 
pointer __new_start (this -> _M_allocate (__len)) ; 
pointer __new_finish (__new_start) ; 
try 
{ 
# 449
_Alloc_traits :: construct (this -> _M_impl , 
__new_start + __elems_before , 

std :: forward < _Args > (__args) ...) ; 



__new_finish = pointer () ; 


if (_S_use_relocate ()) 
{ 
__new_finish = _S_relocate (__old_start , __position . base () , 
__new_start , _M_get_Tp_allocator ()) ; 

++ __new_finish ; 

__new_finish = _S_relocate (__position . base () , __old_finish , 
__new_finish , _M_get_Tp_allocator ()) ; 
} 
else 

{ 
__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(__old_start , __position . base () , 
__new_start , _M_get_Tp_allocator ()) ; 

++ __new_finish ; 

__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(__position . base () , __old_finish , 
__new_finish , _M_get_Tp_allocator ()) ; 
} 
} 
catch (...) 
{ 
if (! __new_finish) 
_Alloc_traits :: destroy (this -> _M_impl , 
__new_start + __elems_before) ; 
else 
std :: _Destroy (__new_start , __new_finish , _M_get_Tp_allocator ()) ; 
_M_deallocate (__new_start , __len) ; 
throw ; 
} 

if (! _S_use_relocate ()) 

std :: _Destroy (__old_start , __old_finish , _M_get_Tp_allocator ()) ; 
; 
_M_deallocate (__old_start , 
this -> _M_impl . _M_end_of_storage - __old_start) ; 
this -> _M_impl . _M_start = __new_start ; 
this -> _M_impl . _M_finish = __new_finish ; 
this -> _M_impl . _M_end_of_storage = __new_start + __len ; 
} 

template < typename _Tp , typename _Alloc > 
void 
vector < _Tp , _Alloc > :: 
_M_fill_insert (iterator __position , size_type __n , const value_type & __x) 
{ 
if (__n != 0) 
{ 
if (size_type (this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_finish) >= __n) 
{ 



_Temporary_value __tmp (this , __x) ; 
value_type & __x_copy = __tmp . _M_val () ; 

const size_type __elems_after = end () - __position ; 
pointer __old_finish (this -> _M_impl . _M_finish) ; 
if (__elems_after > __n) 
{ 
; 
std :: __uninitialized_move_a (this -> _M_impl . _M_finish - __n , 
this -> _M_impl . _M_finish , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish += __n ; 
; 
std :: move_backward (__position . base () , __old_finish - __n , __old_finish) 
; 
std :: fill (__position . base () , __position . base () + __n , 
__x_copy) ; 
} 
else 
{ 
; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_fill_n_a (this -> _M_impl . _M_finish , 
__n - __elems_after , 
__x_copy , 
_M_get_Tp_allocator ()) ; 
; 
std :: __uninitialized_move_a (__position . base () , __old_finish , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish += __elems_after ; 
; 
std :: fill (__position . base () , __old_finish , __x_copy) ; 
} 
} 
else 
{ 
const size_type __len = 
_M_check_len (__n , "vector::_M_fill_insert") ; 
const size_type __elems_before = __position - begin () ; 
pointer __new_start (this -> _M_allocate (__len)) ; 
pointer __new_finish (__new_start) ; 
try 
{ 

std :: __uninitialized_fill_n_a (__new_start + __elems_before , 
__n , __x , 
_M_get_Tp_allocator ()) ; 
__new_finish = pointer () ; 

__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(this -> _M_impl . _M_start , __position . base () , 
__new_start , _M_get_Tp_allocator ()) ; 

__new_finish += __n ; 

__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(__position . base () , this -> _M_impl . _M_finish , 
__new_finish , _M_get_Tp_allocator ()) ; 
} 
catch (...) 
{ 
if (! __new_finish) 
std :: _Destroy (__new_start + __elems_before , 
__new_start + __elems_before + __n , 
_M_get_Tp_allocator ()) ; 
else 
std :: _Destroy (__new_start , __new_finish , 
_M_get_Tp_allocator ()) ; 
_M_deallocate (__new_start , __len) ; 
throw ; 
} 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __new_start ; 
this -> _M_impl . _M_finish = __new_finish ; 
this -> _M_impl . _M_end_of_storage = __new_start + __len ; 
} 
} 
} 


template < typename _Tp , typename _Alloc > 
void 
vector < _Tp , _Alloc > :: 
_M_default_append (size_type __n) 
{ 
if (__n != 0) 
{ 
const size_type __size = size () ; 
size_type __navail = size_type (this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_finish) ; 

if (__size > max_size () || __navail > max_size () - __size) 
__builtin_unreachable () ; 

if (__navail >= __n) 
{ 
; 
this -> _M_impl . _M_finish = 
std :: __uninitialized_default_n_a (this -> _M_impl . _M_finish , 
__n , _M_get_Tp_allocator ()) ; 
; 
} 
else 
{ 
const size_type __len = 
_M_check_len (__n , "vector::_M_default_append") ; 
pointer __new_start (this -> _M_allocate (__len)) ; 
if (_S_use_relocate ()) 
{ 
try 
{ 
std :: __uninitialized_default_n_a (__new_start + __size , 
__n , _M_get_Tp_allocator ()) ; 
} 
catch (...) 
{ 
_M_deallocate (__new_start , __len) ; 
throw ; 
} 
_S_relocate (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
__new_start , _M_get_Tp_allocator ()) ; 
} 
else 
{ 
pointer __destroy_from = pointer () ; 
try 
{ 
std :: __uninitialized_default_n_a (__new_start + __size , 
__n , _M_get_Tp_allocator ()) ; 
__destroy_from = __new_start + __size ; 
std :: __uninitialized_move_if_noexcept_a (
this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
__new_start , _M_get_Tp_allocator ()) ; 
} 
catch (...) 
{ 
if (__destroy_from) 
std :: _Destroy (__destroy_from , __destroy_from + __n , 
_M_get_Tp_allocator ()) ; 
_M_deallocate (__new_start , __len) ; 
throw ; 
} 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
} 
; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __new_start ; 
this -> _M_impl . _M_finish = __new_start + __size + __n ; 
this -> _M_impl . _M_end_of_storage = __new_start + __len ; 
} 
} 
} 

template < typename _Tp , typename _Alloc > 
bool 
vector < _Tp , _Alloc > :: 
_M_shrink_to_fit () 
{ 
if (capacity () == size ()) 
return false ; 
; 
return std :: __shrink_to_fit_aux < vector > :: _S_do_it (* this) ; 
} 


template < typename _Tp , typename _Alloc > 
template < typename _InputIterator > 
void 
vector < _Tp , _Alloc > :: 
_M_range_insert (iterator __pos , _InputIterator __first , 
_InputIterator __last , std :: input_iterator_tag) 
{ 
if (__pos == end ()) 
{ 
for (; __first != __last ; ++ __first) 
insert (end () , * __first) ; 
} 
else if (__first != __last) 
{ 
vector __tmp (__first , __last , _M_get_Tp_allocator ()) ; 
insert (__pos , 
std :: make_move_iterator (__tmp . begin ()) , 
std :: make_move_iterator (__tmp . end ())) ; 
} 
} 

template < typename _Tp , typename _Alloc > 
template < typename _ForwardIterator > 
void 
vector < _Tp , _Alloc > :: 
_M_range_insert (iterator __position , _ForwardIterator __first , 
_ForwardIterator __last , std :: forward_iterator_tag) 
{ 
if (__first != __last) 
{ 
const size_type __n = std :: distance (__first , __last) ; 
if (size_type (this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_finish) >= __n) 
{ 
const size_type __elems_after = end () - __position ; 
pointer __old_finish (this -> _M_impl . _M_finish) ; 
if (__elems_after > __n) 
{ 
; 
std :: __uninitialized_move_a (this -> _M_impl . _M_finish - __n , 
this -> _M_impl . _M_finish , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish += __n ; 
; 
std :: move_backward (__position . base () , __old_finish - __n , __old_finish) 
; 
std :: copy (__first , __last , __position) ; 
} 
else 
{ 
_ForwardIterator __mid = __first ; 
std :: advance (__mid , __elems_after) ; 
; 
std :: __uninitialized_copy_a (__mid , __last , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish += __n - __elems_after ; 
; 
std :: __uninitialized_move_a (__position . base () , 
__old_finish , 
this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
this -> _M_impl . _M_finish += __elems_after ; 
; 
std :: copy (__first , __mid , __position) ; 
} 
} 
else 
{ 
const size_type __len = 
_M_check_len (__n , "vector::_M_range_insert") ; 
pointer __new_start (this -> _M_allocate (__len)) ; 
pointer __new_finish (__new_start) ; 
try 
{ 
__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(this -> _M_impl . _M_start , __position . base () , 
__new_start , _M_get_Tp_allocator ()) ; 
__new_finish 
= std :: __uninitialized_copy_a (__first , __last , 
__new_finish , 
_M_get_Tp_allocator ()) ; 
__new_finish 
= std :: __uninitialized_move_if_noexcept_a 
(__position . base () , this -> _M_impl . _M_finish , 
__new_finish , _M_get_Tp_allocator ()) ; 
} 
catch (...) 
{ 
std :: _Destroy (__new_start , __new_finish , 
_M_get_Tp_allocator ()) ; 
_M_deallocate (__new_start , __len) ; 
throw ; 
} 
std :: _Destroy (this -> _M_impl . _M_start , this -> _M_impl . _M_finish , 
_M_get_Tp_allocator ()) ; 
; 
_M_deallocate (this -> _M_impl . _M_start , 
this -> _M_impl . _M_end_of_storage 
- this -> _M_impl . _M_start) ; 
this -> _M_impl . _M_start = __new_start ; 
this -> _M_impl . _M_finish = __new_finish ; 
this -> _M_impl . _M_end_of_storage = __new_start + __len ; 
} 
} 
} 



template < typename _Alloc > 
void 
vector < bool , _Alloc > :: 
_M_reallocate (size_type __n) 
{ 
_Bit_pointer __q = this -> _M_allocate (__n) ; 
iterator __start (std :: __addressof (* __q) , 0) ; 
iterator __finish (_M_copy_aligned (begin () , end () , __start)) ; 
this -> _M_deallocate () ; 
this -> _M_impl . _M_start = __start ; 
this -> _M_impl . _M_finish = __finish ; 
this -> _M_impl . _M_end_of_storage = __q + _S_nword (__n) ; 
} 

template < typename _Alloc > 
void 
vector < bool , _Alloc > :: 
_M_fill_insert (iterator __position , size_type __n , bool __x) 
{ 
if (__n == 0) 
return ; 
if (capacity () - size () >= __n) 
{ 
std :: copy_backward (__position , end () , 
this -> _M_impl . _M_finish + difference_type (__n)) ; 
std :: fill (__position , __position + difference_type (__n) , __x) ; 
this -> _M_impl . _M_finish += difference_type (__n) ; 
} 
else 
{ 
const size_type __len = 
_M_check_len (__n , "vector<bool>::_M_fill_insert") ; 
_Bit_pointer __q = this -> _M_allocate (__len) ; 
iterator __start (std :: __addressof (* __q) , 0) ; 
iterator __i = _M_copy_aligned (begin () , __position , __start) ; 
std :: fill (__i , __i + difference_type (__n) , __x) ; 
iterator __finish = std :: copy (__position , end () , 
__i + difference_type (__n)) ; 
this -> _M_deallocate () ; 
this -> _M_impl . _M_end_of_storage = __q + _S_nword (__len) ; 
this -> _M_impl . _M_start = __start ; 
this -> _M_impl . _M_finish = __finish ; 
} 
} 

template < typename _Alloc > 
template < typename _ForwardIterator > 
void 
vector < bool , _Alloc > :: 
_M_insert_range (iterator __position , _ForwardIterator __first , 
_ForwardIterator __last , std :: forward_iterator_tag) 
{ 
if (__first != __last) 
{ 
size_type __n = std :: distance (__first , __last) ; 
if (capacity () - size () >= __n) 
{ 
std :: copy_backward (__position , end () , 
this -> _M_impl . _M_finish 
+ difference_type (__n)) ; 
std :: copy (__first , __last , __position) ; 
this -> _M_impl . _M_finish += difference_type (__n) ; 
} 
else 
{ 
const size_type __len = 
_M_check_len (__n , "vector<bool>::_M_insert_range") ; 
_Bit_pointer __q = this -> _M_allocate (__len) ; 
iterator __start (std :: __addressof (* __q) , 0) ; 
iterator __i = _M_copy_aligned (begin () , __position , __start) ; 
__i = std :: copy (__first , __last , __i) ; 
iterator __finish = std :: copy (__position , end () , __i) ; 
this -> _M_deallocate () ; 
this -> _M_impl . _M_end_of_storage = __q + _S_nword (__len) ; 
this -> _M_impl . _M_start = __start ; 
this -> _M_impl . _M_finish = __finish ; 
} 
} 
} 

template < typename _Alloc > 
void 
vector < bool , _Alloc > :: 
_M_insert_aux (iterator __position , bool __x) 
{ 
if (this -> _M_impl . _M_finish . _M_p != this -> _M_impl . _M_end_addr ()) 
{ 
std :: copy_backward (__position , this -> _M_impl . _M_finish , 
this -> _M_impl . _M_finish + 1) ; 
* __position = __x ; 
++ this -> _M_impl . _M_finish ; 
} 
else 
{ 
const size_type __len = 
_M_check_len (size_type (1) , "vector<bool>::_M_insert_aux") ; 
_Bit_pointer __q = this -> _M_allocate (__len) ; 
iterator __start (std :: __addressof (* __q) , 0) ; 
iterator __i = _M_copy_aligned (begin () , __position , __start) ; 
* __i ++ = __x ; 
iterator __finish = std :: copy (__position , end () , __i) ; 
this -> _M_deallocate () ; 
this -> _M_impl . _M_end_of_storage = __q + _S_nword (__len) ; 
this -> _M_impl . _M_start = __start ; 
this -> _M_impl . _M_finish = __finish ; 
} 
} 

template < typename _Alloc > 
typename vector < bool , _Alloc > :: iterator 
vector < bool , _Alloc > :: 
_M_erase (iterator __position) 
{ 
if (__position + 1 != end ()) 
std :: copy (__position + 1 , end () , __position) ; 
-- this -> _M_impl . _M_finish ; 
return __position ; 
} 

template < typename _Alloc > 
typename vector < bool , _Alloc > :: iterator 
vector < bool , _Alloc > :: 
_M_erase (iterator __first , iterator __last) 
{ 
if (__first != __last) 
_M_erase_at_end (std :: copy (__last , end () , __first)) ; 
return __first ; 
} 


template < typename _Alloc > 
bool 
vector < bool , _Alloc > :: 
_M_shrink_to_fit () 
{ 
if (capacity () - size () < int (_S_word_bit)) 
return false ; 
try 
{ 
_M_reallocate (size ()) ; 
return true ; 
} 
catch (...) 
{ return false ; } 
} 




}



namespace std { 



template < typename _Alloc > 
size_t 
hash < std :: vector < bool , _Alloc > > :: 
operator () (const std :: vector < bool , _Alloc > & __b) const noexcept 
{ 
size_t __hash = 0 ; 
using std :: _S_word_bit ; 
using std :: _Bit_type ; 

const size_t __words = __b . size () / _S_word_bit ; 
if (__words) 
{ 
const size_t __clength = __words * sizeof (_Bit_type) ; 
__hash = std :: _Hash_impl :: hash (__b . _M_impl . _M_start . _M_p , __clength) ; 
} 

const size_t __extrabits = __b . size () % _S_word_bit ; 
if (__extrabits) 
{ 
_Bit_type __hiword = * __b . _M_impl . _M_finish . _M_p ; 
__hiword &= ~ ((~ static_cast < _Bit_type > (0)) << __extrabits) ; 

const size_t __clength 
= (__extrabits + 8 - 1) / 8 ; 
if (__words) 
__hash = std :: _Hash_impl :: hash (& __hiword , __clength , __hash) ; 
else 
__hash = std :: _Hash_impl :: hash (& __hiword , __clength) ; 
} 

return __hash ; 
} 


}
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\stdlib.h" 3
using std::abort;
using std::atexit;
using std::exit;
# 54 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\stdlib.h" 3
using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 61 "d:\\mingw\\mingw\\include\\strings.h" 3
extern "C" {

__attribute((__cdecl__)) __attribute((__nothrow__)) inline int strcasecmp(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int strncasecmp(const char *, const char *, size_t); 
# 80 "d:\\mingw\\mingw\\include\\strings.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _stricmp(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _strnicmp(const char *, const char *, size_t); 
# 91 "d:\\mingw\\mingw\\include\\strings.h" 3
__attribute((__always_inline__)) inline int strcasecmp(const char *__s1, const char *__s2) 
{ return _stricmp(__s1, __s2); } 


__attribute((__always_inline__)) inline int strncasecmp(const char *__s1, const char *__s2, size_t __n) 
{ return _strnicmp(__s1, __s2, __n); } 



}
# 65 "d:\\mingw\\mingw\\include\\string.h" 3
extern "C" {




__attribute((__cdecl__)) __attribute((__nothrow__)) void *memchr(const void *, int, size_t) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int memcmp(const void *, const void *, size_t) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void *memcpy(void *, const void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void *memmove(void *, const void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void *memset(void *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strcat(char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strchr(const char *, int) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int strcmp(const char *, const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int strcoll(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strcpy(char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t strcspn(const char *, const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strerror(int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) size_t strlen(const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strncat(char *, const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int strncmp(const char *, const char *, size_t) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strncpy(char *, const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strpbrk(const char *, const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strrchr(const char *, int) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t strspn(const char *, const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strstr(const char *, const char *) __attribute((__pure__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strtok(char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) size_t strxfrm(char *, const char *, size_t); 




__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strerror(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void *_memccpy(void *, const void *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _memicmp(const void *, const void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strdup(const char *) __attribute((__malloc__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _strcmpi(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _stricoll(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strlwr(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strnset(char *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strrev(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strset(char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strupr(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) void _swab(const char *, char *, size_t); 
# 126 "d:\\mingw\\mingw\\include\\string.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _strncoll(const char *, const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _strnicoll(const char *, const char *, size_t); 
# 134
__attribute((__cdecl__)) __attribute((__nothrow__)) void *memccpy(void *, const void *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int memicmp(const void *, const void *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strdup(const char *) __attribute((__malloc__)); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int strcmpi(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int stricmp(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int stricoll(const char *, const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strlwr(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int strnicmp(const char *, const char *, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strnset(char *, int, size_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strrev(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strset(char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *strupr(char *); 
# 151
__attribute((__cdecl__)) __attribute((__nothrow__)) void swab(const char *, char *, size_t); 
# 193 "d:\\mingw\\mingw\\include\\string.h" 3
extern size_t __mingw_strnlen(const char *, size_t); 


__attribute((__always_inline__)) inline size_t strnlen(const char *__text, size_t __maxlen) 
{ return __mingw_strnlen(__text, __maxlen); } 
# 210 "d:\\mingw\\mingw\\include\\string.h" 3
extern char *strtok_r(char *, const char *, char **); 
# 223 "d:\\mingw\\mingw\\include\\string.h" 3
extern int strerror_r(int, char *, size_t); 
# 247 "d:\\mingw\\mingw\\include\\string.h" 3
__attribute((__always_inline__)) inline int strerror_s(char *__buf, size_t __len, int __err) 
{ return strerror_r(__err, __buf, __len); } 




}
# 218 "d:\\mingw\\mingw\\include\\sys\\stat.h" 3
extern "C" {
# 224
__attribute((__cdecl__)) __attribute((__nothrow__)) int _umask(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _chmod(const char *, int); 
# 232
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fstat(int, struct _stat *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _stat(const char *, struct _stat *); 
# 240
__attribute((__cdecl__)) __attribute((__nothrow__)) int umask(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int chmod(const char *, int); 
# 250 "d:\\mingw\\mingw\\include\\sys\\stat.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int fstat(int, struct stat *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int stat(const char *, struct stat *); 
# 260 "d:\\mingw\\mingw\\include\\sys\\stat.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fstati64(int, struct _stati64 *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _stati64(const char *, struct _stati64 *); 
# 268
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fstat64(int, __stat64 *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _stat64(const char *, __stat64 *); 
# 398 "d:\\mingw\\mingw\\include\\sys\\stat.h" 3
}
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_relops.h" 3
namespace std { 



namespace rel_ops { 
# 85 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_relops.h" 3
template < class _Tp > 
inline bool 
operator != (const _Tp & __x , const _Tp & __y) 
{ return ! (__x == __y) ; } 
# 98 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_relops.h" 3
template < class _Tp > 
inline bool 
operator > (const _Tp & __x , const _Tp & __y) 
{ return __y < __x ; } 
# 111 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_relops.h" 3
template < class _Tp > 
inline bool 
operator <= (const _Tp & __x , const _Tp & __y) 
{ return ! (__y < __x) ; } 
# 124 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_relops.h" 3
template < class _Tp > 
inline bool 
operator >= (const _Tp & __x , const _Tp & __y) 
{ return ! (__x < __y) ; } 
}


}
# 78 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\utility" 3
namespace std { 




template < typename _Tp >
    struct tuple_size;
# 90
template < typename _Tp,
    typename _Up = typename remove_cv < _Tp > :: type,
    typename = typename enable_if < is_same < _Tp, _Up > :: value > :: type,
    size_t = tuple_size < _Tp > :: value >
    using __enable_if_has_tuple_size = _Tp;

template < typename _Tp > 
struct tuple_size < const __enable_if_has_tuple_size < _Tp > > 
: public tuple_size < _Tp > { } ;

template < typename _Tp > 
struct tuple_size < volatile __enable_if_has_tuple_size < _Tp > > 
: public tuple_size < _Tp > { } ;

template < typename _Tp > 
struct tuple_size < const volatile __enable_if_has_tuple_size < _Tp > > 
: public tuple_size < _Tp > { } ;


template < std :: size_t __i, typename _Tp >
    struct tuple_element;


template < std :: size_t __i, typename _Tp >
    using __tuple_element_t = typename tuple_element < __i, _Tp > :: type;

template < std :: size_t __i , typename _Tp > 
struct tuple_element < __i , const _Tp > 
{ 
typedef typename add_const < __tuple_element_t < __i , _Tp > > :: type type ; 
} ;

template < std :: size_t __i , typename _Tp > 
struct tuple_element < __i , volatile _Tp > 
{ 
typedef typename add_volatile < __tuple_element_t < __i , _Tp > > :: type type ; 
} ;

template < std :: size_t __i , typename _Tp > 
struct tuple_element < __i , const volatile _Tp > 
{ 
typedef typename add_cv < __tuple_element_t < __i , _Tp > > :: type type ; 
} ;
# 147 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\utility" 3
template < typename _T1 , typename _T2 > 
struct __is_tuple_like_impl < std :: pair < _T1 , _T2 > > : true_type 
{ } ;


template < class _Tp1 , class _Tp2 > 
struct tuple_size < std :: pair < _Tp1 , _Tp2 > > 
: public integral_constant < std :: size_t , 2 > { } ;


template < class _Tp1 , class _Tp2 > 
struct tuple_element < 0 , std :: pair < _Tp1 , _Tp2 > > 
{ typedef _Tp1 type ; } ;


template < class _Tp1 , class _Tp2 > 
struct tuple_element < 1 , std :: pair < _Tp1 , _Tp2 > > 
{ typedef _Tp2 type ; } ;

template < std :: size_t _Int >
    struct __pair_get;


template<> struct __pair_get< 0U>  { 

template < typename _Tp1 , typename _Tp2 > 
static constexpr _Tp1 & 
__get (std :: pair < _Tp1 , _Tp2 > & __pair) noexcept 
{ return __pair . first ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr _Tp1 && 
__move_get (std :: pair < _Tp1 , _Tp2 > && __pair) noexcept 
{ return std :: forward < _Tp1 > (__pair . first) ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr const _Tp1 & 
__const_get (const std :: pair < _Tp1 , _Tp2 > & __pair) noexcept 
{ return __pair . first ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr const _Tp1 && 
__const_move_get (const std :: pair < _Tp1 , _Tp2 > && __pair) noexcept 
{ return std :: forward < const _Tp1 > (__pair . first) ; } 
}; 


template<> struct __pair_get< 1U>  { 

template < typename _Tp1 , typename _Tp2 > 
static constexpr _Tp2 & 
__get (std :: pair < _Tp1 , _Tp2 > & __pair) noexcept 
{ return __pair . second ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr _Tp2 && 
__move_get (std :: pair < _Tp1 , _Tp2 > && __pair) noexcept 
{ return std :: forward < _Tp2 > (__pair . second) ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr const _Tp2 & 
__const_get (const std :: pair < _Tp1 , _Tp2 > & __pair) noexcept 
{ return __pair . second ; } 

template < typename _Tp1 , typename _Tp2 > 
static constexpr const _Tp2 && 
__const_move_get (const std :: pair < _Tp1 , _Tp2 > && __pair) noexcept 
{ return std :: forward < const _Tp2 > (__pair . second) ; } 
}; 

template < std :: size_t _Int , class _Tp1 , class _Tp2 > 
constexpr typename tuple_element < _Int , std :: pair < _Tp1 , _Tp2 > > :: type & 
get (std :: pair < _Tp1 , _Tp2 > & __in) noexcept 
{ return __pair_get < _Int > :: __get (__in) ; } 

template < std :: size_t _Int , class _Tp1 , class _Tp2 > 
constexpr typename tuple_element < _Int , std :: pair < _Tp1 , _Tp2 > > :: type && 
get (std :: pair < _Tp1 , _Tp2 > && __in) noexcept 
{ return __pair_get < _Int > :: __move_get (std :: move (__in)) ; } 

template < std :: size_t _Int , class _Tp1 , class _Tp2 > 
constexpr const typename tuple_element < _Int , std :: pair < _Tp1 , _Tp2 > > :: type & 
get (const std :: pair < _Tp1 , _Tp2 > & __in) noexcept 
{ return __pair_get < _Int > :: __const_get (__in) ; } 

template < std :: size_t _Int , class _Tp1 , class _Tp2 > 
constexpr const typename tuple_element < _Int , std :: pair < _Tp1 , _Tp2 > > :: type && 
get (const std :: pair < _Tp1 , _Tp2 > && __in) noexcept 
{ return __pair_get < _Int > :: __const_move_get (std :: move (__in)) ; } 
# 292 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\utility" 3
template < size_t ... _Indexes > struct _Index_tuple { } ;
# 301 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\utility" 3
template < size_t _Num > 
struct _Build_index_tuple 
{ 
# 310
using __type = _Index_tuple < __integer_pack (_Num) ... > ; 

} ;
# 397 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\utility" 3
}
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\algorithmfwd.h" 3
namespace std { 
# 195 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\algorithmfwd.h" 3
template < typename _IIter, typename _Predicate >
    bool
    all_of ( _IIter, _IIter, _Predicate );

template < typename _IIter, typename _Predicate >
    bool
    any_of ( _IIter, _IIter, _Predicate );


template < typename _FIter, typename _Tp >
    bool
    binary_search ( _FIter, _FIter, const _Tp & );

template < typename _FIter, typename _Tp, typename _Compare >
    bool
    binary_search ( _FIter, _FIter, const _Tp &, _Compare );
# 224 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\algorithmfwd.h" 3
template < typename _IIter, typename _OIter >
    _OIter
    copy ( _IIter, _IIter, _OIter );

template < typename _BIter1, typename _BIter2 >
    _BIter2
    copy_backward ( _BIter1, _BIter1, _BIter2 );


template < typename _IIter, typename _OIter, typename _Predicate >
    _OIter
    copy_if ( _IIter, _IIter, _OIter, _Predicate );

template < typename _IIter, typename _Size, typename _OIter >
    _OIter
    copy_n ( _IIter, _Size, _OIter );
# 245
template < typename _FIter, typename _Tp >
    pair < _FIter, _FIter >
    equal_range ( _FIter, _FIter, const _Tp & );

template < typename _FIter, typename _Tp, typename _Compare >
    pair < _FIter, _FIter >
    equal_range ( _FIter, _FIter, const _Tp &, _Compare );

template < typename _FIter, typename _Tp >
    void
    fill ( _FIter, _FIter, const _Tp & );

template < typename _OIter, typename _Size, typename _Tp >
    _OIter
    fill_n ( _OIter, _Size, const _Tp & );



template < typename _FIter1, typename _FIter2 >
    _FIter1
    find_end ( _FIter1, _FIter1, _FIter2, _FIter2 );

template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    find_end ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );
# 275
template < typename _IIter, typename _Predicate >
    _IIter
    find_if_not ( _IIter, _IIter, _Predicate );
# 284
template < typename _IIter1, typename _IIter2 >
    bool
    includes ( _IIter1, _IIter1, _IIter2, _IIter2 );

template < typename _IIter1, typename _IIter2, typename _Compare >
    bool
    includes ( _IIter1, _IIter1, _IIter2, _IIter2, _Compare );

template < typename _BIter >
    void
    inplace_merge ( _BIter, _BIter, _BIter );

template < typename _BIter, typename _Compare >
    void
    inplace_merge ( _BIter, _BIter, _BIter, _Compare );


template < typename _RAIter >
    bool
    is_heap ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    bool
    is_heap ( _RAIter, _RAIter, _Compare );

template < typename _RAIter >
    _RAIter
    is_heap_until ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    _RAIter
    is_heap_until ( _RAIter, _RAIter, _Compare );

template < typename _IIter, typename _Predicate >
    bool
    is_partitioned ( _IIter, _IIter, _Predicate );

template < typename _FIter1, typename _FIter2 >
    bool
    is_permutation ( _FIter1, _FIter1, _FIter2 );

template < typename _FIter1, typename _FIter2,
    typename _BinaryPredicate >
    bool
    is_permutation ( _FIter1, _FIter1, _FIter2, _BinaryPredicate );

template < typename _FIter >
    bool
    is_sorted ( _FIter, _FIter );

template < typename _FIter, typename _Compare >
    bool
    is_sorted ( _FIter, _FIter, _Compare );

template < typename _FIter >
    _FIter
    is_sorted_until ( _FIter, _FIter );

template < typename _FIter, typename _Compare >
    _FIter
    is_sorted_until ( _FIter, _FIter, _Compare );


template < typename _FIter1, typename _FIter2 >
    void
    iter_swap ( _FIter1, _FIter2 );

template < typename _FIter, typename _Tp >
    _FIter
    lower_bound ( _FIter, _FIter, const _Tp & );

template < typename _FIter, typename _Tp, typename _Compare >
    _FIter
    lower_bound ( _FIter, _FIter, const _Tp &, _Compare );

template < typename _RAIter >
    void
    make_heap ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    make_heap ( _RAIter, _RAIter, _Compare );

template < typename _Tp >

    const _Tp &
    max ( const _Tp &, const _Tp & );

template < typename _Tp, typename _Compare >

    const _Tp &
    max ( const _Tp &, const _Tp &, _Compare );




template < typename _Tp >

    const _Tp &
    min ( const _Tp &, const _Tp & );

template < typename _Tp, typename _Compare >

    const _Tp &
    min ( const _Tp &, const _Tp &, _Compare );




template < typename _Tp >

    pair < const _Tp &, const _Tp & >
    minmax ( const _Tp &, const _Tp & );

template < typename _Tp, typename _Compare >

    pair < const _Tp &, const _Tp & >
    minmax ( const _Tp &, const _Tp &, _Compare );

template < typename _FIter >

    pair < _FIter, _FIter >
    minmax_element ( _FIter, _FIter );

template < typename _FIter, typename _Compare >

    pair < _FIter, _FIter >
    minmax_element ( _FIter, _FIter, _Compare );

template < typename _Tp >

    _Tp
    min ( initializer_list < _Tp > );

template < typename _Tp, typename _Compare >

    _Tp
    min ( initializer_list < _Tp >, _Compare );

template < typename _Tp >

    _Tp
    max ( initializer_list < _Tp > );

template < typename _Tp, typename _Compare >

    _Tp
    max ( initializer_list < _Tp >, _Compare );

template < typename _Tp >

    pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp > );

template < typename _Tp, typename _Compare >

    pair < _Tp, _Tp >
    minmax ( initializer_list < _Tp >, _Compare );




template < typename _BIter >
    bool
    next_permutation ( _BIter, _BIter );

template < typename _BIter, typename _Compare >
    bool
    next_permutation ( _BIter, _BIter, _Compare );


template < typename _IIter, typename _Predicate >
    bool
    none_of ( _IIter, _IIter, _Predicate );
# 463
template < typename _IIter, typename _RAIter >
    _RAIter
    partial_sort_copy ( _IIter, _IIter, _RAIter, _RAIter );

template < typename _IIter, typename _RAIter, typename _Compare >
    _RAIter
    partial_sort_copy ( _IIter, _IIter, _RAIter, _RAIter, _Compare );




template < typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate >
    pair < _OIter1, _OIter2 >
    partition_copy ( _IIter, _IIter, _OIter1, _OIter2, _Predicate );

template < typename _FIter, typename _Predicate >
    _FIter
    partition_point ( _FIter, _FIter, _Predicate );


template < typename _RAIter >
    void
    pop_heap ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    pop_heap ( _RAIter, _RAIter, _Compare );

template < typename _BIter >
    bool
    prev_permutation ( _BIter, _BIter );

template < typename _BIter, typename _Compare >
    bool
    prev_permutation ( _BIter, _BIter, _Compare );

template < typename _RAIter >
    void
    push_heap ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    push_heap ( _RAIter, _RAIter, _Compare );



template < typename _FIter, typename _Tp >
    _FIter
    remove ( _FIter, _FIter, const _Tp & );

template < typename _FIter, typename _Predicate >
    _FIter
    remove_if ( _FIter, _FIter, _Predicate );

template < typename _IIter, typename _OIter, typename _Tp >
    _OIter
    remove_copy ( _IIter, _IIter, _OIter, const _Tp & );

template < typename _IIter, typename _OIter, typename _Predicate >
    _OIter
    remove_copy_if ( _IIter, _IIter, _OIter, _Predicate );



template < typename _IIter, typename _OIter, typename _Tp >
    _OIter
    replace_copy ( _IIter, _IIter, _OIter, const _Tp &, const _Tp & );

template < typename _Iter, typename _OIter, typename _Predicate, typename _Tp >
    _OIter
    replace_copy_if ( _Iter, _Iter, _OIter, _Predicate, const _Tp & );



template < typename _BIter >
    void
    reverse ( _BIter, _BIter );

template < typename _BIter, typename _OIter >
    _OIter
    reverse_copy ( _BIter, _BIter, _OIter );

inline namespace _V2 { 

template < typename _FIter >
      _FIter
      rotate ( _FIter, _FIter, _FIter );
}

template < typename _FIter, typename _OIter >
    _OIter
    rotate_copy ( _FIter, _FIter, _FIter, _OIter );
# 565 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\algorithmfwd.h" 3
template < typename _RAIter, typename _UGenerator >
    void
    shuffle ( _RAIter, _RAIter, _UGenerator && );


template < typename _RAIter >
    void
    sort_heap ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    sort_heap ( _RAIter, _RAIter, _Compare );

template < typename _BIter, typename _Predicate >
    _BIter
    stable_partition ( _BIter, _BIter, _Predicate );
# 594 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\algorithmfwd.h" 3
template < typename _FIter1, typename _FIter2 >
    _FIter2
    swap_ranges ( _FIter1, _FIter1, _FIter2 );



template < typename _FIter >
    _FIter
    unique ( _FIter, _FIter );

template < typename _FIter, typename _BinaryPredicate >
    _FIter
    unique ( _FIter, _FIter, _BinaryPredicate );



template < typename _FIter, typename _Tp >
    _FIter
    upper_bound ( _FIter, _FIter, const _Tp & );

template < typename _FIter, typename _Tp, typename _Compare >
    _FIter
    upper_bound ( _FIter, _FIter, const _Tp &, _Compare );



template < typename _FIter >
    _FIter
    adjacent_find ( _FIter, _FIter );

template < typename _FIter, typename _BinaryPredicate >
    _FIter
    adjacent_find ( _FIter, _FIter, _BinaryPredicate );

template < typename _IIter, typename _Tp >
    typename iterator_traits < _IIter > :: difference_type
    count ( _IIter, _IIter, const _Tp & );

template < typename _IIter, typename _Predicate >
    typename iterator_traits < _IIter > :: difference_type
    count_if ( _IIter, _IIter, _Predicate );

template < typename _IIter1, typename _IIter2 >
    bool
    equal ( _IIter1, _IIter1, _IIter2 );

template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    bool
    equal ( _IIter1, _IIter1, _IIter2, _BinaryPredicate );

template < typename _IIter, typename _Tp >
    _IIter
    find ( _IIter, _IIter, const _Tp & );

template < typename _FIter1, typename _FIter2 >
    _FIter1
    find_first_of ( _FIter1, _FIter1, _FIter2, _FIter2 );

template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    find_first_of ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );

template < typename _IIter, typename _Predicate >
    _IIter
    find_if ( _IIter, _IIter, _Predicate );

template < typename _IIter, typename _Funct >
    _Funct
    for_each ( _IIter, _IIter, _Funct );

template < typename _FIter, typename _Generator >
    void
    generate ( _FIter, _FIter, _Generator );

template < typename _OIter, typename _Size, typename _Generator >
    _OIter
    generate_n ( _OIter, _Size, _Generator );

template < typename _IIter1, typename _IIter2 >
    bool
    lexicographical_compare ( _IIter1, _IIter1, _IIter2, _IIter2 );

template < typename _IIter1, typename _IIter2, typename _Compare >
    bool
    lexicographical_compare ( _IIter1, _IIter1, _IIter2, _IIter2, _Compare );

template < typename _FIter >

    _FIter
    max_element ( _FIter, _FIter );

template < typename _FIter, typename _Compare >

    _FIter
    max_element ( _FIter, _FIter, _Compare );

template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    merge ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    merge ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );

template < typename _FIter >

    _FIter
    min_element ( _FIter, _FIter );

template < typename _FIter, typename _Compare >

    _FIter
    min_element ( _FIter, _FIter, _Compare );

template < typename _IIter1, typename _IIter2 >
    pair < _IIter1, _IIter2 >
    mismatch ( _IIter1, _IIter1, _IIter2 );

template < typename _IIter1, typename _IIter2, typename _BinaryPredicate >
    pair < _IIter1, _IIter2 >
    mismatch ( _IIter1, _IIter1, _IIter2, _BinaryPredicate );

template < typename _RAIter >
    void
    nth_element ( _RAIter, _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    nth_element ( _RAIter, _RAIter, _RAIter, _Compare );

template < typename _RAIter >
    void
    partial_sort ( _RAIter, _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    partial_sort ( _RAIter, _RAIter, _RAIter, _Compare );

template < typename _BIter, typename _Predicate >
    _BIter
    partition ( _BIter, _BIter, _Predicate );

template < typename _RAIter >
    void
    random_shuffle ( _RAIter, _RAIter );

template < typename _RAIter, typename _Generator >
    void
    random_shuffle ( _RAIter, _RAIter,

     _Generator && );




template < typename _FIter, typename _Tp >
    void
    replace ( _FIter, _FIter, const _Tp &, const _Tp & );

template < typename _FIter, typename _Predicate, typename _Tp >
    void
    replace_if ( _FIter, _FIter, _Predicate, const _Tp & );

template < typename _FIter1, typename _FIter2 >
    _FIter1
    search ( _FIter1, _FIter1, _FIter2, _FIter2 );

template < typename _FIter1, typename _FIter2, typename _BinaryPredicate >
    _FIter1
    search ( _FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate );

template < typename _FIter, typename _Size, typename _Tp >
    _FIter
    search_n ( _FIter, _FIter, _Size, const _Tp & );

template < typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate >
    _FIter
    search_n ( _FIter, _FIter, _Size, const _Tp &, _BinaryPredicate );

template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );

template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_intersection ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_intersection ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );

template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_symmetric_difference ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_symmetric_difference ( _IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare );

template < typename _IIter1, typename _IIter2, typename _OIter >
    _OIter
    set_union ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare >
    _OIter
    set_union ( _IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare );

template < typename _RAIter >
    void
    sort ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    sort ( _RAIter, _RAIter, _Compare );

template < typename _RAIter >
    void
    stable_sort ( _RAIter, _RAIter );

template < typename _RAIter, typename _Compare >
    void
    stable_sort ( _RAIter, _RAIter, _Compare );

template < typename _IIter, typename _OIter, typename _UnaryOperation >
    _OIter
    transform ( _IIter, _IIter, _OIter, _UnaryOperation );

template < typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation >
    _OIter
    transform ( _IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation );

template < typename _IIter, typename _OIter >
    _OIter
    unique_copy ( _IIter, _IIter, _OIter );

template < typename _IIter, typename _OIter, typename _BinaryPredicate >
    _OIter
    unique_copy ( _IIter, _IIter, _OIter, _BinaryPredicate );



}
# 62 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
namespace std { 
# 71
template < typename _RandomAccessIterator , typename _Distance , 
typename _Compare > 
_Distance 
__is_heap_until (_RandomAccessIterator __first , _Distance __n , 
_Compare & __comp) 
{ 
_Distance __parent = 0 ; 
for (_Distance __child = 1 ; __child < __n ; ++ __child) 
{ 
if (__comp (__first + __parent , __first + __child)) 
return __child ; 
if ((__child & 1) == 0) 
++ __parent ; 
} 
return __n ; 
} 



template < typename _RandomAccessIterator , typename _Distance > 
inline bool 
__is_heap (_RandomAccessIterator __first , _Distance __n) 
{ 
__gnu_cxx :: __ops :: _Iter_less_iter __comp ; 
return std :: __is_heap_until (__first , __n , __comp) == __n ; 
} 

template < typename _RandomAccessIterator , typename _Compare , 
typename _Distance > 
inline bool 
__is_heap (_RandomAccessIterator __first , _Compare __comp , _Distance __n) 
{ 
typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
return std :: __is_heap_until (__first , __n , __cmp) == __n ; 
} 

template < typename _RandomAccessIterator > 
inline bool 
__is_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ return std :: __is_heap (__first , std :: distance (__first , __last)) ; } 

template < typename _RandomAccessIterator , typename _Compare > 
inline bool 
__is_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
return std :: __is_heap (__first , std :: move (__comp) , 
std :: distance (__first , __last)) ; 
} 




template < typename _RandomAccessIterator , typename _Distance , typename _Tp , 
typename _Compare > 
void 
__push_heap (_RandomAccessIterator __first , 
_Distance __holeIndex , _Distance __topIndex , _Tp __value , 
_Compare & __comp) 
{ 
_Distance __parent = (__holeIndex - 1) / 2 ; 
while (__holeIndex > __topIndex && __comp (__first + __parent , __value)) 
{ 
* (__first + __holeIndex) = std :: move (* (__first + __parent)) ; 
__holeIndex = __parent ; 
__parent = (__holeIndex - 1) / 2 ; 
} 
* (__first + __holeIndex) = std :: move (__value) ; 
} 
# 152 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline void 
push_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 
# 165
; 
; 
; 

__gnu_cxx :: __ops :: _Iter_less_val __comp ; 
_ValueType __value = std :: move (* (__last - 1)) ; 
std :: __push_heap (__first , _DistanceType ((__last - __first) - 1) , 
_DistanceType (0) , std :: move (__value) , __comp) ; 
} 
# 187 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
push_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 




; 
; 
; 

__decltype (__gnu_cxx :: __ops :: __iter_comp_val (std :: move (__comp))) 
__cmp (std :: move (__comp)) ; 
_ValueType __value = std :: move (* (__last - 1)) ; 
std :: __push_heap (__first , _DistanceType ((__last - __first) - 1) , 
_DistanceType (0) , std :: move (__value) , __cmp) ; 
} 

template < typename _RandomAccessIterator , typename _Distance , 
typename _Tp , typename _Compare > 
void 
__adjust_heap (_RandomAccessIterator __first , _Distance __holeIndex , 
_Distance __len , _Tp __value , _Compare __comp) 
{ 
const _Distance __topIndex = __holeIndex ; 
_Distance __secondChild = __holeIndex ; 
while (__secondChild < (__len - 1) / 2) 
{ 
__secondChild = 2 * (__secondChild + 1) ; 
if (__comp (__first + __secondChild , 
__first + (__secondChild - 1))) 
__secondChild -- ; 
* (__first + __holeIndex) = std :: move (* (__first + __secondChild)) ; 
__holeIndex = __secondChild ; 
} 
if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2) 
{ 
__secondChild = 2 * (__secondChild + 1) ; 
* (__first + __holeIndex) = std :: move (* (__first + (__secondChild - 1))) 
; 
__holeIndex = __secondChild - 1 ; 
} 
__decltype (__gnu_cxx :: __ops :: __iter_comp_val (std :: move (__comp))) 
__cmp (std :: move (__comp)) ; 
std :: __push_heap (__first , __holeIndex , __topIndex , 
std :: move (__value) , __cmp) ; 
} 

template < typename _RandomAccessIterator , typename _Compare > 
inline void 
__pop_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_RandomAccessIterator __result , _Compare & __comp) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 

_ValueType __value = std :: move (* __result) ; 
* __result = std :: move (* __first) ; 
std :: __adjust_heap (__first , _DistanceType (0) , 
_DistanceType (__last - __first) , 
std :: move (__value) , __comp) ; 
} 
# 269 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline void 
pop_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 278
; 
; 
; 
; 

if (__last - __first > 1) 
{ 
-- __last ; 
__gnu_cxx :: __ops :: _Iter_less_iter __comp ; 
std :: __pop_heap (__first , __last , __last , __comp) ; 
} 
} 
# 302 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
pop_heap (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 



; 
; 
; 
; 

if (__last - __first > 1) 
{ 
typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
-- __last ; 
std :: __pop_heap (__first , __last , __last , __cmp) ; 
} 
} 

template < typename _RandomAccessIterator , typename _Compare > 
void 
__make_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare & __comp) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 

if (__last - __first < 2) 
return ; 

const _DistanceType __len = __last - __first ; 
_DistanceType __parent = (__len - 2) / 2 ; 
while (true) 
{ 
_ValueType __value = std :: move (* (__first + __parent)) ; 
std :: __adjust_heap (__first , __parent , __len , std :: move (__value) , 
__comp) ; 
if (__parent == 0) 
return ; 
__parent -- ; 
} 
} 
# 358 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline void 
make_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 367
; 
; 

__gnu_cxx :: __ops :: _Iter_less_iter __comp ; 
std :: __make_heap (__first , __last , __comp) ; 
} 
# 384 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
make_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 



; 
; 

typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
std :: __make_heap (__first , __last , __cmp) ; 
} 

template < typename _RandomAccessIterator , typename _Compare > 
void 
__sort_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare & __comp) 
{ 
while (__last - __first > 1) 
{ 
-- __last ; 
std :: __pop_heap (__first , __last , __last , __comp) ; 
} 
} 
# 420 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline void 
sort_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 429
; 
; 
; 

__gnu_cxx :: __ops :: _Iter_less_iter __comp ; 
std :: __sort_heap (__first , __last , __comp) ; 
} 
# 447 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
sort_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 



; 
; 
; 

typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
std :: __sort_heap (__first , __last , __cmp) ; 
} 
# 475 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline _RandomAccessIterator 
is_heap_until (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 484
; 
; 

__gnu_cxx :: __ops :: _Iter_less_iter __comp ; 
return __first + 
std :: __is_heap_until (__first , std :: distance (__first , __last) , __comp) ; 
} 
# 503 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline _RandomAccessIterator 
is_heap_until (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 



; 
; 

typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
return __first 
+ std :: __is_heap_until (__first , std :: distance (__first , __last) , __cmp) ; 
} 
# 527 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator > 
inline bool 
is_heap (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ return std :: is_heap_until (__first , __last) == __last ; } 
# 540 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_heap.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline bool 
is_heap (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 



; 
; 

const auto __dist = std :: distance (__first , __last) ; 
typedef __decltype (__comp) _Cmp ; 
__gnu_cxx :: __ops :: _Iter_comp_iter < _Cmp > __cmp (std :: move (__comp)) ; 
return std :: __is_heap_until (__first , __dist , __cmp) == __dist ; 
} 



}
# 62 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tempbuf.h" 3
namespace std { 
# 83 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tempbuf.h" 3
template < typename _Tp > 
pair < _Tp * , ptrdiff_t > 
get_temporary_buffer (ptrdiff_t __len) noexcept 
{ 
const ptrdiff_t __max = 
__gnu_cxx :: __numeric_traits < ptrdiff_t > :: __max / sizeof (_Tp) ; 
if (__len > __max) 
__len = __max ; 

while (__len > 0) 
{ 
_Tp * __tmp = static_cast < _Tp * > (:: operator new (__len * sizeof (_Tp) , 
std :: nothrow)) ; 
if (__tmp != 0) 
return std :: pair < _Tp * , ptrdiff_t > (__tmp , __len) ; 
__len /= 2 ; 
} 
return std :: pair < _Tp * , ptrdiff_t > (static_cast < _Tp * > (0) , 0) ; 
} 
# 110 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tempbuf.h" 3
template < typename _Tp > 
inline void 
return_temporary_buffer (_Tp * __p) 
{ :: operator delete (__p) ; } 
# 121
template < typename _ForwardIterator , typename _Tp > 
class _Temporary_buffer 
{ 



public : 
typedef _Tp value_type ; 
typedef value_type * pointer ; 
typedef pointer iterator ; 
typedef ptrdiff_t size_type ; 

protected : 
size_type _M_original_len ; 
size_type _M_len ; 
pointer _M_buffer ; 

public : 

size_type 
size () const 
{ return _M_len ; } 


size_type 
requested_size () const 
{ return _M_original_len ; } 


iterator 
begin () 
{ return _M_buffer ; } 


iterator 
end () 
{ return _M_buffer + _M_len ; } 
# 163
_Temporary_buffer (_ForwardIterator __seed , size_type __original_len) ; 

~ _Temporary_buffer () 
{ 
std :: _Destroy (_M_buffer , _M_buffer + _M_len) ; 
std :: return_temporary_buffer (_M_buffer) ; 
} 

private : 

_Temporary_buffer (const _Temporary_buffer &) ; 

void 
operator = (const _Temporary_buffer &) ; 
} ;


template < bool > 
struct __uninitialized_construct_buf_dispatch 
{ 
template < typename _Pointer , typename _ForwardIterator > 
static void 
__ucr (_Pointer __first , _Pointer __last , 
_ForwardIterator __seed) 
{ 
if (__first == __last) 
return ; 

_Pointer __cur = __first ; 
try 
{ 
std :: _Construct (std :: __addressof (* __first) , 
std :: move (* __seed)) ; 
_Pointer __prev = __cur ; 
++ __cur ; 
for (; __cur != __last ; ++ __cur , ++ __prev) 
std :: _Construct (std :: __addressof (* __cur) , 
std :: move (* __prev)) ; 
* __seed = std :: move (* __prev) ; 
} 
catch (...) 
{ 
std :: _Destroy (__first , __cur) ; 
throw ; 
} 
} 
} ;


template<> struct __uninitialized_construct_buf_dispatch< true>  { 

template < typename _Pointer , typename _ForwardIterator > 
static void 
__ucr (_Pointer , _Pointer , _ForwardIterator) { } 
}; 
# 229 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tempbuf.h" 3
template < typename _Pointer , typename _ForwardIterator > 
inline void 
__uninitialized_construct_buf (_Pointer __first , _Pointer __last , 
_ForwardIterator __seed) 
{ 
typedef typename std :: iterator_traits < _Pointer > :: value_type 
_ValueType ; 

std :: __uninitialized_construct_buf_dispatch < 
__has_trivial_constructor (_ValueType) > :: 
__ucr (__first , __last , __seed) ; 
} 

template < typename _ForwardIterator , typename _Tp > 
_Temporary_buffer < _ForwardIterator , _Tp > :: 
_Temporary_buffer (_ForwardIterator __seed , size_type __original_len) 
: _M_original_len (__original_len) , _M_len (0) , _M_buffer (0) 
{ 
try 
{ 
std :: pair < pointer , size_type > __p (std :: get_temporary_buffer < 
value_type > (_M_original_len)) ; 
_M_buffer = __p . first ; 
_M_len = __p . second ; 
if (_M_buffer) 
std :: __uninitialized_construct_buf (_M_buffer , _M_buffer + _M_len , 
__seed) ; 
} 
catch (...) 
{ 
std :: return_temporary_buffer (_M_buffer) ; 
_M_buffer = 0 ; 
_M_len = 0 ; 
throw ; 
} 
} 


}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\uniform_int_dist.h" 3
namespace std { 



namespace __detail { 


template < typename _Tp > 
inline bool 
_Power_of_2 (_Tp __x) 
{ 
return ((__x - 1) & __x) == 0 ; 
} 
}
# 57
template < typename _IntType = int > 
class uniform_int_distribution 
{ 
static_assert (std :: is_integral < _IntType > :: value , 
"template argument must be an integral type") ; 

public : 

typedef _IntType result_type ; 

struct param_type 
{ 
typedef uniform_int_distribution < _IntType > distribution_type ; 

param_type () : param_type (0) { } 

explicit 
param_type (_IntType __a , 
_IntType __b = numeric_limits < _IntType > :: max ()) 
: _M_a (__a) , _M_b (__b) 
{ 
; 
} 

result_type 
a () const 
{ return _M_a ; } 

result_type 
b () const 
{ return _M_b ; } 

friend bool 
operator == (const param_type & __p1 , const param_type & __p2) 
{ return __p1 . _M_a == __p2 . _M_a && __p1 . _M_b == __p2 . _M_b ; } 

friend bool 
operator != (const param_type & __p1 , const param_type & __p2) 
{ return ! (__p1 == __p2) ; } 

private : 
_IntType _M_a ; 
_IntType _M_b ; 
} ; 

public : 



uniform_int_distribution () : uniform_int_distribution (0) { } 




explicit 
uniform_int_distribution (_IntType __a , 
_IntType __b = numeric_limits < _IntType > :: max ()) 
: _M_param (__a , __b) 
{ } 

explicit 
uniform_int_distribution (const param_type & __p) 
: _M_param (__p) 
{ } 
# 127
void 
reset () { } 

result_type 
a () const 
{ return _M_param . a () ; } 

result_type 
b () const 
{ return _M_param . b () ; } 




param_type 
param () const 
{ return _M_param ; } 
# 149
void 
param (const param_type & __param) 
{ _M_param = __param ; } 




result_type 
min () const 
{ return this -> a () ; } 




result_type 
max () const 
{ return this -> b () ; } 




template < typename _UniformRandomNumberGenerator > 
result_type 
operator () (_UniformRandomNumberGenerator & __urng) 
{ return this -> operator () (__urng , _M_param) ; } 

template < typename _UniformRandomNumberGenerator > 
result_type 
operator () (_UniformRandomNumberGenerator & __urng , 
const param_type & __p) ; 

template < typename _ForwardIterator , 
typename _UniformRandomNumberGenerator > 
void 
__generate (_ForwardIterator __f , _ForwardIterator __t , 
_UniformRandomNumberGenerator & __urng) 
{ this -> __generate (__f , __t , __urng , _M_param) ; } 

template < typename _ForwardIterator , 
typename _UniformRandomNumberGenerator > 
void 
__generate (_ForwardIterator __f , _ForwardIterator __t , 
_UniformRandomNumberGenerator & __urng , 
const param_type & __p) 
{ this -> __generate_impl (__f , __t , __urng , __p) ; } 

template < typename _UniformRandomNumberGenerator > 
void 
__generate (result_type * __f , result_type * __t , 
_UniformRandomNumberGenerator & __urng , 
const param_type & __p) 
{ this -> __generate_impl (__f , __t , __urng , __p) ; } 
# 206
friend bool 
operator == (const uniform_int_distribution & __d1 , 
const uniform_int_distribution & __d2) 
{ return __d1 . _M_param == __d2 . _M_param ; } 

private : 
template < typename _ForwardIterator , 
typename _UniformRandomNumberGenerator > 
void 
__generate_impl (_ForwardIterator __f , _ForwardIterator __t , 
_UniformRandomNumberGenerator & __urng , 
const param_type & __p) ; 

param_type _M_param ; 
} ;

template < typename _IntType > 
template < typename _UniformRandomNumberGenerator > 
typename uniform_int_distribution < _IntType > :: result_type 
uniform_int_distribution < _IntType > :: 
operator () (_UniformRandomNumberGenerator & __urng , 
const param_type & __param) 
{ 
typedef typename _UniformRandomNumberGenerator :: result_type 
_Gresult_type ; 
typedef typename std :: make_unsigned < result_type > :: type __utype ; 
typedef typename std :: common_type < _Gresult_type , __utype > :: type 
__uctype ; 

const __uctype __urngmin = __urng . min () ; 
const __uctype __urngmax = __urng . max () ; 
const __uctype __urngrange = __urngmax - __urngmin ; 
const __uctype __urange 
= __uctype (__param . b ()) - __uctype (__param . a ()) ; 

__uctype __ret ; 

if (__urngrange > __urange) 
{ 

const __uctype __uerange = __urange + 1 ; 
const __uctype __scaling = __urngrange / __uerange ; 
const __uctype __past = __uerange * __scaling ; 
do 
__ret = __uctype (__urng ()) - __urngmin ; 
while (__ret >= __past) ; 
__ret /= __scaling ; 
} 
else if (__urngrange < __urange) 
{ 
# 271 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\uniform_int_dist.h" 3
__uctype __tmp ; 
do 
{ 
const __uctype __uerngrange = __urngrange + 1 ; 
__tmp = (__uerngrange * operator () 
(__urng , param_type (0 , __urange / __uerngrange))) ; 
__ret = __tmp + (__uctype (__urng ()) - __urngmin) ; 
} 
while (__ret > __urange || __ret < __tmp) ; 
} 
else 
__ret = __uctype (__urng ()) - __urngmin ; 

return __ret + __param . a () ; 
} 


template < typename _IntType > 
template < typename _ForwardIterator , 
typename _UniformRandomNumberGenerator > 
void 
uniform_int_distribution < _IntType > :: 
__generate_impl (_ForwardIterator __f , _ForwardIterator __t , 
_UniformRandomNumberGenerator & __urng , 
const param_type & __param) 
{ 

typedef typename _UniformRandomNumberGenerator :: result_type 
_Gresult_type ; 
typedef typename std :: make_unsigned < result_type > :: type __utype ; 
typedef typename std :: common_type < _Gresult_type , __utype > :: type 
__uctype ; 

const __uctype __urngmin = __urng . min () ; 
const __uctype __urngmax = __urng . max () ; 
const __uctype __urngrange = __urngmax - __urngmin ; 
const __uctype __urange 
= __uctype (__param . b ()) - __uctype (__param . a ()) ; 

__uctype __ret ; 

if (__urngrange > __urange) 
{ 
if (__detail :: _Power_of_2 (__urngrange + 1) 
&& __detail :: _Power_of_2 (__urange + 1)) 
{ 
while (__f != __t) 
{ 
__ret = __uctype (__urng ()) - __urngmin ; 
* __f ++ = (__ret & __urange) + __param . a () ; 
} 
} 
else 
{ 

const __uctype __uerange = __urange + 1 ; 
const __uctype __scaling = __urngrange / __uerange ; 
const __uctype __past = __uerange * __scaling ; 
while (__f != __t) 
{ 
do 
__ret = __uctype (__urng ()) - __urngmin ; 
while (__ret >= __past) ; 
* __f ++ = __ret / __scaling + __param . a () ; 
} 
} 
} 
else if (__urngrange < __urange) 
{ 
# 355 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\uniform_int_dist.h" 3
__uctype __tmp ; 
while (__f != __t) 
{ 
do 
{ 
const __uctype __uerngrange = __urngrange + 1 ; 
__tmp = (__uerngrange * operator () 
(__urng , param_type (0 , __urange / __uerngrange))) ; 
__ret = __tmp + (__uctype (__urng ()) - __urngmin) ; 
} 
while (__ret > __urange || __ret < __tmp) ; 
* __f ++ = __ret ; 
} 
} 
else 
while (__f != __t) 
* __f ++ = __uctype (__urng ()) - __urngmin + __param . a () ; 
} 




}
# 71 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
namespace std { 




template < typename _Iterator , typename _Compare > 
void 
__move_median_to_first (_Iterator __result , _Iterator __a , _Iterator __b , 
_Iterator __c , _Compare __comp) 
{ 
if (__comp (__a , __b)) 
{ 
if (__comp (__b , __c)) 
std :: iter_swap (__result , __b) ; 
else if (__comp (__a , __c)) 
std :: iter_swap (__result , __c) ; 
else 
std :: iter_swap (__result , __a) ; 
} 
else if (__comp (__a , __c)) 
std :: iter_swap (__result , __a) ; 
else if (__comp (__b , __c)) 
std :: iter_swap (__result , __c) ; 
else 
std :: iter_swap (__result , __b) ; 
} 


template < typename _InputIterator , typename _Predicate > 
inline _InputIterator 
__find_if (_InputIterator __first , _InputIterator __last , 
_Predicate __pred , input_iterator_tag) 
{ 
while (__first != __last && ! __pred (__first)) 
++ __first ; 
return __first ; 
} 


template < typename _RandomAccessIterator , typename _Predicate > 
_RandomAccessIterator 
__find_if (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Predicate __pred , random_access_iterator_tag) 
{ 
typename iterator_traits < _RandomAccessIterator > :: difference_type 
__trip_count = (__last - __first) >> 2 ; 

for (; __trip_count > 0 ; -- __trip_count) 
{ 
if (__pred (__first)) 
return __first ; 
++ __first ; 

if (__pred (__first)) 
return __first ; 
++ __first ; 

if (__pred (__first)) 
return __first ; 
++ __first ; 

if (__pred (__first)) 
return __first ; 
++ __first ; 
} 

switch (__last - __first) 
{ 
case 3 : 
if (__pred (__first)) 
return __first ; 
++ __first ; 
case 2 : 
if (__pred (__first)) 
return __first ; 
++ __first ; 
case 1 : 
if (__pred (__first)) 
return __first ; 
++ __first ; 
case 0 : 
default : 
return __last ; 
} 
} 

template < typename _Iterator , typename _Predicate > 
inline _Iterator 
__find_if (_Iterator __first , _Iterator __last , _Predicate __pred) 
{ 
return __find_if (__first , __last , __pred , 
std :: __iterator_category (__first)) ; 
} 


template < typename _InputIterator , typename _Predicate > 
inline _InputIterator 
__find_if_not (_InputIterator __first , _InputIterator __last , 
_Predicate __pred) 
{ 
return std :: __find_if (__first , __last , 
__gnu_cxx :: __ops :: __negate (__pred) , 
std :: __iterator_category (__first)) ; 
} 




template < typename _InputIterator , typename _Predicate , typename _Distance > 
_InputIterator 
__find_if_not_n (_InputIterator __first , _Distance & __len , _Predicate __pred) 
{ 
for (; __len ; -- __len , (void) ++ __first) 
if (! __pred (__first)) 
break ; 
return __first ; 
} 
# 202 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
_ForwardIterator1 
__search (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2 , 
_BinaryPredicate __predicate) 
{ 

if (__first1 == __last1 || __first2 == __last2) 
return __first1 ; 


_ForwardIterator2 __p1 (__first2) ; 
if (++ __p1 == __last2) 
return std :: __find_if (__first1 , __last1 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__predicate , __first2)) ; 


_ForwardIterator2 __p ; 
_ForwardIterator1 __current = __first1 ; 

for (; ;) 
{ 
__first1 = 
std :: __find_if (__first1 , __last1 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__predicate , __first2)) ; 

if (__first1 == __last1) 
return __last1 ; 

__p = __p1 ; 
__current = __first1 ; 
if (++ __current == __last1) 
return __last1 ; 

while (__predicate (__current , __p)) 
{ 
if (++ __p == __last2) 
return __first1 ; 
if (++ __current == __last1) 
return __last1 ; 
} 
++ __first1 ; 
} 
return __first1 ; 
} 
# 254
template < typename _ForwardIterator , typename _Integer , 
typename _UnaryPredicate > 
_ForwardIterator 
__search_n_aux (_ForwardIterator __first , _ForwardIterator __last , 
_Integer __count , _UnaryPredicate __unary_pred , 
std :: forward_iterator_tag) 
{ 
__first = std :: __find_if (__first , __last , __unary_pred) ; 
while (__first != __last) 
{ 
typename iterator_traits < _ForwardIterator > :: difference_type 
__n = __count ; 
_ForwardIterator __i = __first ; 
++ __i ; 
while (__i != __last && __n != 1 && __unary_pred (__i)) 
{ 
++ __i ; 
-- __n ; 
} 
if (__n == 1) 
return __first ; 
if (__i == __last) 
return __last ; 
__first = std :: __find_if (++ __i , __last , __unary_pred) ; 
} 
return __last ; 
} 
# 286
template < typename _RandomAccessIter , typename _Integer , 
typename _UnaryPredicate > 
_RandomAccessIter 
__search_n_aux (_RandomAccessIter __first , _RandomAccessIter __last , 
_Integer __count , _UnaryPredicate __unary_pred , 
std :: random_access_iterator_tag) 
{ 
typedef typename std :: iterator_traits < _RandomAccessIter > :: difference_type 
_DistanceType ; 

_DistanceType __tailSize = __last - __first ; 
_DistanceType __remainder = __count ; 

while (__remainder <= __tailSize) 
{ 
__first += __remainder ; 
__tailSize -= __remainder ; 


_RandomAccessIter __backTrack = __first ; 
while (__unary_pred (-- __backTrack)) 
{ 
if (-- __remainder == 0) 
return (__first - __count) ; 
} 
__remainder = __count + 1 - (__first - __backTrack) ; 
} 
return __last ; 
} 

template < typename _ForwardIterator , typename _Integer , 
typename _UnaryPredicate > 
_ForwardIterator 
__search_n (_ForwardIterator __first , _ForwardIterator __last , 
_Integer __count , 
_UnaryPredicate __unary_pred) 
{ 
if (__count <= 0) 
return __first ; 

if (__count == 1) 
return std :: __find_if (__first , __last , __unary_pred) ; 

return std :: __search_n_aux (__first , __last , __count , __unary_pred , 
std :: __iterator_category (__first)) ; 
} 


template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
_ForwardIterator1 
__find_end (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2 , 
forward_iterator_tag , forward_iterator_tag , 
_BinaryPredicate __comp) 
{ 
if (__first2 == __last2) 
return __last1 ; 

_ForwardIterator1 __result = __last1 ; 
while (1) 
{ 
_ForwardIterator1 __new_result 
= std :: __search (__first1 , __last1 , __first2 , __last2 , __comp) ; 
if (__new_result == __last1) 
return __result ; 
else 
{ 
__result = __new_result ; 
__first1 = __new_result ; 
++ __first1 ; 
} 
} 
} 


template < typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , 
typename _BinaryPredicate > 
_BidirectionalIterator1 
__find_end (_BidirectionalIterator1 __first1 , 
_BidirectionalIterator1 __last1 , 
_BidirectionalIterator2 __first2 , 
_BidirectionalIterator2 __last2 , 
bidirectional_iterator_tag , bidirectional_iterator_tag , 
_BinaryPredicate __comp) 
{ 
# 378
typedef reverse_iterator < _BidirectionalIterator1 > _RevIterator1 ; 
typedef reverse_iterator < _BidirectionalIterator2 > _RevIterator2 ; 

_RevIterator1 __rlast1 (__first1) ; 
_RevIterator2 __rlast2 (__first2) ; 
_RevIterator1 __rresult = std :: __search (_RevIterator1 (__last1) , __rlast1 , 
_RevIterator2 (__last2) , __rlast2 , 
__comp) ; 

if (__rresult == __rlast1) 
return __last1 ; 
else 
{ 
_BidirectionalIterator1 __result = __rresult . base () ; 
std :: advance (__result , - std :: distance (__first2 , __last2)) ; 
return __result ; 
} 
} 
# 423 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 > 
inline _ForwardIterator1 
find_end (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2) 
{ 
# 434
; 
; 

return std :: __find_end (__first1 , __last1 , __first2 , __last2 , 
std :: __iterator_category (__first1) , 
std :: __iterator_category (__first2) , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 471 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
inline _ForwardIterator1 
find_end (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2 , 
_BinaryPredicate __comp) 
{ 
# 484
; 
; 

return std :: __find_end (__first1 , __last1 , __first2 , __last2 , 
std :: __iterator_category (__first1) , 
std :: __iterator_category (__first2) , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 506 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline bool 
all_of (_InputIterator __first , _InputIterator __last , _Predicate __pred) 
{ return __last == std :: find_if_not (__first , __last , __pred) ; } 
# 523 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline bool 
none_of (_InputIterator __first , _InputIterator __last , _Predicate __pred) 
{ return __last == std :: find_if (__first , __last , __pred) ; } 
# 541 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline bool 
any_of (_InputIterator __first , _InputIterator __last , _Predicate __pred) 
{ return ! std :: none_of (__first , __last , __pred) ; } 
# 556 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline _InputIterator 
find_if_not (_InputIterator __first , _InputIterator __last , 
_Predicate __pred) 
{ 




; 
return std :: __find_if_not (__first , __last , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 
# 580 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline bool 
is_partitioned (_InputIterator __first , _InputIterator __last , 
_Predicate __pred) 
{ 
__first = std :: find_if_not (__first , __last , __pred) ; 
if (__first == __last) 
return true ; 
++ __first ; 
return std :: none_of (__first , __last , __pred) ; 
} 
# 601 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Predicate > 
_ForwardIterator 
partition_point (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
# 612
; 

typedef typename iterator_traits < _ForwardIterator > :: difference_type 
_DistanceType ; 

_DistanceType __len = std :: distance (__first , __last) ; 
_DistanceType __half ; 
_ForwardIterator __middle ; 

while (__len > 0) 
{ 
__half = __len >> 1 ; 
__middle = __first ; 
std :: advance (__middle , __half) ; 
if (__pred (* __middle)) 
{ 
__first = __middle ; 
++ __first ; 
__len = __len - __half - 1 ; 
} 
else 
__len = __half ; 
} 
return __first ; 
} 


template < typename _InputIterator , typename _OutputIterator , 
typename _Predicate > 
_OutputIterator 
__remove_copy_if (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , _Predicate __pred) 
{ 
for (; __first != __last ; ++ __first) 
if (! __pred (__first)) 
{ 
* __result = * __first ; 
++ __result ; 
} 
return __result ; 
} 
# 668 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , typename _Tp > 
inline _OutputIterator 
remove_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , const _Tp & __value) 
{ 
# 679
; 

return std :: __remove_copy_if (__first , __last , __result , 
__gnu_cxx :: __ops :: __iter_equals_val (__value)) ; 
} 
# 700 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , 
typename _Predicate > 
inline _OutputIterator 
remove_copy_if (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , _Predicate __pred) 
{ 
# 712
; 

return std :: __remove_copy_if (__first , __last , __result , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 
# 734 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , 
typename _Predicate > 
_OutputIterator 
copy_if (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , _Predicate __pred) 
{ 
# 746
; 

for (; __first != __last ; ++ __first) 
if (__pred (* __first)) 
{ 
* __result = * __first ; 
++ __result ; 
} 
return __result ; 
} 

template < typename _InputIterator , typename _Size , typename _OutputIterator > 
_OutputIterator 
__copy_n (_InputIterator __first , _Size __n , 
_OutputIterator __result , input_iterator_tag) 
{ 
if (__n > 0) 
{ 
while (true) 
{ 
* __result = * __first ; 
++ __result ; 
if (-- __n > 0) 
++ __first ; 
else 
break ; 
} 
} 
return __result ; 
} 

template < typename _RandomAccessIterator , typename _Size , 
typename _OutputIterator > 
inline _OutputIterator 
__copy_n (_RandomAccessIterator __first , _Size __n , 
_OutputIterator __result , random_access_iterator_tag) 
{ return std :: copy (__first , __first + __n , __result) ; } 
# 797 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Size , typename _OutputIterator > 
inline _OutputIterator 
copy_n (_InputIterator __first , _Size __n , _OutputIterator __result) 
{ 
# 806
return std :: __copy_n (__first , __n , __result , 
std :: __iterator_category (__first)) ; 
} 
# 825 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator1 , 
typename _OutputIterator2 , typename _Predicate > 
pair < _OutputIterator1 , _OutputIterator2 > 
partition_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator1 __out_true , _OutputIterator2 __out_false , 
_Predicate __pred) 
{ 
# 840
; 

for (; __first != __last ; ++ __first) 
if (__pred (* __first)) 
{ 
* __out_true = * __first ; 
++ __out_true ; 
} 
else 
{ 
* __out_false = * __first ; 
++ __out_false ; 
} 

return pair < _OutputIterator1 , _OutputIterator2 > (__out_true , __out_false) ; 
} 


template < typename _ForwardIterator , typename _Predicate > 
_ForwardIterator 
__remove_if (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
__first = std :: __find_if (__first , __last , __pred) ; 
if (__first == __last) 
return __first ; 
_ForwardIterator __result = __first ; 
++ __first ; 
for (; __first != __last ; ++ __first) 
if (! __pred (__first)) 
{ 
* __result = std :: move (* __first) ; 
++ __result ; 
} 
return __result ; 
} 
# 894 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline _ForwardIterator 
remove (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __value) 
{ 
# 904
; 

return std :: __remove_if (__first , __last , 
__gnu_cxx :: __ops :: __iter_equals_val (__value)) ; 
} 
# 927 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Predicate > 
inline _ForwardIterator 
remove_if (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
# 937
; 

return std :: __remove_if (__first , __last , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 

template < typename _ForwardIterator , typename _BinaryPredicate > 
_ForwardIterator 
__adjacent_find (_ForwardIterator __first , _ForwardIterator __last , 
_BinaryPredicate __binary_pred) 
{ 
if (__first == __last) 
return __last ; 
_ForwardIterator __next = __first ; 
while (++ __next != __last) 
{ 
if (__binary_pred (__first , __next)) 
return __first ; 
__first = __next ; 
} 
return __last ; 
} 

template < typename _ForwardIterator , typename _BinaryPredicate > 
_ForwardIterator 
__unique (_ForwardIterator __first , _ForwardIterator __last , 
_BinaryPredicate __binary_pred) 
{ 

__first = std :: __adjacent_find (__first , __last , __binary_pred) ; 
if (__first == __last) 
return __last ; 


_ForwardIterator __dest = __first ; 
++ __first ; 
while (++ __first != __last) 
if (! __binary_pred (__dest , __first)) 
* ++ __dest = std :: move (* __first) ; 
return ++ __dest ; 
} 
# 993 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 
inline _ForwardIterator 
unique (_ForwardIterator __first , _ForwardIterator __last) 
{ 
# 1002
; 

return std :: __unique (__first , __last , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 1023 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _BinaryPredicate > 
inline _ForwardIterator 
unique (_ForwardIterator __first , _ForwardIterator __last , 
_BinaryPredicate __binary_pred) 
{ 
# 1034
; 

return std :: __unique (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__binary_pred)) ; 
} 
# 1046
template < typename _ForwardIterator , typename _OutputIterator , 
typename _BinaryPredicate > 
_OutputIterator 
__unique_copy (_ForwardIterator __first , _ForwardIterator __last , 
_OutputIterator __result , _BinaryPredicate __binary_pred , 
forward_iterator_tag , output_iterator_tag) 
{ 
# 1058
_ForwardIterator __next = __first ; 
* __result = * __first ; 
while (++ __next != __last) 
if (! __binary_pred (__first , __next)) 
{ 
__first = __next ; 
* ++ __result = * __first ; 
} 
return ++ __result ; 
} 
# 1075
template < typename _InputIterator , typename _OutputIterator , 
typename _BinaryPredicate > 
_OutputIterator 
__unique_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , _BinaryPredicate __binary_pred , 
input_iterator_tag , output_iterator_tag) 
{ 
# 1087
typename iterator_traits < _InputIterator > :: value_type __value = * __first ; 
__decltype (__gnu_cxx :: __ops :: __iter_comp_val (__binary_pred)) 
__rebound_pred 
= __gnu_cxx :: __ops :: __iter_comp_val (__binary_pred) ; 
* __result = __value ; 
while (++ __first != __last) 
if (! __rebound_pred (__first , __value)) 
{ 
__value = * __first ; 
* ++ __result = __value ; 
} 
return ++ __result ; 
} 
# 1107
template < typename _InputIterator , typename _ForwardIterator , 
typename _BinaryPredicate > 
_ForwardIterator 
__unique_copy (_InputIterator __first , _InputIterator __last , 
_ForwardIterator __result , _BinaryPredicate __binary_pred , 
input_iterator_tag , forward_iterator_tag) 
{ 




* __result = * __first ; 
while (++ __first != __last) 
if (! __binary_pred (__result , __first)) 
* ++ __result = * __first ; 
return ++ __result ; 
} 
# 1130
template < typename _BidirectionalIterator > 
void 
__reverse (_BidirectionalIterator __first , _BidirectionalIterator __last , 
bidirectional_iterator_tag) 
{ 
while (true) 
if (__first == __last || __first == -- __last) 
return ; 
else 
{ 
std :: iter_swap (__first , __last) ; 
++ __first ; 
} 
} 
# 1150
template < typename _RandomAccessIterator > 
void 
__reverse (_RandomAccessIterator __first , _RandomAccessIterator __last , 
random_access_iterator_tag) 
{ 
if (__first == __last) 
return ; 
-- __last ; 
while (__first < __last) 
{ 
std :: iter_swap (__first , __last) ; 
++ __first ; 
-- __last ; 
} 
} 
# 1178 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator > 
inline void 
reverse (_BidirectionalIterator __first , _BidirectionalIterator __last) 
{ 



; 
std :: __reverse (__first , __last , std :: __iterator_category (__first)) ; 
} 
# 1205 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator , typename _OutputIterator > 
_OutputIterator 
reverse_copy (_BidirectionalIterator __first , _BidirectionalIterator __last , 
_OutputIterator __result) 
{ 
# 1215
; 

while (__first != __last) 
{ 
-- __last ; 
* __result = * __last ; 
++ __result ; 
} 
return __result ; 
} 
# 1230
template < typename _EuclideanRingElement > 
_EuclideanRingElement 
__gcd (_EuclideanRingElement __m , _EuclideanRingElement __n) 
{ 
while (__n != 0) 
{ 
_EuclideanRingElement __t = __m % __n ; 
__m = __n ; 
__n = __t ; 
} 
return __m ; 
} 

inline namespace _V2 { 



template < typename _ForwardIterator > 
_ForwardIterator 
__rotate (_ForwardIterator __first , 
_ForwardIterator __middle , 
_ForwardIterator __last , 
forward_iterator_tag) 
{ 
if (__first == __middle) 
return __last ; 
else if (__last == __middle) 
return __first ; 

_ForwardIterator __first2 = __middle ; 
do 
{ 
std :: iter_swap (__first , __first2) ; 
++ __first ; 
++ __first2 ; 
if (__first == __middle) 
__middle = __first2 ; 
} 
while (__first2 != __last) ; 

_ForwardIterator __ret = __first ; 

__first2 = __middle ; 

while (__first2 != __last) 
{ 
std :: iter_swap (__first , __first2) ; 
++ __first ; 
++ __first2 ; 
if (__first == __middle) 
__middle = __first2 ; 
else if (__first2 == __last) 
__first2 = __middle ; 
} 
return __ret ; 
} 


template < typename _BidirectionalIterator > 
_BidirectionalIterator 
__rotate (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last , 
bidirectional_iterator_tag) 
{ 




if (__first == __middle) 
return __last ; 
else if (__last == __middle) 
return __first ; 

std :: __reverse (__first , __middle , bidirectional_iterator_tag ()) ; 
std :: __reverse (__middle , __last , bidirectional_iterator_tag ()) ; 

while (__first != __middle && __middle != __last) 
{ 
std :: iter_swap (__first , -- __last) ; 
++ __first ; 
} 

if (__first == __middle) 
{ 
std :: __reverse (__middle , __last , bidirectional_iterator_tag ()) ; 
return __last ; 
} 
else 
{ 
std :: __reverse (__first , __middle , bidirectional_iterator_tag ()) ; 
return __first ; 
} 
} 


template < typename _RandomAccessIterator > 
_RandomAccessIterator 
__rotate (_RandomAccessIterator __first , 
_RandomAccessIterator __middle , 
_RandomAccessIterator __last , 
random_access_iterator_tag) 
{ 




if (__first == __middle) 
return __last ; 
else if (__last == __middle) 
return __first ; 

typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_Distance ; 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 

_Distance __n = __last - __first ; 
_Distance __k = __middle - __first ; 

if (__k == __n - __k) 
{ 
std :: swap_ranges (__first , __middle , __middle) ; 
return __middle ; 
} 

_RandomAccessIterator __p = __first ; 
_RandomAccessIterator __ret = __first + (__last - __middle) ; 

for (; ;) 
{ 
if (__k < __n - __k) 
{ 
if (__is_pod (_ValueType) && __k == 1) 
{ 
_ValueType __t = std :: move (* __p) ; 
std :: move (__p + 1 , __p + __n , __p) ; 
* (__p + __n - 1) = std :: move (__t) ; 
return __ret ; 
} 
_RandomAccessIterator __q = __p + __k ; 
for (_Distance __i = 0 ; __i < __n - __k ; ++ __i) 
{ 
std :: iter_swap (__p , __q) ; 
++ __p ; 
++ __q ; 
} 
__n %= __k ; 
if (__n == 0) 
return __ret ; 
std :: swap (__n , __k) ; 
__k = __n - __k ; 
} 
else 
{ 
__k = __n - __k ; 
if (__is_pod (_ValueType) && __k == 1) 
{ 
_ValueType __t = std :: move (* (__p + __n - 1)) ; 
std :: move_backward (__p , __p + __n - 1 , __p + __n) ; 
* __p = std :: move (__t) ; 
return __ret ; 
} 
_RandomAccessIterator __q = __p + __n ; 
__p = __q - __k ; 
for (_Distance __i = 0 ; __i < __n - __k ; ++ __i) 
{ 
-- __p ; 
-- __q ; 
std :: iter_swap (__p , __q) ; 
} 
__n %= __k ; 
if (__n == 0) 
return __ret ; 
std :: swap (__n , __k) ; 
} 
} 
} 
# 1432 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 
inline _ForwardIterator 
rotate (_ForwardIterator __first , _ForwardIterator __middle , 
_ForwardIterator __last) 
{ 



; 
; 

return std :: __rotate (__first , __middle , __last , 
std :: __iterator_category (__first)) ; 
} 

}
# 1469 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _OutputIterator > 
inline _OutputIterator 
rotate_copy (_ForwardIterator __first , _ForwardIterator __middle , 
_ForwardIterator __last , _OutputIterator __result) 
{ 




; 
; 

return std :: copy (__first , __middle , 
std :: copy (__middle , __last , __result)) ; 
} 


template < typename _ForwardIterator , typename _Predicate > 
_ForwardIterator 
__partition (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred , forward_iterator_tag) 
{ 
if (__first == __last) 
return __first ; 

while (__pred (* __first)) 
if (++ __first == __last) 
return __first ; 

_ForwardIterator __next = __first ; 

while (++ __next != __last) 
if (__pred (* __next)) 
{ 
std :: iter_swap (__first , __next) ; 
++ __first ; 
} 

return __first ; 
} 


template < typename _BidirectionalIterator , typename _Predicate > 
_BidirectionalIterator 
__partition (_BidirectionalIterator __first , _BidirectionalIterator __last , 
_Predicate __pred , bidirectional_iterator_tag) 
{ 
while (true) 
{ 
while (true) 
if (__first == __last) 
return __first ; 
else if (__pred (* __first)) 
++ __first ; 
else 
break ; 
-- __last ; 
while (true) 
if (__first == __last) 
return __first ; 
else if (! bool (__pred (* __last))) 
-- __last ; 
else 
break ; 
std :: iter_swap (__first , __last) ; 
++ __first ; 
} 
} 
# 1546 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Pointer , typename _Predicate , 
typename _Distance > 
_ForwardIterator 
__stable_partition_adaptive (_ForwardIterator __first , 
_ForwardIterator __last , 
_Predicate __pred , _Distance __len , 
_Pointer __buffer , 
_Distance __buffer_size) 
{ 
if (__len == 1) 
return __first ; 

if (__len <= __buffer_size) 
{ 
_ForwardIterator __result1 = __first ; 
_Pointer __result2 = __buffer ; 




* __result2 = std :: move (* __first) ; 
++ __result2 ; 
++ __first ; 
for (; __first != __last ; ++ __first) 
if (__pred (__first)) 
{ 
* __result1 = std :: move (* __first) ; 
++ __result1 ; 
} 
else 
{ 
* __result2 = std :: move (* __first) ; 
++ __result2 ; 
} 

std :: move (__buffer , __result2 , __result1) ; 
return __result1 ; 
} 

_ForwardIterator __middle = __first ; 
std :: advance (__middle , __len / 2) ; 
_ForwardIterator __left_split = 
std :: __stable_partition_adaptive (__first , __middle , __pred , 
__len / 2 , __buffer , 
__buffer_size) ; 



_Distance __right_len = __len - __len / 2 ; 
_ForwardIterator __right_split = 
std :: __find_if_not_n (__middle , __right_len , __pred) ; 

if (__right_len) 
__right_split = 
std :: __stable_partition_adaptive (__right_split , __last , __pred , 
__right_len , 
__buffer , __buffer_size) ; 

return std :: rotate (__left_split , __middle , __right_split) ; 
} 

template < typename _ForwardIterator , typename _Predicate > 
_ForwardIterator 
__stable_partition (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
__first = std :: __find_if_not (__first , __last , __pred) ; 

if (__first == __last) 
return __first ; 

typedef typename iterator_traits < _ForwardIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _ForwardIterator > :: difference_type 
_DistanceType ; 

_Temporary_buffer < _ForwardIterator , _ValueType > 
__buf (__first , std :: distance (__first , __last)) ; 
return 
std :: __stable_partition_adaptive (__first , __last , __pred , 
_DistanceType (__buf . requested_size ()) , 
__buf . begin () , 
_DistanceType (__buf . size ())) ; 
} 
# 1648 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Predicate > 
inline _ForwardIterator 
stable_partition (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
# 1658
; 

return std :: __stable_partition (__first , __last , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 


template < typename _RandomAccessIterator , typename _Compare > 
void 
__heap_select (_RandomAccessIterator __first , 
_RandomAccessIterator __middle , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
std :: __make_heap (__first , __middle , __comp) ; 
for (_RandomAccessIterator __i = __middle ; __i < __last ; ++ __i) 
if (__comp (__i , __first)) 
std :: __pop_heap (__first , __middle , __i , __comp) ; 
} 



template < typename _InputIterator , typename _RandomAccessIterator , 
typename _Compare > 
_RandomAccessIterator 
__partial_sort_copy (_InputIterator __first , _InputIterator __last , 
_RandomAccessIterator __result_first , 
_RandomAccessIterator __result_last , 
_Compare __comp) 
{ 
typedef typename iterator_traits < _InputIterator > :: value_type 
_InputValueType ; 
typedef iterator_traits < _RandomAccessIterator > _RItTraits ; 
typedef typename _RItTraits :: difference_type _DistanceType ; 

if (__result_first == __result_last) 
return __result_last ; 
_RandomAccessIterator __result_real_last = __result_first ; 
while (__first != __last && __result_real_last != __result_last) 
{ 
* __result_real_last = * __first ; 
++ __result_real_last ; 
++ __first ; 
} 

std :: __make_heap (__result_first , __result_real_last , __comp) ; 
while (__first != __last) 
{ 
if (__comp (__first , __result_first)) 
std :: __adjust_heap (__result_first , _DistanceType (0) , 
_DistanceType (__result_real_last 
- __result_first) , 
_InputValueType (* __first) , __comp) ; 
++ __first ; 
} 
std :: __sort_heap (__result_first , __result_real_last , __comp) ; 
return __result_real_last ; 
} 
# 1734 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _RandomAccessIterator > 
inline _RandomAccessIterator 
partial_sort_copy (_InputIterator __first , _InputIterator __last , 
_RandomAccessIterator __result_first , 
_RandomAccessIterator __result_last) 
{ 
# 1754 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
; 
; 
; 

return std :: __partial_sort_copy (__first , __last , 
__result_first , __result_last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 1783 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _RandomAccessIterator , 
typename _Compare > 
inline _RandomAccessIterator 
partial_sort_copy (_InputIterator __first , _InputIterator __last , 
_RandomAccessIterator __result_first , 
_RandomAccessIterator __result_last , 
_Compare __comp) 
{ 
# 1808 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
; 
; 
; 

return std :: __partial_sort_copy (__first , __last , 
__result_first , __result_last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 


template < typename _RandomAccessIterator , typename _Compare > 
void 
__unguarded_linear_insert (_RandomAccessIterator __last , 
_Compare __comp) 
{ 
typename iterator_traits < _RandomAccessIterator > :: value_type 
__val = std :: move (* __last) ; 
_RandomAccessIterator __next = __last ; 
-- __next ; 
while (__comp (__val , __next)) 
{ 
* __last = std :: move (* __next) ; 
__last = __next ; 
-- __next ; 
} 
* __last = std :: move (__val) ; 
} 


template < typename _RandomAccessIterator , typename _Compare > 
void 
__insertion_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
if (__first == __last) return ; 

for (_RandomAccessIterator __i = __first + 1 ; __i != __last ; ++ __i) 
{ 
if (__comp (__i , __first)) 
{ 
typename iterator_traits < _RandomAccessIterator > :: value_type 
__val = std :: move (* __i) ; 
std :: move_backward (__first , __i , __i + 1) ; 
* __first = std :: move (__val) ; 
} 
else 
std :: __unguarded_linear_insert (__i , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
} 
} 


template < typename _RandomAccessIterator , typename _Compare > 
inline void 
__unguarded_insertion_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
for (_RandomAccessIterator __i = __first ; __i != __last ; ++ __i) 
std :: __unguarded_linear_insert (__i , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
} 
# 1874
enum { _S_threshold = 16}; 


template < typename _RandomAccessIterator , typename _Compare > 
void 
__final_insertion_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
if (__last - __first > int (_S_threshold)) 
{ 
std :: __insertion_sort (__first , __first + int (_S_threshold) , __comp) ; 
std :: __unguarded_insertion_sort (__first + int (_S_threshold) , __last , 
__comp) ; 
} 
else 
std :: __insertion_sort (__first , __last , __comp) ; 
} 


template < typename _RandomAccessIterator , typename _Compare > 
_RandomAccessIterator 
__unguarded_partition (_RandomAccessIterator __first , 
_RandomAccessIterator __last , 
_RandomAccessIterator __pivot , _Compare __comp) 
{ 
while (true) 
{ 
while (__comp (__first , __pivot)) 
++ __first ; 
-- __last ; 
while (__comp (__pivot , __last)) 
-- __last ; 
if (! (__first < __last)) 
return __first ; 
std :: iter_swap (__first , __last) ; 
++ __first ; 
} 
} 


template < typename _RandomAccessIterator , typename _Compare > 
inline _RandomAccessIterator 
__unguarded_partition_pivot (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
_RandomAccessIterator __mid = __first + (__last - __first) / 2 ; 
std :: __move_median_to_first (__first , __first + 1 , __mid , __last - 1 , 
__comp) ; 
return std :: __unguarded_partition (__first + 1 , __last , __first , __comp) ; 
} 

template < typename _RandomAccessIterator , typename _Compare > 
inline void 
__partial_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __middle , 
_RandomAccessIterator __last , 
_Compare __comp) 
{ 
std :: __heap_select (__first , __middle , __last , __comp) ; 
std :: __sort_heap (__first , __middle , __comp) ; 
} 


template < typename _RandomAccessIterator , typename _Size , typename _Compare > 
void 
__introsort_loop (_RandomAccessIterator __first , 
_RandomAccessIterator __last , 
_Size __depth_limit , _Compare __comp) 
{ 
while (__last - __first > int (_S_threshold)) 
{ 
if (__depth_limit == 0) 
{ 
std :: __partial_sort (__first , __last , __last , __comp) ; 
return ; 
} 
-- __depth_limit ; 
_RandomAccessIterator __cut = 
std :: __unguarded_partition_pivot (__first , __last , __comp) ; 
std :: __introsort_loop (__cut , __last , __depth_limit , __comp) ; 
__last = __cut ; 
} 
} 



template < typename _RandomAccessIterator , typename _Compare > 
inline void 
__sort (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
if (__first != __last) 
{ 
std :: __introsort_loop (__first , __last , 
std :: __lg (__last - __first) * 2 , 
__comp) ; 
std :: __final_insertion_sort (__first , __last , __comp) ; 
} 
} 

template < typename _RandomAccessIterator , typename _Size , typename _Compare > 
void 
__introselect (_RandomAccessIterator __first , _RandomAccessIterator __nth , 
_RandomAccessIterator __last , _Size __depth_limit , 
_Compare __comp) 
{ 
while (__last - __first > 3) 
{ 
if (__depth_limit == 0) 
{ 
std :: __heap_select (__first , __nth + 1 , __last , __comp) ; 

std :: iter_swap (__first , __nth) ; 
return ; 
} 
-- __depth_limit ; 
_RandomAccessIterator __cut = 
std :: __unguarded_partition_pivot (__first , __last , __comp) ; 
if (__cut <= __nth) 
__first = __cut ; 
else 
__last = __cut ; 
} 
std :: __insertion_sort (__first , __last , __comp) ; 
} 
# 2020 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp , typename _Compare > 
inline _ForwardIterator 
lower_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
# 2030
; 

return std :: __lower_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_comp_val (__comp)) ; 
} 

template < typename _ForwardIterator , typename _Tp , typename _Compare > 
_ForwardIterator 
__upper_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: difference_type 
_DistanceType ; 

_DistanceType __len = std :: distance (__first , __last) ; 

while (__len > 0) 
{ 
_DistanceType __half = __len >> 1 ; 
_ForwardIterator __middle = __first ; 
std :: advance (__middle , __half) ; 
if (__comp (__val , __middle)) 
__len = __half ; 
else 
{ 
__first = __middle ; 
++ __first ; 
__len = __len - __half - 1 ; 
} 
} 
return __first ; 
} 
# 2074 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline _ForwardIterator 
upper_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val) 
{ 




; 

return std :: __upper_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __val_less_iter ()) ; 
} 
# 2104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp , typename _Compare > 
inline _ForwardIterator 
upper_bound (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
# 2114
; 

return std :: __upper_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
} 

template < typename _ForwardIterator , typename _Tp , 
typename _CompareItTp , typename _CompareTpIt > 
pair < _ForwardIterator , _ForwardIterator > 
__equal_range (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , 
_CompareItTp __comp_it_val , _CompareTpIt __comp_val_it) 
{ 
typedef typename iterator_traits < _ForwardIterator > :: difference_type 
_DistanceType ; 

_DistanceType __len = std :: distance (__first , __last) ; 

while (__len > 0) 
{ 
_DistanceType __half = __len >> 1 ; 
_ForwardIterator __middle = __first ; 
std :: advance (__middle , __half) ; 
if (__comp_it_val (__middle , __val)) 
{ 
__first = __middle ; 
++ __first ; 
__len = __len - __half - 1 ; 
} 
else if (__comp_val_it (__val , __middle)) 
__len = __half ; 
else 
{ 
_ForwardIterator __left 
= std :: __lower_bound (__first , __middle , __val , __comp_it_val) ; 
std :: advance (__first , __len) ; 
_ForwardIterator __right 
= std :: __upper_bound (++ __middle , __first , __val , __comp_val_it) ; 
return pair < _ForwardIterator , _ForwardIterator > (__left , __right) ; 
} 
} 
return pair < _ForwardIterator , _ForwardIterator > (__first , __first) ; 
} 
# 2175 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp > 
inline pair < _ForwardIterator , _ForwardIterator > 
equal_range (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val) 
{ 
# 2186
; 
; 

return std :: __equal_range (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_less_val () , 
__gnu_cxx :: __ops :: __val_less_iter ()) ; 
} 
# 2211 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp , typename _Compare > 
inline pair < _ForwardIterator , _ForwardIterator > 
equal_range (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
# 2223
; 

; 

return std :: __equal_range (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_comp_val (__comp) , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
} 
# 2244 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp > 
bool 
binary_search (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val) 
{ 




; 
; 

_ForwardIterator __i 
= std :: __lower_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_less_val ()) ; 
return __i != __last && ! (__val < * __i) ; 
} 
# 2277 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp , typename _Compare > 
bool 
binary_search (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __val , _Compare __comp) 
{ 
# 2287
; 

; 

_ForwardIterator __i 
= std :: __lower_bound (__first , __last , __val , 
__gnu_cxx :: __ops :: __iter_comp_val (__comp)) ; 
return __i != __last && ! bool (__comp (__val , * __i)) ; 
} 




template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
void 
__move_merge_adaptive (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
{ 
if (__comp (__first2 , __first1)) 
{ 
* __result = std :: move (* __first2) ; 
++ __first2 ; 
} 
else 
{ 
* __result = std :: move (* __first1) ; 
++ __first1 ; 
} 
++ __result ; 
} 
if (__first1 != __last1) 
std :: move (__first1 , __last1 , __result) ; 
} 


template < typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , 
typename _BidirectionalIterator3 , typename _Compare > 
void 
__move_merge_adaptive_backward (_BidirectionalIterator1 __first1 , 
_BidirectionalIterator1 __last1 , 
_BidirectionalIterator2 __first2 , 
_BidirectionalIterator2 __last2 , 
_BidirectionalIterator3 __result , 
_Compare __comp) 
{ 
if (__first1 == __last1) 
{ 
std :: move_backward (__first2 , __last2 , __result) ; 
return ; 
} 
else if (__first2 == __last2) 
return ; 

-- __last1 ; 
-- __last2 ; 
while (true) 
{ 
if (__comp (__last2 , __last1)) 
{ 
* -- __result = std :: move (* __last1) ; 
if (__first1 == __last1) 
{ 
std :: move_backward (__first2 , ++ __last2 , __result) ; 
return ; 
} 
-- __last1 ; 
} 
else 
{ 
* -- __result = std :: move (* __last2) ; 
if (__first2 == __last2) 
return ; 
-- __last2 ; 
} 
} 
} 


template < typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , 
typename _Distance > 
_BidirectionalIterator1 
__rotate_adaptive (_BidirectionalIterator1 __first , 
_BidirectionalIterator1 __middle , 
_BidirectionalIterator1 __last , 
_Distance __len1 , _Distance __len2 , 
_BidirectionalIterator2 __buffer , 
_Distance __buffer_size) 
{ 
_BidirectionalIterator2 __buffer_end ; 
if (__len1 > __len2 && __len2 <= __buffer_size) 
{ 
if (__len2) 
{ 
__buffer_end = std :: move (__middle , __last , __buffer) ; 
std :: move_backward (__first , __middle , __last) ; 
return std :: move (__buffer , __buffer_end , __first) ; 
} 
else 
return __first ; 
} 
else if (__len1 <= __buffer_size) 
{ 
if (__len1) 
{ 
__buffer_end = std :: move (__first , __middle , __buffer) ; 
std :: move (__middle , __last , __first) ; 
return std :: move_backward (__buffer , __buffer_end , __last) ; 
} 
else 
return __last ; 
} 
else 
return std :: rotate (__first , __middle , __last) ; 
} 


template < typename _BidirectionalIterator , typename _Distance , 
typename _Pointer , typename _Compare > 
void 
__merge_adaptive (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last , 
_Distance __len1 , _Distance __len2 , 
_Pointer __buffer , _Distance __buffer_size , 
_Compare __comp) 
{ 
if (__len1 <= __len2 && __len1 <= __buffer_size) 
{ 
_Pointer __buffer_end = std :: move (__first , __middle , __buffer) ; 
std :: __move_merge_adaptive (__buffer , __buffer_end , __middle , __last , 
__first , __comp) ; 
} 
else if (__len2 <= __buffer_size) 
{ 
_Pointer __buffer_end = std :: move (__middle , __last , __buffer) ; 
std :: __move_merge_adaptive_backward (__first , __middle , __buffer , 
__buffer_end , __last , __comp) ; 
} 
else 
{ 
_BidirectionalIterator __first_cut = __first ; 
_BidirectionalIterator __second_cut = __middle ; 
_Distance __len11 = 0 ; 
_Distance __len22 = 0 ; 
if (__len1 > __len2) 
{ 
__len11 = __len1 / 2 ; 
std :: advance (__first_cut , __len11) ; 
__second_cut 
= std :: __lower_bound (__middle , __last , * __first_cut , 
__gnu_cxx :: __ops :: __iter_comp_val (__comp)) ; 
__len22 = std :: distance (__middle , __second_cut) ; 
} 
else 
{ 
__len22 = __len2 / 2 ; 
std :: advance (__second_cut , __len22) ; 
__first_cut 
= std :: __upper_bound (__first , __middle , * __second_cut , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
__len11 = std :: distance (__first , __first_cut) ; 
} 

_BidirectionalIterator __new_middle 
= std :: __rotate_adaptive (__first_cut , __middle , __second_cut , 
__len1 - __len11 , __len22 , __buffer , 
__buffer_size) ; 
std :: __merge_adaptive (__first , __first_cut , __new_middle , __len11 , 
__len22 , __buffer , __buffer_size , __comp) ; 
std :: __merge_adaptive (__new_middle , __second_cut , __last , 
__len1 - __len11 , 
__len2 - __len22 , __buffer , 
__buffer_size , __comp) ; 
} 
} 


template < typename _BidirectionalIterator , typename _Distance , 
typename _Compare > 
void 
__merge_without_buffer (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last , 
_Distance __len1 , _Distance __len2 , 
_Compare __comp) 
{ 
if (__len1 == 0 || __len2 == 0) 
return ; 

if (__len1 + __len2 == 2) 
{ 
if (__comp (__middle , __first)) 
std :: iter_swap (__first , __middle) ; 
return ; 
} 

_BidirectionalIterator __first_cut = __first ; 
_BidirectionalIterator __second_cut = __middle ; 
_Distance __len11 = 0 ; 
_Distance __len22 = 0 ; 
if (__len1 > __len2) 
{ 
__len11 = __len1 / 2 ; 
std :: advance (__first_cut , __len11) ; 
__second_cut 
= std :: __lower_bound (__middle , __last , * __first_cut , 
__gnu_cxx :: __ops :: __iter_comp_val (__comp)) ; 
__len22 = std :: distance (__middle , __second_cut) ; 
} 
else 
{ 
__len22 = __len2 / 2 ; 
std :: advance (__second_cut , __len22) ; 
__first_cut 
= std :: __upper_bound (__first , __middle , * __second_cut , 
__gnu_cxx :: __ops :: __val_comp_iter (__comp)) ; 
__len11 = std :: distance (__first , __first_cut) ; 
} 

_BidirectionalIterator __new_middle 
= std :: rotate (__first_cut , __middle , __second_cut) ; 
std :: __merge_without_buffer (__first , __first_cut , __new_middle , 
__len11 , __len22 , __comp) ; 
std :: __merge_without_buffer (__new_middle , __second_cut , __last , 
__len1 - __len11 , __len2 - __len22 , __comp) ; 
} 

template < typename _BidirectionalIterator , typename _Compare > 
void 
__inplace_merge (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last , 
_Compare __comp) 
{ 
typedef typename iterator_traits < _BidirectionalIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _BidirectionalIterator > :: difference_type 
_DistanceType ; 

if (__first == __middle || __middle == __last) 
return ; 

const _DistanceType __len1 = std :: distance (__first , __middle) ; 
const _DistanceType __len2 = std :: distance (__middle , __last) ; 

typedef _Temporary_buffer < _BidirectionalIterator , _ValueType > _TmpBuf ; 
_TmpBuf __buf (__first , __len1 + __len2) ; 

if (__buf . begin () == 0) 
std :: __merge_without_buffer 
(__first , __middle , __last , __len1 , __len2 , __comp) ; 
else 
std :: __merge_adaptive 
(__first , __middle , __last , __len1 , __len2 , __buf . begin () , 
_DistanceType (__buf . size ()) , __comp) ; 
} 
# 2566 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator > 
inline void 
inplace_merge (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last) 
{ 
# 2577
; 
; 
; 

std :: __inplace_merge (__first , __middle , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 2607 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator , typename _Compare > 
inline void 
inplace_merge (_BidirectionalIterator __first , 
_BidirectionalIterator __middle , 
_BidirectionalIterator __last , 
_Compare __comp) 
{ 
# 2620
; 
; 
; 

std :: __inplace_merge (__first , __middle , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 



template < typename _InputIterator , typename _OutputIterator , 
typename _Compare > 
_OutputIterator 
__move_merge (_InputIterator __first1 , _InputIterator __last1 , 
_InputIterator __first2 , _InputIterator __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
{ 
if (__comp (__first2 , __first1)) 
{ 
* __result = std :: move (* __first2) ; 
++ __first2 ; 
} 
else 
{ 
* __result = std :: move (* __first1) ; 
++ __first1 ; 
} 
++ __result ; 
} 
return std :: move (__first2 , __last2 , std :: move (__first1 , __last1 , __result)) 

; 
} 

template < typename _RandomAccessIterator1 , typename _RandomAccessIterator2 , 
typename _Distance , typename _Compare > 
void 
__merge_sort_loop (_RandomAccessIterator1 __first , 
_RandomAccessIterator1 __last , 
_RandomAccessIterator2 __result , _Distance __step_size , 
_Compare __comp) 
{ 
const _Distance __two_step = 2 * __step_size ; 

while (__last - __first >= __two_step) 
{ 
__result = std :: __move_merge (__first , __first + __step_size , 
__first + __step_size , 
__first + __two_step , 
__result , __comp) ; 
__first += __two_step ; 
} 
__step_size = std :: min (_Distance (__last - __first) , __step_size) ; 

std :: __move_merge (__first , __first + __step_size , 
__first + __step_size , __last , __result , __comp) ; 
} 

template < typename _RandomAccessIterator , typename _Distance , 
typename _Compare > 
void 
__chunk_insertion_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __last , 
_Distance __chunk_size , _Compare __comp) 
{ 
while (__last - __first >= __chunk_size) 
{ 
std :: __insertion_sort (__first , __first + __chunk_size , __comp) ; 
__first += __chunk_size ; 
} 
std :: __insertion_sort (__first , __last , __comp) ; 
} 

enum { _S_chunk_size = 7}; 

template < typename _RandomAccessIterator , typename _Pointer , typename _Compare > 
void 
__merge_sort_with_buffer (_RandomAccessIterator __first , 
_RandomAccessIterator __last , 
_Pointer __buffer , _Compare __comp) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_Distance ; 

const _Distance __len = __last - __first ; 
const _Pointer __buffer_last = __buffer + __len ; 

_Distance __step_size = _S_chunk_size ; 
std :: __chunk_insertion_sort (__first , __last , __step_size , __comp) ; 

while (__step_size < __len) 
{ 
std :: __merge_sort_loop (__first , __last , __buffer , 
__step_size , __comp) ; 
__step_size *= 2 ; 
std :: __merge_sort_loop (__buffer , __buffer_last , __first , 
__step_size , __comp) ; 
__step_size *= 2 ; 
} 
} 

template < typename _RandomAccessIterator , typename _Pointer , 
typename _Distance , typename _Compare > 
void 
__stable_sort_adaptive (_RandomAccessIterator __first , 
_RandomAccessIterator __last , 
_Pointer __buffer , _Distance __buffer_size , 
_Compare __comp) 
{ 
const _Distance __len = (__last - __first + 1) / 2 ; 
const _RandomAccessIterator __middle = __first + __len ; 
if (__len > __buffer_size) 
{ 
std :: __stable_sort_adaptive (__first , __middle , __buffer , 
__buffer_size , __comp) ; 
std :: __stable_sort_adaptive (__middle , __last , __buffer , 
__buffer_size , __comp) ; 
} 
else 
{ 
std :: __merge_sort_with_buffer (__first , __middle , __buffer , __comp) ; 
std :: __merge_sort_with_buffer (__middle , __last , __buffer , __comp) ; 
} 
std :: __merge_adaptive (__first , __middle , __last , 
_Distance (__middle - __first) , 
_Distance (__last - __middle) , 
__buffer , __buffer_size , 
__comp) ; 
} 


template < typename _RandomAccessIterator , typename _Compare > 
void 
__inplace_stable_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
if (__last - __first < 15) 
{ 
std :: __insertion_sort (__first , __last , __comp) ; 
return ; 
} 
_RandomAccessIterator __middle = __first + (__last - __first) / 2 ; 
std :: __inplace_stable_sort (__first , __middle , __comp) ; 
std :: __inplace_stable_sort (__middle , __last , __comp) ; 
std :: __merge_without_buffer (__first , __middle , __last , 
__middle - __first , 
__last - __middle , 
__comp) ; 
} 
# 2779 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _Compare > 
bool 
__includes (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
if (__comp (__first2 , __first1)) 
return false ; 
else if (__comp (__first1 , __first2)) 
++ __first1 ; 
else 
{ 
++ __first1 ; 
++ __first2 ; 
} 

return __first2 == __last2 ; 
} 
# 2818 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 > 
inline bool 
includes (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2) 
{ 
# 2832
; 
; 
; 
; 

return std :: __includes (__first1 , __last1 , __first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 2862 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _Compare > 
inline bool 
includes (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_Compare __comp) 
{ 
# 2878
; 
; 
; 
; 

return std :: __includes (__first1 , __last1 , __first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 2897 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator , typename _Compare > 
bool 
__next_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last , _Compare __comp) 
{ 
if (__first == __last) 
return false ; 
_BidirectionalIterator __i = __first ; 
++ __i ; 
if (__i == __last) 
return false ; 
__i = __last ; 
-- __i ; 

for (; ;) 
{ 
_BidirectionalIterator __ii = __i ; 
-- __i ; 
if (__comp (__i , __ii)) 
{ 
_BidirectionalIterator __j = __last ; 
while (! __comp (__i , -- __j)) 
{ } 
std :: iter_swap (__i , __j) ; 
std :: __reverse (__ii , __last , 
std :: __iterator_category (__first)) ; 
return true ; 
} 
if (__i == __first) 
{ 
std :: __reverse (__first , __last , 
std :: __iterator_category (__first)) ; 
return false ; 
} 
} 
} 
# 2946 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator > 
inline bool 
next_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last) 
{ 
# 2956
; 
; 

return std :: __next_permutation 
(__first , __last , __gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 2978 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator , typename _Compare > 
inline bool 
next_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last , _Compare __comp) 
{ 
# 2989
; 
; 

return std :: __next_permutation 
(__first , __last , __gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _BidirectionalIterator , typename _Compare > 
bool 
__prev_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last , _Compare __comp) 
{ 
if (__first == __last) 
return false ; 
_BidirectionalIterator __i = __first ; 
++ __i ; 
if (__i == __last) 
return false ; 
__i = __last ; 
-- __i ; 

for (; ;) 
{ 
_BidirectionalIterator __ii = __i ; 
-- __i ; 
if (__comp (__ii , __i)) 
{ 
_BidirectionalIterator __j = __last ; 
while (! __comp (-- __j , __i)) 
{ } 
std :: iter_swap (__i , __j) ; 
std :: __reverse (__ii , __last , 
std :: __iterator_category (__first)) ; 
return true ; 
} 
if (__i == __first) 
{ 
std :: __reverse (__first , __last , 
std :: __iterator_category (__first)) ; 
return false ; 
} 
} 
} 
# 3046 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator > 
inline bool 
prev_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last) 
{ 
# 3056
; 
; 

return std :: __prev_permutation (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 3078 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _BidirectionalIterator , typename _Compare > 
inline bool 
prev_permutation (_BidirectionalIterator __first , 
_BidirectionalIterator __last , _Compare __comp) 
{ 
# 3089
; 
; 

return std :: __prev_permutation (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 




template < typename _InputIterator , typename _OutputIterator , 
typename _Predicate , typename _Tp > 
_OutputIterator 
__replace_copy_if (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , 
_Predicate __pred , const _Tp & __new_value) 
{ 
for (; __first != __last ; ++ __first , (void) ++ __result) 
if (__pred (__first)) 
* __result = __new_value ; 
else 
* __result = * __first ; 
return __result ; 
} 
# 3128 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , typename _Tp > 
inline _OutputIterator 
replace_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , 
const _Tp & __old_value , const _Tp & __new_value) 
{ 
# 3140
; 

return std :: __replace_copy_if (__first , __last , __result , 
__gnu_cxx :: __ops :: __iter_equals_val (__old_value) , 
__new_value) ; 
} 
# 3162 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , 
typename _Predicate , typename _Tp > 
inline _OutputIterator 
replace_copy_if (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , 
_Predicate __pred , const _Tp & __new_value) 
{ 
# 3175
; 

return std :: __replace_copy_if (__first , __last , __result , 
__gnu_cxx :: __ops :: __pred_iter (__pred) , 
__new_value) ; 
} 

template < typename _InputIterator , typename _Predicate > 
typename iterator_traits < _InputIterator > :: difference_type 
__count_if (_InputIterator __first , _InputIterator __last , _Predicate __pred) 
{ 
typename iterator_traits < _InputIterator > :: difference_type __n = 0 ; 
for (; __first != __last ; ++ __first) 
if (__pred (__first)) 
++ __n ; 
return __n ; 
} 
# 3201 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 
inline bool 
is_sorted (_ForwardIterator __first , _ForwardIterator __last) 
{ return std :: is_sorted_until (__first , __last) == __last ; } 
# 3215 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Compare > 
inline bool 
is_sorted (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ return std :: is_sorted_until (__first , __last , __comp) == __last ; } 

template < typename _ForwardIterator , typename _Compare > 
_ForwardIterator 
__is_sorted_until (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
if (__first == __last) 
return __last ; 

_ForwardIterator __next = __first ; 
for (++ __next ; __next != __last ; __first = __next , (void) ++ __next) 
if (__comp (__next , __first)) 
return __next ; 
return __next ; 
} 
# 3244 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 
inline _ForwardIterator 
is_sorted_until (_ForwardIterator __first , _ForwardIterator __last) 
{ 




; 
; 

return std :: __is_sorted_until (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 3268 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Compare > 
inline _ForwardIterator 
is_sorted_until (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
# 3278
; 
; 

return std :: __is_sorted_until (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 3293 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _Tp > 

inline pair < const _Tp & , const _Tp & > 
minmax (const _Tp & __a , const _Tp & __b) 
{ 



return __b < __a ? pair < const _Tp & , const _Tp & > (__b , __a) 
: pair < const _Tp & , const _Tp & > (__a , __b) ; 
} 
# 3314 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _Tp , typename _Compare > 

inline pair < const _Tp & , const _Tp & > 
minmax (const _Tp & __a , const _Tp & __b , _Compare __comp) 
{ 
return __comp (__b , __a) ? pair < const _Tp & , const _Tp & > (__b , __a) 
: pair < const _Tp & , const _Tp & > (__a , __b) ; 
} 

template < typename _ForwardIterator , typename _Compare > 

pair < _ForwardIterator , _ForwardIterator > 
__minmax_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
_ForwardIterator __next = __first ; 
if (__first == __last 
|| ++ __next == __last) 
return std :: make_pair (__first , __first) ; 

_ForwardIterator __min { } , __max { } ; 
if (__comp (__next , __first)) 
{ 
__min = __next ; 
__max = __first ; 
} 
else 
{ 
__min = __first ; 
__max = __next ; 
} 

__first = __next ; 
++ __first ; 

while (__first != __last) 
{ 
__next = __first ; 
if (++ __next == __last) 
{ 
if (__comp (__first , __min)) 
__min = __first ; 
else if (! __comp (__first , __max)) 
__max = __first ; 
break ; 
} 

if (__comp (__next , __first)) 
{ 
if (__comp (__next , __min)) 
__min = __next ; 
if (! __comp (__first , __max)) 
__max = __first ; 
} 
else 
{ 
if (__comp (__first , __min)) 
__min = __first ; 
if (! __comp (__next , __max)) 
__max = __next ; 
} 

__first = __next ; 
++ __first ; 
} 

return std :: make_pair (__min , __max) ; 
} 
# 3394 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 

inline pair < _ForwardIterator , _ForwardIterator > 
minmax_element (_ForwardIterator __first , _ForwardIterator __last) 
{ 




; 
; 

return std :: __minmax_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 3422 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Compare > 

inline pair < _ForwardIterator , _ForwardIterator > 
minmax_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
# 3433
; 
; 

return std :: __minmax_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 


template < typename _Tp > 

inline _Tp 
min (initializer_list < _Tp > __l) 
{ return * std :: min_element (__l . begin () , __l . end ()) ; } 

template < typename _Tp , typename _Compare > 

inline _Tp 
min (initializer_list < _Tp > __l , _Compare __comp) 
{ return * std :: min_element (__l . begin () , __l . end () , __comp) ; } 

template < typename _Tp > 

inline _Tp 
max (initializer_list < _Tp > __l) 
{ return * std :: max_element (__l . begin () , __l . end ()) ; } 

template < typename _Tp , typename _Compare > 

inline _Tp 
max (initializer_list < _Tp > __l , _Compare __comp) 
{ return * std :: max_element (__l . begin () , __l . end () , __comp) ; } 

template < typename _Tp > 

inline pair < _Tp , _Tp > 
minmax (initializer_list < _Tp > __l) 
{ 
pair < const _Tp * , const _Tp * > __p = 
std :: minmax_element (__l . begin () , __l . end ()) ; 
return std :: make_pair (* __p . first , * __p . second) ; 
} 

template < typename _Tp , typename _Compare > 

inline pair < _Tp , _Tp > 
minmax (initializer_list < _Tp > __l , _Compare __comp) 
{ 
pair < const _Tp * , const _Tp * > __p = 
std :: minmax_element (__l . begin () , __l . end () , __comp) ; 
return std :: make_pair (* __p . first , * __p . second) ; 
} 

template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
bool 
__is_permutation (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _BinaryPredicate __pred) 
{ 


for (; __first1 != __last1 ; ++ __first1 , (void) ++ __first2) 
if (! __pred (__first1 , __first2)) 
break ; 

if (__first1 == __last1) 
return true ; 



_ForwardIterator2 __last2 = __first2 ; 
std :: advance (__last2 , std :: distance (__first1 , __last1)) ; 
for (_ForwardIterator1 __scan = __first1 ; __scan != __last1 ; ++ __scan) 
{ 
if (__scan != std :: __find_if (__first1 , __scan , 
__gnu_cxx :: __ops :: __iter_comp_iter (__pred , __scan))) 
continue ; 

auto __matches 
= std :: __count_if (__first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__pred , __scan)) ; 
if (0 == __matches || 
std :: __count_if (__scan , __last1 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__pred , __scan)) 
!= __matches) 
return false ; 
} 
return true ; 
} 
# 3534 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 > 
inline bool 
is_permutation (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2) 
{ 
# 3545
; 

return std :: __is_permutation (__first1 , __last1 , __first2 , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 3565 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
inline bool 
is_permutation (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _BinaryPredicate __pred) 
{ 
# 3577
; 

return std :: __is_permutation (__first1 , __last1 , __first2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__pred)) ; 
} 
# 3761 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _IntType , typename _UniformRandomBitGenerator > 
pair < _IntType , _IntType > 
__gen_two_uniform_ints (_IntType __b0 , _IntType __b1 , 
_UniformRandomBitGenerator && __g) 
{ 
_IntType __x 
= uniform_int_distribution < _IntType > { 0 , (__b0 * __b1) - 1 } (__g) ; 
return std :: make_pair (__x / __b1 , __x % __b1) ; 
} 
# 3783 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , 
typename _UniformRandomNumberGenerator > 
void 
shuffle (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_UniformRandomNumberGenerator && __g) 
{ 



; 

if (__first == __last) 
return ; 

typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 

typedef typename std :: make_unsigned < _DistanceType > :: type __ud_type ; 
typedef typename std :: uniform_int_distribution < __ud_type > __distr_type ; 
typedef typename __distr_type :: param_type __p_type ; 

typedef typename remove_reference < _UniformRandomNumberGenerator > :: type 
_Gen ; 
typedef typename common_type < typename _Gen :: result_type , __ud_type > :: type 
__uc_type ; 

const __uc_type __urngrange = __g . max () - __g . min () ; 
const __uc_type __urange = __uc_type (__last - __first) ; 

if (__urngrange / __urange >= __urange) 

{ 
_RandomAccessIterator __i = __first + 1 ; 
# 3821
if ((__urange % 2) == 0) 
{ 
__distr_type __d { 0 , 1 } ; 
std :: iter_swap (__i ++ , __first + __d (__g)) ; 
} 
# 3831
while (__i != __last) 
{ 
const __uc_type __swap_range = __uc_type (__i - __first) + 1 ; 

const pair < __uc_type , __uc_type > __pospos = 
__gen_two_uniform_ints (__swap_range , __swap_range + 1 , __g) ; 

std :: iter_swap (__i ++ , __first + __pospos . first) ; 
std :: iter_swap (__i ++ , __first + __pospos . second) ; 
} 

return ; 
} 

__distr_type __d ; 

for (_RandomAccessIterator __i = __first + 1 ; __i != __last ; ++ __i) 
std :: iter_swap (__i , __first + __d (__g , __p_type (0 , __i - __first))) ; 
} 
# 3868 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Function > 
_Function 
for_each (_InputIterator __first , _InputIterator __last , _Function __f) 
{ 


; 
for (; __first != __last ; ++ __first) 
__f (* __first) ; 
return __f ; 
} 
# 3889 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Tp > 
inline _InputIterator 
find (_InputIterator __first , _InputIterator __last , 
const _Tp & __val) 
{ 




; 
return std :: __find_if (__first , __last , 
__gnu_cxx :: __ops :: __iter_equals_val (__val)) ; 
} 
# 3913 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline _InputIterator 
find_if (_InputIterator __first , _InputIterator __last , 
_Predicate __pred) 
{ 




; 

return std :: __find_if (__first , __last , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 
# 3944 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _ForwardIterator > 
_InputIterator 
find_first_of (_InputIterator __first1 , _InputIterator __last1 , 
_ForwardIterator __first2 , _ForwardIterator __last2) 
{ 
# 3955
; 
; 

for (; __first1 != __last1 ; ++ __first1) 
for (_ForwardIterator __iter = __first2 ; __iter != __last2 ; ++ __iter) 
if (* __first1 == * __iter) 
return __first1 ; 
return __last1 ; 
} 
# 3984 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _ForwardIterator , 
typename _BinaryPredicate > 
_InputIterator 
find_first_of (_InputIterator __first1 , _InputIterator __last1 , 
_ForwardIterator __first2 , _ForwardIterator __last2 , 
_BinaryPredicate __comp) 
{ 
# 3997
; 
; 

for (; __first1 != __last1 ; ++ __first1) 
for (_ForwardIterator __iter = __first2 ; __iter != __last2 ; ++ __iter) 
if (__comp (* __first1 , * __iter)) 
return __first1 ; 
return __last1 ; 
} 
# 4016 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 
inline _ForwardIterator 
adjacent_find (_ForwardIterator __first , _ForwardIterator __last) 
{ 




; 

return std :: __adjacent_find (__first , __last , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 4041 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _BinaryPredicate > 
inline _ForwardIterator 
adjacent_find (_ForwardIterator __first , _ForwardIterator __last , 
_BinaryPredicate __binary_pred) 
{ 
# 4051
; 

return std :: __adjacent_find (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__binary_pred)) ; 
} 
# 4066 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Tp > 
inline typename iterator_traits < _InputIterator > :: difference_type 
count (_InputIterator __first , _InputIterator __last , const _Tp & __value) 
{ 




; 

return std :: __count_if (__first , __last , 
__gnu_cxx :: __ops :: __iter_equals_val (__value)) ; 
} 
# 4089 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _Predicate > 
inline typename iterator_traits < _InputIterator > :: difference_type 
count_if (_InputIterator __first , _InputIterator __last , _Predicate __pred) 
{ 




; 

return std :: __count_if (__first , __last , 
__gnu_cxx :: __ops :: __pred_iter (__pred)) ; 
} 
# 4129 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 > 
inline _ForwardIterator1 
search (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2) 
{ 
# 4140
; 
; 

return std :: __search (__first1 , __last1 , __first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_equal_to_iter ()) ; 
} 
# 4168 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator1 , typename _ForwardIterator2 , 
typename _BinaryPredicate > 
inline _ForwardIterator1 
search (_ForwardIterator1 __first1 , _ForwardIterator1 __last1 , 
_ForwardIterator2 __first2 , _ForwardIterator2 __last2 , 
_BinaryPredicate __predicate) 
{ 
# 4181
; 
; 

return std :: __search (__first1 , __last1 , __first2 , __last2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__predicate)) ; 
} 
# 4203 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Integer , typename _Tp > 
inline _ForwardIterator 
search_n (_ForwardIterator __first , _ForwardIterator __last , 
_Integer __count , const _Tp & __val) 
{ 




; 

return std :: __search_n (__first , __last , __count , 
__gnu_cxx :: __ops :: __iter_equals_val (__val)) ; 
} 
# 4236 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Integer , typename _Tp , 
typename _BinaryPredicate > 
inline _ForwardIterator 
search_n (_ForwardIterator __first , _ForwardIterator __last , 
_Integer __count , const _Tp & __val , 
_BinaryPredicate __binary_pred) 
{ 




; 

return std :: __search_n (__first , __last , __count , 
__gnu_cxx :: __ops :: __iter_comp_val (__binary_pred , __val)) ; 
} 
# 4284 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , 
typename _UnaryOperation > 
_OutputIterator 
transform (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , _UnaryOperation __unary_op) 
{ 
# 4295
; 

for (; __first != __last ; ++ __first , (void) ++ __result) 
* __result = __unary_op (* __first) ; 
return __result ; 
} 
# 4321 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _BinaryOperation > 
_OutputIterator 
transform (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _OutputIterator __result , 
_BinaryOperation __binary_op) 
{ 
# 4334
; 

for (; __first1 != __last1 ; ++ __first1 , (void) ++ __first2 , ++ __result) 
* __result = __binary_op (* __first1 , * __first2) ; 
return __result ; 
} 
# 4354 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Tp > 
void 
replace (_ForwardIterator __first , _ForwardIterator __last , 
const _Tp & __old_value , const _Tp & __new_value) 
{ 
# 4366
; 

for (; __first != __last ; ++ __first) 
if (* __first == __old_value) 
* __first = __new_value ; 
} 
# 4386 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Predicate , typename _Tp > 
void 
replace_if (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred , const _Tp & __new_value) 
{ 
# 4398
; 

for (; __first != __last ; ++ __first) 
if (__pred (* __first)) 
* __first = __new_value ; 
} 
# 4418 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Generator > 
void 
generate (_ForwardIterator __first , _ForwardIterator __last , 
_Generator __gen) 
{ 




; 

for (; __first != __last ; ++ __first) 
* __first = __gen () ; 
} 
# 4449 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _OutputIterator , typename _Size , typename _Generator > 
_OutputIterator 
generate_n (_OutputIterator __first , _Size __n , _Generator __gen) 
{ 
# 4458
for (__decltype (__n + 0) __niter = __n ; 
__niter > 0 ; -- __niter , (void) ++ __first) 
* __first = __gen () ; 
return __first ; 
} 
# 4485 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator > 
inline _OutputIterator 
unique_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result) 
{ 
# 4496
; 

if (__first == __last) 
return __result ; 
return std :: __unique_copy (__first , __last , __result , 
__gnu_cxx :: __ops :: __iter_equal_to_iter () , 
std :: __iterator_category (__first) , 
std :: __iterator_category (__result)) ; 
} 
# 4525 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator , typename _OutputIterator , 
typename _BinaryPredicate > 
inline _OutputIterator 
unique_copy (_InputIterator __first , _InputIterator __last , 
_OutputIterator __result , 
_BinaryPredicate __binary_pred) 
{ 




; 

if (__first == __last) 
return __result ; 
return std :: __unique_copy (__first , __last , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__binary_pred) , 
std :: __iterator_category (__first) , 
std :: __iterator_category (__result)) ; 
} 
# 4558 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator > 
inline void 
random_shuffle (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 



; 

if (__first != __last) 
for (_RandomAccessIterator __i = __first + 1 ; __i != __last ; ++ __i) 
{ 

_RandomAccessIterator __j = __first 
+ std :: rand () % ((__i - __first) + 1) ; 
if (__i != __j) 
std :: iter_swap (__i , __j) ; 
} 
} 
# 4593 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , typename _RandomNumberGenerator > 
void 
random_shuffle (_RandomAccessIterator __first , _RandomAccessIterator __last , 

_RandomNumberGenerator && __rand) 



{ 



; 

if (__first == __last) 
return ; 
for (_RandomAccessIterator __i = __first + 1 ; __i != __last ; ++ __i) 
{ 
_RandomAccessIterator __j = __first + __rand ((__i - __first) + 1) ; 
if (__i != __j) 
std :: iter_swap (__i , __j) ; 
} 
} 
# 4633 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Predicate > 
inline _ForwardIterator 
partition (_ForwardIterator __first , _ForwardIterator __last , 
_Predicate __pred) 
{ 
# 4643
; 

return std :: __partition (__first , __last , __pred , 
std :: __iterator_category (__first)) ; 
} 
# 4666 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator > 
inline void 
partial_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __middle , 
_RandomAccessIterator __last) 
{ 
# 4677
; 
; 
; 

std :: __partial_sort (__first , __middle , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 4704 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
partial_sort (_RandomAccessIterator __first , 
_RandomAccessIterator __middle , 
_RandomAccessIterator __last , 
_Compare __comp) 
{ 
# 4717
; 
; 
; 

std :: __partial_sort (__first , __middle , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 4740 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator > 
inline void 
nth_element (_RandomAccessIterator __first , _RandomAccessIterator __nth , 
_RandomAccessIterator __last) 
{ 
# 4750
; 
; 
; 

if (__first == __last || __nth == __last) 
return ; 

std :: __introselect (__first , __nth , __last , 
std :: __lg (__last - __first) * 2 , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 4779 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
nth_element (_RandomAccessIterator __first , _RandomAccessIterator __nth , 
_RandomAccessIterator __last , _Compare __comp) 
{ 
# 4790
; 
; 
; 

if (__first == __last || __nth == __last) 
return ; 

std :: __introselect (__first , __nth , __last , 
std :: __lg (__last - __first) * 2 , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 4816 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator > 
inline void 
sort (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 4825
; 
; 

std :: __sort (__first , __last , __gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 4846 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
sort (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
# 4857
; 
; 

std :: __sort (__first , __last , __gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
_OutputIterator 
__merge (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
{ 
if (__comp (__first2 , __first1)) 
{ 
* __result = * __first2 ; 
++ __first2 ; 
} 
else 
{ 
* __result = * __first1 ; 
++ __first1 ; 
} 
++ __result ; 
} 
return std :: copy (__first2 , __last2 , 
std :: copy (__first1 , __last1 , __result)) ; 
} 
# 4907 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator > 
inline _OutputIterator 
merge (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result) 
{ 
# 4924
; 
; 
; 
; 

return std :: __merge (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 4957 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
inline _OutputIterator 
merge (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
# 4974
; 
; 
; 
; 

return std :: __merge (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _RandomAccessIterator , typename _Compare > 
inline void 
__stable_sort (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
typedef typename iterator_traits < _RandomAccessIterator > :: value_type 
_ValueType ; 
typedef typename iterator_traits < _RandomAccessIterator > :: difference_type 
_DistanceType ; 

typedef _Temporary_buffer < _RandomAccessIterator , _ValueType > _TmpBuf ; 
_TmpBuf __buf (__first , std :: distance (__first , __last)) ; 

if (__buf . begin () == 0) 
std :: __inplace_stable_sort (__first , __last , __comp) ; 
else 
std :: __stable_sort_adaptive (__first , __last , __buf . begin () , 
_DistanceType (__buf . size ()) , __comp) ; 
} 
# 5021 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator > 
inline void 
stable_sort (_RandomAccessIterator __first , _RandomAccessIterator __last) 
{ 
# 5030
; 
; 

std :: __stable_sort (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5055 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _RandomAccessIterator , typename _Compare > 
inline void 
stable_sort (_RandomAccessIterator __first , _RandomAccessIterator __last , 
_Compare __comp) 
{ 
# 5066
; 
; 

std :: __stable_sort (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , 
typename _Compare > 
_OutputIterator 
__set_union (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
{ 
if (__comp (__first1 , __first2)) 
{ 
* __result = * __first1 ; 
++ __first1 ; 
} 
else if (__comp (__first2 , __first1)) 
{ 
* __result = * __first2 ; 
++ __first2 ; 
} 
else 
{ 
* __result = * __first1 ; 
++ __first1 ; 
++ __first2 ; 
} 
++ __result ; 
} 
return std :: copy (__first2 , __last2 , 
std :: copy (__first1 , __last1 , __result)) ; 
} 
# 5124 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator > 
inline _OutputIterator 
set_union (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result) 
{ 
# 5144
; 
; 
; 
; 

return std :: __set_union (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5174 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
inline _OutputIterator 
set_union (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
# 5194
; 
; 
; 
; 

return std :: __set_union (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , 
typename _Compare > 
_OutputIterator 
__set_intersection (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
if (__comp (__first1 , __first2)) 
++ __first1 ; 
else if (__comp (__first2 , __first1)) 
++ __first2 ; 
else 
{ 
* __result = * __first1 ; 
++ __first1 ; 
++ __first2 ; 
++ __result ; 
} 
return __result ; 
} 
# 5245 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator > 
inline _OutputIterator 
set_intersection (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result) 
{ 
# 5263
; 
; 
; 
; 

return std :: __set_intersection (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5294 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
inline _OutputIterator 
set_intersection (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
# 5312
; 
; 
; 
; 

return std :: __set_intersection (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , 
typename _Compare > 
_OutputIterator 
__set_difference (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
if (__comp (__first1 , __first2)) 
{ 
* __result = * __first1 ; 
++ __first1 ; 
++ __result ; 
} 
else if (__comp (__first2 , __first1)) 
++ __first2 ; 
else 
{ 
++ __first1 ; 
++ __first2 ; 
} 
return std :: copy (__first1 , __last1 , __result) ; 
} 
# 5367 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator > 
inline _OutputIterator 
set_difference (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result) 
{ 
# 5385
; 
; 
; 
; 

return std :: __set_difference (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5418 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
inline _OutputIterator 
set_difference (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , _Compare __comp) 
{ 
# 5436
; 
; 
; 
; 

return std :: __set_difference (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , 
typename _Compare > 
_OutputIterator 
__set_symmetric_difference (_InputIterator1 __first1 , 
_InputIterator1 __last1 , 
_InputIterator2 __first2 , 
_InputIterator2 __last2 , 
_OutputIterator __result , 
_Compare __comp) 
{ 
while (__first1 != __last1 && __first2 != __last2) 
if (__comp (__first1 , __first2)) 
{ 
* __result = * __first1 ; 
++ __first1 ; 
++ __result ; 
} 
else if (__comp (__first2 , __first1)) 
{ 
* __result = * __first2 ; 
++ __first2 ; 
++ __result ; 
} 
else 
{ 
++ __first1 ; 
++ __first2 ; 
} 
return std :: copy (__first2 , __last2 , 
std :: copy (__first1 , __last1 , __result)) ; 
} 
# 5497 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator > 
inline _OutputIterator 
set_symmetric_difference (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result) 
{ 
# 5517
; 
; 
; 
; 

return std :: __set_symmetric_difference (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5548 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _InputIterator1 , typename _InputIterator2 , 
typename _OutputIterator , typename _Compare > 
inline _OutputIterator 
set_symmetric_difference (_InputIterator1 __first1 , _InputIterator1 __last1 , 
_InputIterator2 __first2 , _InputIterator2 __last2 , 
_OutputIterator __result , 
_Compare __comp) 
{ 
# 5569
; 
; 
; 
; 

return std :: __set_symmetric_difference (__first1 , __last1 , 
__first2 , __last2 , __result , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _ForwardIterator , typename _Compare > 

_ForwardIterator 
__min_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
if (__first == __last) 
return __first ; 
_ForwardIterator __result = __first ; 
while (++ __first != __last) 
if (__comp (__first , __result)) 
__result = __first ; 
return __result ; 
} 
# 5601 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 

_ForwardIterator 
inline min_element (_ForwardIterator __first , _ForwardIterator __last) 
{ 




; 
; 

return std :: __min_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5626 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Compare > 

inline _ForwardIterator 
min_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
# 5637
; 
; 

return std :: __min_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 

template < typename _ForwardIterator , typename _Compare > 

_ForwardIterator 
__max_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
if (__first == __last) return __first ; 
_ForwardIterator __result = __first ; 
while (++ __first != __last) 
if (__comp (__result , __first)) 
__result = __first ; 
return __result ; 
} 
# 5665 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator > 

inline _ForwardIterator 
max_element (_ForwardIterator __first , _ForwardIterator __last) 
{ 




; 
; 

return std :: __max_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_less_iter ()) ; 
} 
# 5690 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
template < typename _ForwardIterator , typename _Compare > 

inline _ForwardIterator 
max_element (_ForwardIterator __first , _ForwardIterator __last , 
_Compare __comp) 
{ 
# 5701
; 
; 

return std :: __max_element (__first , __last , 
__gnu_cxx :: __ops :: __iter_comp_iter (__comp)) ; 
} 
# 5835 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_algo.h" 3
}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
namespace std { 
# 57 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT , typename _Traits > 
class basic_istream : virtual public basic_ios < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef typename _Traits :: pos_type pos_type ; 
typedef typename _Traits :: off_type off_type ; 
typedef _Traits traits_type ; 


typedef basic_streambuf < _CharT , _Traits > __streambuf_type ; 
typedef basic_ios < _CharT , _Traits > __ios_type ; 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef num_get < _CharT , istreambuf_iterator < _CharT , _Traits > > 
__num_get_type ; 
typedef ctype < _CharT > __ctype_type ; 

protected : 
# 82
streamsize _M_gcount ; 

public : 
# 92
explicit 
basic_istream (__streambuf_type * __sb) 
: _M_gcount (streamsize (0)) 
{ this -> init (__sb) ; } 
# 102
virtual 
~ basic_istream () 
{ _M_gcount = streamsize (0) ; } 


class sentry ; 
friend class sentry ; 
# 119 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
operator >> (__istream_type & (* __pf) (__istream_type &)) 
{ return __pf (* this) ; } 

__istream_type & 
operator >> (__ios_type & (* __pf) (__ios_type &)) 
{ 
__pf (* this) ; 
return * this ; 
} 

__istream_type & 
operator >> (ios_base & (* __pf) (ios_base &)) 
{ 
__pf (* this) ; 
return * this ; 
} 
# 167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
operator >> (bool & __n) 
{ return _M_extract (__n) ; } 

__istream_type & 
operator >> (short & __n) ; 

__istream_type & 
operator >> (unsigned short & __n) 
{ return _M_extract (__n) ; } 

__istream_type & 
operator >> (int & __n) ; 

__istream_type & 
operator >> (unsigned int & __n) 
{ return _M_extract (__n) ; } 

__istream_type & 
operator >> (long & __n) 
{ return _M_extract (__n) ; } 

__istream_type & 
operator >> (unsigned long & __n) 
{ return _M_extract (__n) ; } 


__istream_type & 
operator >> (long long & __n) 
{ return _M_extract (__n) ; } 

__istream_type & 
operator >> (unsigned long long & __n) 
{ return _M_extract (__n) ; } 
# 213 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
operator >> (float & __f) 
{ return _M_extract (__f) ; } 

__istream_type & 
operator >> (double & __f) 
{ return _M_extract (__f) ; } 

__istream_type & 
operator >> (long double & __f) 
{ return _M_extract (__f) ; } 
# 234 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
operator >> (void * & __p) 
{ return _M_extract (__p) ; } 
# 258 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
operator >> (__streambuf_type * __sb) ; 
# 268 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
streamsize 
gcount () const 
{ return _M_gcount ; } 
# 301 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
int_type 
get () ; 
# 315 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
get (char_type & __c) ; 
# 342 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
get (char_type * __s , streamsize __n , char_type __delim) ; 
# 353 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
get (char_type * __s , streamsize __n) 
{ return this -> get (__s , __n , this -> widen ('\n')) ; } 
# 376 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
get (__streambuf_type & __sb , char_type __delim) ; 
# 386 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
get (__streambuf_type & __sb) 
{ return this -> get (__sb , this -> widen ('\n')) ; } 
# 415 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
getline (char_type * __s , streamsize __n , char_type __delim) ; 
# 426 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
getline (char_type * __s , streamsize __n) 
{ return this -> getline (__s , __n , this -> widen ('\n')) ; } 
# 450 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
ignore (streamsize __n , int_type __delim) ; 

__istream_type & 
ignore (streamsize __n) ; 

__istream_type & 
ignore () ; 
# 467 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
int_type 
peek () ; 
# 485 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
read (char_type * __s , streamsize __n) ; 
# 504 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
streamsize 
readsome (char_type * __s , streamsize __n) ; 
# 521 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
putback (char_type __c) ; 
# 537 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
unget () ; 
# 555 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
int 
sync () ; 
# 570 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
pos_type 
tellg () ; 
# 585 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
seekg (pos_type) ; 
# 601 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
__istream_type & 
seekg (off_type , ios_base :: seekdir) ; 


protected : 
basic_istream () 
: _M_gcount (streamsize (0)) 
{ this -> init (0) ; } 


basic_istream (const basic_istream &) = delete ; 

basic_istream (basic_istream && __rhs) 
: __ios_type () , _M_gcount (__rhs . _M_gcount) 
{ 
__ios_type :: move (__rhs) ; 
__rhs . _M_gcount = 0 ; 
} 



basic_istream & operator = (const basic_istream &) = delete ; 

basic_istream & 
operator = (basic_istream && __rhs) 
{ 
swap (__rhs) ; 
return * this ; 
} 

void 
swap (basic_istream & __rhs) 
{ 
__ios_type :: swap (__rhs) ; 
std :: swap (_M_gcount , __rhs . _M_gcount) ; 
} 


template < typename _ValueT > 
__istream_type & 
_M_extract (_ValueT & __v) ; 
} ;
# 648
template<> basic_istream< char>  &basic_istream< char> ::getline(char_type * __s, streamsize __n, char_type __delim); 




template<> basic_istream< char>  &basic_istream< char> ::ignore(streamsize __n); 




template<> basic_istream< char>  &basic_istream< char> ::ignore(streamsize __n, int_type __delim); 
# 664
template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::getline(char_type * __s, streamsize __n, char_type __delim); 




template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::ignore(streamsize __n); 




template<> basic_istream< wchar_t>  &basic_istream< wchar_t> ::ignore(streamsize __n, int_type __delim); 
# 685 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT, typename _Traits >
    class basic_istream < _CharT, _Traits > :: sentry
    {

      bool _M_ok;

    public :

      typedef _Traits traits_type;
      typedef basic_streambuf < _CharT, _Traits > __streambuf_type;
      typedef basic_istream < _CharT, _Traits > __istream_type;
      typedef typename __istream_type :: __ctype_type __ctype_type;
      typedef typename _Traits :: int_type __int_type;

      explicit
      sentry ( basic_istream < _CharT, _Traits > & __is, bool __noskipws = false );

      explicit

      operator bool ( ) const
      { return _M_ok; }
    };
# 750 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT & __c );

template < class _Traits > 
inline basic_istream < char , _Traits > & 
operator >> (basic_istream < char , _Traits > & __in , unsigned char & __c) 
{ return (__in >> reinterpret_cast < char & > (__c)) ; } 

template < class _Traits > 
inline basic_istream < char , _Traits > & 
operator >> (basic_istream < char , _Traits > & __in , signed char & __c) 
{ return (__in >> reinterpret_cast < char & > (__c)) ; } 
# 792 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    operator >> ( basic_istream < _CharT, _Traits > & __in, _CharT * __s );




template<> basic_istream< char>  &operator>>(basic_istream< char>  & __in, char * __s); 

template < class _Traits > 
inline basic_istream < char , _Traits > & 
operator >> (basic_istream < char , _Traits > & __in , unsigned char * __s) 
{ return (__in >> reinterpret_cast < char * > (__s)) ; } 

template < class _Traits > 
inline basic_istream < char , _Traits > & 
operator >> (basic_istream < char , _Traits > & __in , signed char * __s) 
{ return (__in >> reinterpret_cast < char * > (__s)) ; } 
# 823 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT , typename _Traits > 
class basic_iostream 
: public basic_istream < _CharT , _Traits > , 
public basic_ostream < _CharT , _Traits > 
{ 
public : 



typedef _CharT char_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef typename _Traits :: pos_type pos_type ; 
typedef typename _Traits :: off_type off_type ; 
typedef _Traits traits_type ; 


typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef basic_ostream < _CharT , _Traits > __ostream_type ; 
# 848
explicit 
basic_iostream (basic_streambuf < _CharT , _Traits > * __sb) 
: __istream_type (__sb) , __ostream_type (__sb) { } 




virtual 
~ basic_iostream () { } 

protected : 
basic_iostream () 
: __istream_type () , __ostream_type () { } 


basic_iostream (const basic_iostream &) = delete ; 

basic_iostream (basic_iostream && __rhs) 
: __istream_type (std :: move (__rhs)) , __ostream_type (* this) 
{ } 



basic_iostream & operator = (const basic_iostream &) = delete ; 

basic_iostream & 
operator = (basic_iostream && __rhs) 
{ 
swap (__rhs) ; 
return * this ; 
} 

void 
swap (basic_iostream & __rhs) 
{ __istream_type :: swap (__rhs) ; } 

} ;
# 906 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _CharT, typename _Traits >
    basic_istream < _CharT, _Traits > &
    ws ( basic_istream < _CharT, _Traits > & __is );


template < typename _Ch, typename _Up >
    basic_istream < _Ch, _Up > &
    __is_convertible_to_basic_istream_test ( basic_istream < _Ch, _Up > * );

template < typename _Tp , typename = void > 
struct __is_convertible_to_basic_istream_impl 
{ 
using __istream_type = void ; 
} ;

template < typename _Tp >
    using __do_is_convertible_to_basic_istream_impl =
    __decltype ( __is_convertible_to_basic_istream_test
      ( declval < typename remove_reference < _Tp > :: type * > ( ) ) );

template < typename _Tp > 
struct __is_convertible_to_basic_istream_impl 
< _Tp , 
__void_t < __do_is_convertible_to_basic_istream_impl < _Tp > > > 
{ 
using __istream_type = 
__do_is_convertible_to_basic_istream_impl < _Tp > ; 
} ;

template < typename _Tp > 
struct __is_convertible_to_basic_istream 
: __is_convertible_to_basic_istream_impl < _Tp > 
{ 
public : 
using type = __not_ < is_void < 
typename __is_convertible_to_basic_istream_impl < _Tp > :: __istream_type > > ; 
constexpr static bool value = type :: value ; 
} ;

template < typename _Istream , typename _Tp , typename = void > 
struct __is_extractable : false_type { } ;

template < typename _Istream , typename _Tp > 
struct __is_extractable < _Istream , _Tp , 
__void_t < decltype (declval < _Istream & > () 
>> declval < _Tp > ()) > > 
: true_type { } ;

template < typename _Istream >
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream <
 _Istream > :: __istream_type;
# 972 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\istream" 3
template < typename _Istream , typename _Tp > 
inline 
typename enable_if < __and_ < __not_ < is_lvalue_reference < _Istream > > , 
__is_convertible_to_basic_istream < _Istream > , 
__is_extractable < 
__rvalue_istream_type < _Istream > , 
_Tp && > > :: value , 
__rvalue_istream_type < _Istream > > :: type 
operator >> (_Istream && __is , _Tp && __x) 
{ 
__rvalue_istream_type < _Istream > __ret_is = __is ; 
__ret_is >> std :: forward < _Tp > (__x) ; 
return __ret_is ; 
} 



}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\istream.tcc" 3
namespace std { 



template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > :: sentry :: 
sentry (basic_istream < _CharT , _Traits > & __in , bool __noskip) : _M_ok (false) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
if (__in . good ()) 
try 
{ 
if (__in . tie ()) 
__in . tie () -> flush () ; 
if (! __noskip && bool (__in . flags () & ios_base :: skipws)) 
{ 
const __int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = __in . rdbuf () ; 
__int_type __c = __sb -> sgetc () ; 

const __ctype_type & __ct = __check_facet (__in . _M_ctype) ; 
while (! traits_type :: eq_int_type (__c , __eof) 
&& __ct . is (ctype_base :: space , 
traits_type :: to_char_type (__c))) 
__c = __sb -> snextc () ; 




if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__in . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __in . _M_setstate (ios_base :: badbit) ; } 

if (__in . good () && __err == ios_base :: goodbit) 
_M_ok = true ; 
else 
{ 
__err |= ios_base :: failbit ; 
__in . setstate (__err) ; 
} 
} 

template < typename _CharT , typename _Traits > 
template < typename _ValueT > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
_M_extract (_ValueT & __v) 
{ 
sentry __cerb (* this , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const __num_get_type & __ng = __check_facet (this -> _M_num_get) ; 
__ng . get (* this , 0 , * this , __err , __v) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
operator >> (short & __n) 
{ 


sentry __cerb (* this , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
long __l ; 
const __num_get_type & __ng = __check_facet (this -> _M_num_get) ; 
__ng . get (* this , 0 , * this , __err , __l) ; 



if (__l < __gnu_cxx :: __numeric_traits < short > :: __min) 
{ 
__err |= ios_base :: failbit ; 
__n = __gnu_cxx :: __numeric_traits < short > :: __min ; 
} 
else if (__l > __gnu_cxx :: __numeric_traits < short > :: __max) 
{ 
__err |= ios_base :: failbit ; 
__n = __gnu_cxx :: __numeric_traits < short > :: __max ; 
} 
else 
__n = short (__l) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
operator >> (int & __n) 
{ 


sentry __cerb (* this , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
long __l ; 
const __num_get_type & __ng = __check_facet (this -> _M_num_get) ; 
__ng . get (* this , 0 , * this , __err , __l) ; 



if (__l < __gnu_cxx :: __numeric_traits < int > :: __min) 
{ 
__err |= ios_base :: failbit ; 
__n = __gnu_cxx :: __numeric_traits < int > :: __min ; 
} 
else if (__l > __gnu_cxx :: __numeric_traits < int > :: __max) 
{ 
__err |= ios_base :: failbit ; 
__n = __gnu_cxx :: __numeric_traits < int > :: __max ; 
} 
else 
__n = int (__l) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
operator >> (__streambuf_type * __sbout) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , false) ; 
if (__cerb && __sbout) 
{ 
try 
{ 
bool __ineof ; 
if (! __copy_streambufs_eof (this -> rdbuf () , __sbout , __ineof)) 
__err |= ios_base :: failbit ; 
if (__ineof) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: failbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: failbit) ; } 
} 
else if (! __sbout) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_istream < _CharT , _Traits > :: int_type 
basic_istream < _CharT , _Traits > :: 
get (void) 
{ 
const int_type __eof = traits_type :: eof () ; 
int_type __c = __eof ; 
_M_gcount = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
__c = this -> rdbuf () -> sbumpc () ; 

if (! traits_type :: eq_int_type (__c , __eof)) 
_M_gcount = 1 ; 
else 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 
if (! _M_gcount) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return __c ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
get (char_type & __c) 
{ 
_M_gcount = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
const int_type __cb = this -> rdbuf () -> sbumpc () ; 

if (! traits_type :: eq_int_type (__cb , traits_type :: eof ())) 
{ 
_M_gcount = 1 ; 
__c = traits_type :: to_char_type (__cb) ; 
} 
else 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 
if (! _M_gcount) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
get (char_type * __s , streamsize __n , char_type __delim) 
{ 
_M_gcount = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
const int_type __idelim = traits_type :: to_int_type (__delim) ; 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
int_type __c = __sb -> sgetc () ; 

while (_M_gcount + 1 < __n 
&& ! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __idelim)) 
{ 
* __s ++ = traits_type :: to_char_type (__c) ; 
++ _M_gcount ; 
__c = __sb -> snextc () ; 
} 
if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 


if (__n > 0) 
* __s = char_type () ; 
if (! _M_gcount) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
get (__streambuf_type & __sb , char_type __delim) 
{ 
_M_gcount = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
const int_type __idelim = traits_type :: to_int_type (__delim) ; 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __this_sb = this -> rdbuf () ; 
int_type __c = __this_sb -> sgetc () ; 
char_type __c2 = traits_type :: to_char_type (__c) ; 

while (! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __idelim) 
&& ! traits_type :: eq_int_type (__sb . sputc (__c2) , __eof)) 
{ 
++ _M_gcount ; 
__c = __this_sb -> snextc () ; 
__c2 = traits_type :: to_char_type (__c) ; 
} 
if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 
if (! _M_gcount) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
getline (char_type * __s , streamsize __n , char_type __delim) 
{ 
_M_gcount = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
const int_type __idelim = traits_type :: to_int_type (__delim) ; 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
int_type __c = __sb -> sgetc () ; 

while (_M_gcount + 1 < __n 
&& ! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __idelim)) 
{ 
* __s ++ = traits_type :: to_char_type (__c) ; 
__c = __sb -> snextc () ; 
++ _M_gcount ; 
} 
if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
else 
{ 
if (traits_type :: eq_int_type (__c , __idelim)) 
{ 
__sb -> sbumpc () ; 
++ _M_gcount ; 
} 
else 
__err |= ios_base :: failbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 


if (__n > 0) 
* __s = char_type () ; 
if (! _M_gcount) 
__err |= ios_base :: failbit ; 
if (__err) 
this -> setstate (__err) ; 
return * this ; 
} 




template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
ignore (void) 
{ 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 

if (traits_type :: eq_int_type (__sb -> sbumpc () , __eof)) 
__err |= ios_base :: eofbit ; 
else 
_M_gcount = 1 ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
ignore (streamsize __n) 
{ 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb && __n > 0) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
int_type __c = __sb -> sgetc () ; 
# 521 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\istream.tcc" 3
bool __large_ignore = false ; 
while (true) 
{ 
while (_M_gcount < __n 
&& ! traits_type :: eq_int_type (__c , __eof)) 
{ 
++ _M_gcount ; 
__c = __sb -> snextc () ; 
} 
if (__n == __gnu_cxx :: __numeric_traits < streamsize > :: __max 
&& ! traits_type :: eq_int_type (__c , __eof)) 
{ 
_M_gcount = 
__gnu_cxx :: __numeric_traits < streamsize > :: __min ; 
__large_ignore = true ; 
} 
else 
break ; 
} 

if (__large_ignore) 
_M_gcount = __gnu_cxx :: __numeric_traits < streamsize > :: __max ; 

if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
ignore (streamsize __n , int_type __delim) 
{ 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb && __n > 0) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
int_type __c = __sb -> sgetc () ; 


bool __large_ignore = false ; 
while (true) 
{ 
while (_M_gcount < __n 
&& ! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __delim)) 
{ 
++ _M_gcount ; 
__c = __sb -> snextc () ; 
} 
if (__n == __gnu_cxx :: __numeric_traits < streamsize > :: __max 
&& ! traits_type :: eq_int_type (__c , __eof) 
&& ! traits_type :: eq_int_type (__c , __delim)) 
{ 
_M_gcount = 
__gnu_cxx :: __numeric_traits < streamsize > :: __min ; 
__large_ignore = true ; 
} 
else 
break ; 
} 

if (__large_ignore) 
_M_gcount = __gnu_cxx :: __numeric_traits < streamsize > :: __max ; 

if (traits_type :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 
else if (traits_type :: eq_int_type (__c , __delim)) 
{ 
if (_M_gcount 
< __gnu_cxx :: __numeric_traits < streamsize > :: __max) 
++ _M_gcount ; 
__sb -> sbumpc () ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_istream < _CharT , _Traits > :: int_type 
basic_istream < _CharT , _Traits > :: 
peek (void) 
{ 
int_type __c = traits_type :: eof () ; 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
__c = this -> rdbuf () -> sgetc () ; 
if (traits_type :: eq_int_type (__c , traits_type :: eof ())) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return __c ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
read (char_type * __s , streamsize __n) 
{ 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
_M_gcount = this -> rdbuf () -> sgetn (__s , __n) ; 
if (_M_gcount != __n) 
__err |= (ios_base :: eofbit | ios_base :: failbit) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
streamsize 
basic_istream < _CharT , _Traits > :: 
readsome (char_type * __s , streamsize __n) 
{ 
_M_gcount = 0 ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 

const streamsize __num = this -> rdbuf () -> in_avail () ; 
if (__num > 0) 
_M_gcount = this -> rdbuf () -> sgetn (__s , std :: min (__num , __n)) ; 
else if (__num == - 1) 
__err |= ios_base :: eofbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return _M_gcount ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
putback (char_type __c) 
{ 


_M_gcount = 0 ; 

this -> clear (this -> rdstate () & ~ ios_base :: eofbit) ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
if (! __sb 
|| traits_type :: eq_int_type (__sb -> sputbackc (__c) , __eof)) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
unget (void) 
{ 


_M_gcount = 0 ; 

this -> clear (this -> rdstate () & ~ ios_base :: eofbit) ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const int_type __eof = traits_type :: eof () ; 
__streambuf_type * __sb = this -> rdbuf () ; 
if (! __sb 
|| traits_type :: eq_int_type (__sb -> sungetc () , __eof)) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
int 
basic_istream < _CharT , _Traits > :: 
sync (void) 
{ 


int __ret = - 1 ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
__streambuf_type * __sb = this -> rdbuf () ; 
if (__sb) 
{ 
if (__sb -> pubsync () == - 1) 
__err |= ios_base :: badbit ; 
else 
__ret = 0 ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_istream < _CharT , _Traits > :: pos_type 
basic_istream < _CharT , _Traits > :: 
tellg (void) 
{ 


pos_type __ret = pos_type (- 1) ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
try 
{ 
if (! this -> fail ()) 
__ret = this -> rdbuf () -> pubseekoff (0 , ios_base :: cur , 
ios_base :: in) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
seekg (pos_type __pos) 
{ 



this -> clear (this -> rdstate () & ~ ios_base :: eofbit) ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
if (! this -> fail ()) 
{ 

const pos_type __p = this -> rdbuf () -> pubseekpos (__pos , 
ios_base :: in) ; 


if (__p == pos_type (off_type (- 1))) 
__err |= ios_base :: failbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
basic_istream < _CharT , _Traits > :: 
seekg (off_type __off , ios_base :: seekdir __dir) 
{ 



this -> clear (this -> rdstate () & ~ ios_base :: eofbit) ; 
sentry __cerb (* this , true) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
if (! this -> fail ()) 
{ 

const pos_type __p = this -> rdbuf () -> pubseekoff (__off , __dir , 
ios_base :: in) ; 


if (__p == pos_type (off_type (- 1))) 
__err |= ios_base :: failbit ; 
} 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
this -> _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ this -> _M_setstate (ios_base :: badbit) ; } 
if (__err) 
this -> setstate (__err) ; 
} 
return * this ; 
} 


template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __in , _CharT & __c) 
{ 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef typename __istream_type :: int_type __int_type ; 

typename __istream_type :: sentry __cerb (__in , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
const __int_type __cb = __in . rdbuf () -> sbumpc () ; 
if (! _Traits :: eq_int_type (__cb , _Traits :: eof ())) 
__c = _Traits :: to_char_type (__cb) ; 
else 
__err |= (ios_base :: eofbit | ios_base :: failbit) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__in . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __in . _M_setstate (ios_base :: badbit) ; } 
if (__err) 
__in . setstate (__err) ; 
} 
return __in ; 
} 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __in , _CharT * __s) 
{ 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef basic_streambuf < _CharT , _Traits > __streambuf_type ; 
typedef typename _Traits :: int_type int_type ; 
typedef _CharT char_type ; 
typedef ctype < _CharT > __ctype_type ; 

streamsize __extracted = 0 ; 
ios_base :: iostate __err = ios_base :: goodbit ; 
typename __istream_type :: sentry __cerb (__in , false) ; 
if (__cerb) 
{ 
try 
{ 

streamsize __num = __in . width () ; 
if (__num <= 0) 
__num = __gnu_cxx :: __numeric_traits < streamsize > :: __max ; 

const __ctype_type & __ct = use_facet < __ctype_type > (__in . getloc ()) ; 

const int_type __eof = _Traits :: eof () ; 
__streambuf_type * __sb = __in . rdbuf () ; 
int_type __c = __sb -> sgetc () ; 

while (__extracted < __num - 1 
&& ! _Traits :: eq_int_type (__c , __eof) 
&& ! __ct . is (ctype_base :: space , 
_Traits :: to_char_type (__c))) 
{ 
* __s ++ = _Traits :: to_char_type (__c) ; 
++ __extracted ; 
__c = __sb -> snextc () ; 
} 
if (_Traits :: eq_int_type (__c , __eof)) 
__err |= ios_base :: eofbit ; 



* __s = char_type () ; 
__in . width (0) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__in . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __in . _M_setstate (ios_base :: badbit) ; } 
} 
if (! __extracted) 
__err |= ios_base :: failbit ; 
if (__err) 
__in . setstate (__err) ; 
return __in ; 
} 


template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
ws (basic_istream < _CharT , _Traits > & __in) 
{ 
typedef basic_istream < _CharT , _Traits > __istream_type ; 
typedef basic_streambuf < _CharT , _Traits > __streambuf_type ; 
typedef typename __istream_type :: int_type __int_type ; 
typedef ctype < _CharT > __ctype_type ; 

const __ctype_type & __ct = use_facet < __ctype_type > (__in . getloc ()) ; 
const __int_type __eof = _Traits :: eof () ; 
__streambuf_type * __sb = __in . rdbuf () ; 
__int_type __c = __sb -> sgetc () ; 

while (! _Traits :: eq_int_type (__c , __eof) 
&& __ct . is (ctype_base :: space , _Traits :: to_char_type (__c))) 
__c = __sb -> snextc () ; 

if (_Traits :: eq_int_type (__c , __eof)) 
__in . setstate (ios_base :: eofbit) ; 
return __in ; 
} 




extern template class basic_istream< char> ;
extern template basic_istream< char>  &ws(basic_istream< char>  & __is);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, char & __c);
extern template basic_istream< char>  &operator>>(basic_istream< char>  &, char *);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, unsigned char & __c);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, signed char & __c);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, unsigned char * __s);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __in, signed char * __s);

extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned short & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned long & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(bool & __v);

extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long long & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(unsigned long long & __v);

extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(float & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(double & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(long double & __v);
extern template basic_istream< char> ::__istream_type &basic_istream< char> ::_M_extract(void *& __v);

extern template class basic_iostream< char> ;


extern template class basic_istream< wchar_t> ;
extern template basic_istream< wchar_t>  &ws(basic_istream< wchar_t>  & __is);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __in, wchar_t & __c);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  &, wchar_t *);

extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned short & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned long & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(bool & __v);

extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long long & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(unsigned long long & __v);

extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(float & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(double & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(long double & __v);
extern template basic_istream< wchar_t> ::__istream_type &basic_istream< wchar_t> ::_M_extract(void *& __v);

extern template class basic_iostream< wchar_t> ;




}
# 42 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iostream" 3
namespace std { 
# 60 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iostream" 3
extern istream cin; 
extern ostream cout; 
extern ostream cerr; 
extern ostream clog; 


extern wistream wcin; 
extern wostream wcout; 
extern wostream wcerr; 
extern wostream wclog; 




static ios_base::Init __ioinit; 


}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
namespace std { 


inline namespace __cxx11 { 
# 64 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
class basic_stringbuf : public basic_streambuf < _CharT , _Traits > 
{ 
struct __xfer_bufptrs ; 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 


typedef _Alloc allocator_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 

typedef basic_streambuf < char_type , traits_type > __streambuf_type ; 
typedef basic_string < char_type , _Traits , _Alloc > __string_type ; 
typedef typename __string_type :: size_type __size_type ; 

protected : 

ios_base :: openmode _M_mode ; 


__string_type _M_string ; 

public : 
# 99 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
basic_stringbuf () 
: __streambuf_type () , _M_mode (ios_base :: in | ios_base :: out) , _M_string () 
{ } 
# 110 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_stringbuf (ios_base :: openmode __mode) 
: __streambuf_type () , _M_mode (__mode) , _M_string () 
{ } 
# 123 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_stringbuf (const __string_type & __str , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
: __streambuf_type () , _M_mode () , 
_M_string (__str . data () , __str . size () , __str . get_allocator ()) 
{ _M_stringbuf_init (__mode) ; } 


basic_stringbuf (const basic_stringbuf &) = delete ; 

basic_stringbuf (basic_stringbuf && __rhs) 
: basic_stringbuf (std :: move (__rhs) , __xfer_bufptrs (__rhs , this)) 
{ __rhs . _M_sync (const_cast < char_type * > (__rhs . _M_string . data ()) , 0 , 0) ; } 



basic_stringbuf & 
operator = (const basic_stringbuf &) = delete ; 

basic_stringbuf & 
operator = (basic_stringbuf && __rhs) 
{ 
__xfer_bufptrs __st { __rhs , this } ; 
const __streambuf_type & __base = __rhs ; 
__streambuf_type :: operator = (__base) ; 
this -> pubimbue (__rhs . getloc ()) ; 
_M_mode = __rhs . _M_mode ; 
_M_string = std :: move (__rhs . _M_string) ; 
__rhs . _M_sync (const_cast < char_type * > (__rhs . _M_string . data ()) , 0 , 0) ; 
return * this ; 
} 

void 
swap (basic_stringbuf & __rhs) 
{ 
__xfer_bufptrs __l_st { * this , std :: __addressof (__rhs) } ; 
__xfer_bufptrs __r_st { __rhs , this } ; 
__streambuf_type & __base = __rhs ; 
__streambuf_type :: swap (__base) ; 
__rhs . pubimbue (this -> pubimbue (__rhs . getloc ())) ; 
std :: swap (_M_mode , __rhs . _M_mode) ; 
std :: swap (_M_string , __rhs . _M_string) ; 
} 
# 177 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
__string_type 
str () const 
{ 
__string_type __ret (_M_string . get_allocator ()) ; 
if (this -> pptr ()) 
{ 

if (this -> pptr () > this -> egptr ()) 
__ret . assign (this -> pbase () , this -> pptr ()) ; 
else 
__ret . assign (this -> pbase () , this -> egptr ()) ; 
} 
else 
__ret = _M_string ; 
return __ret ; 
} 
# 201 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
void 
str (const __string_type & __s) 
{ 


_M_string . assign (__s . data () , __s . size ()) ; 
_M_stringbuf_init (_M_mode) ; 
} 

protected : 

void 
_M_stringbuf_init (ios_base :: openmode __mode) 
{ 
_M_mode = __mode ; 
__size_type __len = 0 ; 
if (_M_mode & (ios_base :: ate | ios_base :: app)) 
__len = _M_string . size () ; 
_M_sync (const_cast < char_type * > (_M_string . data ()) , 0 , __len) ; 
} 

virtual streamsize 
showmanyc () 
{ 
streamsize __ret = - 1 ; 
if (_M_mode & ios_base :: in) 
{ 
_M_update_egptr () ; 
__ret = this -> egptr () - this -> gptr () ; 
} 
return __ret ; 
} 

virtual int_type 
underflow () ; 

virtual int_type 
pbackfail (int_type __c = traits_type :: eof ()) ; 

virtual int_type 
overflow (int_type __c = traits_type :: eof ()) ; 
# 254 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
virtual __streambuf_type * 
setbuf (char_type * __s , streamsize __n) 
{ 
if (__s && __n >= 0) 
{ 
# 265
_M_string . clear () ; 


_M_sync (__s , __n , 0) ; 
} 
return this ; 
} 

virtual pos_type 
seekoff (off_type __off , ios_base :: seekdir __way , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) ; 

virtual pos_type 
seekpos (pos_type __sp , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) ; 




void 
_M_sync (char_type * __base , __size_type __i , __size_type __o) ; 



void 
_M_update_egptr () 
{ 
const bool __testin = _M_mode & ios_base :: in ; 
if (this -> pptr () && this -> pptr () > this -> egptr ()) 
{ 
if (__testin) 
this -> setg (this -> eback () , this -> gptr () , this -> pptr ()) ; 
else 
this -> setg (this -> pptr () , this -> pptr () , this -> pptr ()) ; 
} 
} 



void 
_M_pbump (char_type * __pbeg , char_type * __pend , off_type __off) ; 

private : 




struct __xfer_bufptrs 
{ 
__xfer_bufptrs (const basic_stringbuf & __from , basic_stringbuf * __to) 
: _M_to { __to } , _M_goff { - 1 , - 1 , - 1 } , _M_poff { - 1 , - 1 , - 1 } 
{ 
const _CharT * const __str = __from . _M_string . data () ; 
const _CharT * __end = nullptr ; 
if (__from . eback ()) 
{ 
_M_goff [ 0 ] = __from . eback () - __str ; 
_M_goff [ 1 ] = __from . gptr () - __str ; 
_M_goff [ 2 ] = __from . egptr () - __str ; 
__end = __from . egptr () ; 
} 
if (__from . pbase ()) 
{ 
_M_poff [ 0 ] = __from . pbase () - __str ; 
_M_poff [ 1 ] = __from . pptr () - __from . pbase () ; 
_M_poff [ 2 ] = __from . epptr () - __str ; 
if (__from . pptr () > __end) 
__end = __from . pptr () ; 
} 


if (__end) 
{ 


auto & __mut_from = const_cast < basic_stringbuf & > (__from) ; 
__mut_from . _M_string . _M_length (__end - __str) ; 
} 
} 

~ __xfer_bufptrs () 
{ 
char_type * __str = const_cast < char_type * > (_M_to -> _M_string . data ()) ; 
if (_M_goff [ 0 ] != - 1) 
_M_to -> setg (__str + _M_goff [ 0 ] , __str + _M_goff [ 1 ] , __str + _M_goff [ 2 ]) ; 
if (_M_poff [ 0 ] != - 1) 
_M_to -> _M_pbump (__str + _M_poff [ 0 ] , __str + _M_poff [ 2 ] , _M_poff [ 1 ]) ; 
} 

basic_stringbuf * _M_to ; 
off_type _M_goff [ 3 ] ; 
off_type _M_poff [ 3 ] ; 
} ; 
# 368 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
basic_stringbuf (basic_stringbuf && __rhs , __xfer_bufptrs &&) 
: __streambuf_type (static_cast < const __streambuf_type & > (__rhs)) , 
_M_mode (__rhs . _M_mode) , _M_string (std :: move (__rhs . _M_string)) 
{ } 

} ;
# 391 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
class basic_istringstream : public basic_istream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 


typedef _Alloc allocator_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef basic_stringbuf < _CharT , _Traits , _Alloc > __stringbuf_type ; 
typedef basic_istream < char_type , traits_type > __istream_type ; 

private : 
__stringbuf_type _M_stringbuf ; 

public : 
# 425 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
basic_istringstream () 
: __istream_type () , _M_stringbuf (ios_base :: in) 
{ this -> init (& _M_stringbuf) ; } 
# 441 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_istringstream (ios_base :: openmode __mode) 
: __istream_type () , _M_stringbuf (__mode | ios_base :: in) 
{ this -> init (& _M_stringbuf) ; } 
# 459 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_istringstream (const __string_type & __str , 
ios_base :: openmode __mode = ios_base :: in) 
: __istream_type () , _M_stringbuf (__str , __mode | ios_base :: in) 
{ this -> init (& _M_stringbuf) ; } 
# 471
~ basic_istringstream () 
{ } 


basic_istringstream (const basic_istringstream &) = delete ; 

basic_istringstream (basic_istringstream && __rhs) 
: __istream_type (std :: move (__rhs)) , 
_M_stringbuf (std :: move (__rhs . _M_stringbuf)) 
{ __istream_type :: set_rdbuf (& _M_stringbuf) ; } 



basic_istringstream & 
operator = (const basic_istringstream &) = delete ; 

basic_istringstream & 
operator = (basic_istringstream && __rhs) 
{ 
__istream_type :: operator = (std :: move (__rhs)) ; 
_M_stringbuf = std :: move (__rhs . _M_stringbuf) ; 
return * this ; 
} 

void 
swap (basic_istringstream & __rhs) 
{ 
__istream_type :: swap (__rhs) ; 
_M_stringbuf . swap (__rhs . _M_stringbuf) ; 
} 
# 510 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
__stringbuf_type * 
rdbuf () const 
{ return const_cast < __stringbuf_type * > (& _M_stringbuf) ; } 
# 518
__string_type 
str () const 
{ return _M_stringbuf . str () ; } 
# 528
void 
str (const __string_type & __s) 
{ _M_stringbuf . str (__s) ; } 
} ;
# 549 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
class basic_ostringstream : public basic_ostream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 


typedef _Alloc allocator_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef basic_stringbuf < _CharT , _Traits , _Alloc > __stringbuf_type ; 
typedef basic_ostream < char_type , traits_type > __ostream_type ; 

private : 
__stringbuf_type _M_stringbuf ; 

public : 
# 583 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
basic_ostringstream () 
: __ostream_type () , _M_stringbuf (ios_base :: out) 
{ this -> init (& _M_stringbuf) ; } 
# 599 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_ostringstream (ios_base :: openmode __mode) 
: __ostream_type () , _M_stringbuf (__mode | ios_base :: out) 
{ this -> init (& _M_stringbuf) ; } 
# 617 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_ostringstream (const __string_type & __str , 
ios_base :: openmode __mode = ios_base :: out) 
: __ostream_type () , _M_stringbuf (__str , __mode | ios_base :: out) 
{ this -> init (& _M_stringbuf) ; } 
# 629
~ basic_ostringstream () 
{ } 


basic_ostringstream (const basic_ostringstream &) = delete ; 

basic_ostringstream (basic_ostringstream && __rhs) 
: __ostream_type (std :: move (__rhs)) , 
_M_stringbuf (std :: move (__rhs . _M_stringbuf)) 
{ __ostream_type :: set_rdbuf (& _M_stringbuf) ; } 



basic_ostringstream & 
operator = (const basic_ostringstream &) = delete ; 

basic_ostringstream & 
operator = (basic_ostringstream && __rhs) 
{ 
__ostream_type :: operator = (std :: move (__rhs)) ; 
_M_stringbuf = std :: move (__rhs . _M_stringbuf) ; 
return * this ; 
} 

void 
swap (basic_ostringstream & __rhs) 
{ 
__ostream_type :: swap (__rhs) ; 
_M_stringbuf . swap (__rhs . _M_stringbuf) ; 
} 
# 668 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
__stringbuf_type * 
rdbuf () const 
{ return const_cast < __stringbuf_type * > (& _M_stringbuf) ; } 
# 676
__string_type 
str () const 
{ return _M_stringbuf . str () ; } 
# 686
void 
str (const __string_type & __s) 
{ _M_stringbuf . str (__s) ; } 
} ;
# 707 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
template < typename _CharT , typename _Traits , typename _Alloc > 
class basic_stringstream : public basic_iostream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 


typedef _Alloc allocator_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_string < _CharT , _Traits , _Alloc > __string_type ; 
typedef basic_stringbuf < _CharT , _Traits , _Alloc > __stringbuf_type ; 
typedef basic_iostream < char_type , traits_type > __iostream_type ; 

private : 
__stringbuf_type _M_stringbuf ; 

public : 
# 741 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
basic_stringstream () 
: __iostream_type () , _M_stringbuf (ios_base :: out | ios_base :: in) 
{ this -> init (& _M_stringbuf) ; } 
# 755 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_stringstream (ios_base :: openmode __m) 
: __iostream_type () , _M_stringbuf (__m) 
{ this -> init (& _M_stringbuf) ; } 
# 771 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
explicit 
basic_stringstream (const __string_type & __str , 
ios_base :: openmode __m = ios_base :: out | ios_base :: in) 
: __iostream_type () , _M_stringbuf (__str , __m) 
{ this -> init (& _M_stringbuf) ; } 
# 783
~ basic_stringstream () 
{ } 


basic_stringstream (const basic_stringstream &) = delete ; 

basic_stringstream (basic_stringstream && __rhs) 
: __iostream_type (std :: move (__rhs)) , 
_M_stringbuf (std :: move (__rhs . _M_stringbuf)) 
{ __iostream_type :: set_rdbuf (& _M_stringbuf) ; } 



basic_stringstream & 
operator = (const basic_stringstream &) = delete ; 

basic_stringstream & 
operator = (basic_stringstream && __rhs) 
{ 
__iostream_type :: operator = (std :: move (__rhs)) ; 
_M_stringbuf = std :: move (__rhs . _M_stringbuf) ; 
return * this ; 
} 

void 
swap (basic_stringstream & __rhs) 
{ 
__iostream_type :: swap (__rhs) ; 
_M_stringbuf . swap (__rhs . _M_stringbuf) ; 
} 
# 822 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\sstream" 3
__stringbuf_type * 
rdbuf () const 
{ return const_cast < __stringbuf_type * > (& _M_stringbuf) ; } 
# 830
__string_type 
str () const 
{ return _M_stringbuf . str () ; } 
# 840
void 
str (const __string_type & __s) 
{ _M_stringbuf . str (__s) ; } 
} ;



template < class _CharT , class _Traits , class _Allocator > 
inline void 
swap (basic_stringbuf < _CharT , _Traits , _Allocator > & __x , 
basic_stringbuf < _CharT , _Traits , _Allocator > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits , class _Allocator > 
inline void 
swap (basic_istringstream < _CharT , _Traits , _Allocator > & __x , 
basic_istringstream < _CharT , _Traits , _Allocator > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits , class _Allocator > 
inline void 
swap (basic_ostringstream < _CharT , _Traits , _Allocator > & __x , 
basic_ostringstream < _CharT , _Traits , _Allocator > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits , class _Allocator > 
inline void 
swap (basic_stringstream < _CharT , _Traits , _Allocator > & __x , 
basic_stringstream < _CharT , _Traits , _Allocator > & __y) 
{ __x . swap (__y) ; } 


}

}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\sstream.tcc" 3
namespace std { 



template < class _CharT , class _Traits , class _Alloc > 
typename basic_stringbuf < _CharT , _Traits , _Alloc > :: int_type 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
pbackfail (int_type __c) 
{ 
int_type __ret = traits_type :: eof () ; 
if (this -> eback () < this -> gptr ()) 
{ 


const bool __testeof = traits_type :: eq_int_type (__c , __ret) ; 
if (! __testeof) 
{ 
const bool __testeq = traits_type :: eq (traits_type :: 
to_char_type (__c) , 
this -> gptr () [ - 1 ]) ; 
const bool __testout = this -> _M_mode & ios_base :: out ; 
if (__testeq || __testout) 
{ 
this -> gbump (- 1) ; 
if (! __testeq) 
* this -> gptr () = traits_type :: to_char_type (__c) ; 
__ret = __c ; 
} 
} 
else 
{ 
this -> gbump (- 1) ; 
__ret = traits_type :: not_eof (__c) ; 
} 
} 
return __ret ; 
} 

template < class _CharT , class _Traits , class _Alloc > 
typename basic_stringbuf < _CharT , _Traits , _Alloc > :: int_type 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
overflow (int_type __c) 
{ 
const bool __testout = this -> _M_mode & ios_base :: out ; 
if (__builtin_expect (! __testout , false)) 
return traits_type :: eof () ; 

const bool __testeof = traits_type :: eq_int_type (__c , traits_type :: eof ()) ; 
if (__builtin_expect (__testeof , false)) 
return traits_type :: not_eof (__c) ; 

const __size_type __capacity = _M_string . capacity () ; 


if ((this -> epptr () - this -> pbase ()) < __capacity) 
{ 

char_type * __base = const_cast < char_type * > (_M_string . data ()) ; 
_M_pbump (__base , __base + __capacity , this -> pptr () - this -> pbase ()) ; 
if (_M_mode & ios_base :: in) 
{ 
const __size_type __nget = this -> gptr () - this -> eback () ; 
const __size_type __eget = this -> egptr () - this -> eback () ; 
this -> setg (__base , __base + __nget , __base + __eget + 1) ; 
} 
* this -> pptr () = traits_type :: to_char_type (__c) ; 
this -> pbump (1) ; 
return __c ; 
} 


const __size_type __max_size = _M_string . max_size () ; 
const bool __testput = this -> pptr () < this -> epptr () ; 
if (__builtin_expect (! __testput && __capacity == __max_size , false)) 
return traits_type :: eof () ; 



const char_type __conv = traits_type :: to_char_type (__c) ; 
if (! __testput) 
{ 
# 129 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\sstream.tcc" 3
const __size_type __opt_len = std :: max (__size_type (2 * __capacity) , 
__size_type (512)) ; 
const __size_type __len = std :: min (__opt_len , __max_size) ; 
__string_type __tmp (_M_string . get_allocator ()) ; 
__tmp . reserve (__len) ; 
if (this -> pbase ()) 
__tmp . assign (this -> pbase () , this -> epptr () - this -> pbase ()) ; 
__tmp . push_back (__conv) ; 
_M_string . swap (__tmp) ; 
_M_sync (const_cast < char_type * > (_M_string . data ()) , 
this -> gptr () - this -> eback () , this -> pptr () - this -> pbase ()) ; 
} 
else 
* this -> pptr () = __conv ; 
this -> pbump (1) ; 
return __c ; 
} 

template < class _CharT , class _Traits , class _Alloc > 
typename basic_stringbuf < _CharT , _Traits , _Alloc > :: int_type 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
underflow () 
{ 
int_type __ret = traits_type :: eof () ; 
const bool __testin = this -> _M_mode & ios_base :: in ; 
if (__testin) 
{ 

_M_update_egptr () ; 

if (this -> gptr () < this -> egptr ()) 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
} 
return __ret ; 
} 

template < class _CharT , class _Traits , class _Alloc > 
typename basic_stringbuf < _CharT , _Traits , _Alloc > :: pos_type 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
seekoff (off_type __off , ios_base :: seekdir __way , ios_base :: openmode __mode) 
{ 
pos_type __ret = pos_type (off_type (- 1)) ; 
bool __testin = (ios_base :: in & this -> _M_mode & __mode) != 0 ; 
bool __testout = (ios_base :: out & this -> _M_mode & __mode) != 0 ; 
const bool __testboth = __testin && __testout && __way != ios_base :: cur ; 
__testin &= ! (__mode & ios_base :: out) ; 
__testout &= ! (__mode & ios_base :: in) ; 



const char_type * __beg = __testin ? this -> eback () : this -> pbase () ; 
if ((__beg || ! __off) && (__testin || __testout || __testboth)) 
{ 
_M_update_egptr () ; 

off_type __newoffi = __off ; 
off_type __newoffo = __newoffi ; 
if (__way == ios_base :: cur) 
{ 
__newoffi += this -> gptr () - __beg ; 
__newoffo += this -> pptr () - __beg ; 
} 
else if (__way == ios_base :: end) 
__newoffo = __newoffi += this -> egptr () - __beg ; 

if ((__testin || __testboth) 
&& __newoffi >= 0 
&& this -> egptr () - __beg >= __newoffi) 
{ 
this -> setg (this -> eback () , this -> eback () + __newoffi , 
this -> egptr ()) ; 
__ret = pos_type (__newoffi) ; 
} 
if ((__testout || __testboth) 
&& __newoffo >= 0 
&& this -> egptr () - __beg >= __newoffo) 
{ 
_M_pbump (this -> pbase () , this -> epptr () , __newoffo) ; 
__ret = pos_type (__newoffo) ; 
} 
} 
return __ret ; 
} 

template < class _CharT , class _Traits , class _Alloc > 
typename basic_stringbuf < _CharT , _Traits , _Alloc > :: pos_type 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
seekpos (pos_type __sp , ios_base :: openmode __mode) 
{ 
pos_type __ret = pos_type (off_type (- 1)) ; 
const bool __testin = (ios_base :: in & this -> _M_mode & __mode) != 0 ; 
const bool __testout = (ios_base :: out & this -> _M_mode & __mode) != 0 ; 

const char_type * __beg = __testin ? this -> eback () : this -> pbase () ; 
if ((__beg || ! off_type (__sp)) && (__testin || __testout)) 
{ 
_M_update_egptr () ; 

const off_type __pos (__sp) ; 
const bool __testpos = (0 <= __pos 
&& __pos <= this -> egptr () - __beg) ; 
if (__testpos) 
{ 
if (__testin) 
this -> setg (this -> eback () , this -> eback () + __pos , 
this -> egptr ()) ; 
if (__testout) 
_M_pbump (this -> pbase () , this -> epptr () , __pos) ; 
__ret = __sp ; 
} 
} 
return __ret ; 
} 

template < class _CharT , class _Traits , class _Alloc > 
void 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
_M_sync (char_type * __base , __size_type __i , __size_type __o) 
{ 
const bool __testin = _M_mode & ios_base :: in ; 
const bool __testout = _M_mode & ios_base :: out ; 
char_type * __endg = __base + _M_string . size () ; 
char_type * __endp = __base + _M_string . capacity () ; 

if (__base != _M_string . data ()) 
{ 

__endg += __i ; 
__i = 0 ; 
__endp = __endg ; 
} 

if (__testin) 
this -> setg (__base , __base + __i , __endg) ; 
if (__testout) 
{ 
_M_pbump (__base , __endp , __o) ; 



if (! __testin) 
this -> setg (__endg , __endg , __endg) ; 
} 
} 

template < class _CharT , class _Traits , class _Alloc > 
void 
basic_stringbuf < _CharT , _Traits , _Alloc > :: 
_M_pbump (char_type * __pbeg , char_type * __pend , off_type __off) 
{ 
this -> setp (__pbeg , __pend) ; 
while (__off > __gnu_cxx :: __numeric_traits < int > :: __max) 
{ 
this -> pbump (__gnu_cxx :: __numeric_traits < int > :: __max) ; 
__off -= __gnu_cxx :: __numeric_traits < int > :: __max ; 
} 
this -> pbump (__off) ; 
} 




extern template class __cxx11::basic_stringbuf< char> ;
extern template class __cxx11::basic_istringstream< char> ;
extern template class __cxx11::basic_ostringstream< char> ;
extern template class __cxx11::basic_stringstream< char> ;


extern template class __cxx11::basic_stringbuf< wchar_t> ;
extern template class __cxx11::basic_istringstream< wchar_t> ;
extern template class __cxx11::basic_ostringstream< wchar_t> ;
extern template class __cxx11::basic_stringstream< wchar_t> ;




}
# 175 "d:\\mingw\\mingw\\include\\io.h" 3
extern "C" {
# 185 "d:\\mingw\\mingw\\include\\io.h" 3
struct _finddata_t { unsigned attrib; time_t time_create; time_t time_access; time_t time_write; _fsize_t size; char name[(260)]; }; 
struct _finddatai64_t { unsigned attrib; time_t time_create; time_t time_access; time_t time_write; long long size; char name[(260)]; }; 
# 202 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _findfirst(const char *, _finddata_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _findnext(intptr_t, _finddata_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _findfirsti64(const char *, _finddatai64_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _findnexti64(intptr_t, _finddatai64_t *); 
# 224 "d:\\mingw\\mingw\\include\\io.h" 3
struct __finddata64_t { unsigned attrib; __time64_t time_create; __time64_t time_access; __time64_t time_write; long long size; char name[(260)]; }; 
# 233
__attribute((__cdecl__)) __attribute((__nothrow__)) intptr_t _findfirst64(const char *, __finddata64_t *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) int _findnext64(intptr_t, __finddata64_t *); 
# 491 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _chdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_getcwd(char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _mkdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_mktemp(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _rmdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _chmod(const char *, int); 


__attribute((__cdecl__)) __attribute((__nothrow__)) long long _filelengthi64(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long long _lseeki64(int, long long, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long long _telli64(int); 


inline __off64_t lseek64(int, __off64_t, int); 

inline __off64_t lseek64(int fd, __off64_t offset, int whence) 
{ return _lseeki64(fd, (long long)(offset), whence); } 
# 515
__attribute((__cdecl__)) __attribute((__nothrow__)) int chdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *getcwd(char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int mkdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *mktemp(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int rmdir(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int chmod(const char *, int); 
# 526
}
# 552 "d:\\mingw\\mingw\\include\\io.h" 3
extern "C" {




__attribute((__cdecl__)) __attribute((__nothrow__)) int _access(const char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _chsize(int, long); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _close(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _commit(int); 




__attribute((__cdecl__)) __attribute((__nothrow__)) int _creat(const char *, int); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _dup(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _dup2(int, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long _filelength(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long _get_osfhandle(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _isatty(int); 
# 580 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _eof(int); 
# 586
__attribute((__cdecl__)) __attribute((__nothrow__)) int _locking(int, int, long); 

__attribute((__cdecl__)) __attribute((__nothrow__)) long _lseek(int, long, int); 
# 596
__attribute((__cdecl__)) __attribute((__nothrow__)) int _open(const char *, int, ...); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _open_osfhandle(intptr_t, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _pipe(int *, unsigned, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _read(int, void *, unsigned); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _setmode(int, int); 
# 608
__attribute((__cdecl__)) __attribute((__nothrow__)) int remove(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int rename(const char *, const char *); 
# 616
__attribute((__cdecl__)) __attribute((__nothrow__)) int _sopen(const char *, int, int, ...); 

__attribute((__cdecl__)) __attribute((__nothrow__)) long _tell(int); 




__attribute((__cdecl__)) __attribute((__nothrow__)) int _umask(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _unlink(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _write(int, const void *, unsigned); 
# 652 "d:\\mingw\\mingw\\include\\io.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int access(const char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int chsize(int, long); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int close(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int creat(const char *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int dup(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int dup2(int, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int eof(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long filelength(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int isatty(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long lseek(int, long, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int open(const char *, int, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int read(int, void *, unsigned); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int setmode(int, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int sopen(const char *, int, int, ...); 
__attribute((__cdecl__)) __attribute((__nothrow__)) long tell(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int umask(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int unlink(const char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int write(int, const void *, unsigned); 
# 702 "d:\\mingw\\mingw\\include\\io.h" 3
}
# 68 "d:\\mingw\\mingw\\include\\dos.h" 3
extern "C" {
# 126 "d:\\mingw\\mingw\\include\\dos.h" 3
struct _diskfree_t { 



unsigned total_clusters; 
unsigned avail_clusters; 
unsigned sectors_per_cluster; 
unsigned bytes_per_sector; 
}; 


__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _getdiskfree(unsigned, _diskfree_t *); 



}
# 60 "d:\\mingw\\mingw\\include\\direct.h" 3
extern "C" {
# 66
__attribute((__cdecl__)) __attribute((__nothrow__)) int _getdrive(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned long _getdrives(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _chdrive(int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_getdcwd(int, char *, int); 
# 86 "d:\\mingw\\mingw\\include\\direct.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wchdir(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wgetcwd(wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) wchar_t *_wgetdcwd(int, wchar_t *, int); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wmkdir(const wchar_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _wrmdir(const wchar_t *); 



}
# 432 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
typedef struct _CRITICAL_SECTION GTEST_CRITICAL_SECTION; 
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\array" 3
namespace std { 



template < typename _Tp , std :: size_t _Nm > 
struct __array_traits 
{ 
typedef _Tp _Type [ _Nm ] ; 
typedef __is_swappable < _Tp > _Is_swappable ; 
typedef __is_nothrow_swappable < _Tp > _Is_nothrow_swappable ; 

static constexpr _Tp & 
_S_ref (const _Type & __t , std :: size_t __n) noexcept 
{ return const_cast < _Tp & > (__t [ __n ]) ; } 

static constexpr _Tp * 
_S_ptr (const _Type & __t) noexcept 
{ return const_cast < _Tp * > (__t) ; } 
} ;

template < typename _Tp > 
struct __array_traits < _Tp , 0 > 
{ 
struct _Type { } ; 
typedef true_type _Is_swappable ; 
typedef true_type _Is_nothrow_swappable ; 

static constexpr _Tp & 
_S_ref (const _Type & , std :: size_t) noexcept 
{ return * static_cast < _Tp * > (nullptr) ; } 

static constexpr _Tp * 
_S_ptr (const _Type &) noexcept 
{ return nullptr ; } 
} ;
# 93 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\array" 3
template < typename _Tp , std :: size_t _Nm > 
struct array 
{ 
typedef _Tp value_type ; 
typedef value_type * pointer ; 
typedef const value_type * const_pointer ; 
typedef value_type & reference ; 
typedef const value_type & const_reference ; 
typedef value_type * iterator ; 
typedef const value_type * const_iterator ; 
typedef std :: size_t size_type ; 
typedef std :: ptrdiff_t difference_type ; 
typedef std :: reverse_iterator < iterator > reverse_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 


typedef std :: __array_traits < _Tp , _Nm > _AT_Type ; 
typename _AT_Type :: _Type _M_elems ; 




void 
fill (const value_type & __u) 
{ std :: fill_n (begin () , size () , __u) ; } 

void 
swap (array & __other) 
noexcept (_AT_Type :: _Is_nothrow_swappable :: value) 
{ std :: swap_ranges (begin () , end () , __other . begin ()) ; } 


iterator 
begin () noexcept 
{ return iterator (data ()) ; } 

const_iterator 
begin () const noexcept 
{ return const_iterator (data ()) ; } 

iterator 
end () noexcept 
{ return iterator (data () + _Nm) ; } 

const_iterator 
end () const noexcept 
{ return const_iterator (data () + _Nm) ; } 

reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (end ()) ; } 

const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 

reverse_iterator 
rend () noexcept 
{ return reverse_iterator (begin ()) ; } 

const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 

const_iterator 
cbegin () const noexcept 
{ return const_iterator (data ()) ; } 

const_iterator 
cend () const noexcept 
{ return const_iterator (data () + _Nm) ; } 

const_reverse_iterator 
crbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 

const_reverse_iterator 
crend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 


constexpr size_type 
size () const noexcept { return _Nm ; } 

constexpr size_type 
max_size () const noexcept { return _Nm ; } 

constexpr bool 
empty () const noexcept { return size () == 0 ; } 


reference 
operator [ ] (size_type __n) noexcept 
{ return _AT_Type :: _S_ref (_M_elems , __n) ; } 

constexpr const_reference 
operator [ ] (size_type __n) const noexcept 
{ return _AT_Type :: _S_ref (_M_elems , __n) ; } 

reference 
at (size_type __n) 
{ 
if (__n >= _Nm) 
std :: __throw_out_of_range_fmt (("array::at: __n (which is %zu) " ">= _Nm (which is %zu)") 
, 
__n , _Nm) ; 
return _AT_Type :: _S_ref (_M_elems , __n) ; 
} 

constexpr const_reference 
at (size_type __n) const 
{ 


return __n < _Nm ? _AT_Type :: _S_ref (_M_elems , __n) 
: (std :: __throw_out_of_range_fmt (("array::at: __n (which is %zu) " ">= _Nm (which is %zu)") 
, 
__n , _Nm) , 
_AT_Type :: _S_ref (_M_elems , 0)) ; 
} 

reference 
front () noexcept 
{ return * begin () ; } 

constexpr const_reference 
front () const noexcept 
{ return _AT_Type :: _S_ref (_M_elems , 0) ; } 

reference 
back () noexcept 
{ return _Nm ? * (end () - 1) : * end () ; } 

constexpr const_reference 
back () const noexcept 
{ 
return _Nm ? _AT_Type :: _S_ref (_M_elems , _Nm - 1) 
: _AT_Type :: _S_ref (_M_elems , 0) ; 
} 

pointer 
data () noexcept 
{ return _AT_Type :: _S_ptr (_M_elems) ; } 

const_pointer 
data () const noexcept 
{ return _AT_Type :: _S_ptr (_M_elems) ; } 
} ;
# 250 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\array" 3
template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator == (const array < _Tp , _Nm > & __one , const array < _Tp , _Nm > & __two) 
{ return std :: equal (__one . begin () , __one . end () , __two . begin ()) ; } 

template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator != (const array < _Tp , _Nm > & __one , const array < _Tp , _Nm > & __two) 
{ return ! (__one == __two) ; } 

template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator < (const array < _Tp , _Nm > & __a , const array < _Tp , _Nm > & __b) 
{ 
return std :: lexicographical_compare (__a . begin () , __a . end () , 
__b . begin () , __b . end ()) ; 
} 

template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator > (const array < _Tp , _Nm > & __one , const array < _Tp , _Nm > & __two) 
{ return __two < __one ; } 

template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator <= (const array < _Tp , _Nm > & __one , const array < _Tp , _Nm > & __two) 
{ return ! (__one > __two) ; } 

template < typename _Tp , std :: size_t _Nm > 
inline bool 
operator >= (const array < _Tp , _Nm > & __one , const array < _Tp , _Nm > & __two) 
{ return ! (__one < __two) ; } 


template < typename _Tp , std :: size_t _Nm > 
inline 


typename enable_if < 
std :: __array_traits < _Tp , _Nm > :: _Is_swappable :: value 
> :: type 



swap (array < _Tp , _Nm > & __one , array < _Tp , _Nm > & __two) 
noexcept (noexcept (__one . swap (__two))) 
{ __one . swap (__two) ; } 


template < typename _Tp , std :: size_t _Nm > 
typename enable_if < 
! std :: __array_traits < _Tp , _Nm > :: _Is_swappable :: value > :: type 
swap (array < _Tp , _Nm > & , array < _Tp , _Nm > &) = delete ; ;


template < std :: size_t _Int , typename _Tp , std :: size_t _Nm > 
constexpr _Tp & 
get (array < _Tp , _Nm > & __arr) noexcept 
{ 
static_assert (_Int < _Nm , "array index is within bounds") ; 
return std :: __array_traits < _Tp , _Nm > :: 
_S_ref (__arr . _M_elems , _Int) ; 
} 

template < std :: size_t _Int , typename _Tp , std :: size_t _Nm > 
constexpr _Tp && 
get (array < _Tp , _Nm > && __arr) noexcept 
{ 
static_assert (_Int < _Nm , "array index is within bounds") ; 
return std :: move (std :: get < _Int > (__arr)) ; 
} 

template < std :: size_t _Int , typename _Tp , std :: size_t _Nm > 
constexpr const _Tp & 
get (const array < _Tp , _Nm > & __arr) noexcept 
{ 
static_assert (_Int < _Nm , "array index is within bounds") ; 
return std :: __array_traits < _Tp , _Nm > :: 
_S_ref (__arr . _M_elems , _Int) ; 
} 

template < std :: size_t _Int , typename _Tp , std :: size_t _Nm > 
constexpr const _Tp && 
get (const array < _Tp , _Nm > && __arr) noexcept 
{ 
static_assert (_Int < _Nm , "array index is within bounds") ; 
return std :: move (std :: get < _Int > (__arr)) ; 
} 


}

namespace std { 
# 349
template < typename _Tp >
    struct tuple_size;


template < typename _Tp , std :: size_t _Nm > 
struct tuple_size < std :: array < _Tp , _Nm > > 
: public integral_constant < std :: size_t , _Nm > { } ;


template < std :: size_t _Int, typename _Tp >
    struct tuple_element;


template < std :: size_t _Int , typename _Tp , std :: size_t _Nm > 
struct tuple_element < _Int , std :: array < _Tp , _Nm > > 
{ 
static_assert (_Int < _Nm , "index is out of bounds") ; 
typedef _Tp type ; 
} ;

template < typename _Tp , std :: size_t _Nm > 
struct __is_tuple_like_impl < std :: array < _Tp , _Nm > > : true_type 
{ } ;


}
# 35 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\uses_allocator.h" 3
namespace std { 




struct __erased_type { }; 




template < typename _Alloc, typename _Tp >
    using __is_erased_or_convertible
      = __or_ < is_convertible < _Alloc, _Tp >, is_same < _Tp, __erased_type >>;


struct allocator_arg_t { explicit allocator_arg_t() = default;}; 

constexpr allocator_arg_t allocator_arg = allocator_arg_t(); 


template < typename _Tp , typename _Alloc , typename = __void_t < > > 
struct __uses_allocator_helper 
: false_type { } ;

template < typename _Tp , typename _Alloc > 
struct __uses_allocator_helper < _Tp , _Alloc , 
__void_t < typename _Tp :: allocator_type > > 
: __is_erased_or_convertible < _Alloc , typename _Tp :: allocator_type > :: type 
{ } ;


template < typename _Tp , typename _Alloc > 
struct uses_allocator 
: __uses_allocator_helper < _Tp , _Alloc > :: type 
{ } ;

struct __uses_alloc_base { }; 

struct __uses_alloc0 : public __uses_alloc_base { 

struct _Sink { void operator=(const void *) { } } _M_a; 
}; 

template < typename _Alloc > 
struct __uses_alloc1 : __uses_alloc_base { const _Alloc * _M_a ; } ;

template < typename _Alloc > 
struct __uses_alloc2 : __uses_alloc_base { const _Alloc * _M_a ; } ;

template < bool, typename _Tp, typename _Alloc, typename ... _Args >
    struct __uses_alloc;

template < typename _Tp , typename _Alloc , typename ... _Args > 
struct __uses_alloc < true , _Tp , _Alloc , _Args ... > 
: conditional < 
is_constructible < _Tp , allocator_arg_t , const _Alloc & , _Args ... > :: value , 
__uses_alloc1 < _Alloc > , 
__uses_alloc2 < _Alloc > > :: type 
{ 


static_assert (__or_ < 
is_constructible < _Tp , allocator_arg_t , const _Alloc & , _Args ... > , 
is_constructible < _Tp , _Args ... , const _Alloc & > > :: value , 
"construction with an allocator must be possible" 
" if uses_allocator is true") ; 
} ;

template < typename _Tp , typename _Alloc , typename ... _Args > 
struct __uses_alloc < false , _Tp , _Alloc , _Args ... > 
: __uses_alloc0 { } ;

template < typename _Tp, typename _Alloc, typename ... _Args >
    using __uses_alloc_t =
      __uses_alloc < uses_allocator < _Tp, _Alloc > :: value, _Tp, _Alloc, _Args ... >;

template < typename _Tp , typename _Alloc , typename ... _Args > 
inline __uses_alloc_t < _Tp , _Alloc , _Args ... > 
__use_alloc (const _Alloc & __a) 
{ 
__uses_alloc_t < _Tp , _Alloc , _Args ... > __ret ; 
__ret . _M_a = std :: __addressof (__a) ; 
return __ret ; 
} 

template < typename _Tp , typename _Alloc , typename ... _Args > 
void 
__use_alloc (const _Alloc &&) = delete ; ;
# 130
template < template < typename ... > class _Predicate , 
typename _Tp , typename _Alloc , typename ... _Args > 
struct __is_uses_allocator_predicate 
: conditional < uses_allocator < _Tp , _Alloc > :: value , 
__or_ < _Predicate < _Tp , allocator_arg_t , _Alloc , _Args ... > , 
_Predicate < _Tp , _Args ... , _Alloc > > , 
_Predicate < _Tp , _Args ... > > :: type { } ;

template < typename _Tp , typename _Alloc , typename ... _Args > 
struct __is_uses_allocator_constructible 
: __is_uses_allocator_predicate < is_constructible , _Tp , _Alloc , _Args ... > 
{ } ;
# 149
template < typename _Tp , typename _Alloc , typename ... _Args > 
struct __is_nothrow_uses_allocator_constructible 
: __is_uses_allocator_predicate < is_nothrow_constructible , 
_Tp , _Alloc , _Args ... > 
{ } ;
# 163 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\uses_allocator.h" 3
template < typename _Tp , typename ... _Args > 
void __uses_allocator_construct_impl (__uses_alloc0 __a , _Tp * __ptr , 
_Args && ... __args) 
{ :: new ((void *) __ptr) _Tp (std :: forward < _Args > (__args) ...) ; } 

template < typename _Tp , typename _Alloc , typename ... _Args > 
void __uses_allocator_construct_impl (__uses_alloc1 < _Alloc > __a , _Tp * __ptr , 
_Args && ... __args) 
{ 
:: new ((void *) __ptr) _Tp (allocator_arg , * __a . _M_a , 
std :: forward < _Args > (__args) ...) ; 
} 

template < typename _Tp , typename _Alloc , typename ... _Args > 
void __uses_allocator_construct_impl (__uses_alloc2 < _Alloc > __a , _Tp * __ptr , 
_Args && ... __args) 
{ :: new ((void *) __ptr) _Tp (std :: forward < _Args > (__args) ... , * __a . _M_a) ; } 

template < typename _Tp , typename _Alloc , typename ... _Args > 
void __uses_allocator_construct (const _Alloc & __a , _Tp * __ptr , 
_Args && ... __args) 
{ 
std :: __uses_allocator_construct_impl (
std :: __use_alloc < _Tp , _Alloc , _Args ... > (__a) , __ptr , 
std :: forward < _Args > (__args) ...) ; 
} 


}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\invoke.h" 3
namespace std { 
# 52 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\invoke.h" 3
template < typename _Tp , typename _Up = typename __inv_unwrap < _Tp > :: type > 
constexpr _Up && 
__invfwd (typename remove_reference < _Tp > :: type & __t) noexcept 
{ return static_cast < _Up && > (__t) ; } 

template < typename _Res , typename _Fn , typename ... _Args > 
constexpr _Res 
__invoke_impl (__invoke_other , _Fn && __f , _Args && ... __args) 
{ return std :: forward < _Fn > (__f) (std :: forward < _Args > (__args) ...) ; } 

template < typename _Res , typename _MemFun , typename _Tp , typename ... _Args > 
constexpr _Res 
__invoke_impl (__invoke_memfun_ref , _MemFun && __f , _Tp && __t , 
_Args && ... __args) 
{ return (__invfwd < _Tp > (__t) .* __f) (std :: forward < _Args > (__args) ...) ; } 

template < typename _Res , typename _MemFun , typename _Tp , typename ... _Args > 
constexpr _Res 
__invoke_impl (__invoke_memfun_deref , _MemFun && __f , _Tp && __t , 
_Args && ... __args) 
{ 
return ((* std :: forward < _Tp > (__t)) .* __f) (std :: forward < _Args > (__args) ...) ; 
} 

template < typename _Res , typename _MemPtr , typename _Tp > 
constexpr _Res 
__invoke_impl (__invoke_memobj_ref , _MemPtr && __f , _Tp && __t) 
{ return __invfwd < _Tp > (__t) .* __f ; } 

template < typename _Res , typename _MemPtr , typename _Tp > 
constexpr _Res 
__invoke_impl (__invoke_memobj_deref , _MemPtr && __f , _Tp && __t) 
{ return (* std :: forward < _Tp > (__t)) .* __f ; } 


template < typename _Callable , typename ... _Args > 
constexpr typename __invoke_result < _Callable , _Args ... > :: type 
__invoke (_Callable && __fn , _Args && ... __args) 
noexcept (__is_nothrow_invocable < _Callable , _Args ... > :: value) 
{ 
using __result = __invoke_result < _Callable , _Args ... > ; 
using __type = typename __result :: type ; 
using __tag = typename __result :: __invoke_type ; 
return std :: __invoke_impl < __type > (__tag { } , std :: forward < _Callable > (__fn) , 
std :: forward < _Args > (__args) ...) ; 
} 


}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
namespace std { 
# 52
template < typename ... _Elements >
    class tuple;

template < typename _Tp > 
struct __is_empty_non_tuple : is_empty < _Tp > { } ;


template < typename _El0 , typename ... _El > 
struct __is_empty_non_tuple < tuple < _El0 , _El ... > > : false_type { } ;


template < typename _Tp >
    using __empty_not_final
    = typename conditional < __is_final ( _Tp ), false_type,
      __is_empty_non_tuple < _Tp >> :: type;

template < std :: size_t _Idx, typename _Head,
    bool = __empty_not_final < _Head > :: value >
    struct _Head_base;

template < std :: size_t _Idx , typename _Head > 
struct _Head_base < _Idx , _Head , true > 
: public _Head 
{ 
constexpr _Head_base () 
: _Head () { } 

constexpr _Head_base (const _Head & __h) 
: _Head (__h) { } 

constexpr _Head_base (const _Head_base &) = default ; 
constexpr _Head_base (_Head_base &&) = default ; 

template < typename _UHead > 
constexpr _Head_base (_UHead && __h) 
: _Head (std :: forward < _UHead > (__h)) { } 

_Head_base (allocator_arg_t , __uses_alloc0) 
: _Head () { } 

template < typename _Alloc > 
_Head_base (allocator_arg_t , __uses_alloc1 < _Alloc > __a) 
: _Head (allocator_arg , * __a . _M_a) { } 

template < typename _Alloc > 
_Head_base (allocator_arg_t , __uses_alloc2 < _Alloc > __a) 
: _Head (* __a . _M_a) { } 

template < typename _UHead > 
_Head_base (__uses_alloc0 , _UHead && __uhead) 
: _Head (std :: forward < _UHead > (__uhead)) { } 

template < typename _Alloc , typename _UHead > 
_Head_base (__uses_alloc1 < _Alloc > __a , _UHead && __uhead) 
: _Head (allocator_arg , * __a . _M_a , std :: forward < _UHead > (__uhead)) { } 

template < typename _Alloc , typename _UHead > 
_Head_base (__uses_alloc2 < _Alloc > __a , _UHead && __uhead) 
: _Head (std :: forward < _UHead > (__uhead) , * __a . _M_a) { } 

static constexpr _Head & 
_M_head (_Head_base & __b) noexcept { return __b ; } 

static constexpr const _Head & 
_M_head (const _Head_base & __b) noexcept { return __b ; } 
} ;

template < std :: size_t _Idx , typename _Head > 
struct _Head_base < _Idx , _Head , false > 
{ 
constexpr _Head_base () 
: _M_head_impl () { } 

constexpr _Head_base (const _Head & __h) 
: _M_head_impl (__h) { } 

constexpr _Head_base (const _Head_base &) = default ; 
constexpr _Head_base (_Head_base &&) = default ; 

template < typename _UHead > 
constexpr _Head_base (_UHead && __h) 
: _M_head_impl (std :: forward < _UHead > (__h)) { } 

_Head_base (allocator_arg_t , __uses_alloc0) 
: _M_head_impl () { } 

template < typename _Alloc > 
_Head_base (allocator_arg_t , __uses_alloc1 < _Alloc > __a) 
: _M_head_impl (allocator_arg , * __a . _M_a) { } 

template < typename _Alloc > 
_Head_base (allocator_arg_t , __uses_alloc2 < _Alloc > __a) 
: _M_head_impl (* __a . _M_a) { } 

template < typename _UHead > 
_Head_base (__uses_alloc0 , _UHead && __uhead) 
: _M_head_impl (std :: forward < _UHead > (__uhead)) { } 

template < typename _Alloc , typename _UHead > 
_Head_base (__uses_alloc1 < _Alloc > __a , _UHead && __uhead) 
: _M_head_impl (allocator_arg , * __a . _M_a , std :: forward < _UHead > (__uhead)) 
{ } 

template < typename _Alloc , typename _UHead > 
_Head_base (__uses_alloc2 < _Alloc > __a , _UHead && __uhead) 
: _M_head_impl (std :: forward < _UHead > (__uhead) , * __a . _M_a) { } 

static constexpr _Head & 
_M_head (_Head_base & __b) noexcept { return __b . _M_head_impl ; } 

static constexpr const _Head & 
_M_head (const _Head_base & __b) noexcept { return __b . _M_head_impl ; } 

_Head _M_head_impl ; 
} ;
# 176 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
template < std :: size_t _Idx, typename ... _Elements >
    struct _Tuple_impl;
# 184
template < std :: size_t _Idx , typename _Head , typename ... _Tail > 
struct _Tuple_impl < _Idx , _Head , _Tail ... > 
: public _Tuple_impl < _Idx + 1 , _Tail ... > , 
private _Head_base < _Idx , _Head > 
{ 
template < std :: size_t , typename ... > friend class _Tuple_impl ; 

typedef _Tuple_impl < _Idx + 1 , _Tail ... > _Inherited ; 
typedef _Head_base < _Idx , _Head > _Base ; 

static constexpr _Head & 
_M_head (_Tuple_impl & __t) noexcept { return _Base :: _M_head (__t) ; } 

static constexpr const _Head & 
_M_head (const _Tuple_impl & __t) noexcept { return _Base :: _M_head (__t) ; } 

static constexpr _Inherited & 
_M_tail (_Tuple_impl & __t) noexcept { return __t ; } 

static constexpr const _Inherited & 
_M_tail (const _Tuple_impl & __t) noexcept { return __t ; } 

constexpr _Tuple_impl () 
: _Inherited () , _Base () { } 

explicit 
constexpr _Tuple_impl (const _Head & __head , const _Tail & ... __tail) 
: _Inherited (__tail ...) , _Base (__head) { } 

template < typename _UHead , typename ... _UTail , typename = typename 
enable_if < sizeof ... (_Tail) == sizeof ... (_UTail) > :: type > 
explicit 
constexpr _Tuple_impl (_UHead && __head , _UTail && ... __tail) 
: _Inherited (std :: forward < _UTail > (__tail) ...) , 
_Base (std :: forward < _UHead > (__head)) { } 

constexpr _Tuple_impl (const _Tuple_impl &) = default ; 



_Tuple_impl & operator = (const _Tuple_impl &) = delete ; 

constexpr 
_Tuple_impl (_Tuple_impl && __in) 
noexcept (__and_ < is_nothrow_move_constructible < _Head > , 
is_nothrow_move_constructible < _Inherited > > :: value) 
: _Inherited (std :: move (_M_tail (__in))) , 
_Base (std :: forward < _Head > (_M_head (__in))) { } 

template < typename ... _UElements > 
constexpr _Tuple_impl (const _Tuple_impl < _Idx , _UElements ... > & __in) 
: _Inherited (_Tuple_impl < _Idx , _UElements ... > :: _M_tail (__in)) , 
_Base (_Tuple_impl < _Idx , _UElements ... > :: _M_head (__in)) { } 

template < typename _UHead , typename ... _UTails > 
constexpr _Tuple_impl (_Tuple_impl < _Idx , _UHead , _UTails ... > && __in) 
: _Inherited (std :: move 
(_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_tail (__in))) , 
_Base (std :: forward < _UHead > 
(_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_head (__in))) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a) 
: _Inherited (__tag , __a) , 
_Base (__tag , __use_alloc < _Head > (__a)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Head & __head , const _Tail & ... __tail) 
: _Inherited (__tag , __a , __tail ...) , 
_Base (__use_alloc < _Head , _Alloc , _Head > (__a) , __head) { } 

template < typename _Alloc , typename _UHead , typename ... _UTail , 
typename = typename enable_if < sizeof ... (_Tail) 
== sizeof ... (_UTail) > :: type > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_UHead && __head , _UTail && ... __tail) 
: _Inherited (__tag , __a , std :: forward < _UTail > (__tail) ...) , 
_Base (__use_alloc < _Head , _Alloc , _UHead > (__a) , 
std :: forward < _UHead > (__head)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Tuple_impl & __in) 
: _Inherited (__tag , __a , _M_tail (__in)) , 
_Base (__use_alloc < _Head , _Alloc , _Head > (__a) , _M_head (__in)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_Tuple_impl && __in) 
: _Inherited (__tag , __a , std :: move (_M_tail (__in))) , 
_Base (__use_alloc < _Head , _Alloc , _Head > (__a) , 
std :: forward < _Head > (_M_head (__in))) { } 

template < typename _Alloc , typename ... _UElements > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Tuple_impl < _Idx , _UElements ... > & __in) 
: _Inherited (__tag , __a , 
_Tuple_impl < _Idx , _UElements ... > :: _M_tail (__in)) , 
_Base (__use_alloc < _Head , _Alloc , _Head > (__a) , 
_Tuple_impl < _Idx , _UElements ... > :: _M_head (__in)) { } 

template < typename _Alloc , typename _UHead , typename ... _UTails > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_Tuple_impl < _Idx , _UHead , _UTails ... > && __in) 
: _Inherited (__tag , __a , std :: move 
(_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_tail (__in))) , 
_Base (__use_alloc < _Head , _Alloc , _UHead > (__a) , 
std :: forward < _UHead > 
(_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_head (__in))) { } 

template < typename ... _UElements > 
void 
_M_assign (const _Tuple_impl < _Idx , _UElements ... > & __in) 
{ 
_M_head (* this) = _Tuple_impl < _Idx , _UElements ... > :: _M_head (__in) ; 
_M_tail (* this) . _M_assign (
_Tuple_impl < _Idx , _UElements ... > :: _M_tail (__in)) ; 
} 

template < typename _UHead , typename ... _UTails > 
void 
_M_assign (_Tuple_impl < _Idx , _UHead , _UTails ... > && __in) 
{ 
_M_head (* this) = std :: forward < _UHead > 
(_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_head (__in)) ; 
_M_tail (* this) . _M_assign (
std :: move (_Tuple_impl < _Idx , _UHead , _UTails ... > :: _M_tail (__in))) ; 
} 

protected : 
void 
_M_swap (_Tuple_impl & __in) 
{ 
using std :: swap ; 
swap (_M_head (* this) , _M_head (__in)) ; 
_Inherited :: _M_swap (_M_tail (__in)) ; 
} 
} ;


template < std :: size_t _Idx , typename _Head > 
struct _Tuple_impl < _Idx , _Head > 
: private _Head_base < _Idx , _Head > 
{ 
template < std :: size_t , typename ... > friend class _Tuple_impl ; 

typedef _Head_base < _Idx , _Head > _Base ; 

static constexpr _Head & 
_M_head (_Tuple_impl & __t) noexcept { return _Base :: _M_head (__t) ; } 

static constexpr const _Head & 
_M_head (const _Tuple_impl & __t) noexcept { return _Base :: _M_head (__t) ; } 

constexpr _Tuple_impl () 
: _Base () { } 

explicit 
constexpr _Tuple_impl (const _Head & __head) 
: _Base (__head) { } 

template < typename _UHead > 
explicit 
constexpr _Tuple_impl (_UHead && __head) 
: _Base (std :: forward < _UHead > (__head)) { } 

constexpr _Tuple_impl (const _Tuple_impl &) = default ; 



_Tuple_impl & operator = (const _Tuple_impl &) = delete ; 

constexpr 
_Tuple_impl (_Tuple_impl && __in) 
noexcept (is_nothrow_move_constructible < _Head > :: value) 
: _Base (std :: forward < _Head > (_M_head (__in))) { } 

template < typename _UHead > 
constexpr _Tuple_impl (const _Tuple_impl < _Idx , _UHead > & __in) 
: _Base (_Tuple_impl < _Idx , _UHead > :: _M_head (__in)) { } 

template < typename _UHead > 
constexpr _Tuple_impl (_Tuple_impl < _Idx , _UHead > && __in) 
: _Base (std :: forward < _UHead > (_Tuple_impl < _Idx , _UHead > :: _M_head (__in))) 
{ } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a) 
: _Base (__tag , __use_alloc < _Head > (__a)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Head & __head) 
: _Base (__use_alloc < _Head , _Alloc , _Head > (__a) , __head) { } 

template < typename _Alloc , typename _UHead > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_UHead && __head) 
: _Base (__use_alloc < _Head , _Alloc , _UHead > (__a) , 
std :: forward < _UHead > (__head)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Tuple_impl & __in) 
: _Base (__use_alloc < _Head , _Alloc , _Head > (__a) , _M_head (__in)) { } 

template < typename _Alloc > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_Tuple_impl && __in) 
: _Base (__use_alloc < _Head , _Alloc , _Head > (__a) , 
std :: forward < _Head > (_M_head (__in))) { } 

template < typename _Alloc , typename _UHead > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
const _Tuple_impl < _Idx , _UHead > & __in) 
: _Base (__use_alloc < _Head , _Alloc , _Head > (__a) , 
_Tuple_impl < _Idx , _UHead > :: _M_head (__in)) { } 

template < typename _Alloc , typename _UHead > 
_Tuple_impl (allocator_arg_t __tag , const _Alloc & __a , 
_Tuple_impl < _Idx , _UHead > && __in) 
: _Base (__use_alloc < _Head , _Alloc , _UHead > (__a) , 
std :: forward < _UHead > (_Tuple_impl < _Idx , _UHead > :: _M_head (__in))) 
{ } 

template < typename _UHead > 
void 
_M_assign (const _Tuple_impl < _Idx , _UHead > & __in) 
{ 
_M_head (* this) = _Tuple_impl < _Idx , _UHead > :: _M_head (__in) ; 
} 

template < typename _UHead > 
void 
_M_assign (_Tuple_impl < _Idx , _UHead > && __in) 
{ 
_M_head (* this) 
= std :: forward < _UHead > (_Tuple_impl < _Idx , _UHead > :: _M_head (__in)) ; 
} 

protected : 
void 
_M_swap (_Tuple_impl & __in) 
{ 
using std :: swap ; 
swap (_M_head (* this) , _M_head (__in)) ; 
} 
} ;



template < bool , typename ... _Elements > 
struct _TC 
{ 
template < typename ... _UElements > 
static constexpr bool _ConstructibleTuple () 
{ 
return __and_ < is_constructible < _Elements , const _UElements & > ... > :: value ; 
} 

template < typename ... _UElements > 
static constexpr bool _ImplicitlyConvertibleTuple () 
{ 
return __and_ < is_convertible < const _UElements & , _Elements > ... > :: value ; 
} 

template < typename ... _UElements > 
static constexpr bool _MoveConstructibleTuple () 
{ 
return __and_ < is_constructible < _Elements , _UElements && > ... > :: value ; 
} 

template < typename ... _UElements > 
static constexpr bool _ImplicitlyMoveConvertibleTuple () 
{ 
return __and_ < is_convertible < _UElements && , _Elements > ... > :: value ; 
} 

template < typename _SrcTuple > 
static constexpr bool _NonNestedTuple () 
{ 
return __and_ < __not_ < is_same < tuple < _Elements ... > , 
__remove_cvref_t < _SrcTuple > > > , 
__not_ < is_convertible < _SrcTuple , _Elements ... > > , 
__not_ < is_constructible < _Elements ... , _SrcTuple > > 
> :: value ; 
} 

template < typename ... _UElements > 
static constexpr bool _NotSameTuple () 
{ 
return __not_ < is_same < tuple < _Elements ... > , 
__remove_cvref_t < _UElements > ... > > :: value ; 
} 
} ;

template < typename ... _Elements > 
struct _TC < false , _Elements ... > 
{ 
template < typename ... _UElements > 
static constexpr bool _ConstructibleTuple () 
{ 
return false ; 
} 

template < typename ... _UElements > 
static constexpr bool _ImplicitlyConvertibleTuple () 
{ 
return false ; 
} 

template < typename ... _UElements > 
static constexpr bool _MoveConstructibleTuple () 
{ 
return false ; 
} 

template < typename ... _UElements > 
static constexpr bool _ImplicitlyMoveConvertibleTuple () 
{ 
return false ; 
} 

template < typename ... _UElements > 
static constexpr bool _NonNestedTuple () 
{ 
return true ; 
} 

template < typename ... _UElements > 
static constexpr bool _NotSameTuple () 
{ 
return true ; 
} 
} ;


template < typename ... _Elements > 
class tuple : public _Tuple_impl < 0 , _Elements ... > 
{ 
typedef _Tuple_impl < 0 , _Elements ... > _Inherited ; 



template < typename _Dummy > 
struct _TC2 
{ 
static constexpr bool _DefaultConstructibleTuple () 
{ 
return __and_ < is_default_constructible < _Elements > ... > :: value ; 
} 
static constexpr bool _ImplicitlyDefaultConstructibleTuple () 
{ 
return __and_ < __is_implicitly_default_constructible < _Elements > ... > 
:: value ; 
} 
} ; 

template < typename ... _UElements > 
static constexpr 
__enable_if_t < sizeof ... (_UElements) == sizeof ... (_Elements) , bool > 
__assignable () 
{ return __and_ < is_assignable < _Elements & , _UElements > ... > :: value ; } 

template < typename ... _UElements > 
static constexpr bool __nothrow_assignable () 
{ 
return 
__and_ < is_nothrow_assignable < _Elements & , _UElements > ... > :: value ; 
} 

public : 
template < typename _Dummy = void , 
typename enable_if < _TC2 < _Dummy > :: 
_ImplicitlyDefaultConstructibleTuple () , 
bool > :: type = true > 
constexpr tuple () 
: _Inherited () { } 

template < typename _Dummy = void , 
typename enable_if < _TC2 < _Dummy > :: 
_DefaultConstructibleTuple () 
&& 
! _TC2 < _Dummy > :: 
_ImplicitlyDefaultConstructibleTuple () , 
bool > :: type = false > 
explicit constexpr tuple () 
: _Inherited () { } 



template < typename _Dummy > using _TCC = 
_TC < is_same < _Dummy , void > :: value , 
_Elements ... > ; 

template < typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _Elements ... > () 
&& _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _Elements ... > () 
&& (sizeof ... (_Elements) >= 1) , 
bool > :: type = true > 
constexpr tuple (const _Elements & ... __elements) 
: _Inherited (__elements ...) { } 

template < typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _Elements ... > () 
&& ! _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _Elements ... > () 
&& (sizeof ... (_Elements) >= 1) , 
bool > :: type = false > 
explicit constexpr tuple (const _Elements & ... __elements) 
: _Inherited (__elements ...) { } 



template < typename ... _UElements > using _TMC = 
_TC < (sizeof ... (_Elements) == sizeof ... (_UElements)) 
&& (_TC < (sizeof ... (_UElements) == 1) , _Elements ... > :: 
template _NotSameTuple < _UElements ... > ()) , 
_Elements ... > ; 



template < typename ... _UElements > using _TMCT = 
_TC < (sizeof ... (_Elements) == sizeof ... (_UElements)) 
&& ! is_same < tuple < _Elements ... > , 
tuple < _UElements ... > > :: value , 
_Elements ... > ; 

template < typename ... _UElements , typename 
enable_if < 
_TMC < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& _TMC < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& (sizeof ... (_Elements) >= 1) , 
bool > :: type = true > 
constexpr tuple (_UElements && ... __elements) 
: _Inherited (std :: forward < _UElements > (__elements) ...) { } 

template < typename ... _UElements , typename 
enable_if < 
_TMC < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& ! _TMC < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& (sizeof ... (_Elements) >= 1) , 
bool > :: type = false > 
explicit constexpr tuple (_UElements && ... __elements) 
: _Inherited (std :: forward < _UElements > (__elements) ...) { } 

constexpr tuple (const tuple &) = default ; 

constexpr tuple (tuple &&) = default ; 



template < typename _Dummy > using _TNTC = 
_TC < is_same < _Dummy , void > :: value && sizeof ... (_Elements) == 1 , 
_Elements ... > ; 

template < typename ... _UElements , typename _Dummy = void , typename 
enable_if < _TMCT < _UElements ... > :: template 
_ConstructibleTuple < _UElements ... > () 
&& _TMCT < _UElements ... > :: template 
_ImplicitlyConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < const tuple < _UElements ... > & > () , 
bool > :: type = true > 
constexpr tuple (const tuple < _UElements ... > & __in) 
: _Inherited (static_cast < const _Tuple_impl < 0 , _UElements ... > & > (__in)) 
{ } 

template < typename ... _UElements , typename _Dummy = void , typename 
enable_if < _TMCT < _UElements ... > :: template 
_ConstructibleTuple < _UElements ... > () 
&& ! _TMCT < _UElements ... > :: template 
_ImplicitlyConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < const tuple < _UElements ... > & > () , 
bool > :: type = false > 
explicit constexpr tuple (const tuple < _UElements ... > & __in) 
: _Inherited (static_cast < const _Tuple_impl < 0 , _UElements ... > & > (__in)) 
{ } 

template < typename ... _UElements , typename _Dummy = void , typename 
enable_if < _TMCT < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& _TMCT < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < tuple < _UElements ... > && > () , 
bool > :: type = true > 
constexpr tuple (tuple < _UElements ... > && __in) 
: _Inherited (static_cast < _Tuple_impl < 0 , _UElements ... > && > (__in)) { } 

template < typename ... _UElements , typename _Dummy = void , typename 
enable_if < _TMCT < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& ! _TMCT < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < tuple < _UElements ... > && > () , 
bool > :: type = false > 
explicit constexpr tuple (tuple < _UElements ... > && __in) 
: _Inherited (static_cast < _Tuple_impl < 0 , _UElements ... > && > (__in)) { } 



template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a) 
: _Inherited (__tag , __a) { } 

template < typename _Alloc , typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _Elements ... > () 
&& _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _Elements ... > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
const _Elements & ... __elements) 
: _Inherited (__tag , __a , __elements ...) { } 

template < typename _Alloc , typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _Elements ... > () 
&& ! _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _Elements ... > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
const _Elements & ... __elements) 
: _Inherited (__tag , __a , __elements ...) { } 

template < typename _Alloc , typename ... _UElements , typename 
enable_if < _TMC < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& _TMC < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
_UElements && ... __elements) 
: _Inherited (__tag , __a , std :: forward < _UElements > (__elements) ...) 
{ } 

template < typename _Alloc , typename ... _UElements , typename 
enable_if < _TMC < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& ! _TMC < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
_UElements && ... __elements) 
: _Inherited (__tag , __a , std :: forward < _UElements > (__elements) ...) 
{ } 

template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a , const tuple & __in) 
: _Inherited (__tag , __a , static_cast < const _Inherited & > (__in)) { } 

template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a , tuple && __in) 
: _Inherited (__tag , __a , static_cast < _Inherited && > (__in)) { } 

template < typename _Alloc , typename _Dummy = void , 
typename ... _UElements , typename 
enable_if < _TMCT < _UElements ... > :: template 
_ConstructibleTuple < _UElements ... > () 
&& _TMCT < _UElements ... > :: template 
_ImplicitlyConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < const tuple < _UElements ... > & > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
const tuple < _UElements ... > & __in) 
: _Inherited (__tag , __a , 
static_cast < const _Tuple_impl < 0 , _UElements ... > & > (__in)) 
{ } 

template < typename _Alloc , typename _Dummy = void , 
typename ... _UElements , typename 
enable_if < _TMCT < _UElements ... > :: template 
_ConstructibleTuple < _UElements ... > () 
&& ! _TMCT < _UElements ... > :: template 
_ImplicitlyConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < const tuple < _UElements ... > & > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
const tuple < _UElements ... > & __in) 
: _Inherited (__tag , __a , 
static_cast < const _Tuple_impl < 0 , _UElements ... > & > (__in)) 
{ } 

template < typename _Alloc , typename _Dummy = void , 
typename ... _UElements , typename 
enable_if < _TMCT < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& _TMCT < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < tuple < _UElements ... > && > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
tuple < _UElements ... > && __in) 
: _Inherited (__tag , __a , 
static_cast < _Tuple_impl < 0 , _UElements ... > && > (__in)) 
{ } 

template < typename _Alloc , typename _Dummy = void , 
typename ... _UElements , typename 
enable_if < _TMCT < _UElements ... > :: template 
_MoveConstructibleTuple < _UElements ... > () 
&& ! _TMCT < _UElements ... > :: template 
_ImplicitlyMoveConvertibleTuple < _UElements ... > () 
&& _TNTC < _Dummy > :: template 
_NonNestedTuple < tuple < _UElements ... > && > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
tuple < _UElements ... > && __in) 
: _Inherited (__tag , __a , 
static_cast < _Tuple_impl < 0 , _UElements ... > && > (__in)) 
{ } 



tuple & 
operator = (typename conditional < __assignable < const _Elements & ... > () , 
const tuple & , 
const __nonesuch_no_braces & > :: type __in) 
noexcept (__nothrow_assignable < const _Elements & ... > ()) 
{ 
this -> _M_assign (__in) ; 
return * this ; 
} 

tuple & 
operator = (typename conditional < __assignable < _Elements ... > () , 
tuple && , 
__nonesuch_no_braces && > :: type __in) 
noexcept (__nothrow_assignable < _Elements ... > ()) 
{ 
this -> _M_assign (std :: move (__in)) ; 
return * this ; 
} 

template < typename ... _UElements > 
__enable_if_t < __assignable < const _UElements & ... > () , tuple & > 
operator = (const tuple < _UElements ... > & __in) 
noexcept (__nothrow_assignable < const _UElements & ... > ()) 
{ 
this -> _M_assign (__in) ; 
return * this ; 
} 

template < typename ... _UElements > 
__enable_if_t < __assignable < _UElements ... > () , tuple & > 
operator = (tuple < _UElements ... > && __in) 
noexcept (__nothrow_assignable < _UElements ... > ()) 
{ 
this -> _M_assign (std :: move (__in)) ; 
return * this ; 
} 


void 
swap (tuple & __in) 
noexcept (__and_ < __is_nothrow_swappable < _Elements > ... > :: value) 
{ _Inherited :: _M_swap (__in) ; } 
} ;
# 876 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
template<> class tuple< >  { 


public: void swap(std::tuple< >  &) noexcept { } 


tuple() = default;

template < typename _Alloc > 
tuple (allocator_arg_t , const _Alloc &) { } 
template < typename _Alloc > 
tuple (allocator_arg_t , const _Alloc & , const tuple &) { } 
}; 



template < typename _T1 , typename _T2 > 
class tuple < _T1 , _T2 > : public _Tuple_impl < 0 , _T1 , _T2 > 
{ 
typedef _Tuple_impl < 0 , _T1 , _T2 > _Inherited ; 

template < typename _U1 , typename _U2 > 
static constexpr bool __assignable () 
{ 
return __and_ < is_assignable < _T1 & , _U1 > , 
is_assignable < _T2 & , _U2 >> :: value ; 
} 

template < typename _U1 , typename _U2 > 
static constexpr bool __nothrow_assignable () 
{ 
return __and_ < is_nothrow_assignable < _T1 & , _U1 > , 
is_nothrow_assignable < _T2 & , _U2 >> :: value ; 
} 

public : 
template < typename _U1 = _T1 , 
typename _U2 = _T2 , 
typename enable_if < __and_ < 
__is_implicitly_default_constructible < _U1 > , 
__is_implicitly_default_constructible < _U2 > > 
:: value , bool > :: type = true > 
constexpr tuple () 
: _Inherited () { } 

template < typename _U1 = _T1 , 
typename _U2 = _T2 , 
typename enable_if < 
__and_ < 
is_default_constructible < _U1 > , 
is_default_constructible < _U2 > , 
__not_ < 
__and_ < __is_implicitly_default_constructible < _U1 > , 
__is_implicitly_default_constructible < _U2 > > > > 
:: value , bool > :: type = false > 
explicit constexpr tuple () 
: _Inherited () { } 



template < typename _Dummy > using _TCC = 
_TC < is_same < _Dummy , void > :: value , _T1 , _T2 > ; 

template < typename _Dummy = void , typename 
enable_if < _TCC < _Dummy > :: template 
_ConstructibleTuple < _T1 , _T2 > () 
&& _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _T1 , _T2 > () , 
bool > :: type = true > 
constexpr tuple (const _T1 & __a1 , const _T2 & __a2) 
: _Inherited (__a1 , __a2) { } 

template < typename _Dummy = void , typename 
enable_if < _TCC < _Dummy > :: template 
_ConstructibleTuple < _T1 , _T2 > () 
&& ! _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _T1 , _T2 > () , 
bool > :: type = false > 
explicit constexpr tuple (const _T1 & __a1 , const _T2 & __a2) 
: _Inherited (__a1 , __a2) { } 



using _TMC = _TC < true , _T1 , _T2 > ; 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () 
&& ! is_same < __remove_cvref_t < _U1 > , allocator_arg_t > :: value , 
bool > :: type = true > 
constexpr tuple (_U1 && __a1 , _U2 && __a2) 
: _Inherited (std :: forward < _U1 > (__a1) , std :: forward < _U2 > (__a2)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () 
&& ! is_same < __remove_cvref_t < _U1 > , allocator_arg_t > :: value , 
bool > :: type = false > 
explicit constexpr tuple (_U1 && __a1 , _U2 && __a2) 
: _Inherited (std :: forward < _U1 > (__a1) , std :: forward < _U2 > (__a2)) { } 

constexpr tuple (const tuple &) = default ; 

constexpr tuple (tuple &&) = default ; 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr tuple (const tuple < _U1 , _U2 > & __in) 
: _Inherited (static_cast < const _Tuple_impl < 0 , _U1 , _U2 > & > (__in)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr tuple (const tuple < _U1 , _U2 > & __in) 
: _Inherited (static_cast < const _Tuple_impl < 0 , _U1 , _U2 > & > (__in)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr tuple (tuple < _U1 , _U2 > && __in) 
: _Inherited (static_cast < _Tuple_impl < 0 , _U1 , _U2 > && > (__in)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr tuple (tuple < _U1 , _U2 > && __in) 
: _Inherited (static_cast < _Tuple_impl < 0 , _U1 , _U2 > && > (__in)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr tuple (const pair < _U1 , _U2 > & __in) 
: _Inherited (__in . first , __in . second) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr tuple (const pair < _U1 , _U2 > & __in) 
: _Inherited (__in . first , __in . second) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
constexpr tuple (pair < _U1 , _U2 > && __in) 
: _Inherited (std :: forward < _U1 > (__in . first) , 
std :: forward < _U2 > (__in . second)) { } 

template < typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit constexpr tuple (pair < _U1 , _U2 > && __in) 
: _Inherited (std :: forward < _U1 > (__in . first) , 
std :: forward < _U2 > (__in . second)) { } 



template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a) 
: _Inherited (__tag , __a) { } 

template < typename _Alloc , typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _T1 , _T2 > () 
&& _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _T1 , _T2 > () , 
bool > :: type = true > 

tuple (allocator_arg_t __tag , const _Alloc & __a , 
const _T1 & __a1 , const _T2 & __a2) 
: _Inherited (__tag , __a , __a1 , __a2) { } 

template < typename _Alloc , typename _Dummy = void , 
typename enable_if < 
_TCC < _Dummy > :: template 
_ConstructibleTuple < _T1 , _T2 > () 
&& ! _TCC < _Dummy > :: template 
_ImplicitlyConvertibleTuple < _T1 , _T2 > () , 
bool > :: type = false > 

explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
const _T1 & __a1 , const _T2 & __a2) 
: _Inherited (__tag , __a , __a1 , __a2) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , _U1 && __a1 , _U2 && __a2) 
: _Inherited (__tag , __a , std :: forward < _U1 > (__a1) , 
std :: forward < _U2 > (__a2)) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
_U1 && __a1 , _U2 && __a2) 
: _Inherited (__tag , __a , std :: forward < _U1 > (__a1) , 
std :: forward < _U2 > (__a2)) { } 

template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a , const tuple & __in) 
: _Inherited (__tag , __a , static_cast < const _Inherited & > (__in)) { } 

template < typename _Alloc > 
tuple (allocator_arg_t __tag , const _Alloc & __a , tuple && __in) 
: _Inherited (__tag , __a , static_cast < _Inherited && > (__in)) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
const tuple < _U1 , _U2 > & __in) 
: _Inherited (__tag , __a , 
static_cast < const _Tuple_impl < 0 , _U1 , _U2 > & > (__in)) 
{ } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
const tuple < _U1 , _U2 > & __in) 
: _Inherited (__tag , __a , 
static_cast < const _Tuple_impl < 0 , _U1 , _U2 > & > (__in)) 
{ } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , tuple < _U1 , _U2 > && __in) 
: _Inherited (__tag , __a , static_cast < _Tuple_impl < 0 , _U1 , _U2 > && > (__in)) 
{ } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
tuple < _U1 , _U2 > && __in) 
: _Inherited (__tag , __a , static_cast < _Tuple_impl < 0 , _U1 , _U2 > && > (__in)) 
{ } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , 
const pair < _U1 , _U2 > & __in) 
: _Inherited (__tag , __a , __in . first , __in . second) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_ConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
const pair < _U1 , _U2 > & __in) 
: _Inherited (__tag , __a , __in . first , __in . second) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = true > 
tuple (allocator_arg_t __tag , const _Alloc & __a , pair < _U1 , _U2 > && __in) 
: _Inherited (__tag , __a , std :: forward < _U1 > (__in . first) , 
std :: forward < _U2 > (__in . second)) { } 

template < typename _Alloc , typename _U1 , typename _U2 , typename 
enable_if < _TMC :: template 
_MoveConstructibleTuple < _U1 , _U2 > () 
&& ! _TMC :: template 
_ImplicitlyMoveConvertibleTuple < _U1 , _U2 > () , 
bool > :: type = false > 
explicit tuple (allocator_arg_t __tag , const _Alloc & __a , 
pair < _U1 , _U2 > && __in) 
: _Inherited (__tag , __a , std :: forward < _U1 > (__in . first) , 
std :: forward < _U2 > (__in . second)) { } 

tuple & 
operator = (typename conditional < __assignable < const _T1 & , const _T2 & > () , 
const tuple & , 
const __nonesuch_no_braces & > :: type __in) 
noexcept (__nothrow_assignable < const _T1 & , const _T2 & > ()) 
{ 
this -> _M_assign (__in) ; 
return * this ; 
} 

tuple & 
operator = (typename conditional < __assignable < _T1 , _T2 > () , 
tuple && , 
__nonesuch_no_braces && > :: type __in) 
noexcept (__nothrow_assignable < _T1 , _T2 > ()) 
{ 
this -> _M_assign (std :: move (__in)) ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
__enable_if_t < __assignable < const _U1 & , const _U2 & > () , tuple & > 
operator = (const tuple < _U1 , _U2 > & __in) 
noexcept (__nothrow_assignable < const _U1 & , const _U2 & > ()) 
{ 
this -> _M_assign (__in) ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
__enable_if_t < __assignable < _U1 , _U2 > () , tuple & > 
operator = (tuple < _U1 , _U2 > && __in) 
noexcept (__nothrow_assignable < _U1 , _U2 > ()) 
{ 
this -> _M_assign (std :: move (__in)) ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
__enable_if_t < __assignable < const _U1 & , const _U2 & > () , tuple & > 
operator = (const pair < _U1 , _U2 > & __in) 
noexcept (__nothrow_assignable < const _U1 & , const _U2 & > ()) 
{ 
this -> _M_head (* this) = __in . first ; 
this -> _M_tail (* this) . _M_head (* this) = __in . second ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
__enable_if_t < __assignable < _U1 , _U2 > () , tuple & > 
operator = (pair < _U1 , _U2 > && __in) 
noexcept (__nothrow_assignable < _U1 , _U2 > ()) 
{ 
this -> _M_head (* this) = std :: forward < _U1 > (__in . first) ; 
this -> _M_tail (* this) . _M_head (* this) = std :: forward < _U2 > (__in . second) ; 
return * this ; 
} 

void 
swap (tuple & __in) 
noexcept (__and_ < __is_nothrow_swappable < _T1 > , 
__is_nothrow_swappable < _T2 > > :: value) 
{ _Inherited :: _M_swap (__in) ; } 
} ;



template < typename ... _Elements > 
struct tuple_size < tuple < _Elements ... > > 
: public integral_constant < std :: size_t , sizeof ... (_Elements) > { } ;
# 1284 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
template < std :: size_t __i , typename _Head , typename ... _Tail > 
struct tuple_element < __i , tuple < _Head , _Tail ... > > 
: tuple_element < __i - 1 , tuple < _Tail ... > > { } ;




template < typename _Head , typename ... _Tail > 
struct tuple_element < 0 , tuple < _Head , _Tail ... > > 
{ 
typedef _Head type ; 
} ;




template < size_t __i > 
struct tuple_element < __i , tuple < > > 
{ 
static_assert (__i < tuple_size < tuple < > > :: value , 
"tuple index is in range") ; 
} ;

template < std :: size_t __i , typename _Head , typename ... _Tail > 
constexpr _Head & 
__get_helper (_Tuple_impl < __i , _Head , _Tail ... > & __t) noexcept 
{ return _Tuple_impl < __i , _Head , _Tail ... > :: _M_head (__t) ; } 

template < std :: size_t __i , typename _Head , typename ... _Tail > 
constexpr const _Head & 
__get_helper (const _Tuple_impl < __i , _Head , _Tail ... > & __t) noexcept 
{ return _Tuple_impl < __i , _Head , _Tail ... > :: _M_head (__t) ; } 


template < std :: size_t __i , typename ... _Elements > 
constexpr __tuple_element_t < __i , tuple < _Elements ... > > & 
get (tuple < _Elements ... > & __t) noexcept 
{ return std :: __get_helper < __i > (__t) ; } 


template < std :: size_t __i , typename ... _Elements > 
constexpr const __tuple_element_t < __i , tuple < _Elements ... > > & 
get (const tuple < _Elements ... > & __t) noexcept 
{ return std :: __get_helper < __i > (__t) ; } 


template < std :: size_t __i , typename ... _Elements > 
constexpr __tuple_element_t < __i , tuple < _Elements ... > > && 
get (tuple < _Elements ... > && __t) noexcept 
{ 
typedef __tuple_element_t < __i , tuple < _Elements ... >> __element_type ; 
return std :: forward < __element_type && > (std :: get < __i > (__t)) ; 
} 


template < std :: size_t __i , typename ... _Elements > 
constexpr const __tuple_element_t < __i , tuple < _Elements ... > > && 
get (const tuple < _Elements ... > && __t) noexcept 
{ 
typedef __tuple_element_t < __i , tuple < _Elements ... >> __element_type ; 
return std :: forward < const __element_type && > (std :: get < __i > (__t)) ; 
} 
# 1388 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
template < typename _Tp , typename _Up , size_t __i , size_t __size > 
struct __tuple_compare 
{ 
static constexpr bool 
__eq (const _Tp & __t , const _Up & __u) 
{ 
return bool (std :: get < __i > (__t) == std :: get < __i > (__u)) 
&& __tuple_compare < _Tp , _Up , __i + 1 , __size > :: __eq (__t , __u) ; 
} 

static constexpr bool 
__less (const _Tp & __t , const _Up & __u) 
{ 
return bool (std :: get < __i > (__t) < std :: get < __i > (__u)) 
|| (! bool (std :: get < __i > (__u) < std :: get < __i > (__t)) 
&& __tuple_compare < _Tp , _Up , __i + 1 , __size > :: __less (__t , __u)) ; 
} 
} ;

template < typename _Tp , typename _Up , size_t __size > 
struct __tuple_compare < _Tp , _Up , __size , __size > 
{ 
static constexpr bool 
__eq (const _Tp & , const _Up &) { return true ; } 

static constexpr bool 
__less (const _Tp & , const _Up &) { return false ; } 
} ;

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator == (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ 
static_assert (sizeof ... (_TElements) == sizeof ... (_UElements) , 
"tuple objects can only be compared if they have equal sizes.") ; 
using __compare = __tuple_compare < tuple < _TElements ... > , 
tuple < _UElements ... > , 
0 , sizeof ... (_TElements) > ; 
return __compare :: __eq (__t , __u) ; 
} 

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator < (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ 
static_assert (sizeof ... (_TElements) == sizeof ... (_UElements) , 
"tuple objects can only be compared if they have equal sizes.") ; 
using __compare = __tuple_compare < tuple < _TElements ... > , 
tuple < _UElements ... > , 
0 , sizeof ... (_TElements) > ; 
return __compare :: __less (__t , __u) ; 
} 

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator != (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__t == __u) ; } 

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator > (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return __u < __t ; } 

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator <= (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__u < __t) ; } 

template < typename ... _TElements , typename ... _UElements > 
constexpr bool 
operator >= (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__t < __u) ; } 


template < typename ... _Elements > 
constexpr tuple < typename __decay_and_strip < _Elements > :: __type ... > 
make_tuple (_Elements && ... __args) 
{ 
typedef tuple < typename __decay_and_strip < _Elements > :: __type ... > 
__result_type ; 
return __result_type (std :: forward < _Elements > (__args) ...) ; 
} 




template < typename ... _Elements > 
constexpr tuple < _Elements && ... > 
forward_as_tuple (_Elements && ... __args) noexcept 
{ return tuple < _Elements && ... > (std :: forward < _Elements > (__args) ...) ; } 

template < size_t, typename, typename, size_t >
    struct __make_tuple_impl;

template < size_t _Idx , typename _Tuple , typename ... _Tp , size_t _Nm > 
struct __make_tuple_impl < _Idx , tuple < _Tp ... > , _Tuple , _Nm > 
: __make_tuple_impl < _Idx + 1 , 
tuple < _Tp ... , __tuple_element_t < _Idx , _Tuple > > , 
_Tuple , _Nm > 
{ } ;

template < std :: size_t _Nm , typename _Tuple , typename ... _Tp > 
struct __make_tuple_impl < _Nm , tuple < _Tp ... > , _Tuple , _Nm > 
{ 
typedef tuple < _Tp ... > __type ; 
} ;

template < typename _Tuple > 
struct __do_make_tuple 
: __make_tuple_impl < 0 , tuple < > , _Tuple , std :: tuple_size < _Tuple > :: value > 
{ } ;


template < typename _Tuple > 
struct __make_tuple 
: public __do_make_tuple < __remove_cvref_t < _Tuple > > 
{ } ;


template < typename ... >
    struct __combine_tuples;


template<> struct __combine_tuples< >  { 

typedef tuple< >  __type; 
}; 

template < typename ... _Ts > 
struct __combine_tuples < tuple < _Ts ... > > 
{ 
typedef tuple < _Ts ... > __type ; 
} ;

template < typename ... _T1s , typename ... _T2s , typename ... _Rem > 
struct __combine_tuples < tuple < _T1s ... > , tuple < _T2s ... > , _Rem ... > 
{ 
typedef typename __combine_tuples < tuple < _T1s ... , _T2s ... > , 
_Rem ... > :: __type __type ; 
} ;


template < typename ... _Tpls > 
struct __tuple_cat_result 
{ 
typedef typename __combine_tuples 
< typename __make_tuple < _Tpls > :: __type ... > :: __type __type ; 
} ;



template < typename ... >
    struct __make_1st_indices;


template<> struct __make_1st_indices< >  { 

typedef _Index_tuple< >  __type; 
}; 

template < typename _Tp , typename ... _Tpls > 
struct __make_1st_indices < _Tp , _Tpls ... > 
{ 
typedef typename std :: _Build_index_tuple < std :: tuple_size < 
typename std :: remove_reference < _Tp > :: type > :: value > :: __type __type ; 
} ;




template < typename _Ret, typename _Indices, typename ... _Tpls >
    struct __tuple_concater;

template < typename _Ret , std :: size_t ... _Is , typename _Tp , typename ... _Tpls > 
struct __tuple_concater < _Ret , std :: _Index_tuple < _Is ... > , _Tp , _Tpls ... > 
{ 
template < typename ... _Us > 
static constexpr _Ret 
_S_do (_Tp && __tp , _Tpls && ... __tps , _Us && ... __us) 
{ 
typedef typename __make_1st_indices < _Tpls ... > :: __type __idx ; 
typedef __tuple_concater < _Ret , __idx , _Tpls ... > __next ; 
return __next :: _S_do (std :: forward < _Tpls > (__tps) ... , 
std :: forward < _Us > (__us) ... , 
std :: get < _Is > (std :: forward < _Tp > (__tp)) ...) ; 
} 
} ;

template < typename _Ret > 
struct __tuple_concater < _Ret , std :: _Index_tuple < > > 
{ 
template < typename ... _Us > 
static constexpr _Ret 
_S_do (_Us && ... __us) 
{ 
return _Ret (std :: forward < _Us > (__us) ...) ; 
} 
} ;


template < typename ... _Tpls , typename = typename 
enable_if < __and_ < __is_tuple_like < _Tpls > ... > :: value > :: type > 
constexpr auto 
tuple_cat (_Tpls && ... __tpls) 
-> typename __tuple_cat_result < _Tpls ... > :: __type 
{ 
typedef typename __tuple_cat_result < _Tpls ... > :: __type __ret ; 
typedef typename __make_1st_indices < _Tpls ... > :: __type __idx ; 
typedef __tuple_concater < __ret , __idx , _Tpls ... > __concater ; 
return __concater :: _S_do (std :: forward < _Tpls > (__tpls) ...) ; 
} 




template < typename ... _Elements > 
constexpr tuple < _Elements & ... > 
tie (_Elements & ... __args) noexcept 
{ return tuple < _Elements & ... > (__args ...) ; } 


template < typename ... _Elements > 
inline 


typename enable_if < __and_ < __is_swappable < _Elements > ... > :: value 
> :: type 



swap (tuple < _Elements ... > & __x , tuple < _Elements ... > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 


template < typename ... _Elements > 
typename enable_if < ! __and_ < __is_swappable < _Elements > ... > :: value > :: type 
swap (tuple < _Elements ... > & , tuple < _Elements ... > &) = delete ; ;
# 1638
struct _Swallow_assign { 

template < class _Tp > 
const _Swallow_assign & 
operator = (const _Tp &) const 
{ return * this ; } 
}; 



constexpr _Swallow_assign ignore{}; 


template < typename ... _Types , typename _Alloc > 
struct uses_allocator < tuple < _Types ... > , _Alloc > : true_type { } ;


template < class _T1 , class _T2 > 
template < typename ... _Args1 , typename ... _Args2 > 
inline 
pair < _T1 , _T2 > :: 
pair (piecewise_construct_t , 
tuple < _Args1 ... > __first , tuple < _Args2 ... > __second) 
: pair (__first , __second , 
typename _Build_index_tuple < sizeof ... (_Args1) > :: __type () , 
typename _Build_index_tuple < sizeof ... (_Args2) > :: __type ()) 
{ } 

template < class _T1 , class _T2 > 
template < typename ... _Args1 , std :: size_t ... _Indexes1 , 
typename ... _Args2 , std :: size_t ... _Indexes2 > 
inline 
pair < _T1 , _T2 > :: 
pair (tuple < _Args1 ... > & __tuple1 , tuple < _Args2 ... > & __tuple2 , 
_Index_tuple < _Indexes1 ... > , _Index_tuple < _Indexes2 ... >) 
: first (std :: forward < _Args1 > (std :: get < _Indexes1 > (__tuple1)) ...) , 
second (std :: forward < _Args2 > (std :: get < _Indexes2 > (__tuple2)) ...) 
{ } 
# 1719 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tuple" 3
}
# 39 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tr1\\tuple" 3
namespace std { 



namespace tr1 { 


template < typename _Tp > 
struct __add_c_ref 
{ typedef const _Tp & type ; } ;

template < typename _Tp > 
struct __add_c_ref < _Tp & > 
{ typedef _Tp & type ; } ;


template < typename _Tp > 
struct __add_ref 
{ typedef _Tp & type ; } ;

template < typename _Tp > 
struct __add_ref < _Tp & > 
{ typedef _Tp & type ; } ;
# 71 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\tr1\\tuple" 3
template < int _Idx, typename ... _Elements >
    struct _Tuple_impl;
# 78
template < int _Idx > 
struct _Tuple_impl < _Idx > { } ;
# 86
template < int _Idx , typename _Head , typename ... _Tail > 
struct _Tuple_impl < _Idx , _Head , _Tail ... > 
: public _Tuple_impl < _Idx + 1 , _Tail ... > 
{ 
typedef _Tuple_impl < _Idx + 1 , _Tail ... > _Inherited ; 

_Head _M_head ; 

_Inherited & _M_tail () { return * this ; } 
const _Inherited & _M_tail () const { return * this ; } 

_Tuple_impl () : _Inherited () , _M_head () { } 

explicit 
_Tuple_impl (typename __add_c_ref < _Head > :: type __head , 
typename __add_c_ref < _Tail > :: type ... __tail) 
: _Inherited (__tail ...) , _M_head (__head) { } 

template < typename ... _UElements > 
_Tuple_impl (const _Tuple_impl < _Idx , _UElements ... > & __in) 
: _Inherited (__in . _M_tail ()) , _M_head (__in . _M_head) { } 

_Tuple_impl (const _Tuple_impl & __in) 
: _Inherited (__in . _M_tail ()) , _M_head (__in . _M_head) { } 

template < typename ... _UElements > 
_Tuple_impl & 
operator = (const _Tuple_impl < _Idx , _UElements ... > & __in) 
{ 
_M_head = __in . _M_head ; 
_M_tail () = __in . _M_tail () ; 
return * this ; 
} 

_Tuple_impl & 
operator = (const _Tuple_impl & __in) 
{ 
_M_head = __in . _M_head ; 
_M_tail () = __in . _M_tail () ; 
return * this ; 
} 
} ;

template < typename ... _Elements > 
class tuple : public _Tuple_impl < 0 , _Elements ... > 
{ 
typedef _Tuple_impl < 0 , _Elements ... > _Inherited ; 

public : 
tuple () : _Inherited () { } 

explicit 
tuple (typename __add_c_ref < _Elements > :: type ... __elements) 
: _Inherited (__elements ...) { } 

template < typename ... _UElements > 
tuple (const tuple < _UElements ... > & __in) 
: _Inherited (__in) { } 

tuple (const tuple & __in) 
: _Inherited (__in) { } 

template < typename ... _UElements > 
tuple & 
operator = (const tuple < _UElements ... > & __in) 
{ 
static_cast < _Inherited & > (* this) = __in ; 
return * this ; 
} 

tuple & 
operator = (const tuple & __in) 
{ 
static_cast < _Inherited & > (* this) = __in ; 
return * this ; 
} 
} ;

template<> class tuple< >  { }; 


template < typename _T1 , typename _T2 > 
class tuple < _T1 , _T2 > : public _Tuple_impl < 0 , _T1 , _T2 > 
{ 
typedef _Tuple_impl < 0 , _T1 , _T2 > _Inherited ; 

public : 
tuple () : _Inherited () { } 

explicit 
tuple (typename __add_c_ref < _T1 > :: type __a1 , 
typename __add_c_ref < _T2 > :: type __a2) 
: _Inherited (__a1 , __a2) { } 

template < typename _U1 , typename _U2 > 
tuple (const tuple < _U1 , _U2 > & __in) 
: _Inherited (__in) { } 

tuple (const tuple & __in) 
: _Inherited (__in) { } 

template < typename _U1 , typename _U2 > 
tuple (const pair < _U1 , _U2 > & __in) 
: _Inherited (_Tuple_impl < 0 , 
typename __add_c_ref < _U1 > :: type , 
typename __add_c_ref < _U2 > :: type > (__in . first , 
__in . second)) 
{ } 

template < typename _U1 , typename _U2 > 
tuple & 
operator = (const tuple < _U1 , _U2 > & __in) 
{ 
static_cast < _Inherited & > (* this) = __in ; 
return * this ; 
} 

tuple & 
operator = (const tuple & __in) 
{ 
static_cast < _Inherited & > (* this) = __in ; 
return * this ; 
} 

template < typename _U1 , typename _U2 > 
tuple & 
operator = (const pair < _U1 , _U2 > & __in) 
{ 
this -> _M_head = __in . first ; 
this -> _M_tail () . _M_head = __in . second ; 
return * this ; 
} 
} ;



template < int __i, typename _Tp >
    struct tuple_element;
# 229
template < int __i , typename _Head , typename ... _Tail > 
struct tuple_element < __i , tuple < _Head , _Tail ... > > 
: tuple_element < __i - 1 , tuple < _Tail ... > > { } ;




template < typename _Head , typename ... _Tail > 
struct tuple_element < 0 , tuple < _Head , _Tail ... > > 
{ 
typedef _Head type ; 
} ;


template < typename _Tp >
    struct tuple_size;


template < typename ... _Elements > 
struct tuple_size < tuple < _Elements ... > > 
{ 
static const int value = sizeof ... (_Elements) ; 
} ;

template < typename ... _Elements >
    const int tuple_size < tuple < _Elements ... > > :: value;

template < int __i , typename _Head , typename ... _Tail > 
inline typename __add_ref < _Head > :: type 
__get_helper (_Tuple_impl < __i , _Head , _Tail ... > & __t) 
{ 
return __t . _M_head ; 
} 

template < int __i , typename _Head , typename ... _Tail > 
inline typename __add_c_ref < _Head > :: type 
__get_helper (const _Tuple_impl < __i , _Head , _Tail ... > & __t) 
{ 
return __t . _M_head ; 
} 



template < int __i , typename ... _Elements > 
inline typename __add_ref < 
typename tuple_element < __i , tuple < _Elements ... > > :: type 
> :: type 
get (tuple < _Elements ... > & __t) 
{ 
return __get_helper < __i > (__t) ; 
} 

template < int __i , typename ... _Elements > 
inline typename __add_c_ref < 
typename tuple_element < __i , tuple < _Elements ... > > :: type 
> :: type 
get (const tuple < _Elements ... > & __t) 
{ 
return __get_helper < __i > (__t) ; 
} 


template < int __check_equal_size, int __i, int __j,
    typename _Tp, typename _Up >
    struct __tuple_compare;

template < int __i , int __j , typename _Tp , typename _Up > 
struct __tuple_compare < 0 , __i , __j , _Tp , _Up > 
{ 
static bool __eq (const _Tp & __t , const _Up & __u) 
{ 
return (get < __i > (__t) == get < __i > (__u) && 
__tuple_compare < 0 , __i + 1 , __j , _Tp , _Up > :: __eq (__t , __u)) ; 
} 

static bool __less (const _Tp & __t , const _Up & __u) 
{ 
return ((get < __i > (__t) < get < __i > (__u)) 
|| ! (get < __i > (__u) < get < __i > (__t)) && 
__tuple_compare < 0 , __i + 1 , __j , _Tp , _Up > :: __less (__t , __u)) ; 
} 
} ;

template < int __i , typename _Tp , typename _Up > 
struct __tuple_compare < 0 , __i , __i , _Tp , _Up > 
{ 
static bool __eq (const _Tp & , const _Up &) 
{ return true ; } 

static bool __less (const _Tp & , const _Up &) 
{ return false ; } 
} ;

template < typename ... _TElements , typename ... _UElements > 
bool 
operator == (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ 
typedef tuple < _TElements ... > _Tp ; 
typedef tuple < _UElements ... > _Up ; 
return (__tuple_compare < tuple_size < _Tp > :: value - tuple_size < _Up > :: value , 
0 , tuple_size < _Tp > :: value , _Tp , _Up > :: __eq (__t , __u)) ; 
} 

template < typename ... _TElements , typename ... _UElements > 
bool 
operator < (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ 
typedef tuple < _TElements ... > _Tp ; 
typedef tuple < _UElements ... > _Up ; 
return (__tuple_compare < tuple_size < _Tp > :: value - tuple_size < _Up > :: value , 
0 , tuple_size < _Tp > :: value , _Tp , _Up > :: __less (__t , __u)) ; 
} 

template < typename ... _TElements , typename ... _UElements > 
inline bool 
operator != (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__t == __u) ; } 

template < typename ... _TElements , typename ... _UElements > 
inline bool 
operator > (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return __u < __t ; } 

template < typename ... _TElements , typename ... _UElements > 
inline bool 
operator <= (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__u < __t) ; } 

template < typename ... _TElements , typename ... _UElements > 
inline bool 
operator >= (const tuple < _TElements ... > & __t , 
const tuple < _UElements ... > & __u) 
{ return ! (__t < __u) ; } 

template < typename _Tp >
    class reference_wrapper;


template < typename _Tp > 
struct __strip_reference_wrapper 
{ 
typedef _Tp __type ; 
} ;

template < typename _Tp > 
struct __strip_reference_wrapper < reference_wrapper < _Tp > > 
{ 
typedef _Tp & __type ; 
} ;

template < typename _Tp > 
struct __strip_reference_wrapper < const reference_wrapper < _Tp > > 
{ 
typedef _Tp & __type ; 
} ;

template < typename ... _Elements > 
inline tuple < typename __strip_reference_wrapper < _Elements > :: __type ... > 
make_tuple (_Elements ... __args) 
{ 
typedef tuple < typename __strip_reference_wrapper < _Elements > :: __type ... > 
__result_type ; 
return __result_type (__args ...) ; 
} 

template < typename ... _Elements > 
inline tuple < _Elements & ... > 
tie (_Elements & ... __args) 
{ 
return tuple < _Elements & ... > (__args ...) ; 
} 



struct _Swallow_assign { 

template < class _Tp > 
_Swallow_assign & 
operator = (const _Tp &) 
{ return * this ; } 
}; 



namespace { 
_Swallow_assign ignore; 
}
}


}
# 1059 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
namespace testing { 

class Message; 
# 1067
using std::get;
using std::make_tuple;
using std::tuple;
using std::tuple_size;
using std::tuple_element;


namespace internal { 




class Secret; 
# 1154 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename T1, typename T2 >
struct StaticAssertTypeEqHelper;

template < typename T > 
struct StaticAssertTypeEqHelper < T , T > { 
enum { value = true } ; 
} ;


template < typename T , typename U > 
struct IsSame { 
enum { value = false } ; 
} ;
template < typename T > 
struct IsSame < T , T > { 
enum { value = true } ; 
} ;
# 1178
typedef std::string string; 
# 1184
typedef std::wstring wstring; 




__attribute((visibility("default"))) bool IsTrue(bool condition); 
# 1195
template < typename T > 
class scoped_ptr { 
public : 
typedef T element_type ; 

explicit scoped_ptr (T * p = nullptr) : ptr_ (p) { } 
~ scoped_ptr () { reset () ; } 

T & operator * () const { return * ptr_ ; } 
T * operator -> () const { return ptr_ ; } 
T * get () const { return ptr_ ; } 

T * release () { 
T * const ptr = ptr_ ; 
ptr_ = nullptr ; 
return ptr ; 
} 

void reset (T * p = nullptr) { 
if (p != ptr_) { 
if (IsTrue (sizeof (T) > 0)) { 
delete ptr_ ; 
} 
ptr_ = p ; 
} 
} 

friend void swap (scoped_ptr & a , scoped_ptr & b) { 
using std :: swap ; 
swap (a . ptr_ , b . ptr_) ; 
} 

private : 
T * ptr_ ; 

scoped_ptr (scoped_ptr const &) = delete ; void operator = (scoped_ptr const &) = delete ; 
} ;
# 1241 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
class __attribute((visibility("default"))) RE { 



public: RE(const RE &other) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1 + 0 + 1U - 1);this->Init(other.pattern()); } 


RE(const std::string &regex) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2 + 0 + 1U - 1);this->Init(regex.c_str()); } 
# 1256
RE(const char *regex) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(3 + 0 + 1U - 1);this->Init(regex); } 
~RE(); 


const char *pattern() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(4 + 0 + 1U - 1);return pattern_; } 
# 1269 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
static bool FullMatch(const std::string &str, const RE &re) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(5 + 0 + 1U - 1);
return FullMatch(str.c_str(), re); 
} 
static bool PartialMatch(const std::string &str, const RE &re) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(6 + 0 + 1U - 1);
return PartialMatch(str.c_str(), re); 
} 
# 1287 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
static bool FullMatch(const char * str, const RE & re); 
static bool PartialMatch(const char * str, const RE & re); 


private: void Init(const char * regex); 




const char *pattern_; 
bool is_valid_; 
# 1306 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
const char *full_pattern_; 



void operator=(const RE &) = delete;
}; 
# 1317
__attribute((visibility("default"))) std::string FormatFileLocation(const char * file, int line); 




__attribute((visibility("default"))) std::string FormatCompilerIndependentFileLocation(const char * file, int line); 
# 1331
enum GTestLogSeverity { 
GTEST_INFO, 
GTEST_WARNING, 
GTEST_ERROR, 
GTEST_FATAL
}; 




class __attribute((visibility("default"))) GTestLog { 

public: GTestLog(GTestLogSeverity severity, const char * file, int line); 


~GTestLog(); 

std::ostream &GetStream() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(7 + 0 + 1U - 1);return ::std::cerr; } 


private: const GTestLogSeverity severity_; 

GTestLog(const GTestLog &) = delete;void operator=(const GTestLog &) = delete;
}; 
# 1362
inline void LogToStderr() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(8 + 0 + 1U - 1);} 
inline void FlushInfoLog() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(9 + 0 + 1U - 1);fflush(nullptr); } 
# 1403 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename T > 
struct AddReference { typedef T & type ; } ;
template < typename T > 
struct AddReference < T & > { typedef T & type ; } ;
# 1424 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename T > 
struct ConstRef { typedef const T & type ; } ;
template < typename T > 
struct ConstRef < T & > { typedef T & type ; } ;
# 1434
using std::forward;
using std::move;

template < typename T > 
struct RvalueRef { 
typedef T && type ; 
} ;
# 1475 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename To > 
inline To ImplicitCast_ (To x) { return x ; } 
# 1499 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename To , typename From > 
inline To DownCast_ (From * f) { 
# 1506
if (false) { 

const To to = 
# 1508 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h" 3
__null 
# 1508 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
; 
:: testing :: internal :: ImplicitCast_ < From * > (to) ; 
} 



switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (f == nullptr || dynamic_cast < To > (f) != 
# 1514 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h" 3
__null 
# 1514 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
)) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h" , 1514) . GetStream () << "Condition " "f == nullptr || dynamic_cast<To>(f) != NULL" " failed. " ; 

return static_cast < To > (f) ; 
} 
# 1524
template < class Derived , class Base > 
Derived * CheckedDowncastToActualType (Base * base) { 

switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (typeid (* base) == typeid (Derived))) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h" , 1527) . GetStream () << "Condition " "typeid(*base) == typeid(Derived)" " failed. " ; 
# 1533
return dynamic_cast < Derived * > (base) ; 



} 
# 1547 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
__attribute((visibility("default"))) void CaptureStdout(); 
__attribute((visibility("default"))) std::string GetCapturedStdout(); 
__attribute((visibility("default"))) void CaptureStderr(); 
__attribute((visibility("default"))) std::string GetCapturedStderr(); 



__attribute((visibility("default"))) size_t GetFileSize(FILE * file); 


__attribute((visibility("default"))) std::string ReadEntireFile(FILE * file); 


__attribute((visibility("default"))) std::vector< std::__cxx11::basic_string< char> >  GetArgvs(); 



std::vector< std::__cxx11::basic_string< char> >  GetInjectableArgvs(); 

void SetInjectableArgvs(const std::vector< std::__cxx11::basic_string< char> >  * new_argvs); 
void SetInjectableArgvs(const std::vector< std::__cxx11::basic_string< char> >  & new_argvs); 



void ClearInjectableArgvs(); 
# 1640 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
__attribute((visibility("default"))) void SleepMilliseconds(int n); 



class __attribute((visibility("default"))) AutoHandle { 
# 1651
public: typedef void *Handle; 
AutoHandle(); 
explicit AutoHandle(Handle handle); 

~AutoHandle(); 

Handle Get() const; 
void Reset(); 
void Reset(Handle handle); 



private: bool IsCloseable() const; 

Handle handle_; 

AutoHandle(const AutoHandle &) = delete;void operator=(const AutoHandle &) = delete;
}; 
# 1676
class __attribute((visibility("default"))) Notification { 

public: Notification(); 
void Notify(); 
void WaitForNotification(); 


private: AutoHandle event_; 

Notification(const Notification &) = delete;void operator=(const Notification &) = delete;
}; 
# 1792 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
class __attribute((visibility("default"))) Mutex { 

public: enum MutexType { kStatic, kDynamic}; 



enum StaticConstructorSelector { kStaticMutex}; 




explicit Mutex(StaticConstructorSelector) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(10 + 0 + 1U - 1);} 

Mutex(); 
~Mutex(); 

void Lock(); 

void Unlock(); 



void AssertHeld(); 



private: void ThreadSafeLazyInit(); 



unsigned owner_thread_id_; 



MutexType type_; 
long critical_section_init_phase_; 
GTEST_CRITICAL_SECTION *critical_section_; 

Mutex(const Mutex &) = delete;void operator=(const Mutex &) = delete;
}; 
# 1844 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
class GTestMutexLock { 

public: explicit GTestMutexLock(Mutex *mutex) : mutex_(mutex) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(11 + 0 + 1U - 1);(mutex_)->Lock(); } 

~GTestMutexLock() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(12 + 0 + 1U - 1);(mutex_)->Unlock(); } 


private: Mutex *const mutex_; 

GTestMutexLock(const GTestMutexLock &) = delete;void operator=(const GTestMutexLock &) = delete;
}; 

typedef GTestMutexLock MutexLock; 



class ThreadLocalValueHolderBase { 

public: virtual ~ThreadLocalValueHolderBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(13 + 0 + 1U - 1);} 
}; 



class ThreadLocalBase { 
# 1874
public: virtual ThreadLocalValueHolderBase *NewValueForCurrentThread() const = 0; 


protected: ThreadLocalBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(14 + 0 + 1U - 1);} 
virtual ~ThreadLocalBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(15 + 0 + 1U - 1);} 


private: ThreadLocalBase(const ThreadLocalBase &) = delete;void operator=(const ThreadLocalBase &) = delete;
}; 




class __attribute((visibility("default"))) ThreadLocalRegistry { 



public: static ThreadLocalValueHolderBase *GetValueOnCurrentThread(const ThreadLocalBase * thread_local_instance); 



static void OnThreadLocalDestroyed(const ThreadLocalBase * thread_local_instance); 

}; 

class __attribute((visibility("default"))) ThreadWithParamBase { 

public: void Join(); 


protected: class Runnable { 

public: virtual ~Runnable() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(16 + 0 + 1U - 1);} 
virtual void Run() = 0; 
}; 

ThreadWithParamBase(Runnable * runnable, Notification * thread_can_start); 
virtual ~ThreadWithParamBase(); 


private: AutoHandle thread_; 
}; 


template < typename T > 
class ThreadWithParam : public ThreadWithParamBase { 
public : 
typedef void UserThreadFunc (T) ; 

ThreadWithParam (UserThreadFunc * func , T param , Notification * thread_can_start) 
: ThreadWithParamBase (new RunnableImpl (func , param) , thread_can_start) { 
} 
virtual ~ ThreadWithParam () { } 

private : 
class RunnableImpl : public Runnable { 
public : 
RunnableImpl (UserThreadFunc * func , T param) 
: func_ (func) , 
param_ (param) { 
} 
virtual ~ RunnableImpl () { } 
virtual void Run () { 
func_ (param_) ; 
} 

private : 
UserThreadFunc * const func_ ; 
const T param_ ; 

RunnableImpl (RunnableImpl const &) = delete ; void operator = (RunnableImpl const &) = delete ; 
} ; 

ThreadWithParam (ThreadWithParam const &) = delete ; void operator = (ThreadWithParam const &) = delete ; 
} ;
# 1977 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < typename T > 
class ThreadLocal : public ThreadLocalBase { 
public : 
ThreadLocal () : default_factory_ (new DefaultValueHolderFactory ()) { } 
explicit ThreadLocal (const T & value) 
: default_factory_ (new InstanceValueHolderFactory (value)) { } 

~ ThreadLocal () { ThreadLocalRegistry :: OnThreadLocalDestroyed (this) ; } 

T * pointer () { return GetOrCreateValue () ; } 
const T * pointer () const { return GetOrCreateValue () ; } 
const T & get () const { return * pointer () ; } 
void set (const T & value) { * pointer () = value ; } 

private : 


class ValueHolder : public ThreadLocalValueHolderBase { 
public : 
ValueHolder () : value_ () { } 
explicit ValueHolder (const T & value) : value_ (value) { } 

T * pointer () { return & value_ ; } 

private : 
T value_ ; 
ValueHolder (ValueHolder const &) = delete ; void operator = (ValueHolder const &) = delete ; 
} ; 


T * GetOrCreateValue () const { 
return static_cast < ValueHolder * > (
ThreadLocalRegistry :: GetValueOnCurrentThread (this)) -> pointer () ; 
} 

virtual ThreadLocalValueHolderBase * NewValueForCurrentThread () const { 
return default_factory_ -> MakeNewHolder () ; 
} 

class ValueHolderFactory { 
public : 
ValueHolderFactory () { } 
virtual ~ ValueHolderFactory () { } 
virtual ValueHolder * MakeNewHolder () const = 0 ; 

private : 
ValueHolderFactory (ValueHolderFactory const &) = delete ; void operator = (ValueHolderFactory const &) = delete ; 
} ; 

class DefaultValueHolderFactory : public ValueHolderFactory { 
public : 
DefaultValueHolderFactory () { } 
virtual ValueHolder * MakeNewHolder () const { return new ValueHolder () ; } 

private : 
DefaultValueHolderFactory (DefaultValueHolderFactory const &) = delete ; void operator = (DefaultValueHolderFactory const &) = delete ; 
} ; 

class InstanceValueHolderFactory : public ValueHolderFactory { 
public : 
explicit InstanceValueHolderFactory (const T & value) : value_ (value) { } 
virtual ValueHolder * MakeNewHolder () const { 
return new ValueHolder (value_) ; 
} 

private : 
const T value_ ; 

InstanceValueHolderFactory (InstanceValueHolderFactory const &) = delete ; void operator = (InstanceValueHolderFactory const &) = delete ; 
} ; 

scoped_ptr < ValueHolderFactory > default_factory_ ; 

ThreadLocal (ThreadLocal const &) = delete ; void operator = (ThreadLocal const &) = delete ; 
} ;
# 2315 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
__attribute((visibility("default"))) size_t GetThreadCount(); 
# 2340 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < bool bool_value > 
struct bool_constant { 
typedef bool_constant < bool_value > type ; 
static const bool value = bool_value ; 
} ;
template < bool bool_value > const bool bool_constant < bool_value > :: value;

typedef bool_constant< false>  false_type; 
typedef bool_constant< true>  true_type; 

template < typename T , typename U > 
struct is_same : public false_type { } ;

template < typename T > 
struct is_same < T , T > : public true_type { } ;


template < typename T > 
struct is_pointer : public false_type { } ;

template < typename T > 
struct is_pointer < T * > : public true_type { } ;

template < typename Iterator > 
struct IteratorTraits { 
typedef typename Iterator :: value_type value_type ; 
} ;


template < typename T > 
struct IteratorTraits < T * > { 
typedef T value_type ; 
} ;

template < typename T > 
struct IteratorTraits < const T * > { 
typedef T value_type ; 
} ;
# 2383 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
typedef long long BiggestInt; 
# 2397 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
inline bool IsAlpha(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(17 + 0 + 1U - 1);
return isalpha(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsAlNum(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(18 + 0 + 1U - 1);
return isalnum(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsDigit(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(19 + 0 + 1U - 1);
return isdigit(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsLower(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(20 + 0 + 1U - 1);
return islower(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsSpace(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(21 + 0 + 1U - 1);
return isspace(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsUpper(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(22 + 0 + 1U - 1);
return isupper(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsXDigit(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(23 + 0 + 1U - 1);
return isxdigit(static_cast< unsigned char>(ch)) != 0; 
} 
inline bool IsXDigit(wchar_t ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(24 + 0 + 1U - 1);
const unsigned char low_byte = static_cast< unsigned char>(ch); cpptestFastCoverageStmt(24 + 0 + 2U - 1);
return ch == low_byte && isxdigit(low_byte) != 0; 
} 

inline char ToLower(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(26 + 0 + 1U - 1);
return static_cast< char>(tolower(static_cast< unsigned char>(ch))); 
} 
inline char ToUpper(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(27 + 0 + 1U - 1);
return static_cast< char>(toupper(static_cast< unsigned char>(ch))); 
} 

inline std::string StripTrailingSpaces(std::string str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(28 + 0 + 1U - 1);
std::__cxx11::basic_string< char> ::iterator it = str.end(); 
while (((void)cpptestFastCoverageStmt(28 + 0 + 2U - 1), (it != str.begin()) && IsSpace((*(--it))))) {cpptestFastCoverageStmt(28 + 0 + 3U - 1);
it = str.erase(it); }  cpptestFastCoverageStmt(28 + 0 + 4U - 1);
return str; 
} 
# 2443
namespace posix { 
# 2449
typedef struct _stat StatStruct; 
# 2461 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
inline int IsATTY(int fd) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(32 + 0 + 1U - 1);return _isatty(fd); } 

inline int StrCaseCmp(const char *s1, const char *s2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(33 + 0 + 1U - 1);
return _stricmp(s1, s2); 
} 
inline char *StrDup(const char *src) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(34 + 0 + 1U - 1);return _strdup(src); } 
# 2474
inline int FileNo(FILE *file) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(35 + 0 + 1U - 1);return ((file)->_file); 
# 2474 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
} 
inline int Stat(const char *path, StatStruct *buf) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(36 + 0 + 1U - 1);return _stat(path, buf); } 
inline int RmDir(const char *dir) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(37 + 0 + 1U - 1);return _rmdir(dir); } 
inline bool IsDir(const StatStruct &st) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(38 + 0 + 1U - 1);
return (0x4000 & st.st_mode) != 0; 
# 2479 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
} 
# 2502 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
inline const char *StrNCpy(char *dest, const char *src, size_t n) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(39 + 0 + 1U - 1);
return strncpy(dest, src, n); 
} 
# 2511
inline int ChDir(const char *dir) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(40 + 0 + 1U - 1);return chdir(dir); } 

inline FILE *FOpen(const char *path, const char *mode) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(41 + 0 + 1U - 1);
return fopen(path, mode); 
} 

inline FILE *FReopen(const char *path, const char *mode, FILE *stream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(42 + 0 + 1U - 1);
return freopen(path, mode, stream); 
} 
inline FILE *FDOpen(int fd, const char *mode) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(43 + 0 + 1U - 1);return fdopen(fd, mode); } 

inline int FClose(FILE *fp) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(44 + 0 + 1U - 1);return fclose(fp); } 

inline int Read(int fd, void *buf, unsigned count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(45 + 0 + 1U - 1);
return static_cast< int>(read(fd, buf, count)); 
} 
inline int Write(int fd, const void *buf, unsigned count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(46 + 0 + 1U - 1);
return static_cast< int>(write(fd, buf, count)); 
} 
inline int Close(int fd) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(47 + 0 + 1U - 1);return close(fd); } 
inline const char *StrError(int errnum) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(48 + 0 + 1U - 1);return strerror(errnum); } 

inline const char *GetEnv(const char *name) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(49 + 0 + 1U - 1);
# 2544 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
return getenv(name); 

} 
# 2556
inline void Abort() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(50 + 0 + 1U - 1);abort(); } 


}
# 2585 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
const BiggestInt kMaxBiggestInt = (~(static_cast< BiggestInt>(1) << (8 * sizeof(BiggestInt) - 1))); 
# 2606 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
template < size_t size > 
class TypeWithSize { 
public : 


typedef void UInt ; 
} ;



template<> class TypeWithSize< 4U>  { 
# 2622
public: typedef int Int; 
typedef unsigned UInt; 
}; 



template<> class TypeWithSize< 8U>  { 
# 2631 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
public: typedef long long Int; 
# 2632 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
typedef unsigned long long UInt; 




}; 


typedef TypeWithSize< 4U> ::Int Int32; 
typedef TypeWithSize< 4U> ::UInt UInt32; 
typedef TypeWithSize< 8U> ::Int Int64; 
typedef TypeWithSize< 8U> ::UInt UInt64; 
typedef TypeWithSize< 8U> ::Int TimeInMillis; 
# 2689 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-port.h"
bool ParseInt32(const Message & src_text, const char * str, Int32 * value); 



bool BoolFromGTestEnv(const char * flag, bool default_val); 
__attribute((visibility("default"))) Int32 Int32FromGTestEnv(const char * flag, Int32 default_val); 
std::string OutputFlagAlsoCheckEnvVar(); 
const char *StringFromGTestEnv(const char * flag, const char * default_val); 

}
}
# 141 "d:\\mingw\\mingw\\include\\float.h" 3
extern "C" {
# 147
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _controlfp(unsigned unNew, unsigned unMask); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _control87(unsigned unNew, unsigned unMask); 




__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _clearfp(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) unsigned _statusfp(); 
# 181 "d:\\mingw\\mingw\\include\\float.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void _fpreset(); 
# 189
__attribute((__cdecl__)) __attribute((__nothrow__)) inline void fpreset() __attribute((__deprecated__)); 
# 197
typedef struct __fenv_t fenv_t; 
__attribute((__cdecl__)) __attribute((__nothrow__)) int fesetenv(const fenv_t *); 


__attribute((__always_inline__)) inline void fpreset() { fesetenv((const fenv_t *)(0)); } 
# 207
__attribute((__cdecl__)) __attribute((__nothrow__)) int *__fpecode(); 




__attribute((__cdecl__)) __attribute((__nothrow__)) double _chgsign(double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double _copysign(double, double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double _logb(double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double _nextafter(double, double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double _scalb(double, long); 

__attribute((__cdecl__)) __attribute((__nothrow__)) int _finite(double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _fpclass(double); 
__attribute((__cdecl__)) __attribute((__nothrow__)) int _isnan(double); 

}
# 115 "d:\\mingw\\mingw\\include\\time.h" 3
struct timespec { 
# 124
__time64_t tv_sec; 
long tv_nsec; 
}; 


struct __mingw32_expanded_timespec { 
# 137
union { 



__time64_t __tv64_sec; 
__time32_t __tv32_sec; 
time_t tv_sec; 
}; 
long tv_nsec; 
}; 
# 155 "d:\\mingw\\mingw\\include\\time.h" 3
extern "C" {
# 165
__attribute((__always_inline__)) inline __mingw32_expanded_timespec *mingw_timespec(timespec *__tv) 
{ return (__mingw32_expanded_timespec *)(__tv); } 

}
# 183 "d:\\mingw\\mingw\\include\\time.h" 3
typedef long clock_t; 

struct tm { 
# 191
int tm_sec; 
int tm_min; 
int tm_hour; 
int tm_mday; 
int tm_mon; 
int tm_year; 
int tm_wday; 
int tm_yday; 
int tm_isdst; 
}; 

extern "C" {

__attribute((__cdecl__)) __attribute((__nothrow__)) clock_t clock(); 
# 214 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) time_t time(time_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) double difftime(time_t, time_t); 
__attribute((__cdecl__)) __attribute((__nothrow__)) time_t mktime(tm *); 
# 228 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) char *asctime(const tm *); 
# 234
__attribute((__cdecl__)) __attribute((__nothrow__)) char *ctime(const time_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) tm *gmtime(const time_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) tm *localtime(const time_t *); 



__attribute((__cdecl__)) __attribute((__nothrow__)) size_t strftime(char *, size_t, const char *, const tm *); 


__attribute((__cdecl__)) __attribute((__nothrow__)) extern void _tzset(); 


__attribute((__cdecl__)) __attribute((__nothrow__)) extern void tzset(); 


__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strdate(char *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_strtime(char *); 
# 257
__attribute((__cdecl__)) __attribute((__nothrow__)) __time64_t _time64(__time64_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) __time64_t _mktime64(tm *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) char *_ctime64(const __time64_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) tm *_gmtime64(const __time64_t *); 
__attribute((__cdecl__)) __attribute((__nothrow__)) tm *_localtime64(const __time64_t *); 
# 344 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) extern int *__p__daylight(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern long *__p__timezone(); 
__attribute((__cdecl__)) __attribute((__nothrow__)) extern char **__p__tzname(); 

__attribute((__dllimport__)) extern int _daylight; 
__attribute((__dllimport__)) extern long _timezone; 
__attribute((__dllimport__)) extern char *_tzname[2]; 
# 381 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__dllimport__)) extern int daylight; 
__attribute((__dllimport__)) extern long timezone; 
__attribute((__dllimport__)) extern char *tzname[2]; 
# 408 "d:\\mingw\\mingw\\include\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) inline int nanosleep(const timespec *, timespec *); 
# 415
__attribute((__cdecl__)) __attribute((__nothrow__)) int __mingw_sleep(unsigned long, unsigned long); 


inline int nanosleep(const timespec *period, timespec *residual) 
{ 
if (residual != (void *)(0)) 
residual->tv_sec = (__time64_t)(residual->tv_nsec = 0);   
return __mingw_sleep((unsigned)(period->tv_sec), (period->tv_sec < 0LL) ? (unsigned)(-1) : ((unsigned)(period->tv_nsec))); 

} 
# 439 "d:\\mingw\\mingw\\include\\time.h" 3
typedef struct __clockid__ *clockid_t; 
# 463 "d:\\mingw\\mingw\\include\\time.h" 3
int clock_getres(clockid_t, timespec *); 
int clock_gettime(clockid_t, timespec *); 
int clock_settime(clockid_t, const timespec *); 




}
# 58 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ctime" 3
namespace std { 

using ::clock_t;
using ::time_t;
using ::tm;

using ::clock;
using ::difftime;
using ::mktime;
using ::time;
using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;
using ::strftime;
}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
namespace std { 
# 52 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
class time_base { 


public: enum dateorder { no_order, dmy, mdy, ymd, ydm}; 
}; 

template < typename _CharT > 
struct __timepunct_cache : public locale :: facet 
{ 

static const _CharT * _S_timezones [ 14 ] ; 

const _CharT * _M_date_format ; 
const _CharT * _M_date_era_format ; 
const _CharT * _M_time_format ; 
const _CharT * _M_time_era_format ; 
const _CharT * _M_date_time_format ; 
const _CharT * _M_date_time_era_format ; 
const _CharT * _M_am ; 
const _CharT * _M_pm ; 
const _CharT * _M_am_pm_format ; 


const _CharT * _M_day1 ; 
const _CharT * _M_day2 ; 
const _CharT * _M_day3 ; 
const _CharT * _M_day4 ; 
const _CharT * _M_day5 ; 
const _CharT * _M_day6 ; 
const _CharT * _M_day7 ; 


const _CharT * _M_aday1 ; 
const _CharT * _M_aday2 ; 
const _CharT * _M_aday3 ; 
const _CharT * _M_aday4 ; 
const _CharT * _M_aday5 ; 
const _CharT * _M_aday6 ; 
const _CharT * _M_aday7 ; 


const _CharT * _M_month01 ; 
const _CharT * _M_month02 ; 
const _CharT * _M_month03 ; 
const _CharT * _M_month04 ; 
const _CharT * _M_month05 ; 
const _CharT * _M_month06 ; 
const _CharT * _M_month07 ; 
const _CharT * _M_month08 ; 
const _CharT * _M_month09 ; 
const _CharT * _M_month10 ; 
const _CharT * _M_month11 ; 
const _CharT * _M_month12 ; 


const _CharT * _M_amonth01 ; 
const _CharT * _M_amonth02 ; 
const _CharT * _M_amonth03 ; 
const _CharT * _M_amonth04 ; 
const _CharT * _M_amonth05 ; 
const _CharT * _M_amonth06 ; 
const _CharT * _M_amonth07 ; 
const _CharT * _M_amonth08 ; 
const _CharT * _M_amonth09 ; 
const _CharT * _M_amonth10 ; 
const _CharT * _M_amonth11 ; 
const _CharT * _M_amonth12 ; 

bool _M_allocated ; 

__timepunct_cache (size_t __refs = 0) : facet (__refs) , 
_M_date_format (0) , _M_date_era_format (0) , _M_time_format (0) , 
_M_time_era_format (0) , _M_date_time_format (0) , 
_M_date_time_era_format (0) , _M_am (0) , _M_pm (0) , 
_M_am_pm_format (0) , _M_day1 (0) , _M_day2 (0) , _M_day3 (0) , 
_M_day4 (0) , _M_day5 (0) , _M_day6 (0) , _M_day7 (0) , 
_M_aday1 (0) , _M_aday2 (0) , _M_aday3 (0) , _M_aday4 (0) , 
_M_aday5 (0) , _M_aday6 (0) , _M_aday7 (0) , _M_month01 (0) , 
_M_month02 (0) , _M_month03 (0) , _M_month04 (0) , _M_month05 (0) , 
_M_month06 (0) , _M_month07 (0) , _M_month08 (0) , _M_month09 (0) , 
_M_month10 (0) , _M_month11 (0) , _M_month12 (0) , _M_amonth01 (0) , 
_M_amonth02 (0) , _M_amonth03 (0) , _M_amonth04 (0) , 
_M_amonth05 (0) , _M_amonth06 (0) , _M_amonth07 (0) , 
_M_amonth08 (0) , _M_amonth09 (0) , _M_amonth10 (0) , 
_M_amonth11 (0) , _M_amonth12 (0) , _M_allocated (false) 
{ } 

~ __timepunct_cache () ; 

private : 
__timepunct_cache & 
operator = (const __timepunct_cache &) ; 

explicit 
__timepunct_cache (const __timepunct_cache &) ; 
} ;

template < typename _CharT > 
__timepunct_cache < _CharT > :: ~ __timepunct_cache () 
{ 
if (_M_allocated) 
{ 

} 
} 




template<> const char *__timepunct_cache< char> ::_S_timezones[14]; 




template<> const wchar_t *__timepunct_cache< wchar_t> ::_S_timezones[14]; 



template < typename _CharT >
    const _CharT * __timepunct_cache < _CharT > :: _S_timezones [ 14 ];

template < typename _CharT > 
class __timepunct : public locale :: facet 
{ 
public : 

typedef _CharT __char_type ; 
typedef __timepunct_cache < _CharT > __cache_type ; 

protected : 
__cache_type * _M_data ; 
__c_locale _M_c_locale_timepunct ; 
const char * _M_name_timepunct ; 

public : 

static locale :: id id ; 

explicit 
__timepunct (size_t __refs = 0) ; 

explicit 
__timepunct (__cache_type * __cache , size_t __refs = 0) ; 
# 206 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
__timepunct (__c_locale __cloc , const char * __s , size_t __refs = 0) ; 



void 
_M_put (_CharT * __s , size_t __maxlen , const _CharT * __format , 
const tm * __tm) const throw () ; 

void 
_M_date_formats (const _CharT * * __date) const 
{ 

__date [ 0 ] = _M_data -> _M_date_format ; 
__date [ 1 ] = _M_data -> _M_date_era_format ; 
} 

void 
_M_time_formats (const _CharT * * __time) const 
{ 

__time [ 0 ] = _M_data -> _M_time_format ; 
__time [ 1 ] = _M_data -> _M_time_era_format ; 
} 

void 
_M_date_time_formats (const _CharT * * __dt) const 
{ 

__dt [ 0 ] = _M_data -> _M_date_time_format ; 
__dt [ 1 ] = _M_data -> _M_date_time_era_format ; 
} 


void 
_M_am_pm_format (const _CharT *) const 
{ } 


void 
_M_am_pm (const _CharT * * __ampm) const 
{ 
__ampm [ 0 ] = _M_data -> _M_am ; 
__ampm [ 1 ] = _M_data -> _M_pm ; 
} 

void 
_M_days (const _CharT * * __days) const 
{ 
__days [ 0 ] = _M_data -> _M_day1 ; 
__days [ 1 ] = _M_data -> _M_day2 ; 
__days [ 2 ] = _M_data -> _M_day3 ; 
__days [ 3 ] = _M_data -> _M_day4 ; 
__days [ 4 ] = _M_data -> _M_day5 ; 
__days [ 5 ] = _M_data -> _M_day6 ; 
__days [ 6 ] = _M_data -> _M_day7 ; 
} 

void 
_M_days_abbreviated (const _CharT * * __days) const 
{ 
__days [ 0 ] = _M_data -> _M_aday1 ; 
__days [ 1 ] = _M_data -> _M_aday2 ; 
__days [ 2 ] = _M_data -> _M_aday3 ; 
__days [ 3 ] = _M_data -> _M_aday4 ; 
__days [ 4 ] = _M_data -> _M_aday5 ; 
__days [ 5 ] = _M_data -> _M_aday6 ; 
__days [ 6 ] = _M_data -> _M_aday7 ; 
} 

void 
_M_months (const _CharT * * __months) const 
{ 
__months [ 0 ] = _M_data -> _M_month01 ; 
__months [ 1 ] = _M_data -> _M_month02 ; 
__months [ 2 ] = _M_data -> _M_month03 ; 
__months [ 3 ] = _M_data -> _M_month04 ; 
__months [ 4 ] = _M_data -> _M_month05 ; 
__months [ 5 ] = _M_data -> _M_month06 ; 
__months [ 6 ] = _M_data -> _M_month07 ; 
__months [ 7 ] = _M_data -> _M_month08 ; 
__months [ 8 ] = _M_data -> _M_month09 ; 
__months [ 9 ] = _M_data -> _M_month10 ; 
__months [ 10 ] = _M_data -> _M_month11 ; 
__months [ 11 ] = _M_data -> _M_month12 ; 
} 

void 
_M_months_abbreviated (const _CharT * * __months) const 
{ 
__months [ 0 ] = _M_data -> _M_amonth01 ; 
__months [ 1 ] = _M_data -> _M_amonth02 ; 
__months [ 2 ] = _M_data -> _M_amonth03 ; 
__months [ 3 ] = _M_data -> _M_amonth04 ; 
__months [ 4 ] = _M_data -> _M_amonth05 ; 
__months [ 5 ] = _M_data -> _M_amonth06 ; 
__months [ 6 ] = _M_data -> _M_amonth07 ; 
__months [ 7 ] = _M_data -> _M_amonth08 ; 
__months [ 8 ] = _M_data -> _M_amonth09 ; 
__months [ 9 ] = _M_data -> _M_amonth10 ; 
__months [ 10 ] = _M_data -> _M_amonth11 ; 
__months [ 11 ] = _M_data -> _M_amonth12 ; 
} 

protected : 
virtual 
~ __timepunct () ; 


void 
_M_initialize_timepunct (__c_locale __cloc = 0) ; 
} ;

template < typename _CharT >
    locale :: id __timepunct < _CharT > :: id;




template<> void __timepunct< char> ::_M_initialize_timepunct(__c_locale __cloc); 



template<> void __timepunct< char> ::_M_put(char *, size_t, const char *, const tm *) const throw(); 




template<> void __timepunct< wchar_t> ::_M_initialize_timepunct(__c_locale __cloc); 



template<> void __timepunct< wchar_t> ::_M_put(wchar_t *, size_t, const wchar_t *, const tm *) const throw(); 




}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\time_members.h" 3
namespace std { 



template < typename _CharT > 
__timepunct < _CharT > :: __timepunct (size_t __refs) 
: facet (__refs) , _M_data (0) 
{ 
_M_name_timepunct = _S_get_c_name () ; 
_M_initialize_timepunct () ; 
} 

template < typename _CharT > 
__timepunct < _CharT > :: __timepunct (__cache_type * __cache , size_t __refs) 
: facet (__refs) , _M_data (__cache) 
{ 
_M_name_timepunct = _S_get_c_name () ; 
_M_initialize_timepunct () ; 
} 

template < typename _CharT > 
__timepunct < _CharT > :: __timepunct (__c_locale __cloc , const char * __s , 
size_t __refs) 
: facet (__refs) , _M_data (0) 
{ 
if (__builtin_strcmp (__s , _S_get_c_name ()) != 0) 
{ 
const size_t __len = __builtin_strlen (__s) + 1 ; 
char * __tmp = new char [ __len ] ; 
__builtin_memcpy (__tmp , __s , __len) ; 
_M_name_timepunct = __tmp ; 
} 
else 
_M_name_timepunct = _S_get_c_name () ; 

try 
{ _M_initialize_timepunct (__cloc) ; } 
catch (...) 
{ 
if (_M_name_timepunct != _S_get_c_name ()) 
delete [ ] _M_name_timepunct ; 
throw ; 
} 
} 

template < typename _CharT > 
__timepunct < _CharT > :: ~ __timepunct () 
{ 
if (_M_name_timepunct != _S_get_c_name ()) 
delete [ ] _M_name_timepunct ; 
delete _M_data ; 
_S_destroy_c_locale (_M_c_locale_timepunct) ; 
} 


}
# 348 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
namespace std { 



inline namespace __cxx11 { 
# 367 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT , typename _InIter > 
class time_get : public locale :: facet , public time_base 
{ 
public : 



typedef _CharT char_type ; 
typedef _InIter iter_type ; 



static locale :: id id ; 
# 388 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
time_get (size_t __refs = 0) 
: facet (__refs) { } 
# 405 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
dateorder 
date_order () const 
{ return this -> do_date_order () ; } 
# 429 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get_time (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ return this -> do_get_time (__beg , __end , __io , __err , __tm) ; } 
# 454 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get_date (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ return this -> do_get_date (__beg , __end , __io , __err , __tm) ; } 
# 482 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get_weekday (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ return this -> do_get_weekday (__beg , __end , __io , __err , __tm) ; } 
# 511 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get_monthname (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ return this -> do_get_monthname (__beg , __end , __io , __err , __tm) ; } 
# 537 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get_year (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ return this -> do_get_year (__beg , __end , __io , __err , __tm) ; } 
# 558 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
inline 
iter_type get (iter_type __s , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , char __format , 
char __modifier = 0) const 
{ 
return this -> do_get (__s , __end , __io , __err , __tm , __format , 
__modifier) ; 
} 
# 585 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type get (iter_type __s , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , const char_type * __fmt , 
const char_type * __fmtend) const ; 


protected : 

virtual 
~ time_get () { } 
# 605 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual dateorder 
do_date_order () const ; 
# 623 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get_time (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const ; 
# 642 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get_date (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const ; 
# 661 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get_weekday (iter_type __beg , iter_type __end , ios_base & , 
ios_base :: iostate & __err , tm * __tm) const ; 
# 680 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get_monthname (iter_type __beg , iter_type __end , ios_base & , 
ios_base :: iostate & __err , tm * __tm) const ; 
# 699 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get_year (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const ; 
# 722 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual 

iter_type 
do_get (iter_type __s , iter_type __end , ios_base & __f , 
ios_base :: iostate & __err , tm * __tm , 
char __format , char __modifier) const ; 



iter_type 
_M_extract_num (iter_type __beg , iter_type __end , int & __member , 
int __min , int __max , size_t __len , 
ios_base & __io , ios_base :: iostate & __err) const ; 


iter_type 
_M_extract_name (iter_type __beg , iter_type __end , int & __member , 
const _CharT * * __names , size_t __indexlen , 
ios_base & __io , ios_base :: iostate & __err) const ; 


iter_type 
_M_extract_wday_or_month (iter_type __beg , iter_type __end , int & __member , 
const _CharT * * __names , size_t __indexlen , 
ios_base & __io , ios_base :: iostate & __err) const ; 


iter_type 
_M_extract_via_format (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , 
const _CharT * __format) const ; 
} ;

template < typename _CharT, typename _InIter >
    locale :: id time_get < _CharT, _InIter > :: id;


template < typename _CharT , typename _InIter > 
class time_get_byname : public time_get < _CharT , _InIter > 
{ 
public : 

typedef _CharT char_type ; 
typedef _InIter iter_type ; 

explicit 
time_get_byname (const char * , size_t __refs = 0) 
: time_get < _CharT , _InIter > (__refs) { } 


explicit 
time_get_byname (const string & __s , size_t __refs = 0) 
: time_get_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ time_get_byname () { } 
} ;

}
# 796 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT , typename _OutIter > 
class time_put : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef _OutIter iter_type ; 



static locale :: id id ; 
# 817 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
time_put (size_t __refs = 0) 
: facet (__refs) { } 
# 836 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , const tm * __tm , 
const _CharT * __beg , const _CharT * __end) const ; 
# 856 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
put (iter_type __s , ios_base & __io , char_type __fill , 
const tm * __tm , char __format , char __mod = 0) const 
{ return this -> do_put (__s , __io , __fill , __tm , __format , __mod) ; } 

protected : 

virtual 
~ time_put () 
{ } 
# 883 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_put (iter_type __s , ios_base & __io , char_type __fill , const tm * __tm , 
char __format , char __mod) const ; 
} ;

template < typename _CharT, typename _OutIter >
    locale :: id time_put < _CharT, _OutIter > :: id;


template < typename _CharT , typename _OutIter > 
class time_put_byname : public time_put < _CharT , _OutIter > 
{ 
public : 

typedef _CharT char_type ; 
typedef _OutIter iter_type ; 

explicit 
time_put_byname (const char * , size_t __refs = 0) 
: time_put < _CharT , _OutIter > (__refs) 
{ } 


explicit 
time_put_byname (const string & __s , size_t __refs = 0) 
: time_put_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ time_put_byname () { } 
} ;
# 928 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
class money_base { 


public: enum part { none, space, symbol, sign, value}; 
struct pattern { char field[4]; }; 

static const pattern _S_default_pattern; 


enum { 
_S_minus, 
_S_zero, 
_S_end = 11
}; 



static const char *_S_atoms; 




__attribute((const)) static pattern _S_construct_pattern(char __precedes, char __space, char __posn) throw(); 
}; 

template < typename _CharT , bool _Intl > 
struct __moneypunct_cache : public locale :: facet 
{ 
const char * _M_grouping ; 
size_t _M_grouping_size ; 
bool _M_use_grouping ; 
_CharT _M_decimal_point ; 
_CharT _M_thousands_sep ; 
const _CharT * _M_curr_symbol ; 
size_t _M_curr_symbol_size ; 
const _CharT * _M_positive_sign ; 
size_t _M_positive_sign_size ; 
const _CharT * _M_negative_sign ; 
size_t _M_negative_sign_size ; 
int _M_frac_digits ; 
money_base :: pattern _M_pos_format ; 
money_base :: pattern _M_neg_format ; 




_CharT _M_atoms [ money_base :: _S_end ] ; 

bool _M_allocated ; 

__moneypunct_cache (size_t __refs = 0) : facet (__refs) , 
_M_grouping (0) , _M_grouping_size (0) , _M_use_grouping (false) , 
_M_decimal_point (_CharT ()) , _M_thousands_sep (_CharT ()) , 
_M_curr_symbol (0) , _M_curr_symbol_size (0) , 
_M_positive_sign (0) , _M_positive_sign_size (0) , 
_M_negative_sign (0) , _M_negative_sign_size (0) , 
_M_frac_digits (0) , 
_M_pos_format (money_base :: pattern ()) , 
_M_neg_format (money_base :: pattern ()) , _M_allocated (false) 
{ } 

~ __moneypunct_cache () ; 

void 
_M_cache (const locale & __loc) ; 

private : 
__moneypunct_cache & 
operator = (const __moneypunct_cache &) ; 

explicit 
__moneypunct_cache (const __moneypunct_cache &) ; 
} ;

template < typename _CharT , bool _Intl > 
__moneypunct_cache < _CharT , _Intl > :: ~ __moneypunct_cache () 
{ 
if (_M_allocated) 
{ 
delete [ ] _M_grouping ; 
delete [ ] _M_curr_symbol ; 
delete [ ] _M_positive_sign ; 
delete [ ] _M_negative_sign ; 
} 
} 

inline namespace __cxx11 { 
# 1023 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT , bool _Intl > 
class moneypunct : public locale :: facet , public money_base 
{ 
public : 



typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 

typedef __moneypunct_cache < _CharT , _Intl > __cache_type ; 

private : 
__cache_type * _M_data ; 

public : 


static const bool intl = _Intl ; 

static locale :: id id ; 
# 1052 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
moneypunct (size_t __refs = 0) 
: facet (__refs) , _M_data (0) 
{ _M_initialize_moneypunct () ; } 
# 1065 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
moneypunct (__cache_type * __cache , size_t __refs = 0) 
: facet (__refs) , _M_data (__cache) 
{ _M_initialize_moneypunct () ; } 
# 1080 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
moneypunct (__c_locale __cloc , const char * __s , size_t __refs = 0) 
: facet (__refs) , _M_data (0) 
{ _M_initialize_moneypunct (__cloc , __s) ; } 
# 1094 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
char_type 
decimal_point () const 
{ return this -> do_decimal_point () ; } 
# 1107 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
char_type 
thousands_sep () const 
{ return this -> do_thousands_sep () ; } 
# 1137 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
string 
grouping () const 
{ return this -> do_grouping () ; } 
# 1150 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
string_type 
curr_symbol () const 
{ return this -> do_curr_symbol () ; } 
# 1167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
string_type 
positive_sign () const 
{ return this -> do_positive_sign () ; } 
# 1184 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
string_type 
negative_sign () const 
{ return this -> do_negative_sign () ; } 
# 1200 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
int 
frac_digits () const 
{ return this -> do_frac_digits () ; } 
# 1236 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
pattern 
pos_format () const 
{ return this -> do_pos_format () ; } 

pattern 
neg_format () const 
{ return this -> do_neg_format () ; } 


protected : 

virtual 
~ moneypunct () ; 
# 1258 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual char_type 
do_decimal_point () const 
{ return _M_data -> _M_decimal_point ; } 
# 1270 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual char_type 
do_thousands_sep () const 
{ return _M_data -> _M_thousands_sep ; } 
# 1283 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual string 
do_grouping () const 
{ return _M_data -> _M_grouping ; } 
# 1296 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual string_type 
do_curr_symbol () const 
{ return _M_data -> _M_curr_symbol ; } 
# 1309 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual string_type 
do_positive_sign () const 
{ return _M_data -> _M_positive_sign ; } 
# 1322 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual string_type 
do_negative_sign () const 
{ return _M_data -> _M_negative_sign ; } 
# 1336 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual int 
do_frac_digits () const 
{ return _M_data -> _M_frac_digits ; } 
# 1350 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual pattern 
do_pos_format () const 
{ return _M_data -> _M_pos_format ; } 
# 1364 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual pattern 
do_neg_format () const 
{ return _M_data -> _M_neg_format ; } 


void 
_M_initialize_moneypunct (__c_locale __cloc = 0 , 
const char * __name = 0) ; 
} ;

template < typename _CharT, bool _Intl >
    locale :: id moneypunct < _CharT, _Intl > :: id;

template < typename _CharT, bool _Intl >
    const bool moneypunct < _CharT, _Intl > :: intl;


template<> moneypunct< char, true> ::~moneypunct(); 


template<> moneypunct< char> ::~moneypunct(); 



template<> void moneypunct< char, true> ::_M_initialize_moneypunct(__c_locale, const char *); 



template<> void moneypunct< char> ::_M_initialize_moneypunct(__c_locale, const char *); 



template<> moneypunct< wchar_t, true> ::~moneypunct(); 


template<> moneypunct< wchar_t> ::~moneypunct(); 



template<> void moneypunct< wchar_t, true> ::_M_initialize_moneypunct(__c_locale, const char *); 




template<> void moneypunct< wchar_t> ::_M_initialize_moneypunct(__c_locale, const char *); 




template < typename _CharT , bool _Intl > 
class moneypunct_byname : public moneypunct < _CharT , _Intl > 
{ 
public : 
typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 

static const bool intl = _Intl ; 

explicit 
moneypunct_byname (const char * __s , size_t __refs = 0) 
: moneypunct < _CharT , _Intl > (__refs) 
{ 
if (__builtin_strcmp (__s , "C") != 0 
&& __builtin_strcmp (__s , "POSIX") != 0) 
{ 
__c_locale __tmp ; 
this -> _S_create_c_locale (__tmp , __s) ; 
this -> _M_initialize_moneypunct (__tmp) ; 
this -> _S_destroy_c_locale (__tmp) ; 
} 
} 


explicit 
moneypunct_byname (const string & __s , size_t __refs = 0) 
: moneypunct_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ moneypunct_byname () { } 
} ;

template < typename _CharT, bool _Intl >
    const bool moneypunct_byname < _CharT, _Intl > :: intl;

}

inline namespace __cxx11 { 
# 1467 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT , typename _InIter > 
class money_get : public locale :: facet 
{ 
public : 



typedef _CharT char_type ; 
typedef _InIter iter_type ; 
typedef basic_string < _CharT > string_type ; 



static locale :: id id ; 
# 1489 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
money_get (size_t __refs = 0) : facet (__refs) { } 
# 1519 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get (iter_type __s , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , long double & __units) const 
{ return this -> do_get (__s , __end , __intl , __io , __err , __units) ; } 
# 1550 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
get (iter_type __s , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , string_type & __digits) const 
{ return this -> do_get (__s , __end , __intl , __io , __err , __digits) ; } 

protected : 

virtual 
~ money_get () { } 
# 1574 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get (iter_type __s , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , long double & __units) const ; 
# 1586 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_get (iter_type __s , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , string_type & __digits) const ; 
# 1598 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < bool _Intl > 
iter_type 
_M_extract (iter_type __s , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , string & __digits) const ; 
} ;

template < typename _CharT, typename _InIter >
    locale :: id money_get < _CharT, _InIter > :: id;
# 1620 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT , typename _OutIter > 
class money_put : public locale :: facet 
{ 
public : 


typedef _CharT char_type ; 
typedef _OutIter iter_type ; 
typedef basic_string < _CharT > string_type ; 



static locale :: id id ; 
# 1641 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
money_put (size_t __refs = 0) : facet (__refs) { } 
# 1661 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
put (iter_type __s , bool __intl , ios_base & __io , 
char_type __fill , long double __units) const 
{ return this -> do_put (__s , __intl , __io , __fill , __units) ; } 
# 1684 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
iter_type 
put (iter_type __s , bool __intl , ios_base & __io , 
char_type __fill , const string_type & __digits) const 
{ return this -> do_put (__s , __intl , __io , __fill , __digits) ; } 

protected : 

virtual 
~ money_put () { } 
# 1719 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_put (iter_type __s , bool __intl , ios_base & __io , char_type __fill , 
long double __units) const ; 
# 1743 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual iter_type 
do_put (iter_type __s , bool __intl , ios_base & __io , char_type __fill , 
const string_type & __digits) const ; 
# 1755 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < bool _Intl > 
iter_type 
_M_insert (iter_type __s , ios_base & __io , char_type __fill , 
const string_type & __digits) const ; 
} ;

template < typename _CharT, typename _OutIter >
    locale :: id money_put < _CharT, _OutIter > :: id;

}
# 1770
struct messages_base { 

typedef int catalog; 
}; 

inline namespace __cxx11 { 
# 1798 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
template < typename _CharT > 
class messages : public locale :: facet , public messages_base 
{ 
public : 



typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 


protected : 


__c_locale _M_c_locale_messages ; 
const char * _M_name_messages ; 

public : 

static locale :: id id ; 
# 1826 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
messages (size_t __refs = 0) ; 
# 1840 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
explicit 
messages (__c_locale __cloc , const char * __s , size_t __refs = 0) ; 
# 1853 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
catalog 
open (const basic_string < char > & __s , const locale & __loc) const 
{ return this -> do_open (__s , __loc) ; } 
# 1871 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
catalog 
open (const basic_string < char > & , const locale & , const char *) const ; 
# 1889 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
string_type 
get (catalog __c , int __set , int __msgid , const string_type & __s) const 
{ return this -> do_get (__c , __set , __msgid , __s) ; } 
# 1900 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
void 
close (catalog __c) const 
{ return this -> do_close (__c) ; } 

protected : 

virtual 
~ messages () ; 
# 1920 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual catalog 
do_open (const basic_string < char > & , const locale &) const ; 
# 1939 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.h" 3
virtual string_type 
do_get (catalog , int , int , const string_type & __dfault) const ; 
# 1947
virtual void 
do_close (catalog) const ; 


char * 
_M_convert_to_char (const string_type & __msg) const 
{ 

return reinterpret_cast < char * > (const_cast < _CharT * > (__msg . c_str ())) ; 
} 


string_type 
_M_convert_from_char (char *) const 
{ 

return string_type () ; 
} 
} ;

template < typename _CharT >
    locale :: id messages < _CharT > :: id;




template<> string messages< char> ::do_get(catalog, int, int, const string &) const; 




template<> wstring messages< wchar_t> ::do_get(catalog, int, int, const wstring &) const; 



template < typename _CharT > 
class messages_byname : public messages < _CharT > 
{ 
public : 
typedef _CharT char_type ; 
typedef basic_string < _CharT > string_type ; 

explicit 
messages_byname (const char * __s , size_t __refs = 0) ; 


explicit 
messages_byname (const string & __s , size_t __refs = 0) 
: messages_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ messages_byname () 
{ } 
} ;

}


}
# 36 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\messages_members.h" 3
namespace std { 




template < typename _CharT > 
messages < _CharT > :: messages (size_t __refs) 
: facet (__refs) 
{ _M_c_locale_messages = _S_get_c_locale () ; } 

template < typename _CharT > 
messages < _CharT > :: messages (__c_locale , const char * , size_t __refs) 
: facet (__refs) 
{ _M_c_locale_messages = _S_get_c_locale () ; } 

template < typename _CharT > 
typename messages < _CharT > :: catalog 
messages < _CharT > :: open (const basic_string < char > & __s , const locale & __loc , 
const char *) const 
{ return this -> do_open (__s , __loc) ; } 


template < typename _CharT > 
messages < _CharT > :: ~ messages () 
{ _S_destroy_c_locale (_M_c_locale_messages) ; } 

template < typename _CharT > 
typename messages < _CharT > :: catalog 
messages < _CharT > :: do_open (const basic_string < char > & , const locale &) const 
{ return 0 ; } 

template < typename _CharT > 
typename messages < _CharT > :: string_type 
messages < _CharT > :: do_get (catalog , int , int , 
const string_type & __dfault) const 
{ return __dfault ; } 

template < typename _CharT > 
void 
messages < _CharT > :: do_close (catalog) const 
{ } 


template < typename _CharT > 
messages_byname < _CharT > :: messages_byname (const char * __s , size_t __refs) 
: messages < _CharT > (__refs) 
{ 
if (__builtin_strcmp (__s , "C") != 0 
&& __builtin_strcmp (__s , "POSIX") != 0) 
{ 
this -> _S_destroy_c_locale (this -> _M_c_locale_messages) ; 
this -> _S_create_c_locale (this -> _M_c_locale_messages , __s) ; 
} 
} 


}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
namespace std { 




class codecvt_base { 


public: enum result { 

ok, 
partial, 
error, 
noconv
}; 
}; 
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
template < typename _InternT , typename _ExternT , typename _StateT > 
class __codecvt_abstract_base 
: public locale :: facet , public codecvt_base 
{ 
public : 

typedef codecvt_base :: result result ; 
typedef _InternT intern_type ; 
typedef _ExternT extern_type ; 
typedef _StateT state_type ; 
# 115 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
result 
out (state_type & __state , const intern_type * __from , 
const intern_type * __from_end , const intern_type * & __from_next , 
extern_type * __to , extern_type * __to_end , 
extern_type * & __to_next) const 
{ 
return this -> do_out (__state , __from , __from_end , __from_next , 
__to , __to_end , __to_next) ; 
} 
# 154 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
result 
unshift (state_type & __state , extern_type * __to , extern_type * __to_end , 
extern_type * & __to_next) const 
{ return this -> do_unshift (__state , __to , __to_end , __to_next) ; } 
# 195 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
result 
in (state_type & __state , const extern_type * __from , 
const extern_type * __from_end , const extern_type * & __from_next , 
intern_type * __to , intern_type * __to_end , 
intern_type * & __to_next) const 
{ 
return this -> do_in (__state , __from , __from_end , __from_next , 
__to , __to_end , __to_next) ; 
} 

int 
encoding () const throw () 
{ return this -> do_encoding () ; } 

bool 
always_noconv () const throw () 
{ return this -> do_always_noconv () ; } 

int 
length (state_type & __state , const extern_type * __from , 
const extern_type * __end , size_t __max) const 
{ return this -> do_length (__state , __from , __end , __max) ; } 

int 
max_length () const throw () 
{ return this -> do_max_length () ; } 

protected : 
explicit 
__codecvt_abstract_base (size_t __refs = 0) : locale :: facet (__refs) { } 

virtual 
~ __codecvt_abstract_base () { } 
# 236 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
virtual result 
do_out (state_type & __state , const intern_type * __from , 
const intern_type * __from_end , const intern_type * & __from_next , 
extern_type * __to , extern_type * __to_end , 
extern_type * & __to_next) const = 0 ; 

virtual result 
do_unshift (state_type & __state , extern_type * __to , 
extern_type * __to_end , extern_type * & __to_next) const = 0 ; 

virtual result 
do_in (state_type & __state , const extern_type * __from , 
const extern_type * __from_end , const extern_type * & __from_next , 
intern_type * __to , intern_type * __to_end , 
intern_type * & __to_next) const = 0 ; 

virtual int 
do_encoding () const throw () = 0 ; 

virtual bool 
do_always_noconv () const throw () = 0 ; 

virtual int 
do_length (state_type & , const extern_type * __from , 
const extern_type * __end , size_t __max) const = 0 ; 

virtual int 
do_max_length () const throw () = 0 ; 
} ;
# 273 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
template < typename _InternT , typename _ExternT , typename _StateT > 
class codecvt 
: public __codecvt_abstract_base < _InternT , _ExternT , _StateT > 
{ 
public : 

typedef codecvt_base :: result result ; 
typedef _InternT intern_type ; 
typedef _ExternT extern_type ; 
typedef _StateT state_type ; 

protected : 
__c_locale _M_c_locale_codecvt ; 

public : 
static locale :: id id ; 

explicit 
codecvt (size_t __refs = 0) 
: __codecvt_abstract_base < _InternT , _ExternT , _StateT > (__refs) , 
_M_c_locale_codecvt (0) 
{ } 

explicit 
codecvt (__c_locale __cloc , size_t __refs = 0) ; 

protected : 
virtual 
~ codecvt () { } 

virtual result 
do_out (state_type & __state , const intern_type * __from , 
const intern_type * __from_end , const intern_type * & __from_next , 
extern_type * __to , extern_type * __to_end , 
extern_type * & __to_next) const ; 

virtual result 
do_unshift (state_type & __state , extern_type * __to , 
extern_type * __to_end , extern_type * & __to_next) const ; 

virtual result 
do_in (state_type & __state , const extern_type * __from , 
const extern_type * __from_end , const extern_type * & __from_next , 
intern_type * __to , intern_type * __to_end , 
intern_type * & __to_next) const ; 

virtual int 
do_encoding () const throw () ; 

virtual bool 
do_always_noconv () const throw () ; 

virtual int 
do_length (state_type & , const extern_type * __from , 
const extern_type * __end , size_t __max) const ; 

virtual int 
do_max_length () const throw () ; 
} ;

template < typename _InternT, typename _ExternT, typename _StateT >
    locale :: id codecvt < _InternT, _ExternT, _StateT > :: id;



template<> class codecvt< char, char, int>  : public __codecvt_abstract_base< char, char, int>  { 


friend class __cxx11::messages< char> ; 



public: typedef char intern_type; 
typedef char extern_type; 
typedef mbstate_t state_type; 


protected: __c_locale _M_c_locale_codecvt; 


public: static locale::id id; 


explicit codecvt(size_t __refs = 0); 


explicit codecvt(__c_locale __cloc, size_t __refs = 0); 



protected: virtual ~codecvt(); 


virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 372
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 



virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 382
virtual int do_encoding() const throw(); 


virtual bool do_always_noconv() const throw(); 


virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 



virtual int do_max_length() const throw(); 
}; 
# 401
template<> class codecvt< wchar_t, char, int>  : public __codecvt_abstract_base< wchar_t, char, int>  { 


friend class __cxx11::messages< wchar_t> ; 



public: typedef wchar_t intern_type; 
typedef char extern_type; 
typedef mbstate_t state_type; 


protected: __c_locale _M_c_locale_codecvt; 


public: static locale::id id; 


explicit codecvt(size_t __refs = 0); 


explicit codecvt(__c_locale __cloc, size_t __refs = 0); 



protected: virtual ~codecvt(); 


virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 435
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 




virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 447
virtual int do_encoding() const throw(); 


virtual bool do_always_noconv() const throw(); 


virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 



virtual int do_max_length() const throw(); 
}; 
# 467
template<> class codecvt< char16_t, char, int>  : public __codecvt_abstract_base< char16_t, char, int>  { 




public: typedef char16_t intern_type; 
typedef char extern_type; 
typedef mbstate_t state_type; 


static locale::id id; 


explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char16_t, char, int> (__refs) 
{ } 



protected: virtual ~codecvt(); 


virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 494
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 




virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 506
virtual int do_encoding() const throw(); 


virtual bool do_always_noconv() const throw(); 


virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 



virtual int do_max_length() const throw(); 
}; 
# 524
template<> class codecvt< char32_t, char, int>  : public __codecvt_abstract_base< char32_t, char, int>  { 




public: typedef char32_t intern_type; 
typedef char extern_type; 
typedef mbstate_t state_type; 


static locale::id id; 


explicit codecvt(size_t __refs = 0) : std::__codecvt_abstract_base< char32_t, char, int> (__refs) 
{ } 



protected: virtual ~codecvt(); 


virtual result do_out(state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 
# 551
virtual result do_unshift(state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const; 




virtual result do_in(state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const; 
# 563
virtual int do_encoding() const throw(); 


virtual bool do_always_noconv() const throw(); 


virtual int do_length(state_type &, const extern_type * __from, const extern_type * __end, size_t __max) const; 



virtual int do_max_length() const throw(); 
}; 
# 695 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
template < typename _InternT , typename _ExternT , typename _StateT > 
class codecvt_byname : public codecvt < _InternT , _ExternT , _StateT > 
{ 
public : 
explicit 
codecvt_byname (const char * __s , size_t __refs = 0) 
: codecvt < _InternT , _ExternT , _StateT > (__refs) 
{ 
if (__builtin_strcmp (__s , "C") != 0 
&& __builtin_strcmp (__s , "POSIX") != 0) 
{ 
this -> _S_destroy_c_locale (this -> _M_c_locale_codecvt) ; 
this -> _S_create_c_locale (this -> _M_c_locale_codecvt , __s) ; 
} 
} 


explicit 
codecvt_byname (const string & __s , size_t __refs = 0) 
: codecvt_byname (__s . c_str () , __refs) { } 


protected : 
virtual 
~ codecvt_byname () { } 
} ;



template<> class codecvt_byname< char16_t, char, int>  : public codecvt< char16_t, char, int>  { 




public: explicit codecvt_byname(const char *, size_t __refs = 0) : std::codecvt< char16_t, char, int> (__refs) 
{ } 


explicit codecvt_byname(const string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
{ } 



protected: virtual ~codecvt_byname() { } 
}; 


template<> class codecvt_byname< char32_t, char, int>  : public codecvt< char32_t, char, int>  { 




public: explicit codecvt_byname(const char *, size_t __refs = 0) : std::codecvt< char32_t, char, int> (__refs) 
{ } 


explicit codecvt_byname(const string &__s, size_t __refs = 0) : codecvt_byname(__s.c_str(), __refs) 
{ } 



protected: virtual ~codecvt_byname() { } 
}; 
# 802 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
extern template class codecvt_byname< char, char, int> ;

extern template const codecvt< char, char, int>  &use_facet< codecvt< char, char, int> > (const locale &);



extern template bool has_facet< codecvt< char, char, int> > (const locale &) throw();




extern template class codecvt_byname< wchar_t, char, int> ;

extern template const codecvt< wchar_t, char, int>  &use_facet< codecvt< wchar_t, char, int> > (const locale &);



extern template bool has_facet< codecvt< wchar_t, char, int> > (const locale &) throw();
# 838 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\codecvt.h" 3
}
# 35 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.tcc" 3
namespace std { 



template < typename _CharT , bool _Intl > 
struct __use_cache < __moneypunct_cache < _CharT , _Intl > > 
{ 
const __moneypunct_cache < _CharT , _Intl > * 
operator () (const locale & __loc) const 
{ 
const size_t __i = moneypunct < _CharT , _Intl > :: id . _M_id () ; 
const locale :: facet * * __caches = __loc . _M_impl -> _M_caches ; 
if (! __caches [ __i ]) 
{ 
__moneypunct_cache < _CharT , _Intl > * __tmp = 0 ; 
try 
{ 
__tmp = new __moneypunct_cache < _CharT , _Intl > ; 
__tmp -> _M_cache (__loc) ; 
} 
catch (...) 
{ 
delete __tmp ; 
throw ; 
} 
__loc . _M_impl -> _M_install_cache (__tmp , __i) ; 
} 
return static_cast < 
const __moneypunct_cache < _CharT , _Intl > * > (__caches [ __i ]) ; 
} 
} ;

template < typename _CharT , bool _Intl > 
void 
__moneypunct_cache < _CharT , _Intl > :: _M_cache (const locale & __loc) 
{ 
const moneypunct < _CharT , _Intl > & __mp = 
use_facet < moneypunct < _CharT , _Intl > > (__loc) ; 

_M_decimal_point = __mp . decimal_point () ; 
_M_thousands_sep = __mp . thousands_sep () ; 
_M_frac_digits = __mp . frac_digits () ; 

char * __grouping = 0 ; 
_CharT * __curr_symbol = 0 ; 
_CharT * __positive_sign = 0 ; 
_CharT * __negative_sign = 0 ; 
try 
{ 
const string & __g = __mp . grouping () ; 
_M_grouping_size = __g . size () ; 
__grouping = new char [ _M_grouping_size ] ; 
__g . copy (__grouping , _M_grouping_size) ; 
_M_use_grouping = (_M_grouping_size 
&& static_cast < signed char > (__grouping [ 0 ]) > 0 
&& (__grouping [ 0 ] 
!= __gnu_cxx :: __numeric_traits < char > :: __max)) ; 

const basic_string < _CharT > & __cs = __mp . curr_symbol () ; 
_M_curr_symbol_size = __cs . size () ; 
__curr_symbol = new _CharT [ _M_curr_symbol_size ] ; 
__cs . copy (__curr_symbol , _M_curr_symbol_size) ; 

const basic_string < _CharT > & __ps = __mp . positive_sign () ; 
_M_positive_sign_size = __ps . size () ; 
__positive_sign = new _CharT [ _M_positive_sign_size ] ; 
__ps . copy (__positive_sign , _M_positive_sign_size) ; 

const basic_string < _CharT > & __ns = __mp . negative_sign () ; 
_M_negative_sign_size = __ns . size () ; 
__negative_sign = new _CharT [ _M_negative_sign_size ] ; 
__ns . copy (__negative_sign , _M_negative_sign_size) ; 

_M_pos_format = __mp . pos_format () ; 
_M_neg_format = __mp . neg_format () ; 

const ctype < _CharT > & __ct = use_facet < ctype < _CharT > > (__loc) ; 
__ct . widen (money_base :: _S_atoms , 
money_base :: _S_atoms + money_base :: _S_end , _M_atoms) ; 

_M_grouping = __grouping ; 
_M_curr_symbol = __curr_symbol ; 
_M_positive_sign = __positive_sign ; 
_M_negative_sign = __negative_sign ; 
_M_allocated = true ; 
} 
catch (...) 
{ 
delete [ ] __grouping ; 
delete [ ] __curr_symbol ; 
delete [ ] __positive_sign ; 
delete [ ] __negative_sign ; 
throw ; 
} 
} 

inline namespace __cxx11 { 

template < typename _CharT , typename _InIter > 
template < bool _Intl > 
_InIter 
money_get < _CharT , _InIter > :: 
_M_extract (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , string & __units) const 
{ 
typedef char_traits < _CharT > __traits_type ; 
typedef typename string_type :: size_type size_type ; 
typedef money_base :: part part ; 
typedef __moneypunct_cache < _CharT , _Intl > __cache_type ; 

const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

__use_cache < __cache_type > __uc ; 
const __cache_type * __lc = __uc (__loc) ; 
const char_type * __lit = __lc -> _M_atoms ; 


bool __negative = false ; 

size_type __sign_size = 0 ; 

const bool __mandatory_sign = (__lc -> _M_positive_sign_size 
&& __lc -> _M_negative_sign_size) ; 

string __grouping_tmp ; 
if (__lc -> _M_use_grouping) 
__grouping_tmp . reserve (32) ; 

int __last_pos = 0 ; 

int __n = 0 ; 

bool __testvalid = true ; 

bool __testdecfound = false ; 


string __res ; 
__res . reserve (32) ; 

const char_type * __lit_zero = __lit + money_base :: _S_zero ; 
const money_base :: pattern __p = __lc -> _M_neg_format ; 
for (int __i = 0 ; __i < 4 && __testvalid ; ++ __i) 
{ 
const part __which = static_cast < part > (__p . field [ __i ]) ; 
switch (__which) 
{ 
case money_base :: symbol : 




if (__io . flags () & ios_base :: showbase || __sign_size > 1 
|| __i == 0 
|| (__i == 1 && (__mandatory_sign 
|| (static_cast < part > (__p . field [ 0 ]) 
== money_base :: sign) 
|| (static_cast < part > (__p . field [ 2 ]) 
== money_base :: space))) 
|| (__i == 2 && ((static_cast < part > (__p . field [ 3 ]) 
== money_base :: value) 
|| (__mandatory_sign 
&& (static_cast < part > (__p . field [ 3 ]) 
== money_base :: sign))))) 
{ 
const size_type __len = __lc -> _M_curr_symbol_size ; 
size_type __j = 0 ; 
for (; __beg != __end && __j < __len 
&& * __beg == __lc -> _M_curr_symbol [ __j ] ; 
++ __beg , (void) ++ __j) ; 
if (__j != __len 
&& (__j || __io . flags () & ios_base :: showbase)) 
__testvalid = false ; 
} 
break ; 
case money_base :: sign : 

if (__lc -> _M_positive_sign_size && __beg != __end 
&& * __beg == __lc -> _M_positive_sign [ 0 ]) 
{ 
__sign_size = __lc -> _M_positive_sign_size ; 
++ __beg ; 
} 
else if (__lc -> _M_negative_sign_size && __beg != __end 
&& * __beg == __lc -> _M_negative_sign [ 0 ]) 
{ 
__negative = true ; 
__sign_size = __lc -> _M_negative_sign_size ; 
++ __beg ; 
} 
else if (__lc -> _M_positive_sign_size 
&& ! __lc -> _M_negative_sign_size) 


__negative = true ; 
else if (__mandatory_sign) 
__testvalid = false ; 
break ; 
case money_base :: value : 


for (; __beg != __end ; ++ __beg) 
{ 
const char_type __c = * __beg ; 
const char_type * __q = __traits_type :: find (__lit_zero , 
10 , __c) ; 
if (__q != 0) 
{ 
__res += money_base :: _S_atoms [ __q - __lit ] ; 
++ __n ; 
} 
else if (__c == __lc -> _M_decimal_point 
&& ! __testdecfound) 
{ 
if (__lc -> _M_frac_digits <= 0) 
break ; 

__last_pos = __n ; 
__n = 0 ; 
__testdecfound = true ; 
} 
else if (__lc -> _M_use_grouping 
&& __c == __lc -> _M_thousands_sep 
&& ! __testdecfound) 
{ 
if (__n) 
{ 

__grouping_tmp += static_cast < char > (__n) ; 
__n = 0 ; 
} 
else 
{ 
__testvalid = false ; 
break ; 
} 
} 
else 
break ; 
} 
if (__res . empty ()) 
__testvalid = false ; 
break ; 
case money_base :: space : 

if (__beg != __end && __ctype . is (ctype_base :: space , * __beg)) 
++ __beg ; 
else 
__testvalid = false ; 

case money_base :: none : 

if (__i != 3) 
for (; __beg != __end 
&& __ctype . is (ctype_base :: space , * __beg) ; ++ __beg) ; 
break ; 
} 
} 


if (__sign_size > 1 && __testvalid) 
{ 
const char_type * __sign = __negative ? __lc -> _M_negative_sign 
: __lc -> _M_positive_sign ; 
size_type __i = 1 ; 
for (; __beg != __end && __i < __sign_size 
&& * __beg == __sign [ __i ] ; ++ __beg , (void) ++ __i) ; 

if (__i != __sign_size) 
__testvalid = false ; 
} 

if (__testvalid) 
{ 

if (__res . size () > 1) 
{ 
const size_type __first = __res . find_first_not_of ('0') ; 
const bool __only_zeros = __first == string :: npos ; 
if (__first) 
__res . erase (0 , __only_zeros ? __res . size () - 1 : __first) ; 
} 


if (__negative && __res [ 0 ] != '0') 
__res . insert (__res . begin () , '-') ; 


if (__grouping_tmp . size ()) 
{ 

__grouping_tmp += static_cast < char > (__testdecfound ? __last_pos 
: __n) ; 
if (! std :: __verify_grouping (__lc -> _M_grouping , 
__lc -> _M_grouping_size , 
__grouping_tmp)) 
__err |= ios_base :: failbit ; 
} 


if (__testdecfound && __n != __lc -> _M_frac_digits) 
__testvalid = false ; 
} 


if (! __testvalid) 
__err |= ios_base :: failbit ; 
else 
__units . swap (__res) ; 


if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 
# 368 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.tcc" 3
template < typename _CharT , typename _InIter > 
_InIter 
money_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , long double & __units) const 
{ 
string __str ; 
__beg = __intl ? _M_extract < true > (__beg , __end , __io , __err , __str) 
: _M_extract < false > (__beg , __end , __io , __err , __str) ; 
std :: __convert_to_v (__str . c_str () , __units , __err , _S_get_c_locale ()) ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
money_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , bool __intl , ios_base & __io , 
ios_base :: iostate & __err , string_type & __digits) const 
{ 
typedef typename string :: size_type size_type ; 

const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

string __str ; 
__beg = __intl ? _M_extract < true > (__beg , __end , __io , __err , __str) 
: _M_extract < false > (__beg , __end , __io , __err , __str) ; 
const size_type __len = __str . size () ; 
if (__len) 
{ 
__digits . resize (__len) ; 
__ctype . widen (__str . data () , __str . data () + __len , & __digits [ 0 ]) ; 
} 
return __beg ; 
} 

template < typename _CharT , typename _OutIter > 
template < bool _Intl > 
_OutIter 
money_put < _CharT , _OutIter > :: 
_M_insert (iter_type __s , ios_base & __io , char_type __fill , 
const string_type & __digits) const 
{ 
typedef typename string_type :: size_type size_type ; 
typedef money_base :: part part ; 
typedef __moneypunct_cache < _CharT , _Intl > __cache_type ; 

const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

__use_cache < __cache_type > __uc ; 
const __cache_type * __lc = __uc (__loc) ; 
const char_type * __lit = __lc -> _M_atoms ; 



const char_type * __beg = __digits . data () ; 

money_base :: pattern __p ; 
const char_type * __sign ; 
size_type __sign_size ; 
if (! (* __beg == __lit [ money_base :: _S_minus ])) 
{ 
__p = __lc -> _M_pos_format ; 
__sign = __lc -> _M_positive_sign ; 
__sign_size = __lc -> _M_positive_sign_size ; 
} 
else 
{ 
__p = __lc -> _M_neg_format ; 
__sign = __lc -> _M_negative_sign ; 
__sign_size = __lc -> _M_negative_sign_size ; 
if (__digits . size ()) 
++ __beg ; 
} 


size_type __len = __ctype . scan_not (ctype_base :: digit , __beg , 
__beg + __digits . size ()) - __beg ; 
if (__len) 
{ 



string_type __value ; 
__value . reserve (2 * __len) ; 



long __paddec = __len - __lc -> _M_frac_digits ; 
if (__paddec > 0) 
{ 
if (__lc -> _M_frac_digits < 0) 
__paddec = __len ; 
if (__lc -> _M_grouping_size) 
{ 
__value . assign (2 * __paddec , char_type ()) ; 
_CharT * __vend = 
std :: __add_grouping (& __value [ 0 ] , __lc -> _M_thousands_sep , 
__lc -> _M_grouping , 
__lc -> _M_grouping_size , 
__beg , __beg + __paddec) ; 
__value . erase (__vend - & __value [ 0 ]) ; 
} 
else 
__value . assign (__beg , __paddec) ; 
} 


if (__lc -> _M_frac_digits > 0) 
{ 
__value += __lc -> _M_decimal_point ; 
if (__paddec >= 0) 
__value . append (__beg + __paddec , __lc -> _M_frac_digits) ; 
else 
{ 

__value . append (- __paddec , __lit [ money_base :: _S_zero ]) ; 
__value . append (__beg , __len) ; 
} 
} 


const ios_base :: fmtflags __f = __io . flags () 
& ios_base :: adjustfield ; 
__len = __value . size () + __sign_size ; 
__len += ((__io . flags () & ios_base :: showbase) 
? __lc -> _M_curr_symbol_size : 0) ; 

string_type __res ; 
__res . reserve (2 * __len) ; 

const size_type __width = static_cast < size_type > (__io . width ()) ; 
const bool __testipad = (__f == ios_base :: internal 
&& __len < __width) ; 

for (int __i = 0 ; __i < 4 ; ++ __i) 
{ 
const part __which = static_cast < part > (__p . field [ __i ]) ; 
switch (__which) 
{ 
case money_base :: symbol : 
if (__io . flags () & ios_base :: showbase) 
__res . append (__lc -> _M_curr_symbol , 
__lc -> _M_curr_symbol_size) ; 
break ; 
case money_base :: sign : 



if (__sign_size) 
__res += __sign [ 0 ] ; 
break ; 
case money_base :: value : 
__res += __value ; 
break ; 
case money_base :: space : 



if (__testipad) 
__res . append (__width - __len , __fill) ; 
else 
__res += __fill ; 
break ; 
case money_base :: none : 
if (__testipad) 
__res . append (__width - __len , __fill) ; 
break ; 
} 
} 


if (__sign_size > 1) 
__res . append (__sign + 1 , __sign_size - 1) ; 


__len = __res . size () ; 
if (__width > __len) 
{ 
if (__f == ios_base :: left) 

__res . append (__width - __len , __fill) ; 
else 

__res . insert (0 , __width - __len , __fill) ; 
__len = __width ; 
} 


__s = std :: __write (__s , __res . data () , __len) ; 
} 
__io . width (0) ; 
return __s ; 
} 
# 574 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.tcc" 3
template < typename _CharT , typename _OutIter > 
_OutIter 
money_put < _CharT , _OutIter > :: 
do_put (iter_type __s , bool __intl , ios_base & __io , char_type __fill , 
long double __units) const 
{ 
const locale __loc = __io . getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 


int __cs_size = 64 ; 
char * __cs = static_cast < char * > (__builtin_alloca (__cs_size)) ; 


int __len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
"%.*Lf" , 0 , __units) ; 

if (__len >= __cs_size) 
{ 
__cs_size = __len + 1 ; 
__cs = static_cast < char * > (__builtin_alloca (__cs_size)) ; 
__len = std :: __convert_from_v (_S_get_c_locale () , __cs , __cs_size , 
"%.*Lf" , 0 , __units) ; 
} 
# 606 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_facets_nonio.tcc" 3
string_type __digits (__len , char_type ()) ; 
__ctype . widen (__cs , __cs + __len , & __digits [ 0 ]) ; 
return __intl ? _M_insert < true > (__s , __io , __fill , __digits) 
: _M_insert < false > (__s , __io , __fill , __digits) ; 
} 

template < typename _CharT , typename _OutIter > 
_OutIter 
money_put < _CharT , _OutIter > :: 
do_put (iter_type __s , bool __intl , ios_base & __io , char_type __fill , 
const string_type & __digits) const 
{ return __intl ? _M_insert < true > (__s , __io , __fill , __digits) 
: _M_insert < false > (__s , __io , __fill , __digits) ; } 

}




template < typename _CharT , typename _InIter > 
time_base :: dateorder 
time_get < _CharT , _InIter > :: do_date_order () const 
{ return time_base :: no_order ; } 



template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
_M_extract_via_format (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , 
const _CharT * __format) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 
const size_t __len = char_traits < _CharT > :: length (__format) ; 

ios_base :: iostate __tmperr = ios_base :: goodbit ; 
size_t __i = 0 ; 
for (; __beg != __end && __i < __len && ! __tmperr ; ++ __i) 
{ 
if (__ctype . narrow (__format [ __i ] , 0) == '%') 
{ 

char __c = __ctype . narrow (__format [ ++ __i ] , 0) ; 
int __mem = 0 ; 
if (__c == 'E' || __c == 'O') 
__c = __ctype . narrow (__format [ ++ __i ] , 0) ; 
switch (__c) 
{ 
const char * __cs ; 
_CharT __wcs [ 10 ] ; 
case 'a' : 

const char_type * __days1 [ 7 ] ; 
__tp . _M_days_abbreviated (__days1) ; 
__beg = _M_extract_name (__beg , __end , __mem , __days1 , 
7 , __io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_wday = __mem ; 
break ; 
case 'A' : 

const char_type * __days2 [ 7 ] ; 
__tp . _M_days (__days2) ; 
__beg = _M_extract_name (__beg , __end , __mem , __days2 , 
7 , __io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_wday = __mem ; 
break ; 
case 'h' : 
case 'b' : 

const char_type * __months1 [ 12 ] ; 
__tp . _M_months_abbreviated (__months1) ; 
__beg = _M_extract_name (__beg , __end , __mem , 
__months1 , 12 , __io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mon = __mem ; 
break ; 
case 'B' : 

const char_type * __months2 [ 12 ] ; 
__tp . _M_months (__months2) ; 
__beg = _M_extract_name (__beg , __end , __mem , 
__months2 , 12 , __io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mon = __mem ; 
break ; 
case 'c' : 

const char_type * __dt [ 2 ] ; 
__tp . _M_date_time_formats (__dt) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __dt [ 0 ]) ; 
break ; 
case 'd' : 

__beg = _M_extract_num (__beg , __end , __mem , 1 , 31 , 2 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mday = __mem ; 
break ; 
case 'e' : 


if (__ctype . is (ctype_base :: space , * __beg)) 
__beg = _M_extract_num (++ __beg , __end , __mem , 1 , 9 , 
1 , __io , __tmperr) ; 
else 
__beg = _M_extract_num (__beg , __end , __mem , 10 , 31 , 
2 , __io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mday = __mem ; 
break ; 
case 'D' : 

__cs = "%m/%d/%y" ; 
__ctype . widen (__cs , __cs + 9 , __wcs) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __wcs) ; 
break ; 
case 'H' : 

__beg = _M_extract_num (__beg , __end , __mem , 0 , 23 , 2 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_hour = __mem ; 
break ; 
case 'I' : 

__beg = _M_extract_num (__beg , __end , __mem , 1 , 12 , 2 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_hour = __mem ; 
break ; 
case 'm' : 

__beg = _M_extract_num (__beg , __end , __mem , 1 , 12 , 2 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mon = __mem - 1 ; 
break ; 
case 'M' : 

__beg = _M_extract_num (__beg , __end , __mem , 0 , 59 , 2 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_min = __mem ; 
break ; 
case 'n' : 
if (__ctype . narrow (* __beg , 0) == '\n') 
++ __beg ; 
else 
__tmperr |= ios_base :: failbit ; 
break ; 
case 'R' : 

__cs = "%H:%M" ; 
__ctype . widen (__cs , __cs + 6 , __wcs) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __wcs) ; 
break ; 
case 'S' : 
# 776
__beg = _M_extract_num (__beg , __end , __mem , 0 , 61 , 2 , 

__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_sec = __mem ; 
break ; 
case 't' : 
if (__ctype . narrow (* __beg , 0) == '\t') 
++ __beg ; 
else 
__tmperr |= ios_base :: failbit ; 
break ; 
case 'T' : 

__cs = "%H:%M:%S" ; 
__ctype . widen (__cs , __cs + 9 , __wcs) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __wcs) ; 
break ; 
case 'x' : 

const char_type * __dates [ 2 ] ; 
__tp . _M_date_formats (__dates) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __dates [ 0 ]) ; 
break ; 
case 'X' : 

const char_type * __times [ 2 ] ; 
__tp . _M_time_formats (__times) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __tmperr , 
__tm , __times [ 0 ]) ; 
break ; 
case 'y' : 
case 'C' : 

case 'Y' : 




__beg = _M_extract_num (__beg , __end , __mem , 0 , 9999 , 4 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_year = __mem < 0 ? __mem + 100 : __mem - 1900 ; 
break ; 
case 'Z' : 

if (__ctype . is (ctype_base :: upper , * __beg)) 
{ 
int __tmp ; 
__beg = _M_extract_name (__beg , __end , __tmp , 
__timepunct_cache < _CharT > :: _S_timezones , 
14 , __io , __tmperr) ; 


if (__beg != __end && ! __tmperr && __tmp == 0 
&& (* __beg == __ctype . widen ('-') 
|| * __beg == __ctype . widen ('+'))) 
{ 
__beg = _M_extract_num (__beg , __end , __tmp , 0 , 23 , 2 , 
__io , __tmperr) ; 
__beg = _M_extract_num (__beg , __end , __tmp , 0 , 59 , 2 , 
__io , __tmperr) ; 
} 
} 
else 
__tmperr |= ios_base :: failbit ; 
break ; 
default : 

__tmperr |= ios_base :: failbit ; 
} 
} 
else 
{ 

if (__format [ __i ] == * __beg) 
++ __beg ; 
else 
__tmperr |= ios_base :: failbit ; 
} 
} 

if (__tmperr || __i != __len) 
__err |= ios_base :: failbit ; 

return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
_M_extract_num (iter_type __beg , iter_type __end , int & __member , 
int __min , int __max , size_t __len , 
ios_base & __io , ios_base :: iostate & __err) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 


int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1) ; 

++ __min ; 
size_t __i = 0 ; 
int __value = 0 ; 
for (; __beg != __end && __i < __len ; ++ __beg , (void) ++ __i) 
{ 
const char __c = __ctype . narrow (* __beg , '*') ; 
if (__c >= '0' && __c <= '9') 
{ 
__value = __value * 10 + (__c - '0') ; 
const int __valuec = __value * __mult ; 
if (__valuec > __max || __valuec + __mult < __min) 
break ; 
__mult /= 10 ; 
} 
else 
break ; 
} 
if (__i == __len) 
__member = __value ; 

else if (__len == 4 && __i == 2) 
__member = __value - 100 ; 
else 
__err |= ios_base :: failbit ; 

return __beg ; 
} 



template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
_M_extract_name (iter_type __beg , iter_type __end , int & __member , 
const _CharT * * __names , size_t __indexlen , 
ios_base & __io , ios_base :: iostate & __err) const 
{ 
typedef char_traits < _CharT > __traits_type ; 
const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

int * __matches = static_cast < int * > (__builtin_alloca (sizeof (int) 
* __indexlen)) ; 
size_t __nmatches = 0 ; 
size_t __pos = 0 ; 
bool __testvalid = true ; 
const char_type * __name ; 
# 931
if (__beg != __end) 
{ 
const char_type __c = * __beg ; 
for (size_t __i1 = 0 ; __i1 < __indexlen ; ++ __i1) 
if (__c == __names [ __i1 ] [ 0 ] 
|| __c == __ctype . toupper (__names [ __i1 ] [ 0 ])) 
__matches [ __nmatches ++ ] = __i1 ; 
} 

while (__nmatches > 1) 
{ 

size_t __minlen = __traits_type :: length (__names [ __matches [ 0 ] ]) ; 
for (size_t __i2 = 1 ; __i2 < __nmatches ; ++ __i2) 
__minlen = std :: min (__minlen , 
__traits_type :: length (__names [ __matches [ __i2 ] ])) ; 
++ __beg ; 
++ __pos ; 
if (__pos < __minlen && __beg != __end) 
for (size_t __i3 = 0 ; __i3 < __nmatches ;) 
{ 
__name = __names [ __matches [ __i3 ] ] ; 
if (! (__name [ __pos ] == * __beg)) 
__matches [ __i3 ] = __matches [ -- __nmatches ] ; 
else 
++ __i3 ; 
} 
else 
break ; 
} 

if (__nmatches == 1) 
{ 

++ __beg ; 
++ __pos ; 
__name = __names [ __matches [ 0 ] ] ; 
const size_t __len = __traits_type :: length (__name) ; 
while (__pos < __len && __beg != __end && __name [ __pos ] == * __beg) 
++ __beg , (void) ++ __pos ; 

if (__len == __pos) 
__member = __matches [ 0 ] ; 
else 
__testvalid = false ; 
} 
else 
__testvalid = false ; 
if (! __testvalid) 
__err |= ios_base :: failbit ; 

return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
_M_extract_wday_or_month (iter_type __beg , iter_type __end , int & __member , 
const _CharT * * __names , size_t __indexlen , 
ios_base & __io , ios_base :: iostate & __err) const 
{ 
typedef char_traits < _CharT > __traits_type ; 
const locale & __loc = __io . _M_getloc () ; 
const ctype < _CharT > & __ctype = use_facet < ctype < _CharT > > (__loc) ; 

int * __matches = static_cast < int * > (__builtin_alloca (2 * sizeof (int) 
* __indexlen)) ; 
size_t __nmatches = 0 ; 
size_t * __matches_lengths = 0 ; 
size_t __pos = 0 ; 

if (__beg != __end) 
{ 
const char_type __c = * __beg ; 
for (size_t __i = 0 ; __i < 2 * __indexlen ; ++ __i) 
if (__c == __names [ __i ] [ 0 ] 
|| __c == __ctype . toupper (__names [ __i ] [ 0 ])) 
__matches [ __nmatches ++ ] = __i ; 
} 

if (__nmatches) 
{ 
++ __beg ; 
++ __pos ; 

__matches_lengths 
= static_cast < size_t * > (__builtin_alloca (sizeof (size_t) 
* __nmatches)) ; 
for (size_t __i = 0 ; __i < __nmatches ; ++ __i) 
__matches_lengths [ __i ] 
= __traits_type :: length (__names [ __matches [ __i ] ]) ; 
} 

for (; __beg != __end ; ++ __beg , (void) ++ __pos) 
{ 
size_t __nskipped = 0 ; 
const char_type __c = * __beg ; 
for (size_t __i = 0 ; __i < __nmatches ;) 
{ 
const char_type * __name = __names [ __matches [ __i ] ] ; 
if (__pos >= __matches_lengths [ __i ]) 
++ __nskipped , ++ __i ; 
else if (! (__name [ __pos ] == __c)) 
{ 
-- __nmatches ; 
__matches [ __i ] = __matches [ __nmatches ] ; 
__matches_lengths [ __i ] = __matches_lengths [ __nmatches ] ; 
} 
else 
++ __i ; 
} 
if (__nskipped == __nmatches) 
break ; 
} 

if ((__nmatches == 1 && __matches_lengths [ 0 ] == __pos) 
|| (__nmatches == 2 && (__matches_lengths [ 0 ] == __pos 
|| __matches_lengths [ 1 ] == __pos))) 
__member = (__matches [ 0 ] >= __indexlen 
? __matches [ 0 ] - __indexlen : __matches [ 0 ]) ; 
else 
__err |= ios_base :: failbit ; 

return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
do_get_time (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 
const char_type * __times [ 2 ] ; 
__tp . _M_time_formats (__times) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __err , 
__tm , __times [ 0 ]) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
do_get_date (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 
const char_type * __dates [ 2 ] ; 
__tp . _M_date_formats (__dates) ; 
__beg = _M_extract_via_format (__beg , __end , __io , __err , 
__tm , __dates [ 0 ]) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
do_get_weekday (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 
const char_type * __days [ 14 ] ; 
__tp . _M_days_abbreviated (__days) ; 
__tp . _M_days (__days + 7) ; 
int __tmpwday ; 
ios_base :: iostate __tmperr = ios_base :: goodbit ; 

__beg = _M_extract_wday_or_month (__beg , __end , __tmpwday , __days , 7 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_wday = __tmpwday ; 
else 
__err |= ios_base :: failbit ; 

if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
do_get_monthname (iter_type __beg , iter_type __end , 
ios_base & __io , ios_base :: iostate & __err , tm * __tm) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
const __timepunct < _CharT > & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 
const char_type * __months [ 24 ] ; 
__tp . _M_months_abbreviated (__months) ; 
__tp . _M_months (__months + 12) ; 
int __tmpmon ; 
ios_base :: iostate __tmperr = ios_base :: goodbit ; 

__beg = _M_extract_wday_or_month (__beg , __end , __tmpmon , __months , 12 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_mon = __tmpmon ; 
else 
__err |= ios_base :: failbit ; 

if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 

template < typename _CharT , typename _InIter > 
_InIter 
time_get < _CharT , _InIter > :: 
do_get_year (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm) const 
{ 
int __tmpyear ; 
ios_base :: iostate __tmperr = ios_base :: goodbit ; 

__beg = _M_extract_num (__beg , __end , __tmpyear , 0 , 9999 , 4 , 
__io , __tmperr) ; 
if (! __tmperr) 
__tm -> tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900 ; 
else 
__err |= ios_base :: failbit ; 

if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 


template < typename _CharT , typename _InIter > 
inline 
_InIter 
time_get < _CharT , _InIter > :: 
get (iter_type __s , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , const char_type * __fmt , 
const char_type * __fmtend) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > > (__loc) ; 
__err = ios_base :: goodbit ; 
while (__fmt != __fmtend && 
__err == ios_base :: goodbit) 
{ 
if (__s == __end) 
{ 
__err = ios_base :: eofbit | ios_base :: failbit ; 
break ; 
} 
else if (__ctype . narrow (* __fmt , 0) == '%') 
{ 
char __format ; 
char __mod = 0 ; 
if (++ __fmt == __fmtend) 
{ 
__err = ios_base :: failbit ; 
break ; 
} 
const char __c = __ctype . narrow (* __fmt , 0) ; 
if (__c != 'E' && __c != 'O') 
__format = __c ; 
else if (++ __fmt != __fmtend) 
{ 
__mod = __c ; 
__format = __ctype . narrow (* __fmt , 0) ; 
} 
else 
{ 
__err = ios_base :: failbit ; 
break ; 
} 
__s = this -> do_get (__s , __end , __io , __err , __tm , __format , 
__mod) ; 
++ __fmt ; 
} 
else if (__ctype . is (ctype_base :: space , * __fmt)) 
{ 
++ __fmt ; 
while (__fmt != __fmtend && 
__ctype . is (ctype_base :: space , * __fmt)) 
++ __fmt ; 

while (__s != __end && 
__ctype . is (ctype_base :: space , * __s)) 
++ __s ; 
} 

else if (__ctype . tolower (* __s) == __ctype . tolower (* __fmt) || 
__ctype . toupper (* __s) == __ctype . toupper (* __fmt)) 
{ 
++ __s ; 
++ __fmt ; 
} 
else 
{ 
__err = ios_base :: failbit ; 
break ; 
} 
} 
return __s ; 
} 

template < typename _CharT , typename _InIter > 
inline 
_InIter 
time_get < _CharT , _InIter > :: 
do_get (iter_type __beg , iter_type __end , ios_base & __io , 
ios_base :: iostate & __err , tm * __tm , 
char __format , char __mod) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > > (__loc) ; 
__err = ios_base :: goodbit ; 

char_type __fmt [ 4 ] ; 
__fmt [ 0 ] = __ctype . widen ('%') ; 
if (! __mod) 
{ 
__fmt [ 1 ] = __format ; 
__fmt [ 2 ] = char_type () ; 
} 
else 
{ 
__fmt [ 1 ] = __mod ; 
__fmt [ 2 ] = __format ; 
__fmt [ 3 ] = char_type () ; 
} 

__beg = _M_extract_via_format (__beg , __end , __io , __err , __tm , __fmt) ; 
if (__beg == __end) 
__err |= ios_base :: eofbit ; 
return __beg ; 
} 



template < typename _CharT , typename _OutIter > 
_OutIter 
time_put < _CharT , _OutIter > :: 
put (iter_type __s , ios_base & __io , char_type __fill , const tm * __tm , 
const _CharT * __beg , const _CharT * __end) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > > (__loc) ; 
for (; __beg != __end ; ++ __beg) 
if (__ctype . narrow (* __beg , 0) != '%') 
{ 
* __s = * __beg ; 
++ __s ; 
} 
else if (++ __beg != __end) 
{ 
char __format ; 
char __mod = 0 ; 
const char __c = __ctype . narrow (* __beg , 0) ; 
if (__c != 'E' && __c != 'O') 
__format = __c ; 
else if (++ __beg != __end) 
{ 
__mod = __c ; 
__format = __ctype . narrow (* __beg , 0) ; 
} 
else 
break ; 
__s = this -> do_put (__s , __io , __fill , __tm , __format , __mod) ; 
} 
else 
break ; 
return __s ; 
} 

template < typename _CharT , typename _OutIter > 
_OutIter 
time_put < _CharT , _OutIter > :: 
do_put (iter_type __s , ios_base & __io , char_type , const tm * __tm , 
char __format , char __mod) const 
{ 
const locale & __loc = __io . _M_getloc () ; 
ctype < _CharT > const & __ctype = use_facet < ctype < _CharT > > (__loc) ; 
__timepunct < _CharT > const & __tp = use_facet < __timepunct < _CharT > > (__loc) ; 



const size_t __maxlen = 128 ; 
char_type __res [ __maxlen ] ; 
# 1326
char_type __fmt [ 4 ] ; 
__fmt [ 0 ] = __ctype . widen ('%') ; 
if (! __mod) 
{ 
__fmt [ 1 ] = __format ; 
__fmt [ 2 ] = char_type () ; 
} 
else 
{ 
__fmt [ 1 ] = __mod ; 
__fmt [ 2 ] = __format ; 
__fmt [ 3 ] = char_type () ; 
} 

__tp . _M_put (__res , __maxlen , __fmt , __tm) ; 


return std :: __write (__s , __res , char_traits < char_type > :: length (__res)) ; 
} 
# 1350
extern template class __cxx11::moneypunct< char> ;
extern template class __cxx11::moneypunct< char, true> ;
extern template class __cxx11::moneypunct_byname< char, false> ;
extern template class __cxx11::moneypunct_byname< char, true> ;
extern template class __cxx11::money_get< char> ;
extern template class __cxx11::money_put< char> ;
extern template class __timepunct< char> ;
extern template class time_put< char> ;
extern template class time_put_byname< char> ;
extern template class __cxx11::time_get< char> ;
extern template class __cxx11::time_get_byname< char> ;
extern template class __cxx11::messages< char> ;
extern template class __cxx11::messages_byname< char> ;

extern template const __cxx11::moneypunct< char, true>  &use_facet< __cxx11::moneypunct< char, true> > (const locale &);



extern template const __cxx11::moneypunct< char>  &use_facet< __cxx11::moneypunct< char> > (const locale &);



extern template const __cxx11::money_put< char>  &use_facet< __cxx11::money_put< char> > (const locale &);



extern template const __cxx11::money_get< char>  &use_facet< __cxx11::money_get< char> > (const locale &);



extern template const __timepunct< char>  &use_facet< __timepunct< char> > (const locale &);



extern template const time_put< char>  &use_facet< time_put< char> > (const locale &);



extern template const __cxx11::time_get< char>  &use_facet< __cxx11::time_get< char> > (const locale &);



extern template const __cxx11::messages< char>  &use_facet< __cxx11::messages< char> > (const locale &);



extern template bool has_facet< __cxx11::moneypunct< char> > (const locale &) throw();



extern template bool has_facet< __cxx11::money_put< char> > (const locale &) throw();



extern template bool has_facet< __cxx11::money_get< char> > (const locale &) throw();



extern template bool has_facet< __timepunct< char> > (const locale &) throw();



extern template bool has_facet< time_put< char> > (const locale &) throw();



extern template bool has_facet< __cxx11::time_get< char> > (const locale &) throw();



extern template bool has_facet< __cxx11::messages< char> > (const locale &) throw();




extern template class __cxx11::moneypunct< wchar_t> ;
extern template class __cxx11::moneypunct< wchar_t, true> ;
extern template class __cxx11::moneypunct_byname< wchar_t, false> ;
extern template class __cxx11::moneypunct_byname< wchar_t, true> ;
extern template class __cxx11::money_get< wchar_t> ;
extern template class __cxx11::money_put< wchar_t> ;
extern template class __timepunct< wchar_t> ;
extern template class time_put< wchar_t> ;
extern template class time_put_byname< wchar_t> ;
extern template class __cxx11::time_get< wchar_t> ;
extern template class __cxx11::time_get_byname< wchar_t> ;
extern template class __cxx11::messages< wchar_t> ;
extern template class __cxx11::messages_byname< wchar_t> ;

extern template const __cxx11::moneypunct< wchar_t, true>  &use_facet< __cxx11::moneypunct< wchar_t, true> > (const locale &);



extern template const __cxx11::moneypunct< wchar_t>  &use_facet< __cxx11::moneypunct< wchar_t> > (const locale &);



extern template const __cxx11::money_put< wchar_t>  &use_facet< __cxx11::money_put< wchar_t> > (const locale &);



extern template const __cxx11::money_get< wchar_t>  &use_facet< __cxx11::money_get< wchar_t> > (const locale &);



extern template const __timepunct< wchar_t>  &use_facet< __timepunct< wchar_t> > (const locale &);



extern template const time_put< wchar_t>  &use_facet< time_put< wchar_t> > (const locale &);



extern template const __cxx11::time_get< wchar_t>  &use_facet< __cxx11::time_get< wchar_t> > (const locale &);



extern template const __cxx11::messages< wchar_t>  &use_facet< __cxx11::messages< wchar_t> > (const locale &);



extern template bool has_facet< __cxx11::moneypunct< wchar_t> > (const locale &) throw();



extern template bool has_facet< __cxx11::money_put< wchar_t> > (const locale &) throw();



extern template bool has_facet< __cxx11::money_get< wchar_t> > (const locale &) throw();



extern template bool has_facet< __timepunct< wchar_t> > (const locale &) throw();



extern template bool has_facet< time_put< wchar_t> > (const locale &) throw();



extern template bool has_facet< __cxx11::time_get< wchar_t> > (const locale &) throw();



extern template bool has_facet< __cxx11::messages< wchar_t> > (const locale &) throw();
# 1502
}
# 41 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
namespace std { 
# 51
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
template < typename > class auto_ptr;
#pragma GCC diagnostic pop



template < typename _Tp > 
struct default_delete 
{ 

constexpr default_delete () noexcept = default ; 
# 69
template < typename _Up , typename = typename 
enable_if < is_convertible < _Up * , _Tp * > :: value > :: type > 
default_delete (const default_delete < _Up > &) noexcept { } 


void 
operator () (_Tp * __ptr) const 
{ 
static_assert (! is_void < _Tp > :: value , 
"can't delete pointer to incomplete type") ; 
static_assert (sizeof (_Tp) > 0 , 
"can't delete pointer to incomplete type") ; 
delete __ptr ; 
} 
} ;




template < typename _Tp > 
struct default_delete < _Tp [ ] > 
{ 
public : 

constexpr default_delete () noexcept = default ; 
# 104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , typename = typename 
enable_if < is_convertible < _Up (*) [ ] , _Tp (*) [ ] > :: value > :: type > 
default_delete (const default_delete < _Up [ ] > &) noexcept { } 


template < typename _Up > 
typename enable_if < is_convertible < _Up (*) [ ] , _Tp (*) [ ] > :: value > :: type 
operator () (_Up * __ptr) const 
{ 
static_assert (sizeof (_Tp) > 0 , 
"can't delete pointer to incomplete type") ; 
delete [ ] __ptr ; 
} 
} ;

template < typename _Tp , typename _Dp > 
class __uniq_ptr_impl 
{ 
template < typename _Up , typename _Ep , typename = void > 
struct _Ptr 
{ 
using type = _Up * ; 
} ; 

template < typename _Up , typename _Ep > 
struct 
_Ptr < _Up , _Ep , __void_t < typename remove_reference < _Ep > :: type :: pointer > > 
{ 
using type = typename remove_reference < _Ep > :: type :: pointer ; 
} ; 

public : 
using _DeleterConstraint = enable_if < 
__and_ < __not_ < is_pointer < _Dp > > , 
is_default_constructible < _Dp > > :: value > ; 

using pointer = typename _Ptr < _Tp , _Dp > :: type ; 

static_assert (! is_rvalue_reference < _Dp > :: value , 
"unique_ptr's deleter type must be a function object type" 
" or an lvalue reference type") ; 

__uniq_ptr_impl () = default ; 
__uniq_ptr_impl (pointer __p) : _M_t () { _M_ptr () = __p ; } 

template < typename _Del > 
__uniq_ptr_impl (pointer __p , _Del && __d) 
: _M_t (__p , std :: forward < _Del > (__d)) { } 

pointer & _M_ptr () { return std :: get < 0 > (_M_t) ; } 
pointer _M_ptr () const { return std :: get < 0 > (_M_t) ; } 
_Dp & _M_deleter () { return std :: get < 1 > (_M_t) ; } 
const _Dp & _M_deleter () const { return std :: get < 1 > (_M_t) ; } 

private : 
tuple < pointer , _Dp > _M_t ; 
} ;


template < typename _Tp , typename _Dp = default_delete < _Tp > > 
class unique_ptr 
{ 
template < typename _Up > 
using _DeleterConstraint = 
typename __uniq_ptr_impl < _Tp , _Up > :: _DeleterConstraint :: type ; 

__uniq_ptr_impl < _Tp , _Dp > _M_t ; 

public : 
using pointer = typename __uniq_ptr_impl < _Tp , _Dp > :: pointer ; 
using element_type = _Tp ; 
using deleter_type = _Dp ; 

private : 


template < typename _Up , typename _Ep > 
using __safe_conversion_up = __and_ < 
is_convertible < typename unique_ptr < _Up , _Ep > :: pointer , pointer > , 
__not_ < is_array < _Up > > 
> ; 

public : 



template < typename _Del = _Dp , typename = _DeleterConstraint < _Del > > 
constexpr unique_ptr () noexcept 
: _M_t () 
{ } 
# 201
template < typename _Del = _Dp , typename = _DeleterConstraint < _Del > > 
explicit 
unique_ptr (pointer __p) noexcept 
: _M_t (__p) 
{ } 
# 214 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Del = deleter_type , 
typename = _Require < is_copy_constructible < _Del > > > 
unique_ptr (pointer __p , const deleter_type & __d) noexcept 
: _M_t (__p , __d) { } 
# 226 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Del = deleter_type , 
typename = _Require < is_move_constructible < _Del > > > 
unique_ptr (pointer __p , 
__enable_if_t < ! is_lvalue_reference < _Del > :: value , 
_Del && > __d) noexcept 
: _M_t (__p , std :: move (__d)) 
{ } 

template < typename _Del = deleter_type , 
typename _DelUnref = typename remove_reference < _Del > :: type > 
unique_ptr (pointer , 
__enable_if_t < is_lvalue_reference < _Del > :: value , 
_DelUnref && >) = delete ; 


template < typename _Del = _Dp , typename = _DeleterConstraint < _Del > > 
constexpr unique_ptr (nullptr_t) noexcept 
: _M_t () 
{ } 




unique_ptr (unique_ptr && __u) noexcept 
: _M_t (__u . release () , std :: forward < deleter_type > (__u . get_deleter ())) { } 
# 258
template < typename _Up , typename _Ep , typename = _Require < 
__safe_conversion_up < _Up , _Ep > , 
typename conditional < is_reference < _Dp > :: value , 
is_same < _Ep , _Dp > , 
is_convertible < _Ep , _Dp > > :: type > > 
unique_ptr (unique_ptr < _Up , _Ep > && __u) noexcept 
: _M_t (__u . release () , std :: forward < _Ep > (__u . get_deleter ())) 
{ } 


# pragma GCC diagnostic push  
# pragma GCC diagnostic ignored "-Wdeprecated-declarations"  

template < typename _Up , typename = _Require < 
is_convertible < _Up * , _Tp * > , is_same < _Dp , default_delete < _Tp > > > > 
unique_ptr (auto_ptr < _Up > && __u) noexcept ; 
# pragma GCC diagnostic pop  



~ unique_ptr () noexcept 
{ 
static_assert (__is_invocable < deleter_type & , pointer > :: value , 
"unique_ptr's deleter must be invocable with a pointer") ; 
auto & __ptr = _M_t . _M_ptr () ; 
if (__ptr != nullptr) 
get_deleter () (std :: move (__ptr)) ; 
__ptr = pointer () ; 
} 
# 296 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
unique_ptr & 
operator = (unique_ptr && __u) noexcept 
{ 
reset (__u . release ()) ; 
get_deleter () = std :: forward < deleter_type > (__u . get_deleter ()) ; 
return * this ; 
} 
# 311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , typename _Ep > 
typename enable_if < __and_ < 
__safe_conversion_up < _Up , _Ep > , 
is_assignable < deleter_type & , _Ep && > 
> :: value , 
unique_ptr & > :: type 
operator = (unique_ptr < _Up , _Ep > && __u) noexcept 
{ 
reset (__u . release ()) ; 
get_deleter () = std :: forward < _Ep > (__u . get_deleter ()) ; 
return * this ; 
} 


unique_ptr & 
operator = (nullptr_t) noexcept 
{ 
reset () ; 
return * this ; 
} 




typename add_lvalue_reference < element_type > :: type 
operator * () const 
{ 
; 
return * get () ; 
} 


pointer 
operator -> () const noexcept 
{ 
; 
return get () ; 
} 


pointer 
get () const noexcept 
{ return _M_t . _M_ptr () ; } 


deleter_type & 
get_deleter () noexcept 
{ return _M_t . _M_deleter () ; } 


const deleter_type & 
get_deleter () const noexcept 
{ return _M_t . _M_deleter () ; } 


explicit operator bool () const noexcept 
{ return get () == pointer () ? false : true ; } 




pointer 
release () noexcept 
{ 
pointer __p = get () ; 
_M_t . _M_ptr () = pointer () ; 
return __p ; 
} 
# 386
void 
reset (pointer __p = pointer ()) noexcept 
{ 
static_assert (__is_invocable < deleter_type & , pointer > :: value , 
"unique_ptr's deleter must be invocable with a pointer") ; 
using std :: swap ; 
swap (_M_t . _M_ptr () , __p) ; 
if (__p != pointer ()) 
get_deleter () (std :: move (__p)) ; 
} 


void 
swap (unique_ptr & __u) noexcept 
{ 
using std :: swap ; 
swap (_M_t , __u . _M_t) ; 
} 


unique_ptr (const unique_ptr &) = delete ; 
unique_ptr & operator = (const unique_ptr &) = delete ; 
} ;
# 414
template < typename _Tp , typename _Dp > 
class unique_ptr < _Tp [ ] , _Dp > 
{ 
template < typename _Up > 
using _DeleterConstraint = 
typename __uniq_ptr_impl < _Tp , _Up > :: _DeleterConstraint :: type ; 

__uniq_ptr_impl < _Tp , _Dp > _M_t ; 

template < typename _Up > 
using __remove_cv = typename remove_cv < _Up > :: type ; 


template < typename _Up > 
using __is_derived_Tp 
= __and_ < is_base_of < _Tp , _Up > , 
__not_ < is_same < __remove_cv < _Tp > , __remove_cv < _Up > > > > ; 

public : 
using pointer = typename __uniq_ptr_impl < _Tp , _Dp > :: pointer ; 
using element_type = _Tp ; 
using deleter_type = _Dp ; 



template < typename _Up , typename _Ep , 
typename _UPtr = unique_ptr < _Up , _Ep > , 
typename _UP_pointer = typename _UPtr :: pointer , 
typename _UP_element_type = typename _UPtr :: element_type > 
using __safe_conversion_up = __and_ < 
is_array < _Up > , 
is_same < pointer , element_type * > , 
is_same < _UP_pointer , _UP_element_type * > , 
is_convertible < _UP_element_type (*) [ ] , element_type (*) [ ] > 
> ; 


template < typename _Up > 
using __safe_conversion_raw = __and_ < 
__or_ < __or_ < is_same < _Up , pointer > , 
is_same < _Up , nullptr_t > > , 
__and_ < is_pointer < _Up > , 
is_same < pointer , element_type * > , 
is_convertible < 
typename remove_pointer < _Up > :: type (*) [ ] , 
element_type (*) [ ] > 
> 
> 
> ; 




template < typename _Del = _Dp , typename = _DeleterConstraint < _Del > > 
constexpr unique_ptr () noexcept 
: _M_t () 
{ } 
# 479 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , 
typename _Vp = _Dp , 
typename = _DeleterConstraint < _Vp > , 
typename = typename enable_if < 
__safe_conversion_raw < _Up > :: value , bool > :: type > 
explicit 
unique_ptr (_Up __p) noexcept 
: _M_t (__p) 
{ } 
# 497 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , typename _Del = deleter_type , 
typename = _Require < __safe_conversion_raw < _Up > , 
is_copy_constructible < _Del > > > 
unique_ptr (_Up __p , const deleter_type & __d) noexcept 
: _M_t (__p , __d) { } 
# 511 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , typename _Del = deleter_type , 
typename = _Require < __safe_conversion_raw < _Up > , 
is_move_constructible < _Del > > > 
unique_ptr (_Up __p , 
__enable_if_t < ! is_lvalue_reference < _Del > :: value , 
_Del && > __d) noexcept 
: _M_t (std :: move (__p) , std :: move (__d)) 
{ } 

template < typename _Up , typename _Del = deleter_type , 
typename _DelUnref = typename remove_reference < _Del > :: type , 
typename = _Require < __safe_conversion_raw < _Up > > > 
unique_ptr (_Up , 
__enable_if_t < is_lvalue_reference < _Del > :: value , 
_DelUnref && >) = delete ; 


unique_ptr (unique_ptr && __u) noexcept 
: _M_t (__u . release () , std :: forward < deleter_type > (__u . get_deleter ())) { } 


template < typename _Del = _Dp , typename = _DeleterConstraint < _Del > > 
constexpr unique_ptr (nullptr_t) noexcept 
: _M_t () 
{ } 

template < typename _Up , typename _Ep , typename = _Require < 
__safe_conversion_up < _Up , _Ep > , 
typename conditional < is_reference < _Dp > :: value , 
is_same < _Ep , _Dp > , 
is_convertible < _Ep , _Dp > > :: type > > 
unique_ptr (unique_ptr < _Up , _Ep > && __u) noexcept 
: _M_t (__u . release () , std :: forward < _Ep > (__u . get_deleter ())) 
{ } 


~ unique_ptr () 
{ 
auto & __ptr = _M_t . _M_ptr () ; 
if (__ptr != nullptr) 
get_deleter () (__ptr) ; 
__ptr = pointer () ; 
} 
# 563 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
unique_ptr & 
operator = (unique_ptr && __u) noexcept 
{ 
reset (__u . release ()) ; 
get_deleter () = std :: forward < deleter_type > (__u . get_deleter ()) ; 
return * this ; 
} 
# 578 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
template < typename _Up , typename _Ep > 
typename 
enable_if < __and_ < __safe_conversion_up < _Up , _Ep > , 
is_assignable < deleter_type & , _Ep && > 
> :: value , 
unique_ptr & > :: type 
operator = (unique_ptr < _Up , _Ep > && __u) noexcept 
{ 
reset (__u . release ()) ; 
get_deleter () = std :: forward < _Ep > (__u . get_deleter ()) ; 
return * this ; 
} 


unique_ptr & 
operator = (nullptr_t) noexcept 
{ 
reset () ; 
return * this ; 
} 




typename std :: add_lvalue_reference < element_type > :: type 
operator [ ] (size_t __i) const 
{ 
; 
return get () [ __i ] ; 
} 


pointer 
get () const noexcept 
{ return _M_t . _M_ptr () ; } 


deleter_type & 
get_deleter () noexcept 
{ return _M_t . _M_deleter () ; } 


const deleter_type & 
get_deleter () const noexcept 
{ return _M_t . _M_deleter () ; } 


explicit operator bool () const noexcept 
{ return get () == pointer () ? false : true ; } 




pointer 
release () noexcept 
{ 
pointer __p = get () ; 
_M_t . _M_ptr () = pointer () ; 
return __p ; 
} 
# 645
template < typename _Up , 
typename = _Require < 
__or_ < is_same < _Up , pointer > , 
__and_ < is_same < pointer , element_type * > , 
is_pointer < _Up > , 
is_convertible < 
typename remove_pointer < _Up > :: type (*) [ ] , 
element_type (*) [ ] 
> 
> 
> 
> > 
void 
reset (_Up __p) noexcept 
{ 
pointer __ptr = __p ; 
using std :: swap ; 
swap (_M_t . _M_ptr () , __ptr) ; 
if (__ptr != nullptr) 
get_deleter () (__ptr) ; 
} 

void reset (nullptr_t = nullptr) noexcept 
{ 
reset (pointer ()) ; 
} 


void 
swap (unique_ptr & __u) noexcept 
{ 
using std :: swap ; 
swap (_M_t , __u . _M_t) ; 
} 


unique_ptr (const unique_ptr &) = delete ; 
unique_ptr & operator = (const unique_ptr &) = delete ; 
} ;

template < typename _Tp , typename _Dp > 
inline 


typename enable_if < __is_swappable < _Dp > :: value > :: type 



swap (unique_ptr < _Tp , _Dp > & __x , 
unique_ptr < _Tp , _Dp > & __y) noexcept 
{ __x . swap (__y) ; } 


template < typename _Tp , typename _Dp > 
typename enable_if < ! __is_swappable < _Dp > :: value > :: type 
swap (unique_ptr < _Tp , _Dp > & , 
unique_ptr < _Tp , _Dp > &) = delete ; ;


template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator == (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ return __x . get () == __y . get () ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator == (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) noexcept 
{ return ! __x ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator == (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) noexcept 
{ return ! __x ; } 

template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator != (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ return __x . get () != __y . get () ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator != (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) noexcept 
{ return (bool) __x ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator != (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) noexcept 
{ return (bool) __x ; } 

template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator < (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ 
typedef typename 
std :: common_type < typename unique_ptr < _Tp , _Dp > :: pointer , 
typename unique_ptr < _Up , _Ep > :: pointer > :: type _CT ; 
return std :: less < _CT > () (__x . get () , __y . get ()) ; 
} 

template < typename _Tp , typename _Dp > 
inline bool 
operator < (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) 
{ return std :: less < typename unique_ptr < _Tp , _Dp > :: pointer > () (__x . get () , 
nullptr) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator < (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) 
{ return std :: less < typename unique_ptr < _Tp , _Dp > :: pointer > () (nullptr , 
__x . get ()) ; } 

template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator <= (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ return ! (__y < __x) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator <= (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) 
{ return ! (nullptr < __x) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator <= (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) 
{ return ! (__x < nullptr) ; } 

template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator > (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ return (__y < __x) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator > (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) 
{ return std :: less < typename unique_ptr < _Tp , _Dp > :: pointer > () (nullptr , 
__x . get ()) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator > (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) 
{ return std :: less < typename unique_ptr < _Tp , _Dp > :: pointer > () (__x . get () , 
nullptr) ; } 

template < typename _Tp , typename _Dp , 
typename _Up , typename _Ep > 
inline bool 
operator >= (const unique_ptr < _Tp , _Dp > & __x , 
const unique_ptr < _Up , _Ep > & __y) 
{ return ! (__x < __y) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator >= (const unique_ptr < _Tp , _Dp > & __x , nullptr_t) 
{ return ! (__x < nullptr) ; } 

template < typename _Tp , typename _Dp > 
inline bool 
operator >= (nullptr_t , const unique_ptr < _Tp , _Dp > & __x) 
{ return ! (nullptr < __x) ; } 


template < typename _Tp , typename _Dp > 
struct hash < unique_ptr < _Tp , _Dp > > 
: public __hash_base < size_t , unique_ptr < _Tp , _Dp > > , 
private __poison_hash < typename unique_ptr < _Tp , _Dp > :: pointer > 
{ 
size_t 
operator () (const unique_ptr < _Tp , _Dp > & __u) const noexcept 
{ 
typedef unique_ptr < _Tp , _Dp > _UP ; 
return std :: hash < typename _UP :: pointer > () (__u . get ()) ; 
} 
} ;
# 880 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\unique_ptr.h" 3
}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_conv.h" 3
namespace std { 
# 52
template < typename _OutStr , typename _InChar , typename _Codecvt , 
typename _State , typename _Fn > 
bool 
__do_str_codecvt (const _InChar * __first , const _InChar * __last , 
_OutStr & __outstr , const _Codecvt & __cvt , _State & __state , 
size_t & __count , _Fn __fn) 
{ 
if (__first == __last) 
{ 
__outstr . clear () ; 
__count = 0 ; 
return true ; 
} 

size_t __outchars = 0 ; 
auto __next = __first ; 
const auto __maxlen = __cvt . max_length () + 1 ; 

codecvt_base :: result __result ; 
do 
{ 
__outstr . resize (__outstr . size () + (__last - __next) * __maxlen) ; 
auto __outnext = & __outstr . front () + __outchars ; 
auto const __outlast = & __outstr . back () + 1 ; 
__result = (__cvt .* __fn) (__state , __next , __last , __next , 
__outnext , __outlast , __outnext) ; 
__outchars = __outnext - & __outstr . front () ; 
} 
while (__result == codecvt_base :: partial && __next != __last 
&& (__outstr . size () - __outchars) < __maxlen) ; 

if (__result == codecvt_base :: error) 
{ 
__count = __next - __first ; 
return false ; 
} 



if (is_same < typename _Codecvt :: intern_type , 
typename _Codecvt :: extern_type > ()) 
if (__result == codecvt_base :: noconv) 
{ 
__outstr . assign (__first , __last) ; 
__count = __last - __first ; 
return true ; 
} 

__outstr . resize (__outchars) ; 
__count = __next - __first ; 
return true ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_in (const char * __first , const char * __last , 
basic_string < _CharT , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt , 
_State & __state , size_t & __count) 
{ 
using _Codecvt = codecvt < _CharT , char , _State > ; 
using _ConvFn 
= codecvt_base :: result 
(_Codecvt :: *) (_State & , const char * , const char * , const char * & , 
_CharT * , _CharT * , _CharT * &) const ; 
_ConvFn __fn = & codecvt < _CharT , char , _State > :: in ; 
return __do_str_codecvt (__first , __last , __outstr , __cvt , __state , 
__count , __fn) ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_in (const char * __first , const char * __last , 
basic_string < _CharT , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt) 
{ 
_State __state = { } ; 
size_t __n ; 
return __str_codecvt_in (__first , __last , __outstr , __cvt , __state , __n) ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_in_all (const char * __first , const char * __last , 
basic_string < _CharT , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt) 
{ 
_State __state = { } ; 
size_t __n ; 
return __str_codecvt_in (__first , __last , __outstr , __cvt , __state , __n) 
&& (__n == (__last - __first)) ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_out (const _CharT * __first , const _CharT * __last , 
basic_string < char , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt , 
_State & __state , size_t & __count) 
{ 
using _Codecvt = codecvt < _CharT , char , _State > ; 
using _ConvFn 
= codecvt_base :: result 
(_Codecvt :: *) (_State & , const _CharT * , const _CharT * , const _CharT * & , 
char * , char * , char * &) const ; 
_ConvFn __fn = & codecvt < _CharT , char , _State > :: out ; 
return __do_str_codecvt (__first , __last , __outstr , __cvt , __state , 
__count , __fn) ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_out (const _CharT * __first , const _CharT * __last , 
basic_string < char , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt) 
{ 
_State __state = { } ; 
size_t __n ; 
return __str_codecvt_out (__first , __last , __outstr , __cvt , __state , __n) ; 
} 


template < typename _CharT , typename _Traits , typename _Alloc , typename _State > 
inline bool 
__str_codecvt_out_all (const _CharT * __first , const _CharT * __last , 
basic_string < char , _Traits , _Alloc > & __outstr , 
const codecvt < _CharT , char , _State > & __cvt) 
{ 
_State __state = { } ; 
size_t __n ; 
return __str_codecvt_out (__first , __last , __outstr , __cvt , __state , __n) 
&& (__n == (__last - __first)) ; 
} 
# 226 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_conv.h" 3
inline namespace __cxx11 { 


template < typename _Codecvt , typename _Elem = wchar_t , 
typename _Wide_alloc = allocator < _Elem > , 
typename _Byte_alloc = allocator < char > > 
class wstring_convert 
{ 
public : 
typedef basic_string < char , char_traits < char > , _Byte_alloc > byte_string ; 
typedef basic_string < _Elem , char_traits < _Elem > , _Wide_alloc > wide_string ; 
typedef typename _Codecvt :: state_type state_type ; 
typedef typename wide_string :: traits_type :: int_type int_type ; 


wstring_convert () : _M_cvt (new _Codecvt ()) { } 
# 249
explicit 
wstring_convert (_Codecvt * __pcvt) : _M_cvt (__pcvt) 
{ 
if (! _M_cvt) 
__throw_logic_error ("wstring_convert") ; 
} 
# 264 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_conv.h" 3
wstring_convert (_Codecvt * __pcvt , state_type __state) 
: _M_cvt (__pcvt) , _M_state (__state) , _M_with_cvtstate (true) 
{ 
if (! _M_cvt) 
__throw_logic_error ("wstring_convert") ; 
} 
# 276
explicit 
wstring_convert (const byte_string & __byte_err , 
const wide_string & __wide_err = wide_string ()) 
: _M_cvt (new _Codecvt) , 
_M_byte_err_string (__byte_err) , _M_wide_err_string (__wide_err) , 
_M_with_strings (true) 
{ 
if (! _M_cvt) 
__throw_logic_error ("wstring_convert") ; 
} 

~ wstring_convert () = default ; 



wstring_convert (const wstring_convert &) = delete ; 
wstring_convert & operator = (const wstring_convert &) = delete ; 


wide_string 
from_bytes (char __byte) 
{ 
char __bytes [ 2 ] = { __byte } ; 
return from_bytes (__bytes , __bytes + 1) ; 
} 

wide_string 
from_bytes (const char * __ptr) 
{ return from_bytes (__ptr , __ptr + char_traits < char > :: length (__ptr)) ; } 

wide_string 
from_bytes (const byte_string & __str) 
{ 
auto __ptr = __str . data () ; 
return from_bytes (__ptr , __ptr + __str . size ()) ; 
} 

wide_string 
from_bytes (const char * __first , const char * __last) 
{ 
if (! _M_with_cvtstate) 
_M_state = state_type () ; 
wide_string __out { _M_wide_err_string . get_allocator () } ; 
if (__str_codecvt_in (__first , __last , __out , * _M_cvt , _M_state , 
_M_count)) 
return __out ; 
if (_M_with_strings) 
return _M_wide_err_string ; 
__throw_range_error ("wstring_convert::from_bytes") ; 
} 



byte_string 
to_bytes (_Elem __wchar) 
{ 
_Elem __wchars [ 2 ] = { __wchar } ; 
return to_bytes (__wchars , __wchars + 1) ; 
} 

byte_string 
to_bytes (const _Elem * __ptr) 
{ 
return to_bytes (__ptr , __ptr + wide_string :: traits_type :: length (__ptr)) ; 
} 

byte_string 
to_bytes (const wide_string & __wstr) 
{ 
auto __ptr = __wstr . data () ; 
return to_bytes (__ptr , __ptr + __wstr . size ()) ; 
} 

byte_string 
to_bytes (const _Elem * __first , const _Elem * __last) 
{ 
if (! _M_with_cvtstate) 
_M_state = state_type () ; 
byte_string __out { _M_byte_err_string . get_allocator () } ; 
if (__str_codecvt_out (__first , __last , __out , * _M_cvt , _M_state , 
_M_count)) 
return __out ; 
if (_M_with_strings) 
return _M_byte_err_string ; 
__throw_range_error ("wstring_convert::to_bytes") ; 
} 
# 367
size_t converted () const noexcept { return _M_count ; } 


state_type state () const { return _M_state ; } 

private : 
unique_ptr < _Codecvt > _M_cvt ; 
byte_string _M_byte_err_string ; 
wide_string _M_wide_err_string ; 
state_type _M_state = state_type () ; 
size_t _M_count = 0 ; 
bool _M_with_cvtstate = false ; 
bool _M_with_strings = false ; 
} ;

}


template < typename _Codecvt , typename _Elem = wchar_t , 
typename _Tr = char_traits < _Elem > > 
class wbuffer_convert : public basic_streambuf < _Elem , _Tr > 
{ 
typedef basic_streambuf < _Elem , _Tr > _Wide_streambuf ; 

public : 
typedef typename _Codecvt :: state_type state_type ; 


wbuffer_convert () : wbuffer_convert (nullptr) { } 
# 405 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\locale_conv.h" 3
explicit 
wbuffer_convert (streambuf * __bytebuf , _Codecvt * __pcvt = new _Codecvt , 
state_type __state = state_type ()) 
: _M_buf (__bytebuf) , _M_cvt (__pcvt) , _M_state (__state) 
{ 
if (! _M_cvt) 
__throw_logic_error ("wbuffer_convert") ; 

_M_always_noconv = _M_cvt -> always_noconv () ; 

if (_M_buf) 
{ 
this -> setp (_M_put_area , _M_put_area + _S_buffer_length) ; 
this -> setg (_M_get_area + _S_putback_length , 
_M_get_area + _S_putback_length , 
_M_get_area + _S_putback_length) ; 
} 
} 

~ wbuffer_convert () = default ; 



wbuffer_convert (const wbuffer_convert &) = delete ; 
wbuffer_convert & operator = (const wbuffer_convert &) = delete ; 

streambuf * rdbuf () const noexcept { return _M_buf ; } 

streambuf * 
rdbuf (streambuf * __bytebuf) noexcept 
{ 
auto __prev = _M_buf ; 
_M_buf = __bytebuf ; 
return __prev ; 
} 


state_type state () const noexcept { return _M_state ; } 

protected : 
int 
sync () 
{ return _M_buf && _M_conv_put () && ! _M_buf -> pubsync () ? 0 : - 1 ; } 

typename _Wide_streambuf :: int_type 
overflow (typename _Wide_streambuf :: int_type __out) 
{ 
if (! _M_buf || ! _M_conv_put ()) 
return _Tr :: eof () ; 
else if (! _Tr :: eq_int_type (__out , _Tr :: eof ())) 
return this -> sputc (__out) ; 
return _Tr :: not_eof (__out) ; 
} 

typename _Wide_streambuf :: int_type 
underflow () 
{ 
if (! _M_buf) 
return _Tr :: eof () ; 

if (this -> gptr () < this -> egptr () || (_M_buf && _M_conv_get ())) 
return _Tr :: to_int_type (* this -> gptr ()) ; 
else 
return _Tr :: eof () ; 
} 

streamsize 
xsputn (const typename _Wide_streambuf :: char_type * __s , streamsize __n) 
{ 
if (! _M_buf || __n == 0) 
return 0 ; 
streamsize __done = 0 ; 
do 
{ 
auto __nn = std :: min < streamsize > (this -> epptr () - this -> pptr () , 
__n - __done) ; 
_Tr :: copy (this -> pptr () , __s + __done , __nn) ; 
this -> pbump (__nn) ; 
__done += __nn ; 
} while (__done < __n && _M_conv_put ()) ; 
return __done ; 
} 

private : 

bool 
_M_conv_get () 
{ 
const streamsize __pb1 = this -> gptr () - this -> eback () ; 
const streamsize __pb2 = _S_putback_length ; 
const streamsize __npb = std :: min (__pb1 , __pb2) ; 

_Tr :: move (_M_get_area + _S_putback_length - __npb , 
this -> gptr () - __npb , __npb) ; 

streamsize __nbytes = sizeof (_M_get_buf) - _M_unconv ; 
__nbytes = std :: min (__nbytes , _M_buf -> in_avail ()) ; 
if (__nbytes < 1) 
__nbytes = 1 ; 
__nbytes = _M_buf -> sgetn (_M_get_buf + _M_unconv , __nbytes) ; 
if (__nbytes < 1) 
return false ; 
__nbytes += _M_unconv ; 



_Elem * __outbuf = _M_get_area + _S_putback_length ; 
_Elem * __outnext = __outbuf ; 
const char * __bnext = _M_get_buf ; 

codecvt_base :: result __result ; 
if (_M_always_noconv) 
__result = codecvt_base :: noconv ; 
else 
{ 
_Elem * __outend = _M_get_area + _S_buffer_length ; 

__result = _M_cvt -> in (_M_state , 
__bnext , __bnext + __nbytes , __bnext , 
__outbuf , __outend , __outnext) ; 
} 

if (__result == codecvt_base :: noconv) 
{ 

auto __get_buf = reinterpret_cast < const _Elem * > (_M_get_buf) ; 
_Tr :: copy (__outbuf , __get_buf , __nbytes) ; 
_M_unconv = 0 ; 
return true ; 
} 

if ((_M_unconv = _M_get_buf + __nbytes - __bnext)) 
char_traits < char > :: move (_M_get_buf , __bnext , _M_unconv) ; 

this -> setg (__outbuf , __outbuf , __outnext) ; 

return __result != codecvt_base :: error ; 
} 


bool 
_M_put (...) 
{ return false ; } 

bool 
_M_put (const char * __p , streamsize __n) 
{ 
if (_M_buf -> sputn (__p , __n) < __n) 
return false ; 
return true ; 
} 


bool 
_M_conv_put () 
{ 
_Elem * const __first = this -> pbase () ; 
const _Elem * const __last = this -> pptr () ; 
const streamsize __pending = __last - __first ; 

if (_M_always_noconv) 
return _M_put (__first , __pending) ; 

char __outbuf [ 2 * _S_buffer_length ] ; 

const _Elem * __next = __first ; 
const _Elem * __start ; 
do 
{ 
__start = __next ; 
char * __outnext = __outbuf ; 
char * const __outlast = __outbuf + sizeof (__outbuf) ; 
auto __result = _M_cvt -> out (_M_state , __next , __last , __next , 
__outnext , __outlast , __outnext) ; 
if (__result == codecvt_base :: error) 
return false ; 
else if (__result == codecvt_base :: noconv) 
return _M_put (__next , __pending) ; 

if (! _M_put (__outbuf , __outnext - __outbuf)) 
return false ; 
} 
while (__next != __last && __next != __start) ; 

if (__next != __last) 
_Tr :: move (__first , __next , __last - __next) ; 

this -> pbump (__first - __next) ; 
return __next != __first ; 
} 

streambuf * _M_buf ; 
unique_ptr < _Codecvt > _M_cvt ; 
state_type _M_state ; 

static const streamsize _S_buffer_length = 32 ; 
static const streamsize _S_putback_length = 3 ; 
_Elem _M_put_area [ _S_buffer_length ] ; 
_Elem _M_get_area [ _S_buffer_length ] ; 
streamsize _M_unconv = 0 ; 
char _M_get_buf [ _S_buffer_length - _S_putback_length ] ; 
bool _M_always_noconv ; 
} ;
# 614
}
# 49 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
namespace std { 
# 56
struct _Resetiosflags { ios_base::fmtflags _M_mask; }; 
# 66 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
inline _Resetiosflags resetiosflags(ios_base::fmtflags __mask) 
{ return {__mask}; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Resetiosflags __f) 
{ 
__is . setf (ios_base :: fmtflags (0) , __f . _M_mask) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Resetiosflags __f) 
{ 
__os . setf (ios_base :: fmtflags (0) , __f . _M_mask) ; 
return __os ; 
} 


struct _Setiosflags { ios_base::fmtflags _M_mask; }; 
# 96 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
inline _Setiosflags setiosflags(ios_base::fmtflags __mask) 
{ return {__mask}; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Setiosflags __f) 
{ 
__is . setf (__f . _M_mask) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Setiosflags __f) 
{ 
__os . setf (__f . _M_mask) ; 
return __os ; 
} 


struct _Setbase { int _M_base; }; 
# 127 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
inline _Setbase setbase(int __base) 
{ return {__base}; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Setbase __f) 
{ 
__is . setf (__f . _M_base == 8 ? ios_base :: oct : 
__f . _M_base == 10 ? ios_base :: dec : 
__f . _M_base == 16 ? ios_base :: hex : 
ios_base :: fmtflags (0) , ios_base :: basefield) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Setbase __f) 
{ 
__os . setf (__f . _M_base == 8 ? ios_base :: oct : 
__f . _M_base == 10 ? ios_base :: dec : 
__f . _M_base == 16 ? ios_base :: hex : 
ios_base :: fmtflags (0) , ios_base :: basefield) ; 
return __os ; 
} 


template < typename _CharT > 
struct _Setfill { _CharT _M_c ; } ;
# 163 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
template < typename _CharT > 
inline _Setfill < _CharT > 
setfill (_CharT __c) 
{ return { __c } ; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Setfill < _CharT > __f) 
{ 
__is . fill (__f . _M_c) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Setfill < _CharT > __f) 
{ 
__os . fill (__f . _M_c) ; 
return __os ; 
} 


struct _Setprecision { int _M_n; }; 
# 195 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
inline _Setprecision setprecision(int __n) 
{ return {__n}; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Setprecision __f) 
{ 
__is . precision (__f . _M_n) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Setprecision __f) 
{ 
__os . precision (__f . _M_n) ; 
return __os ; 
} 


struct _Setw { int _M_n; }; 
# 225 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
inline _Setw setw(int __n) 
{ return {__n}; } 

template < typename _CharT , typename _Traits > 
inline basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Setw __f) 
{ 
__is . width (__f . _M_n) ; 
return __is ; 
} 

template < typename _CharT , typename _Traits > 
inline basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Setw __f) 
{ 
__os . width (__f . _M_n) ; 
return __os ; 
} 



template < typename _MoneyT > 
struct _Get_money { _MoneyT & _M_mon ; bool _M_intl ; } ;
# 257 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
template < typename _MoneyT > 
inline _Get_money < _MoneyT > 
get_money (_MoneyT & __mon , bool __intl = false) 
{ return { __mon , __intl } ; } 

template < typename _CharT , typename _Traits , typename _MoneyT > 
basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Get_money < _MoneyT > __f) 
{ 
typename basic_istream < _CharT , _Traits > :: sentry __cerb (__is , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
typedef istreambuf_iterator < _CharT , _Traits > _Iter ; 
typedef money_get < _CharT , _Iter > _MoneyGet ; 

const _MoneyGet & __mg = use_facet < _MoneyGet > (__is . getloc ()) ; 
__mg . get (_Iter (__is . rdbuf ()) , _Iter () , __f . _M_intl , 
__is , __err , __f . _M_mon) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__is . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __is . _M_setstate (ios_base :: badbit) ; } 
if (__err) 
__is . setstate (__err) ; 
} 
return __is ; 
} 


template < typename _MoneyT > 
struct _Put_money { const _MoneyT & _M_mon ; bool _M_intl ; } ;
# 304 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
template < typename _MoneyT > 
inline _Put_money < _MoneyT > 
put_money (const _MoneyT & __mon , bool __intl = false) 
{ return { __mon , __intl } ; } 

template < typename _CharT , typename _Traits , typename _MoneyT > 
basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Put_money < _MoneyT > __f) 
{ 
typename basic_ostream < _CharT , _Traits > :: sentry __cerb (__os) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
typedef ostreambuf_iterator < _CharT , _Traits > _Iter ; 
typedef money_put < _CharT , _Iter > _MoneyPut ; 

const _MoneyPut & __mp = use_facet < _MoneyPut > (__os . getloc ()) ; 
if (__mp . put (_Iter (__os . rdbuf ()) , __f . _M_intl , __os , 
__os . fill () , __f . _M_mon) . failed ()) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__os . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __os . _M_setstate (ios_base :: badbit) ; } 
if (__err) 
__os . setstate (__err) ; 
} 
return __os ; 
} 

template < typename _CharT > 
struct _Put_time 
{ 
const std :: tm * _M_tmb ; 
const _CharT * _M_fmt ; 
} ;
# 356 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
template < typename _CharT > 
inline _Put_time < _CharT > 
put_time (const std :: tm * __tmb , const _CharT * __fmt) 
{ return { __tmb , __fmt } ; } 

template < typename _CharT , typename _Traits > 
basic_ostream < _CharT , _Traits > & 
operator << (basic_ostream < _CharT , _Traits > & __os , _Put_time < _CharT > __f) 
{ 
typename basic_ostream < _CharT , _Traits > :: sentry __cerb (__os) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
typedef ostreambuf_iterator < _CharT , _Traits > _Iter ; 
typedef time_put < _CharT , _Iter > _TimePut ; 

const _CharT * const __fmt_end = __f . _M_fmt + 
_Traits :: length (__f . _M_fmt) ; 

const _TimePut & __mp = use_facet < _TimePut > (__os . getloc ()) ; 
if (__mp . put (_Iter (__os . rdbuf ()) , __os , __os . fill () , 
__f . _M_tmb , __f . _M_fmt , __fmt_end) . failed ()) 
__err |= ios_base :: badbit ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__os . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __os . _M_setstate (ios_base :: badbit) ; } 
if (__err) 
__os . setstate (__err) ; 
} 
return __os ; 
} 

template < typename _CharT > 
struct _Get_time 
{ 
std :: tm * _M_tmb ; 
const _CharT * _M_fmt ; 
} ;
# 411 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
template < typename _CharT > 
inline _Get_time < _CharT > 
get_time (std :: tm * __tmb , const _CharT * __fmt) 
{ return { __tmb , __fmt } ; } 

template < typename _CharT , typename _Traits > 
basic_istream < _CharT , _Traits > & 
operator >> (basic_istream < _CharT , _Traits > & __is , _Get_time < _CharT > __f) 
{ 
typename basic_istream < _CharT , _Traits > :: sentry __cerb (__is , false) ; 
if (__cerb) 
{ 
ios_base :: iostate __err = ios_base :: goodbit ; 
try 
{ 
typedef istreambuf_iterator < _CharT , _Traits > _Iter ; 
typedef time_get < _CharT , _Iter > _TimeGet ; 

const _CharT * const __fmt_end = __f . _M_fmt + 
_Traits :: length (__f . _M_fmt) ; 

const _TimeGet & __mg = use_facet < _TimeGet > (__is . getloc ()) ; 
__mg . get (_Iter (__is . rdbuf ()) , _Iter () , __is , 
__err , __f . _M_tmb , __f . _M_fmt , __fmt_end) ; 
} 
catch (__cxxabiv1 :: __forced_unwind &) 
{ 
__is . _M_setstate (ios_base :: badbit) ; 
throw ; 
} 
catch (...) 
{ __is . _M_setstate (ios_base :: badbit) ; } 
if (__err) 
__is . setstate (__err) ; 
} 
return __is ; 
} 
# 508 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\iomanip" 3
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setfill< char>  __f);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setiosflags __f);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Resetiosflags __f);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setbase __f);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setprecision __f);
extern template basic_ostream< char>  &operator<<(basic_ostream< char>  & __os, _Setw __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setfill< char>  __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setiosflags __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Resetiosflags __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setbase __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setprecision __f);
extern template basic_istream< char>  &operator>>(basic_istream< char>  & __is, _Setw __f);


extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setfill< wchar_t>  __f);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setiosflags __f);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Resetiosflags __f);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setbase __f);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setprecision __f);
extern template basic_ostream< wchar_t>  &operator<<(basic_ostream< wchar_t>  & __os, _Setw __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setfill< wchar_t>  __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setiosflags __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Resetiosflags __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setbase __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setprecision __f);
extern template basic_istream< wchar_t>  &operator>>(basic_istream< wchar_t>  & __is, _Setw __f);




}
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\aligned_buffer.h" 3
namespace __gnu_cxx { 
# 46
template < typename _Tp > 
struct __aligned_membuf 
{ 
# 54
struct _Tp2 { _Tp _M_t ; } ; 

alignas (__alignof__ (_Tp2 :: _M_t)) unsigned char _M_storage [ sizeof (_Tp) ] ; 

__aligned_membuf () = default ; 


__aligned_membuf (std :: nullptr_t) { } 

void * 
_M_addr () noexcept 
{ return static_cast < void * > (& _M_storage) ; } 

const void * 
_M_addr () const noexcept 
{ return static_cast < const void * > (& _M_storage) ; } 

_Tp * 
_M_ptr () noexcept 
{ return static_cast < _Tp * > (_M_addr ()) ; } 

const _Tp * 
_M_ptr () const noexcept 
{ return static_cast < const _Tp * > (_M_addr ()) ; } 
} ;
# 89 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\ext\\aligned_buffer.h" 3
template < typename _Tp > 
struct __aligned_buffer 
: std :: aligned_storage < sizeof (_Tp) , __alignof__ (_Tp) > 
{ 
typename 
std :: aligned_storage < sizeof (_Tp) , __alignof__ (_Tp) > :: type _M_storage ; 

__aligned_buffer () = default ; 


__aligned_buffer (std :: nullptr_t) { } 

void * 
_M_addr () noexcept 
{ 
return static_cast < void * > (& _M_storage) ; 
} 

const void * 
_M_addr () const noexcept 
{ 
return static_cast < const void * > (& _M_storage) ; 
} 

_Tp * 
_M_ptr () noexcept 
{ return static_cast < _Tp * > (_M_addr ()) ; } 

const _Tp * 
_M_ptr () const noexcept 
{ return static_cast < const _Tp * > (_M_addr ()) ; } 
} ;


}
# 75 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
namespace std { 
# 99 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
enum _Rb_tree_color { _S_red, _S_black}; 

struct _Rb_tree_node_base { 

typedef _Rb_tree_node_base *_Base_ptr; 
typedef const _Rb_tree_node_base *_Const_Base_ptr; 

_Rb_tree_color _M_color; 
_Base_ptr _M_parent; 
_Base_ptr _M_left; 
_Base_ptr _M_right; 


static _Base_ptr _S_minimum(_Base_ptr __x) noexcept 
{ 
while (__x->_M_left != 0) __x = __x->_M_left;   
return __x; 
} 


static _Const_Base_ptr _S_minimum(_Const_Base_ptr __x) noexcept 
{ 
while (__x->_M_left != 0) __x = __x->_M_left;   
return __x; 
} 


static _Base_ptr _S_maximum(_Base_ptr __x) noexcept 
{ 
while (__x->_M_right != 0) __x = __x->_M_right;   
return __x; 
} 


static _Const_Base_ptr _S_maximum(_Const_Base_ptr __x) noexcept 
{ 
while (__x->_M_right != 0) __x = __x->_M_right;   
return __x; 
} 
}; 


template < typename _Key_compare > 
struct _Rb_tree_key_compare 
{ 
_Key_compare _M_key_compare ; 

_Rb_tree_key_compare () 
noexcept (is_nothrow_default_constructible < _Key_compare > :: value) 

: _M_key_compare () 
{ } 

_Rb_tree_key_compare (const _Key_compare & __comp) 
: _M_key_compare (__comp) 
{ } 



_Rb_tree_key_compare (const _Rb_tree_key_compare &) = default ; 

_Rb_tree_key_compare (_Rb_tree_key_compare && __x) 
noexcept (is_nothrow_copy_constructible < _Key_compare > :: value) 
: _M_key_compare (__x . _M_key_compare) 
{ } 

} ;


struct _Rb_tree_header { 

_Rb_tree_node_base _M_header; 
size_t _M_node_count; 

_Rb_tree_header() noexcept 
{ 
(_M_header)._M_color = _S_red; 
this->_M_reset(); 
} 


_Rb_tree_header(_Rb_tree_header &&__x) noexcept 
{ 
if ((__x._M_header)._M_parent != (nullptr)) 
this->_M_move_data(__x);  else 

{ 
(_M_header)._M_color = _S_red; 
this->_M_reset(); 
}  
} 



void _M_move_data(_Rb_tree_header &__from) 
{ 
(_M_header)._M_color = (__from._M_header)._M_color; 
(_M_header)._M_parent = (__from._M_header)._M_parent; 
(_M_header)._M_left = (__from._M_header)._M_left; 
(_M_header)._M_right = (__from._M_header)._M_right; 
(_M_header)._M_parent->_M_parent = &(_M_header); 
_M_node_count = __from._M_node_count; 

__from._M_reset(); 
} 


void _M_reset() 
{ 
(_M_header)._M_parent = 0; 
(_M_header)._M_left = &(_M_header); 
(_M_header)._M_right = &(_M_header); 
_M_node_count = 0; 
} 
}; 

template < typename _Val > 
struct _Rb_tree_node : public _Rb_tree_node_base 
{ 
typedef _Rb_tree_node < _Val > * _Link_type ; 
# 231 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
__gnu_cxx :: __aligned_membuf < _Val > _M_storage ; 

_Val * 
_M_valptr () 
{ return _M_storage . _M_ptr () ; } 

const _Val * 
_M_valptr () const 
{ return _M_storage . _M_ptr () ; } 

} ;


__attribute((__pure__)) _Rb_tree_node_base *_Rb_tree_increment(_Rb_tree_node_base * __x) throw(); 


__attribute((__pure__)) const _Rb_tree_node_base *_Rb_tree_increment(const _Rb_tree_node_base * __x) throw(); 


__attribute((__pure__)) _Rb_tree_node_base *_Rb_tree_decrement(_Rb_tree_node_base * __x) throw(); 


__attribute((__pure__)) const _Rb_tree_node_base *_Rb_tree_decrement(const _Rb_tree_node_base * __x) throw(); 

template < typename _Tp > 
struct _Rb_tree_iterator 
{ 
typedef _Tp value_type ; 
typedef _Tp & reference ; 
typedef _Tp * pointer ; 

typedef bidirectional_iterator_tag iterator_category ; 
typedef ptrdiff_t difference_type ; 

typedef _Rb_tree_iterator < _Tp > _Self ; 
typedef _Rb_tree_node_base :: _Base_ptr _Base_ptr ; 
typedef _Rb_tree_node < _Tp > * _Link_type ; 

_Rb_tree_iterator () noexcept 
: _M_node () { } 

explicit 
_Rb_tree_iterator (_Base_ptr __x) noexcept 
: _M_node (__x) { } 

reference 
operator * () const noexcept 
{ return * static_cast < _Link_type > (_M_node) -> _M_valptr () ; } 

pointer 
operator -> () const noexcept 
{ return static_cast < _Link_type > (_M_node) -> _M_valptr () ; } 

_Self & 
operator ++ () noexcept 
{ 
_M_node = _Rb_tree_increment (_M_node) ; 
return * this ; 
} 

_Self 
operator ++ (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _Rb_tree_increment (_M_node) ; 
return __tmp ; 
} 

_Self & 
operator -- () noexcept 
{ 
_M_node = _Rb_tree_decrement (_M_node) ; 
return * this ; 
} 

_Self 
operator -- (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _Rb_tree_decrement (_M_node) ; 
return __tmp ; 
} 

friend bool 
operator == (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node == __y . _M_node ; } 

friend bool 
operator != (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node != __y . _M_node ; } 

_Base_ptr _M_node ; 
} ;

template < typename _Tp > 
struct _Rb_tree_const_iterator 
{ 
typedef _Tp value_type ; 
typedef const _Tp & reference ; 
typedef const _Tp * pointer ; 

typedef _Rb_tree_iterator < _Tp > iterator ; 

typedef bidirectional_iterator_tag iterator_category ; 
typedef ptrdiff_t difference_type ; 

typedef _Rb_tree_const_iterator < _Tp > _Self ; 
typedef _Rb_tree_node_base :: _Const_Base_ptr _Base_ptr ; 
typedef const _Rb_tree_node < _Tp > * _Link_type ; 

_Rb_tree_const_iterator () noexcept 
: _M_node () { } 

explicit 
_Rb_tree_const_iterator (_Base_ptr __x) noexcept 
: _M_node (__x) { } 

_Rb_tree_const_iterator (const iterator & __it) noexcept 
: _M_node (__it . _M_node) { } 

iterator 
_M_const_cast () const noexcept 
{ return iterator (const_cast < typename iterator :: _Base_ptr > (_M_node)) ; } 

reference 
operator * () const noexcept 
{ return * static_cast < _Link_type > (_M_node) -> _M_valptr () ; } 

pointer 
operator -> () const noexcept 
{ return static_cast < _Link_type > (_M_node) -> _M_valptr () ; } 

_Self & 
operator ++ () noexcept 
{ 
_M_node = _Rb_tree_increment (_M_node) ; 
return * this ; 
} 

_Self 
operator ++ (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _Rb_tree_increment (_M_node) ; 
return __tmp ; 
} 

_Self & 
operator -- () noexcept 
{ 
_M_node = _Rb_tree_decrement (_M_node) ; 
return * this ; 
} 

_Self 
operator -- (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _Rb_tree_decrement (_M_node) ; 
return __tmp ; 
} 

friend bool 
operator == (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node == __y . _M_node ; } 

friend bool 
operator != (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node != __y . _M_node ; } 

_Base_ptr _M_node ; 
} ;


void _Rb_tree_insert_and_rebalance(const bool __insert_left, _Rb_tree_node_base * __x, _Rb_tree_node_base * __p, _Rb_tree_node_base & __header) throw(); 
# 411
_Rb_tree_node_base *_Rb_tree_rebalance_for_erase(_Rb_tree_node_base *const __z, _Rb_tree_node_base & __header) throw(); 
# 434 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc = allocator < _Val > > 
class _Rb_tree 
{ 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Rb_tree_node < _Val > > :: other _Node_allocator ; 

typedef __gnu_cxx :: __alloc_traits < _Node_allocator > _Alloc_traits ; 

protected : 
typedef _Rb_tree_node_base * _Base_ptr ; 
typedef const _Rb_tree_node_base * _Const_Base_ptr ; 
typedef _Rb_tree_node < _Val > * _Link_type ; 
typedef const _Rb_tree_node < _Val > * _Const_Link_type ; 

private : 


struct _Reuse_or_alloc_node 
{ 
_Reuse_or_alloc_node (_Rb_tree & __t) 
: _M_root (__t . _M_root ()) , _M_nodes (__t . _M_rightmost ()) , _M_t (__t) 
{ 
if (_M_root) 
{ 
_M_root -> _M_parent = 0 ; 

if (_M_nodes -> _M_left) 
_M_nodes = _M_nodes -> _M_left ; 
} 
else 
_M_nodes = 0 ; 
} 


_Reuse_or_alloc_node (const _Reuse_or_alloc_node &) = delete ; 


~ _Reuse_or_alloc_node () 
{ _M_t . _M_erase (static_cast < _Link_type > (_M_root)) ; } 

template < typename _Arg > 
_Link_type 



operator () (_Arg && __arg) 

{ 
_Link_type __node = static_cast < _Link_type > (_M_extract ()) ; 
if (__node) 
{ 
_M_t . _M_destroy_node (__node) ; 
_M_t . _M_construct_node (__node , std :: forward < _Arg > (__arg)) ; 
return __node ; 
} 

return _M_t . _M_create_node (std :: forward < _Arg > (__arg)) ; 
} 

private : 
_Base_ptr 
_M_extract () 
{ 
if (! _M_nodes) 
return _M_nodes ; 

_Base_ptr __node = _M_nodes ; 
_M_nodes = _M_nodes -> _M_parent ; 
if (_M_nodes) 
{ 
if (_M_nodes -> _M_right == __node) 
{ 
_M_nodes -> _M_right = 0 ; 

if (_M_nodes -> _M_left) 
{ 
_M_nodes = _M_nodes -> _M_left ; 

while (_M_nodes -> _M_right) 
_M_nodes = _M_nodes -> _M_right ; 

if (_M_nodes -> _M_left) 
_M_nodes = _M_nodes -> _M_left ; 
} 
} 
else 
_M_nodes -> _M_left = 0 ; 
} 
else 
_M_root = 0 ; 

return __node ; 
} 

_Base_ptr _M_root ; 
_Base_ptr _M_nodes ; 
_Rb_tree & _M_t ; 
} ; 



struct _Alloc_node 
{ 
_Alloc_node (_Rb_tree & __t) 
: _M_t (__t) { } 

template < typename _Arg > 
_Link_type 



operator () (_Arg && __arg) const 

{ return _M_t . _M_create_node (std :: forward < _Arg > (__arg)) ; } 

private : 
_Rb_tree & _M_t ; 
} ; 

public : 
typedef _Key key_type ; 
typedef _Val value_type ; 
typedef value_type * pointer ; 
typedef const value_type * const_pointer ; 
typedef value_type & reference ; 
typedef const value_type & const_reference ; 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Alloc allocator_type ; 

_Node_allocator & 
_M_get_Node_allocator () noexcept 
{ return this -> _M_impl ; } 

const _Node_allocator & 
_M_get_Node_allocator () const noexcept 
{ return this -> _M_impl ; } 

allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_get_Node_allocator ()) ; } 

protected : 
_Link_type 
_M_get_node () 
{ return _Alloc_traits :: allocate (_M_get_Node_allocator () , 1) ; } 

void 
_M_put_node (_Link_type __p) noexcept 
{ _Alloc_traits :: deallocate (_M_get_Node_allocator () , __p , 1) ; } 
# 607 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
template < typename ... _Args > 
void 
_M_construct_node (_Link_type __node , _Args && ... __args) 
{ 
try 
{ 
:: new (__node) _Rb_tree_node < _Val > ; 
_Alloc_traits :: construct (_M_get_Node_allocator () , 
__node -> _M_valptr () , 
std :: forward < _Args > (__args) ...) ; 
} 
catch (...) 
{ 
__node -> ~ _Rb_tree_node < _Val > () ; 
_M_put_node (__node) ; 
throw ; 
} 
} 

template < typename ... _Args > 
_Link_type 
_M_create_node (_Args && ... __args) 
{ 
_Link_type __tmp = _M_get_node () ; 
_M_construct_node (__tmp , std :: forward < _Args > (__args) ...) ; 
return __tmp ; 
} 


void 
_M_destroy_node (_Link_type __p) noexcept 
{ 



_Alloc_traits :: destroy (_M_get_Node_allocator () , __p -> _M_valptr ()) ; 
__p -> ~ _Rb_tree_node < _Val > () ; 

} 

void 
_M_drop_node (_Link_type __p) noexcept 
{ 
_M_destroy_node (__p) ; 
_M_put_node (__p) ; 
} 

template < typename _NodeGen > 
_Link_type 
_M_clone_node (_Const_Link_type __x , _NodeGen & __node_gen) 
{ 
_Link_type __tmp = __node_gen (* __x -> _M_valptr ()) ; 
__tmp -> _M_color = __x -> _M_color ; 
__tmp -> _M_left = 0 ; 
__tmp -> _M_right = 0 ; 
return __tmp ; 
} 

protected : 




template < typename _Key_compare , 
bool = __is_pod (_Key_compare) > 

struct _Rb_tree_impl 
: public _Node_allocator 
, public _Rb_tree_key_compare < _Key_compare > 
, public _Rb_tree_header 
{ 
typedef _Rb_tree_key_compare < _Key_compare > _Base_key_compare ; 

_Rb_tree_impl () 
noexcept (is_nothrow_default_constructible < _Node_allocator > :: value && is_nothrow_default_constructible < _Base_key_compare > :: value) 


: _Node_allocator () 
{ } 

_Rb_tree_impl (const _Rb_tree_impl & __x) 
: _Node_allocator (_Alloc_traits :: _S_select_on_copy (__x)) 
, _Base_key_compare (__x . _M_key_compare) 
{ } 
# 697
_Rb_tree_impl (_Rb_tree_impl &&) = default ; 

explicit 
_Rb_tree_impl (_Node_allocator && __a) 
: _Node_allocator (std :: move (__a)) 
{ } 

_Rb_tree_impl (_Rb_tree_impl && __x , _Node_allocator && __a) 
: _Node_allocator (std :: move (__a)) , 
_Base_key_compare (std :: move (__x)) , 
_Rb_tree_header (std :: move (__x)) 
{ } 

_Rb_tree_impl (const _Key_compare & __comp , _Node_allocator && __a) 
: _Node_allocator (std :: move (__a)) , _Base_key_compare (__comp) 
{ } 

} ; 

_Rb_tree_impl < _Compare > _M_impl ; 

protected : 
_Base_ptr & 
_M_root () noexcept 
{ return this -> _M_impl . _M_header . _M_parent ; } 

_Const_Base_ptr 
_M_root () const noexcept 
{ return this -> _M_impl . _M_header . _M_parent ; } 

_Base_ptr & 
_M_leftmost () noexcept 
{ return this -> _M_impl . _M_header . _M_left ; } 

_Const_Base_ptr 
_M_leftmost () const noexcept 
{ return this -> _M_impl . _M_header . _M_left ; } 

_Base_ptr & 
_M_rightmost () noexcept 
{ return this -> _M_impl . _M_header . _M_right ; } 

_Const_Base_ptr 
_M_rightmost () const noexcept 
{ return this -> _M_impl . _M_header . _M_right ; } 

_Link_type 
_M_begin () noexcept 
{ return static_cast < _Link_type > (this -> _M_impl . _M_header . _M_parent) ; } 

_Const_Link_type 
_M_begin () const noexcept 
{ 
return static_cast < _Const_Link_type > 
(this -> _M_impl . _M_header . _M_parent) ; 
} 

_Base_ptr 
_M_end () noexcept 
{ return & this -> _M_impl . _M_header ; } 

_Const_Base_ptr 
_M_end () const noexcept 
{ return & this -> _M_impl . _M_header ; } 

static const_reference 
_S_value (_Const_Link_type __x) 
{ return * __x -> _M_valptr () ; } 

static const _Key & 
_S_key (_Const_Link_type __x) 
{ 



static_assert (__is_invocable < _Compare & , const _Key & , const _Key & > { } , 
"comparison object must be invocable " 
"with two arguments of key type") ; 
# 785 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
return _KeyOfValue () (* __x -> _M_valptr ()) ; 
} 

static _Link_type 
_S_left (_Base_ptr __x) noexcept 
{ return static_cast < _Link_type > (__x -> _M_left) ; } 

static _Const_Link_type 
_S_left (_Const_Base_ptr __x) noexcept 
{ return static_cast < _Const_Link_type > (__x -> _M_left) ; } 

static _Link_type 
_S_right (_Base_ptr __x) noexcept 
{ return static_cast < _Link_type > (__x -> _M_right) ; } 

static _Const_Link_type 
_S_right (_Const_Base_ptr __x) noexcept 
{ return static_cast < _Const_Link_type > (__x -> _M_right) ; } 

static const_reference 
_S_value (_Const_Base_ptr __x) 
{ return * static_cast < _Const_Link_type > (__x) -> _M_valptr () ; } 

static const _Key & 
_S_key (_Const_Base_ptr __x) 
{ return _S_key (static_cast < _Const_Link_type > (__x)) ; } 

static _Base_ptr 
_S_minimum (_Base_ptr __x) noexcept 
{ return _Rb_tree_node_base :: _S_minimum (__x) ; } 

static _Const_Base_ptr 
_S_minimum (_Const_Base_ptr __x) noexcept 
{ return _Rb_tree_node_base :: _S_minimum (__x) ; } 

static _Base_ptr 
_S_maximum (_Base_ptr __x) noexcept 
{ return _Rb_tree_node_base :: _S_maximum (__x) ; } 

static _Const_Base_ptr 
_S_maximum (_Const_Base_ptr __x) noexcept 
{ return _Rb_tree_node_base :: _S_maximum (__x) ; } 

public : 
typedef _Rb_tree_iterator < value_type > iterator ; 
typedef _Rb_tree_const_iterator < value_type > const_iterator ; 

typedef std :: reverse_iterator < iterator > reverse_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 
# 842 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
pair < _Base_ptr , _Base_ptr > 
_M_get_insert_unique_pos (const key_type & __k) ; 

pair < _Base_ptr , _Base_ptr > 
_M_get_insert_equal_pos (const key_type & __k) ; 

pair < _Base_ptr , _Base_ptr > 
_M_get_insert_hint_unique_pos (const_iterator __pos , 
const key_type & __k) ; 

pair < _Base_ptr , _Base_ptr > 
_M_get_insert_hint_equal_pos (const_iterator __pos , 
const key_type & __k) ; 

private : 

template < typename _Arg , typename _NodeGen > 
iterator 
_M_insert_ (_Base_ptr __x , _Base_ptr __y , _Arg && __v , _NodeGen &) ; 

iterator 
_M_insert_node (_Base_ptr __x , _Base_ptr __y , _Link_type __z) ; 

template < typename _Arg > 
iterator 
_M_insert_lower (_Base_ptr __y , _Arg && __v) ; 

template < typename _Arg > 
iterator 
_M_insert_equal_lower (_Arg && __x) ; 

iterator 
_M_insert_lower_node (_Base_ptr __p , _Link_type __z) ; 

iterator 
_M_insert_equal_lower_node (_Link_type __z) ; 
# 893 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
template < typename _NodeGen > 
_Link_type 
_M_copy (_Const_Link_type __x , _Base_ptr __p , _NodeGen &) ; 

template < typename _NodeGen > 
_Link_type 
_M_copy (const _Rb_tree & __x , _NodeGen & __gen) 
{ 
_Link_type __root = _M_copy (__x . _M_begin () , _M_end () , __gen) ; 
_M_leftmost () = _S_minimum (__root) ; 
_M_rightmost () = _S_maximum (__root) ; 
_M_impl . _M_node_count = __x . _M_impl . _M_node_count ; 
return __root ; 
} 

_Link_type 
_M_copy (const _Rb_tree & __x) 
{ 
_Alloc_node __an (* this) ; 
return _M_copy (__x , __an) ; 
} 

void 
_M_erase (_Link_type __x) ; 

iterator 
_M_lower_bound (_Link_type __x , _Base_ptr __y , 
const _Key & __k) ; 

const_iterator 
_M_lower_bound (_Const_Link_type __x , _Const_Base_ptr __y , 
const _Key & __k) const ; 

iterator 
_M_upper_bound (_Link_type __x , _Base_ptr __y , 
const _Key & __k) ; 

const_iterator 
_M_upper_bound (_Const_Link_type __x , _Const_Base_ptr __y , 
const _Key & __k) const ; 

public : 




_Rb_tree () = default ; 


_Rb_tree (const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_impl (__comp , _Node_allocator (__a)) { } 

_Rb_tree (const _Rb_tree & __x) 
: _M_impl (__x . _M_impl) 
{ 
if (__x . _M_root () != 0) 
_M_root () = _M_copy (__x) ; 
} 


_Rb_tree (const allocator_type & __a) 
: _M_impl (_Node_allocator (__a)) 
{ } 

_Rb_tree (const _Rb_tree & __x , const allocator_type & __a) 
: _M_impl (__x . _M_impl . _M_key_compare , _Node_allocator (__a)) 
{ 
if (__x . _M_root () != nullptr) 
_M_root () = _M_copy (__x) ; 
} 

_Rb_tree (_Rb_tree &&) = default ; 

_Rb_tree (_Rb_tree && __x , const allocator_type & __a) 
: _Rb_tree (std :: move (__x) , _Node_allocator (__a)) 
{ } 

private : 
_Rb_tree (_Rb_tree && __x , _Node_allocator && __a , true_type) 
noexcept (is_nothrow_default_constructible < _Compare > :: value) 
: _M_impl (std :: move (__x . _M_impl) , std :: move (__a)) 
{ } 

_Rb_tree (_Rb_tree && __x , _Node_allocator && __a , false_type) 
: _M_impl (__x . _M_impl . _M_key_compare , std :: move (__a)) 
{ 
if (__x . _M_root () != nullptr) 
_M_move_data (__x , false_type { }) ; 
} 

public : 
_Rb_tree (_Rb_tree && __x , _Node_allocator && __a) 
noexcept (noexcept (
_Rb_tree (std :: declval < _Rb_tree && > () , std :: declval < _Node_allocator && > () , 
std :: declval < typename _Alloc_traits :: is_always_equal > ()))) 
: _Rb_tree (std :: move (__x) , std :: move (__a) , 
typename _Alloc_traits :: is_always_equal { }) 
{ } 


~ _Rb_tree () noexcept 
{ _M_erase (_M_begin ()) ; } 

_Rb_tree & 
operator = (const _Rb_tree & __x) ; 


_Compare 
key_comp () const 
{ return _M_impl . _M_key_compare ; } 

iterator 
begin () noexcept 
{ return iterator (this -> _M_impl . _M_header . _M_left) ; } 

const_iterator 
begin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_header . _M_left) ; } 

iterator 
end () noexcept 
{ return iterator (& this -> _M_impl . _M_header) ; } 

const_iterator 
end () const noexcept 
{ return const_iterator (& this -> _M_impl . _M_header) ; } 

reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (end ()) ; } 

const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 

reverse_iterator 
rend () noexcept 
{ return reverse_iterator (begin ()) ; } 

const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 

bool 
empty () const noexcept 
{ return _M_impl . _M_node_count == 0 ; } 

size_type 
size () const noexcept 
{ return _M_impl . _M_node_count ; } 

size_type 
max_size () const noexcept 
{ return _Alloc_traits :: max_size (_M_get_Node_allocator ()) ; } 

void 
swap (_Rb_tree & __t) 
noexcept (__is_nothrow_swappable < _Compare > :: value) ; 



template < typename _Arg > 
pair < iterator , bool > 
_M_insert_unique (_Arg && __x) ; 

template < typename _Arg > 
iterator 
_M_insert_equal (_Arg && __x) ; 

template < typename _Arg , typename _NodeGen > 
iterator 
_M_insert_unique_ (const_iterator __pos , _Arg && __x , _NodeGen &) ; 

template < typename _Arg > 
iterator 
_M_insert_unique_ (const_iterator __pos , _Arg && __x) 
{ 
_Alloc_node __an (* this) ; 
return _M_insert_unique_ (__pos , std :: forward < _Arg > (__x) , __an) ; 
} 

template < typename _Arg , typename _NodeGen > 
iterator 
_M_insert_equal_ (const_iterator __pos , _Arg && __x , _NodeGen &) ; 

template < typename _Arg > 
iterator 
_M_insert_equal_ (const_iterator __pos , _Arg && __x) 
{ 
_Alloc_node __an (* this) ; 
return _M_insert_equal_ (__pos , std :: forward < _Arg > (__x) , __an) ; 
} 

template < typename ... _Args > 
pair < iterator , bool > 
_M_emplace_unique (_Args && ... __args) ; 

template < typename ... _Args > 
iterator 
_M_emplace_equal (_Args && ... __args) ; 

template < typename ... _Args > 
iterator 
_M_emplace_hint_unique (const_iterator __pos , _Args && ... __args) ; 

template < typename ... _Args > 
iterator 
_M_emplace_hint_equal (const_iterator __pos , _Args && ... __args) ; 

template < typename _Iter > 
using __same_value_type 
= is_same < value_type , typename iterator_traits < _Iter > :: value_type > ; 

template < typename _InputIterator > 
__enable_if_t < __same_value_type < _InputIterator > :: value > 
_M_insert_range_unique (_InputIterator __first , _InputIterator __last) 
{ 
_Alloc_node __an (* this) ; 
for (; __first != __last ; ++ __first) 
_M_insert_unique_ (end () , * __first , __an) ; 
} 

template < typename _InputIterator > 
__enable_if_t < ! __same_value_type < _InputIterator > :: value > 
_M_insert_range_unique (_InputIterator __first , _InputIterator __last) 
{ 
for (; __first != __last ; ++ __first) 
_M_emplace_unique (* __first) ; 
} 

template < typename _InputIterator > 
__enable_if_t < __same_value_type < _InputIterator > :: value > 
_M_insert_range_equal (_InputIterator __first , _InputIterator __last) 
{ 
_Alloc_node __an (* this) ; 
for (; __first != __last ; ++ __first) 
_M_insert_equal_ (end () , * __first , __an) ; 
} 

template < typename _InputIterator > 
__enable_if_t < ! __same_value_type < _InputIterator > :: value > 
_M_insert_range_equal (_InputIterator __first , _InputIterator __last) 
{ 
_Alloc_node __an (* this) ; 
for (; __first != __last ; ++ __first) 
_M_emplace_equal (* __first) ; 
} 
# 1190 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
private : 
void 
_M_erase_aux (const_iterator __position) ; 

void 
_M_erase_aux (const_iterator __first , const_iterator __last) ; 

public : 



__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __position) 
{ 
; 
const_iterator __result = __position ; 
++ __result ; 
_M_erase_aux (__position) ; 
return __result . _M_const_cast () ; 
} 


__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (iterator __position) 
{ 
; 
iterator __result = __position ; 
++ __result ; 
_M_erase_aux (__position) ; 
return __result ; 
} 
# 1238 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
size_type 
erase (const key_type & __x) ; 




__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __first , const_iterator __last) 
{ 
_M_erase_aux (__first , __last) ; 
return __last . _M_const_cast () ; 
} 
# 1260 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
void 
erase (const key_type * __first , const key_type * __last) ; 

void 
clear () noexcept 
{ 
_M_erase (_M_begin ()) ; 
_M_impl . _M_reset () ; 
} 


iterator 
find (const key_type & __k) ; 

const_iterator 
find (const key_type & __k) const ; 

size_type 
count (const key_type & __k) const ; 

iterator 
lower_bound (const key_type & __k) 
{ return _M_lower_bound (_M_begin () , _M_end () , __k) ; } 

const_iterator 
lower_bound (const key_type & __k) const 
{ return _M_lower_bound (_M_begin () , _M_end () , __k) ; } 

iterator 
upper_bound (const key_type & __k) 
{ return _M_upper_bound (_M_begin () , _M_end () , __k) ; } 

const_iterator 
upper_bound (const key_type & __k) const 
{ return _M_upper_bound (_M_begin () , _M_end () , __k) ; } 

pair < iterator , iterator > 
equal_range (const key_type & __k) ; 

pair < const_iterator , const_iterator > 
equal_range (const key_type & __k) const ; 
# 1411 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
bool 
__rb_verify () const ; 


_Rb_tree & 
operator = (_Rb_tree &&) 
noexcept (_Alloc_traits :: _S_nothrow_move () 
&& is_nothrow_move_assignable < _Compare > :: value) ; 

template < typename _Iterator > 
void 
_M_assign_unique (_Iterator , _Iterator) ; 

template < typename _Iterator > 
void 
_M_assign_equal (_Iterator , _Iterator) ; 

private : 

void 
_M_move_data (_Rb_tree & __x , true_type) 
{ _M_impl . _M_move_data (__x . _M_impl) ; } 



void 
_M_move_data (_Rb_tree & , false_type) ; 


void 
_M_move_assign (_Rb_tree & , true_type) ; 



void 
_M_move_assign (_Rb_tree & , false_type) ; 
# 1615 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
friend bool 
operator == (const _Rb_tree & __x , const _Rb_tree & __y) 
{ 
return __x . size () == __y . size () 
&& std :: equal (__x . begin () , __x . end () , __y . begin ()) ; 
} 

friend bool 
operator < (const _Rb_tree & __x , const _Rb_tree & __y) 
{ 
return std :: lexicographical_compare (__x . begin () , __x . end () , 
__y . begin () , __y . end ()) ; 
} 

friend bool __attribute__ ((__deprecated__)) 
operator != (const _Rb_tree & __x , const _Rb_tree & __y) 
{ return ! (__x == __y) ; } 

friend bool __attribute__ ((__deprecated__)) 
operator > (const _Rb_tree & __x , const _Rb_tree & __y) 
{ return __y < __x ; } 

friend bool __attribute__ ((__deprecated__)) 
operator <= (const _Rb_tree & __x , const _Rb_tree & __y) 
{ return ! (__y < __x) ; } 

friend bool __attribute__ ((__deprecated__)) 
operator >= (const _Rb_tree & __x , const _Rb_tree & __y) 
{ return ! (__x < __y) ; } 
} ;

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
inline void 
swap (_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > & __x , 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > & __y) 
{ __x . swap (__y) ; } 


template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_move_data (_Rb_tree & __x , false_type) 
{ 
if (_M_get_Node_allocator () == __x . _M_get_Node_allocator ()) 
_M_move_data (__x , true_type ()) ; 
else 
{ 
_Alloc_node __an (* this) ; 
auto __lbd = 
[ & __an ] (const value_type & __cval) 
{ 
auto & __val = const_cast < value_type & > (__cval) ; 
return __an (std :: move_if_noexcept (__val)) ; 
} ; 
_M_root () = _M_copy (__x , __lbd) ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
inline void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_move_assign (_Rb_tree & __x , true_type) 
{ 
clear () ; 
if (__x . _M_root () != nullptr) 
_M_move_data (__x , true_type ()) ; 
std :: __alloc_on_move (_M_get_Node_allocator () , 
__x . _M_get_Node_allocator ()) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_move_assign (_Rb_tree & __x , false_type) 
{ 
if (_M_get_Node_allocator () == __x . _M_get_Node_allocator ()) 
return _M_move_assign (__x , true_type { }) ; 



_Reuse_or_alloc_node __roan (* this) ; 
_M_impl . _M_reset () ; 
if (__x . _M_root () != nullptr) 
{ 
auto __lbd = 
[ & __roan ] (const value_type & __cval) 
{ 
auto & __val = const_cast < value_type & > (__cval) ; 
return __roan (std :: move_if_noexcept (__val)) ; 
} ; 
_M_root () = _M_copy (__x , __lbd) ; 
__x . clear () ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
inline _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > & 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
operator = (_Rb_tree && __x) 
noexcept (_Alloc_traits :: _S_nothrow_move () 
&& is_nothrow_move_assignable < _Compare > :: value) 
{ 
_M_impl . _M_key_compare = std :: move (__x . _M_impl . _M_key_compare) ; 
_M_move_assign (__x , __bool_constant < _Alloc_traits :: _S_nothrow_move () > ()) ; 
return * this ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename _Iterator > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_assign_unique (_Iterator __first , _Iterator __last) 
{ 
_Reuse_or_alloc_node __roan (* this) ; 
_M_impl . _M_reset () ; 
for (; __first != __last ; ++ __first) 
_M_insert_unique_ (end () , * __first , __roan) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename _Iterator > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_assign_equal (_Iterator __first , _Iterator __last) 
{ 
_Reuse_or_alloc_node __roan (* this) ; 
_M_impl . _M_reset () ; 
for (; __first != __last ; ++ __first) 
_M_insert_equal_ (end () , * __first , __roan) ; 
} 


template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > & 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
operator = (const _Rb_tree & __x) 
{ 
if (this != & __x) 
{ 


if (_Alloc_traits :: _S_propagate_on_copy_assign ()) 
{ 
auto & __this_alloc = this -> _M_get_Node_allocator () ; 
auto & __that_alloc = __x . _M_get_Node_allocator () ; 
if (! _Alloc_traits :: _S_always_equal () 
&& __this_alloc != __that_alloc) 
{ 


clear () ; 
std :: __alloc_on_copy (__this_alloc , __that_alloc) ; 
} 
} 


_Reuse_or_alloc_node __roan (* this) ; 
_M_impl . _M_reset () ; 
_M_impl . _M_key_compare = __x . _M_impl . _M_key_compare ; 
if (__x . _M_root () != 0) 
_M_root () = _M_copy (__x , __roan) ; 
} 

return * this ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg , typename _NodeGen > 



typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_ (_Base_ptr __x , _Base_ptr __p , 

_Arg && __v , 



_NodeGen & __node_gen) 
{ 
bool __insert_left = (__x != 0 || __p == _M_end () 
|| _M_impl . _M_key_compare (_KeyOfValue () (__v) , 
_S_key (__p))) ; 

_Link_type __z = __node_gen (std :: forward < _Arg > (__v)) ; 

_Rb_tree_insert_and_rebalance (__insert_left , __z , __p , 
this -> _M_impl . _M_header) ; 
++ _M_impl . _M_node_count ; 
return iterator (__z) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg > 

typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 

_M_insert_lower (_Base_ptr __p , _Arg && __v) 



{ 
bool __insert_left = (__p == _M_end () 
|| ! _M_impl . _M_key_compare (_S_key (__p) , 
_KeyOfValue () (__v))) ; 

_Link_type __z = _M_create_node (std :: forward < _Arg > (__v)) ; 

_Rb_tree_insert_and_rebalance (__insert_left , __z , __p , 
this -> _M_impl . _M_header) ; 
++ _M_impl . _M_node_count ; 
return iterator (__z) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg > 

typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 

_M_insert_equal_lower (_Arg && __v) 



{ 
_Link_type __x = _M_begin () ; 
_Base_ptr __y = _M_end () ; 
while (__x != 0) 
{ 
__y = __x ; 
__x = ! _M_impl . _M_key_compare (_S_key (__x) , _KeyOfValue () (__v)) ? 
_S_left (__x) : _S_right (__x) ; 
} 
return _M_insert_lower (__y , std :: forward < _Arg > (__v)) ; 
} 

template < typename _Key , typename _Val , typename _KoV , 
typename _Compare , typename _Alloc > 
template < typename _NodeGen > 
typename _Rb_tree < _Key , _Val , _KoV , _Compare , _Alloc > :: _Link_type 
_Rb_tree < _Key , _Val , _KoV , _Compare , _Alloc > :: 
_M_copy (_Const_Link_type __x , _Base_ptr __p , _NodeGen & __node_gen) 
{ 

_Link_type __top = _M_clone_node (__x , __node_gen) ; 
__top -> _M_parent = __p ; 

try 
{ 
if (__x -> _M_right) 
__top -> _M_right = _M_copy (_S_right (__x) , __top , __node_gen) ; 
__p = __top ; 
__x = _S_left (__x) ; 

while (__x != 0) 
{ 
_Link_type __y = _M_clone_node (__x , __node_gen) ; 
__p -> _M_left = __y ; 
__y -> _M_parent = __p ; 
if (__x -> _M_right) 
__y -> _M_right = _M_copy (_S_right (__x) , __y , __node_gen) ; 
__p = __y ; 
__x = _S_left (__x) ; 
} 
} 
catch (...) 
{ 
_M_erase (__top) ; 
throw ; 
} 
return __top ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_erase (_Link_type __x) 
{ 

while (__x != 0) 
{ 
_M_erase (_S_right (__x)) ; 
_Link_type __y = _S_left (__x) ; 
_M_drop_node (__x) ; 
__x = __y ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_lower_bound (_Link_type __x , _Base_ptr __y , 
const _Key & __k) 
{ 
while (__x != 0) 
if (! _M_impl . _M_key_compare (_S_key (__x) , __k)) 
__y = __x , __x = _S_left (__x) ; 
else 
__x = _S_right (__x) ; 
return iterator (__y) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: const_iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_lower_bound (_Const_Link_type __x , _Const_Base_ptr __y , 
const _Key & __k) const 
{ 
while (__x != 0) 
if (! _M_impl . _M_key_compare (_S_key (__x) , __k)) 
__y = __x , __x = _S_left (__x) ; 
else 
__x = _S_right (__x) ; 
return const_iterator (__y) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_upper_bound (_Link_type __x , _Base_ptr __y , 
const _Key & __k) 
{ 
while (__x != 0) 
if (_M_impl . _M_key_compare (__k , _S_key (__x))) 
__y = __x , __x = _S_left (__x) ; 
else 
__x = _S_right (__x) ; 
return iterator (__y) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: const_iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_upper_bound (_Const_Link_type __x , _Const_Base_ptr __y , 
const _Key & __k) const 
{ 
while (__x != 0) 
if (_M_impl . _M_key_compare (__k , _S_key (__x))) 
__y = __x , __x = _S_left (__x) ; 
else 
__x = _S_right (__x) ; 
return const_iterator (__y) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
equal_range (const _Key & __k) 
{ 
_Link_type __x = _M_begin () ; 
_Base_ptr __y = _M_end () ; 
while (__x != 0) 
{ 
if (_M_impl . _M_key_compare (_S_key (__x) , __k)) 
__x = _S_right (__x) ; 
else if (_M_impl . _M_key_compare (__k , _S_key (__x))) 
__y = __x , __x = _S_left (__x) ; 
else 
{ 
_Link_type __xu (__x) ; 
_Base_ptr __yu (__y) ; 
__y = __x , __x = _S_left (__x) ; 
__xu = _S_right (__xu) ; 
return pair < iterator , 
iterator > (_M_lower_bound (__x , __y , __k) , 
_M_upper_bound (__xu , __yu , __k)) ; 
} 
} 
return pair < iterator , iterator > (iterator (__y) , 
iterator (__y)) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: const_iterator , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: const_iterator > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
equal_range (const _Key & __k) const 
{ 
_Const_Link_type __x = _M_begin () ; 
_Const_Base_ptr __y = _M_end () ; 
while (__x != 0) 
{ 
if (_M_impl . _M_key_compare (_S_key (__x) , __k)) 
__x = _S_right (__x) ; 
else if (_M_impl . _M_key_compare (__k , _S_key (__x))) 
__y = __x , __x = _S_left (__x) ; 
else 
{ 
_Const_Link_type __xu (__x) ; 
_Const_Base_ptr __yu (__y) ; 
__y = __x , __x = _S_left (__x) ; 
__xu = _S_right (__xu) ; 
return pair < const_iterator , 
const_iterator > (_M_lower_bound (__x , __y , __k) , 
_M_upper_bound (__xu , __yu , __k)) ; 
} 
} 
return pair < const_iterator , const_iterator > (const_iterator (__y) , 
const_iterator (__y)) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
swap (_Rb_tree & __t) 
noexcept (__is_nothrow_swappable < _Compare > :: value) 
{ 
if (_M_root () == 0) 
{ 
if (__t . _M_root () != 0) 
_M_impl . _M_move_data (__t . _M_impl) ; 
} 
else if (__t . _M_root () == 0) 
__t . _M_impl . _M_move_data (_M_impl) ; 
else 
{ 
std :: swap (_M_root () , __t . _M_root ()) ; 
std :: swap (_M_leftmost () , __t . _M_leftmost ()) ; 
std :: swap (_M_rightmost () , __t . _M_rightmost ()) ; 

_M_root () -> _M_parent = _M_end () ; 
__t . _M_root () -> _M_parent = __t . _M_end () ; 
std :: swap (this -> _M_impl . _M_node_count , __t . _M_impl . _M_node_count) ; 
} 

std :: swap (this -> _M_impl . _M_key_compare , __t . _M_impl . _M_key_compare) ; 

_Alloc_traits :: _S_on_swap (_M_get_Node_allocator () , 
__t . _M_get_Node_allocator ()) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_get_insert_unique_pos (const key_type & __k) 
{ 
typedef pair < _Base_ptr , _Base_ptr > _Res ; 
_Link_type __x = _M_begin () ; 
_Base_ptr __y = _M_end () ; 
bool __comp = true ; 
while (__x != 0) 
{ 
__y = __x ; 
__comp = _M_impl . _M_key_compare (__k , _S_key (__x)) ; 
__x = __comp ? _S_left (__x) : _S_right (__x) ; 
} 
iterator __j = iterator (__y) ; 
if (__comp) 
{ 
if (__j == begin ()) 
return _Res (__x , __y) ; 
else 
-- __j ; 
} 
if (_M_impl . _M_key_compare (_S_key (__j . _M_node) , __k)) 
return _Res (__x , __y) ; 
return _Res (__j . _M_node , 0) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_get_insert_equal_pos (const key_type & __k) 
{ 
typedef pair < _Base_ptr , _Base_ptr > _Res ; 
_Link_type __x = _M_begin () ; 
_Base_ptr __y = _M_end () ; 
while (__x != 0) 
{ 
__y = __x ; 
__x = _M_impl . _M_key_compare (__k , _S_key (__x)) ? 
_S_left (__x) : _S_right (__x) ; 
} 
return _Res (__x , __y) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg > 

pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator , bool > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 

_M_insert_unique (_Arg && __v) 



{ 
typedef pair < iterator , bool > _Res ; 
pair < _Base_ptr , _Base_ptr > __res 
= _M_get_insert_unique_pos (_KeyOfValue () (__v)) ; 

if (__res . second) 
{ 
_Alloc_node __an (* this) ; 
return _Res (_M_insert_ (__res . first , __res . second , 
std :: forward < _Arg > (__v) , __an) , 
true) ; 
} 

return _Res (iterator (__res . first) , false) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg > 

typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 

_M_insert_equal (_Arg && __v) 



{ 
pair < _Base_ptr , _Base_ptr > __res 
= _M_get_insert_equal_pos (_KeyOfValue () (__v)) ; 
_Alloc_node __an (* this) ; 
return _M_insert_ (__res . first , __res . second , 
std :: forward < _Arg > (__v) , __an) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_get_insert_hint_unique_pos (const_iterator __position , 
const key_type & __k) 
{ 
iterator __pos = __position . _M_const_cast () ; 
typedef pair < _Base_ptr , _Base_ptr > _Res ; 


if (__pos . _M_node == _M_end ()) 
{ 
if (size () > 0 
&& _M_impl . _M_key_compare (_S_key (_M_rightmost ()) , __k)) 
return _Res (0 , _M_rightmost ()) ; 
else 
return _M_get_insert_unique_pos (__k) ; 
} 
else if (_M_impl . _M_key_compare (__k , _S_key (__pos . _M_node))) 
{ 

iterator __before = __pos ; 
if (__pos . _M_node == _M_leftmost ()) 
return _Res (_M_leftmost () , _M_leftmost ()) ; 
else if (_M_impl . _M_key_compare (_S_key ((-- __before) . _M_node) , __k)) 
{ 
if (_S_right (__before . _M_node) == 0) 
return _Res (0 , __before . _M_node) ; 
else 
return _Res (__pos . _M_node , __pos . _M_node) ; 
} 
else 
return _M_get_insert_unique_pos (__k) ; 
} 
else if (_M_impl . _M_key_compare (_S_key (__pos . _M_node) , __k)) 
{ 

iterator __after = __pos ; 
if (__pos . _M_node == _M_rightmost ()) 
return _Res (0 , _M_rightmost ()) ; 
else if (_M_impl . _M_key_compare (__k , _S_key ((++ __after) . _M_node))) 
{ 
if (_S_right (__pos . _M_node) == 0) 
return _Res (0 , __pos . _M_node) ; 
else 
return _Res (__after . _M_node , __after . _M_node) ; 
} 
else 
return _M_get_insert_unique_pos (__k) ; 
} 
else 

return _Res (__pos . _M_node , 0) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg , typename _NodeGen > 



typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_unique_ (const_iterator __position , 

_Arg && __v , 



_NodeGen & __node_gen) 
{ 
pair < _Base_ptr , _Base_ptr > __res 
= _M_get_insert_hint_unique_pos (__position , _KeyOfValue () (__v)) ; 

if (__res . second) 
return _M_insert_ (__res . first , __res . second , 
std :: forward < _Arg > (__v) , 
__node_gen) ; 
return iterator (__res . first) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr , 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: _Base_ptr > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_get_insert_hint_equal_pos (const_iterator __position , const key_type & __k) 
{ 
iterator __pos = __position . _M_const_cast () ; 
typedef pair < _Base_ptr , _Base_ptr > _Res ; 


if (__pos . _M_node == _M_end ()) 
{ 
if (size () > 0 
&& ! _M_impl . _M_key_compare (__k , _S_key (_M_rightmost ()))) 
return _Res (0 , _M_rightmost ()) ; 
else 
return _M_get_insert_equal_pos (__k) ; 
} 
else if (! _M_impl . _M_key_compare (_S_key (__pos . _M_node) , __k)) 
{ 

iterator __before = __pos ; 
if (__pos . _M_node == _M_leftmost ()) 
return _Res (_M_leftmost () , _M_leftmost ()) ; 
else if (! _M_impl . _M_key_compare (__k , _S_key ((-- __before) . _M_node))) 
{ 
if (_S_right (__before . _M_node) == 0) 
return _Res (0 , __before . _M_node) ; 
else 
return _Res (__pos . _M_node , __pos . _M_node) ; 
} 
else 
return _M_get_insert_equal_pos (__k) ; 
} 
else 
{ 

iterator __after = __pos ; 
if (__pos . _M_node == _M_rightmost ()) 
return _Res (0 , _M_rightmost ()) ; 
else if (! _M_impl . _M_key_compare (_S_key ((++ __after) . _M_node) , __k)) 
{ 
if (_S_right (__pos . _M_node) == 0) 
return _Res (0 , __pos . _M_node) ; 
else 
return _Res (__after . _M_node , __after . _M_node) ; 
} 
else 
return _Res (0 , 0) ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 

template < typename _Arg , typename _NodeGen > 



typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_equal_ (const_iterator __position , 

_Arg && __v , 



_NodeGen & __node_gen) 
{ 
pair < _Base_ptr , _Base_ptr > __res 
= _M_get_insert_hint_equal_pos (__position , _KeyOfValue () (__v)) ; 

if (__res . second) 
return _M_insert_ (__res . first , __res . second , 
std :: forward < _Arg > (__v) , 
__node_gen) ; 

return _M_insert_equal_lower (std :: forward < _Arg > (__v)) ; 
} 


template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_node (_Base_ptr __x , _Base_ptr __p , _Link_type __z) 
{ 
bool __insert_left = (__x != 0 || __p == _M_end () 
|| _M_impl . _M_key_compare (_S_key (__z) , 
_S_key (__p))) ; 

_Rb_tree_insert_and_rebalance (__insert_left , __z , __p , 
this -> _M_impl . _M_header) ; 
++ _M_impl . _M_node_count ; 
return iterator (__z) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_lower_node (_Base_ptr __p , _Link_type __z) 
{ 
bool __insert_left = (__p == _M_end () 
|| ! _M_impl . _M_key_compare (_S_key (__p) , 
_S_key (__z))) ; 

_Rb_tree_insert_and_rebalance (__insert_left , __z , __p , 
this -> _M_impl . _M_header) ; 
++ _M_impl . _M_node_count ; 
return iterator (__z) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_insert_equal_lower_node (_Link_type __z) 
{ 
_Link_type __x = _M_begin () ; 
_Base_ptr __y = _M_end () ; 
while (__x != 0) 
{ 
__y = __x ; 
__x = ! _M_impl . _M_key_compare (_S_key (__x) , _S_key (__z)) ? 
_S_left (__x) : _S_right (__x) ; 
} 
return _M_insert_lower_node (__y , __z) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename ... _Args > 
pair < typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator , bool > 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_emplace_unique (_Args && ... __args) 
{ 
_Link_type __z = _M_create_node (std :: forward < _Args > (__args) ...) ; 

try 
{ 
typedef pair < iterator , bool > _Res ; 
auto __res = _M_get_insert_unique_pos (_S_key (__z)) ; 
if (__res . second) 
return _Res (_M_insert_node (__res . first , __res . second , __z) , true) ; 

_M_drop_node (__z) ; 
return _Res (iterator (__res . first) , false) ; 
} 
catch (...) 
{ 
_M_drop_node (__z) ; 
throw ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename ... _Args > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_emplace_equal (_Args && ... __args) 
{ 
_Link_type __z = _M_create_node (std :: forward < _Args > (__args) ...) ; 

try 
{ 
auto __res = _M_get_insert_equal_pos (_S_key (__z)) ; 
return _M_insert_node (__res . first , __res . second , __z) ; 
} 
catch (...) 
{ 
_M_drop_node (__z) ; 
throw ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename ... _Args > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_emplace_hint_unique (const_iterator __pos , _Args && ... __args) 
{ 
_Link_type __z = _M_create_node (std :: forward < _Args > (__args) ...) ; 

try 
{ 
auto __res = _M_get_insert_hint_unique_pos (__pos , _S_key (__z)) ; 

if (__res . second) 
return _M_insert_node (__res . first , __res . second , __z) ; 

_M_drop_node (__z) ; 
return iterator (__res . first) ; 
} 
catch (...) 
{ 
_M_drop_node (__z) ; 
throw ; 
} 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
template < typename ... _Args > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_emplace_hint_equal (const_iterator __pos , _Args && ... __args) 
{ 
_Link_type __z = _M_create_node (std :: forward < _Args > (__args) ...) ; 

try 
{ 
auto __res = _M_get_insert_hint_equal_pos (__pos , _S_key (__z)) ; 

if (__res . second) 
return _M_insert_node (__res . first , __res . second , __z) ; 

return _M_insert_equal_lower_node (__z) ; 
} 
catch (...) 
{ 
_M_drop_node (__z) ; 
throw ; 
} 
} 



template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_erase_aux (const_iterator __position) 
{ 
_Link_type __y = 
static_cast < _Link_type > (_Rb_tree_rebalance_for_erase 
(const_cast < _Base_ptr > (__position . _M_node) , 
this -> _M_impl . _M_header)) ; 
_M_drop_node (__y) ; 
-- _M_impl . _M_node_count ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
_M_erase_aux (const_iterator __first , const_iterator __last) 
{ 
if (__first == begin () && __last == end ()) 
clear () ; 
else 
while (__first != __last) 
_M_erase_aux (__first ++) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: size_type 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
erase (const _Key & __x) 
{ 
pair < iterator , iterator > __p = equal_range (__x) ; 
const size_type __old_size = size () ; 
_M_erase_aux (__p . first , __p . second) ; 
return __old_size - size () ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
void 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
erase (const _Key * __first , const _Key * __last) 
{ 
while (__first != __last) 
erase (* __first ++) ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
find (const _Key & __k) 
{ 
iterator __j = _M_lower_bound (_M_begin () , _M_end () , __k) ; 
return (__j == end () 
|| _M_impl . _M_key_compare (__k , 
_S_key (__j . _M_node))) ? end () : __j ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , 
_Compare , _Alloc > :: const_iterator 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
find (const _Key & __k) const 
{ 
const_iterator __j = _M_lower_bound (_M_begin () , _M_end () , __k) ; 
return (__j == end () 
|| _M_impl . _M_key_compare (__k , 
_S_key (__j . _M_node))) ? end () : __j ; 
} 

template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
typename _Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: size_type 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: 
count (const _Key & __k) const 
{ 
pair < const_iterator , const_iterator > __p = equal_range (__k) ; 
const size_type __n = std :: distance (__p . first , __p . second) ; 
return __n ; 
} 


__attribute((__pure__)) unsigned _Rb_tree_black_count(const _Rb_tree_node_base * __node, const _Rb_tree_node_base * __root) throw(); 


template < typename _Key , typename _Val , typename _KeyOfValue , 
typename _Compare , typename _Alloc > 
bool 
_Rb_tree < _Key , _Val , _KeyOfValue , _Compare , _Alloc > :: __rb_verify () const 
{ 
if (_M_impl . _M_node_count == 0 || begin () == end ()) 
return _M_impl . _M_node_count == 0 && begin () == end () 
&& this -> _M_impl . _M_header . _M_left == _M_end () 
&& this -> _M_impl . _M_header . _M_right == _M_end () ; 

unsigned int __len = _Rb_tree_black_count (_M_leftmost () , _M_root ()) ; 
for (const_iterator __it = begin () ; __it != end () ; ++ __it) 
{ 
_Const_Link_type __x = static_cast < _Const_Link_type > (__it . _M_node) ; 
_Const_Link_type __L = _S_left (__x) ; 
_Const_Link_type __R = _S_right (__x) ; 

if (__x -> _M_color == _S_red) 
if ((__L && __L -> _M_color == _S_red) 
|| (__R && __R -> _M_color == _S_red)) 
return false ; 

if (__L && _M_impl . _M_key_compare (_S_key (__x) , _S_key (__L))) 
return false ; 
if (__R && _M_impl . _M_key_compare (_S_key (__R) , _S_key (__x))) 
return false ; 

if (! __L && ! __R && _Rb_tree_black_count (__x , _M_root ()) != __len) 
return false ; 
} 

if (_M_leftmost () != _Rb_tree_node_base :: _S_minimum (_M_root ())) 
return false ; 
if (_M_rightmost () != _Rb_tree_node_base :: _S_maximum (_M_root ())) 
return false ; 
return true ; 
} 
# 2646 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_tree.h" 3
}
# 66 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
namespace std { 




template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    class multimap;
# 98 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _Key , typename _Tp , typename _Compare = std :: less < _Key > , 
typename _Alloc = std :: allocator < std :: pair < const _Key , _Tp > > > 
class map 
{ 
public : 
typedef _Key key_type ; 
typedef _Tp mapped_type ; 
typedef std :: pair < const _Key , _Tp > value_type ; 
typedef _Compare key_compare ; 
typedef _Alloc allocator_type ; 

private : 
# 126 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
public : 
class value_compare 
: public std :: binary_function < value_type , value_type , bool > 
{ 
friend class map < _Key , _Tp , _Compare , _Alloc > ; 
protected : 
_Compare comp ; 

value_compare (_Compare __c) 
: comp (__c) { } 

public : 
bool operator () (const value_type & __x , const value_type & __y) const 
{ return comp (__x . first , __y . first) ; } 
} ; 

private : 

typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < value_type > :: other _Pair_alloc_type ; 

typedef _Rb_tree < key_type , value_type , _Select1st < value_type > , 
key_compare , _Pair_alloc_type > _Rep_type ; 


_Rep_type _M_t ; 

typedef __gnu_cxx :: __alloc_traits < _Pair_alloc_type > _Alloc_traits ; 

public : 


typedef typename _Alloc_traits :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 
typedef typename _Rep_type :: iterator iterator ; 
typedef typename _Rep_type :: const_iterator const_iterator ; 
typedef typename _Rep_type :: size_type size_type ; 
typedef typename _Rep_type :: difference_type difference_type ; 
typedef typename _Rep_type :: reverse_iterator reverse_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator ; 
# 183 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
map () = default ; 
# 191
explicit 
map (const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) { } 
# 205 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
map (const map &) = default ; 
# 213
map (map &&) = default ; 
# 226 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
map (initializer_list < value_type > __l , 
const _Compare & __comp = _Compare () , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__l . begin () , __l . end ()) ; } 


explicit 
map (const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) { } 


map (const map & __m , const allocator_type & __a) 
: _M_t (__m . _M_t , _Pair_alloc_type (__a)) { } 


map (map && __m , const allocator_type & __a) 
noexcept (is_nothrow_copy_constructible < _Compare > :: value 
&& _Alloc_traits :: _S_always_equal ()) 
: _M_t (std :: move (__m . _M_t) , _Pair_alloc_type (__a)) { } 


map (initializer_list < value_type > __l , const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__l . begin () , __l . end ()) ; } 


template < typename _InputIterator > 
map (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 270 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _InputIterator > 
map (_InputIterator __first , _InputIterator __last) 
: _M_t () 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 287 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _InputIterator > 
map (_InputIterator __first , _InputIterator __last , 
const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 300
~ map () = default ; 
# 316 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
map & 
operator = (const map &) = default ; 


map & 
operator = (map &&) = default ; 
# 334 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
map & 
operator = (initializer_list < value_type > __l) 
{ 
_M_t . _M_assign_unique (__l . begin () , __l . end ()) ; 
return * this ; 
} 



allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_t . get_allocator ()) ; } 
# 353
iterator 
begin () noexcept 
{ return _M_t . begin () ; } 
# 362
const_iterator 
begin () const noexcept 
{ return _M_t . begin () ; } 
# 371
iterator 
end () noexcept 
{ return _M_t . end () ; } 
# 380
const_iterator 
end () const noexcept 
{ return _M_t . end () ; } 
# 389
reverse_iterator 
rbegin () noexcept 
{ return _M_t . rbegin () ; } 
# 398
const_reverse_iterator 
rbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 407
reverse_iterator 
rend () noexcept 
{ return _M_t . rend () ; } 
# 416
const_reverse_iterator 
rend () const noexcept 
{ return _M_t . rend () ; } 
# 426
const_iterator 
cbegin () const noexcept 
{ return _M_t . begin () ; } 
# 435
const_iterator 
cend () const noexcept 
{ return _M_t . end () ; } 
# 444
const_reverse_iterator 
crbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 453
const_reverse_iterator 
crend () const noexcept 
{ return _M_t . rend () ; } 
# 462
bool 
empty () const noexcept 
{ return _M_t . empty () ; } 


size_type 
size () const noexcept 
{ return _M_t . size () ; } 


size_type 
max_size () const noexcept 
{ return _M_t . max_size () ; } 
# 489 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
mapped_type & 
operator [ ] (const key_type & __k) 
{ 



iterator __i = lower_bound (__k) ; 

if (__i == end () || key_comp () (__k , (* __i) . first)) 

__i = _M_t . _M_emplace_hint_unique (__i , std :: piecewise_construct , 
std :: tuple < const key_type & > (__k) , 
std :: tuple < > ()) ; 



return (* __i) . second ; 
} 


mapped_type & 
operator [ ] (key_type && __k) 
{ 



iterator __i = lower_bound (__k) ; 

if (__i == end () || key_comp () (__k , (* __i) . first)) 
__i = _M_t . _M_emplace_hint_unique (__i , std :: piecewise_construct , 
std :: forward_as_tuple (std :: move (__k)) , 
std :: tuple < > ()) ; 
return (* __i) . second ; 
} 
# 534 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
mapped_type & 
at (const key_type & __k) 
{ 
iterator __i = lower_bound (__k) ; 
if (__i == end () || key_comp () (__k , (* __i) . first)) 
__throw_out_of_range (("map::at")) ; 
return (* __i) . second ; 
} 

const mapped_type & 
at (const key_type & __k) const 
{ 
const_iterator __i = lower_bound (__k) ; 
if (__i == end () || key_comp () (__k , (* __i) . first)) 
__throw_out_of_range (("map::at")) ; 
return (* __i) . second ; 
} 
# 572 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename ... _Args > 
std :: pair < iterator , bool > 
emplace (_Args && ... __args) 
{ return _M_t . _M_emplace_unique (std :: forward < _Args > (__args) ...) ; } 
# 602 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename ... _Args > 
iterator 
emplace_hint (const_iterator __pos , _Args && ... __args) 
{ 
return _M_t . _M_emplace_hint_unique (__pos , 
std :: forward < _Args > (__args) ...) ; 
} 
# 800 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
std :: pair < iterator , bool > 
insert (const value_type & __x) 
{ return _M_t . _M_insert_unique (__x) ; } 




std :: pair < iterator , bool > 
insert (value_type && __x) 
{ return _M_t . _M_insert_unique (std :: move (__x)) ; } 

template < typename _Pair > 
__enable_if_t < is_constructible < value_type , _Pair > :: value , 
pair < iterator , bool > > 
insert (_Pair && __x) 
{ return _M_t . _M_emplace_unique (std :: forward < _Pair > (__x)) ; } 
# 827 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
void 
insert (std :: initializer_list < value_type > __list) 
{ insert (__list . begin () , __list . end ()) ; } 
# 856 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 

insert (const_iterator __position , const value_type & __x) 



{ return _M_t . _M_insert_unique_ (__position , __x) ; } 




iterator 
insert (const_iterator __position , value_type && __x) 
{ return _M_t . _M_insert_unique_ (__position , std :: move (__x)) ; } 

template < typename _Pair > 
__enable_if_t < is_constructible < value_type , _Pair > :: value , iterator > 
insert (const_iterator __position , _Pair && __x) 
{ 
return _M_t . _M_emplace_hint_unique (__position , 
std :: forward < _Pair > (__x)) ; 
} 
# 889 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _InputIterator > 
void 
insert (_InputIterator __first , _InputIterator __last) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 1029 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 
erase (const_iterator __position) 
{ return _M_t . erase (__position) ; } 


__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (iterator __position) 
{ return _M_t . erase (__position) ; } 
# 1066 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
size_type 
erase (const key_type & __x) 
{ return _M_t . erase (__x) ; } 
# 1086 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 
erase (const_iterator __first , const_iterator __last) 
{ return _M_t . erase (__first , __last) ; } 
# 1120 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
void 
swap (map & __x) 
noexcept (__is_nothrow_swappable < _Compare > :: value) 
{ _M_t . swap (__x . _M_t) ; } 
# 1131
void 
clear () noexcept 
{ _M_t . clear () ; } 
# 1140
key_compare 
key_comp () const 
{ return _M_t . key_comp () ; } 
# 1148
value_compare 
value_comp () const 
{ return value_compare (_M_t . key_comp ()) ; } 
# 1167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 
find (const key_type & __x) 
{ return _M_t . find (__x) ; } 
# 1192 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
const_iterator 
find (const key_type & __x) const 
{ return _M_t . find (__x) ; } 
# 1213 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
size_type 
count (const key_type & __x) const 
{ return _M_t . find (__x) == _M_t . end () ? 0 : 1 ; } 
# 1256 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 
lower_bound (const key_type & __x) 
{ return _M_t . lower_bound (__x) ; } 
# 1281 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
const_iterator 
lower_bound (const key_type & __x) const 
{ return _M_t . lower_bound (__x) ; } 
# 1301 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
iterator 
upper_bound (const key_type & __x) 
{ return _M_t . upper_bound (__x) ; } 
# 1321 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
const_iterator 
upper_bound (const key_type & __x) const 
{ return _M_t . upper_bound (__x) ; } 
# 1350 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
std :: pair < iterator , iterator > 
equal_range (const key_type & __x) 
{ return _M_t . equal_range (__x) ; } 
# 1379 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
std :: pair < const_iterator , const_iterator > 
equal_range (const key_type & __x) const 
{ return _M_t . equal_range (__x) ; } 
# 1396 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _K1 , typename _T1 , typename _C1 , typename _A1 > 
friend bool 
operator == (const map < _K1 , _T1 , _C1 , _A1 > & , 
const map < _K1 , _T1 , _C1 , _A1 > &) ; 

template < typename _K1 , typename _T1 , typename _C1 , typename _A1 > 
friend bool 
operator < (const map < _K1 , _T1 , _C1 , _A1 > & , 
const map < _K1 , _T1 , _C1 , _A1 > &) ; 
} ;
# 1453 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator == (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __x . _M_t == __y . _M_t ; } 
# 1470 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator < (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __x . _M_t < __y . _M_t ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator != (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator > (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator <= (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator >= (const map < _Key , _Tp , _Compare , _Alloc > & __x , 
const map < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline void 
swap (map < _Key , _Tp , _Compare , _Alloc > & __x , 
map < _Key , _Tp , _Compare , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 1536 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_map.h" 3
}
# 64 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
namespace std { 




template < typename _Key, typename _Tp, typename _Compare, typename _Alloc >
    class map;
# 96 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _Key , typename _Tp , 
typename _Compare = std :: less < _Key > , 
typename _Alloc = std :: allocator < std :: pair < const _Key , _Tp > > > 
class multimap 
{ 
public : 
typedef _Key key_type ; 
typedef _Tp mapped_type ; 
typedef std :: pair < const _Key , _Tp > value_type ; 
typedef _Compare key_compare ; 
typedef _Alloc allocator_type ; 

private : 
# 125 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
public : 
class value_compare 
: public std :: binary_function < value_type , value_type , bool > 
{ 
friend class multimap < _Key , _Tp , _Compare , _Alloc > ; 
protected : 
_Compare comp ; 

value_compare (_Compare __c) 
: comp (__c) { } 

public : 
bool operator () (const value_type & __x , const value_type & __y) const 
{ return comp (__x . first , __y . first) ; } 
} ; 

private : 

typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < value_type > :: other _Pair_alloc_type ; 

typedef _Rb_tree < key_type , value_type , _Select1st < value_type > , 
key_compare , _Pair_alloc_type > _Rep_type ; 

_Rep_type _M_t ; 

typedef __gnu_cxx :: __alloc_traits < _Pair_alloc_type > _Alloc_traits ; 

public : 


typedef typename _Alloc_traits :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 
typedef typename _Rep_type :: iterator iterator ; 
typedef typename _Rep_type :: const_iterator const_iterator ; 
typedef typename _Rep_type :: size_type size_type ; 
typedef typename _Rep_type :: difference_type difference_type ; 
typedef typename _Rep_type :: reverse_iterator reverse_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator ; 
# 180 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap () = default ; 
# 188
explicit 
multimap (const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) { } 
# 202 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap (const multimap &) = default ; 
# 211 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap (multimap &&) = default ; 
# 223 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap (initializer_list < value_type > __l , 
const _Compare & __comp = _Compare () , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__l . begin () , __l . end ()) ; } 


explicit 
multimap (const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) { } 


multimap (const multimap & __m , const allocator_type & __a) 
: _M_t (__m . _M_t , _Pair_alloc_type (__a)) { } 


multimap (multimap && __m , const allocator_type & __a) 
noexcept (is_nothrow_copy_constructible < _Compare > :: value 
&& _Alloc_traits :: _S_always_equal ()) 
: _M_t (std :: move (__m . _M_t) , _Pair_alloc_type (__a)) { } 


multimap (initializer_list < value_type > __l , const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__l . begin () , __l . end ()) ; } 


template < typename _InputIterator > 
multimap (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a) 
: _M_t (_Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 266 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _InputIterator > 
multimap (_InputIterator __first , _InputIterator __last) 
: _M_t () 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 282 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _InputIterator > 
multimap (_InputIterator __first , _InputIterator __last , 
const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Pair_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 295
~ multimap () = default ; 
# 311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap & 
operator = (const multimap &) = default ; 


multimap & 
operator = (multimap &&) = default ; 
# 329 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
multimap & 
operator = (initializer_list < value_type > __l) 
{ 
_M_t . _M_assign_equal (__l . begin () , __l . end ()) ; 
return * this ; 
} 



allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_t . get_allocator ()) ; } 
# 348
iterator 
begin () noexcept 
{ return _M_t . begin () ; } 
# 357
const_iterator 
begin () const noexcept 
{ return _M_t . begin () ; } 
# 366
iterator 
end () noexcept 
{ return _M_t . end () ; } 
# 375
const_iterator 
end () const noexcept 
{ return _M_t . end () ; } 
# 384
reverse_iterator 
rbegin () noexcept 
{ return _M_t . rbegin () ; } 
# 393
const_reverse_iterator 
rbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 402
reverse_iterator 
rend () noexcept 
{ return _M_t . rend () ; } 
# 411
const_reverse_iterator 
rend () const noexcept 
{ return _M_t . rend () ; } 
# 421
const_iterator 
cbegin () const noexcept 
{ return _M_t . begin () ; } 
# 430
const_iterator 
cend () const noexcept 
{ return _M_t . end () ; } 
# 439
const_reverse_iterator 
crbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 448
const_reverse_iterator 
crend () const noexcept 
{ return _M_t . rend () ; } 




bool 
empty () const noexcept 
{ return _M_t . empty () ; } 


size_type 
size () const noexcept 
{ return _M_t . size () ; } 


size_type 
max_size () const noexcept 
{ return _M_t . max_size () ; } 
# 487 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename ... _Args > 
iterator 
emplace (_Args && ... __args) 
{ return _M_t . _M_emplace_equal (std :: forward < _Args > (__args) ...) ; } 
# 514 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename ... _Args > 
iterator 
emplace_hint (const_iterator __pos , _Args && ... __args) 
{ 
return _M_t . _M_emplace_hint_equal (__pos , 
std :: forward < _Args > (__args) ...) ; 
} 
# 536 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
insert (const value_type & __x) 
{ return _M_t . _M_insert_equal (__x) ; } 




iterator 
insert (value_type && __x) 
{ return _M_t . _M_insert_equal (std :: move (__x)) ; } 

template < typename _Pair > 
__enable_if_t < is_constructible < value_type , _Pair > :: value , iterator > 
insert (_Pair && __x) 
{ return _M_t . _M_emplace_equal (std :: forward < _Pair > (__x)) ; } 
# 575 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 

insert (const_iterator __position , const value_type & __x) 



{ return _M_t . _M_insert_equal_ (__position , __x) ; } 




iterator 
insert (const_iterator __position , value_type && __x) 
{ return _M_t . _M_insert_equal_ (__position , std :: move (__x)) ; } 

template < typename _Pair > 
__enable_if_t < is_constructible < value_type , _Pair && > :: value , iterator > 
insert (const_iterator __position , _Pair && __x) 
{ 
return _M_t . _M_emplace_hint_equal (__position , 
std :: forward < _Pair > (__x)) ; 
} 
# 609 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _InputIterator > 
void 
insert (_InputIterator __first , _InputIterator __last) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 622 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
void 
insert (initializer_list < value_type > __l) 
{ this -> insert (__l . begin () , __l . end ()) ; } 
# 699 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
erase (const_iterator __position) 
{ return _M_t . erase (__position) ; } 


__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (iterator __position) 
{ return _M_t . erase (__position) ; } 
# 736 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
size_type 
erase (const key_type & __x) 
{ return _M_t . erase (__x) ; } 
# 757 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
erase (const_iterator __first , const_iterator __last) 
{ return _M_t . erase (__first , __last) ; } 
# 794 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
void 
swap (multimap & __x) 
noexcept (__is_nothrow_swappable < _Compare > :: value) 
{ _M_t . swap (__x . _M_t) ; } 
# 805
void 
clear () noexcept 
{ _M_t . clear () ; } 
# 814
key_compare 
key_comp () const 
{ return _M_t . key_comp () ; } 
# 822
value_compare 
value_comp () const 
{ return value_compare (_M_t . key_comp ()) ; } 
# 840 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
find (const key_type & __x) 
{ return _M_t . find (__x) ; } 
# 864 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
const_iterator 
find (const key_type & __x) const 
{ return _M_t . find (__x) ; } 
# 882 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
size_type 
count (const key_type & __x) const 
{ return _M_t . count (__x) ; } 
# 925 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
lower_bound (const key_type & __x) 
{ return _M_t . lower_bound (__x) ; } 
# 950 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
const_iterator 
lower_bound (const key_type & __x) const 
{ return _M_t . lower_bound (__x) ; } 
# 970 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
iterator 
upper_bound (const key_type & __x) 
{ return _M_t . upper_bound (__x) ; } 
# 990 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
const_iterator 
upper_bound (const key_type & __x) const 
{ return _M_t . upper_bound (__x) ; } 
# 1017 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
std :: pair < iterator , iterator > 
equal_range (const key_type & __x) 
{ return _M_t . equal_range (__x) ; } 
# 1044 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
std :: pair < const_iterator , const_iterator > 
equal_range (const key_type & __x) const 
{ return _M_t . equal_range (__x) ; } 
# 1061 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _K1 , typename _T1 , typename _C1 , typename _A1 > 
friend bool 
operator == (const multimap < _K1 , _T1 , _C1 , _A1 > & , 
const multimap < _K1 , _T1 , _C1 , _A1 > &) ; 

template < typename _K1 , typename _T1 , typename _C1 , typename _A1 > 
friend bool 
operator < (const multimap < _K1 , _T1 , _C1 , _A1 > & , 
const multimap < _K1 , _T1 , _C1 , _A1 > &) ; 
} ;
# 1117 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator == (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __x . _M_t == __y . _M_t ; } 
# 1134 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator < (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __x . _M_t < __y . _M_t ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator != (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator > (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator <= (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline bool 
operator >= (const multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
const multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Key , typename _Tp , typename _Compare , typename _Alloc > 
inline void 
swap (multimap < _Key , _Tp , _Compare , _Alloc > & __x , 
multimap < _Key , _Tp , _Compare , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 1200 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multimap.h" 3
}
# 64 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
namespace std { 




template < typename _Key, typename _Compare, typename _Alloc >
    class multiset;
# 92 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _Key , typename _Compare = std :: less < _Key > , 
typename _Alloc = std :: allocator < _Key > > 
class set 
{ 
# 108 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
static_assert (is_same < typename remove_cv < _Key > :: type , _Key > :: value , 
"std::set must have a non-const, non-volatile value_type") ; 
# 116
public : 



typedef _Key key_type ; 
typedef _Key value_type ; 
typedef _Compare key_compare ; 
typedef _Compare value_compare ; 
typedef _Alloc allocator_type ; 


private : 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Key > :: other _Key_alloc_type ; 

typedef _Rb_tree < key_type , value_type , _Identity < value_type > , 
key_compare , _Key_alloc_type > _Rep_type ; 
_Rep_type _M_t ; 

typedef __gnu_cxx :: __alloc_traits < _Key_alloc_type > _Alloc_traits ; 

public : 


typedef typename _Alloc_traits :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 



typedef typename _Rep_type :: const_iterator iterator ; 
typedef typename _Rep_type :: const_iterator const_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator reverse_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator ; 
typedef typename _Rep_type :: size_type size_type ; 
typedef typename _Rep_type :: difference_type difference_type ; 
# 167 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
set () = default ; 
# 175
explicit 
set (const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) { } 
# 190 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _InputIterator > 
set (_InputIterator __first , _InputIterator __last) 
: _M_t () 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 207 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _InputIterator > 
set (_InputIterator __first , _InputIterator __last , 
const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 223 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
set (const set &) = default ; 
# 231
set (set &&) = default ; 
# 243 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
set (initializer_list < value_type > __l , 
const _Compare & __comp = _Compare () , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__l . begin () , __l . end ()) ; } 


explicit 
set (const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) { } 


set (const set & __x , const allocator_type & __a) 
: _M_t (__x . _M_t , _Key_alloc_type (__a)) { } 


set (set && __x , const allocator_type & __a) 
noexcept (is_nothrow_copy_constructible < _Compare > :: value 
&& _Alloc_traits :: _S_always_equal ()) 
: _M_t (std :: move (__x . _M_t) , _Key_alloc_type (__a)) { } 


set (initializer_list < value_type > __l , const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__l . begin () , __l . end ()) ; } 


template < typename _InputIterator > 
set (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 281
~ set () = default ; 
# 297 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
set & 
operator = (const set &) = default ; 


set & 
operator = (set &&) = default ; 
# 315 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
set & 
operator = (initializer_list < value_type > __l) 
{ 
_M_t . _M_assign_unique (__l . begin () , __l . end ()) ; 
return * this ; 
} 
# 326
key_compare 
key_comp () const 
{ return _M_t . key_comp () ; } 

value_compare 
value_comp () const 
{ return _M_t . key_comp () ; } 

allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_t . get_allocator ()) ; } 
# 343
iterator 
begin () const noexcept 
{ return _M_t . begin () ; } 
# 352
iterator 
end () const noexcept 
{ return _M_t . end () ; } 
# 361
reverse_iterator 
rbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 370
reverse_iterator 
rend () const noexcept 
{ return _M_t . rend () ; } 
# 380
iterator 
cbegin () const noexcept 
{ return _M_t . begin () ; } 
# 389
iterator 
cend () const noexcept 
{ return _M_t . end () ; } 
# 398
reverse_iterator 
crbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 407
reverse_iterator 
crend () const noexcept 
{ return _M_t . rend () ; } 



bool 
empty () const noexcept 
{ return _M_t . empty () ; } 


size_type 
size () const noexcept 
{ return _M_t . size () ; } 


size_type 
max_size () const noexcept 
{ return _M_t . max_size () ; } 
# 440 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
void 
swap (set & __x) 
noexcept (__is_nothrow_swappable < _Compare > :: value) 
{ _M_t . swap (__x . _M_t) ; } 
# 460 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename ... _Args > 
std :: pair < iterator , bool > 
emplace (_Args && ... __args) 
{ return _M_t . _M_emplace_unique (std :: forward < _Args > (__args) ...) ; } 
# 486 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename ... _Args > 
iterator 
emplace_hint (const_iterator __pos , _Args && ... __args) 
{ 
return _M_t . _M_emplace_hint_unique (__pos , 
std :: forward < _Args > (__args) ...) ; 
} 
# 508 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
std :: pair < iterator , bool > 
insert (const value_type & __x) 
{ 
std :: pair < typename _Rep_type :: iterator , bool > __p = 
_M_t . _M_insert_unique (__x) ; 
return std :: pair < iterator , bool > (__p . first , __p . second) ; 
} 


std :: pair < iterator , bool > 
insert (value_type && __x) 
{ 
std :: pair < typename _Rep_type :: iterator , bool > __p = 
_M_t . _M_insert_unique (std :: move (__x)) ; 
return std :: pair < iterator , bool > (__p . first , __p . second) ; 
} 
# 545 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
iterator 
insert (const_iterator __position , const value_type & __x) 
{ return _M_t . _M_insert_unique_ (__position , __x) ; } 


iterator 
insert (const_iterator __position , value_type && __x) 
{ return _M_t . _M_insert_unique_ (__position , std :: move (__x)) ; } 
# 564 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _InputIterator > 
void 
insert (_InputIterator __first , _InputIterator __last) 
{ _M_t . _M_insert_range_unique (__first , __last) ; } 
# 577 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
void 
insert (initializer_list < value_type > __l) 
{ this -> insert (__l . begin () , __l . end ()) ; } 
# 652 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __position) 
{ return _M_t . erase (__position) ; } 
# 683 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
size_type 
erase (const key_type & __x) 
{ return _M_t . erase (__x) ; } 
# 704 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __first , const_iterator __last) 
{ return _M_t . erase (__first , __last) ; } 
# 732 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
void 
clear () noexcept 
{ _M_t . clear () ; } 
# 747 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
size_type 
count (const key_type & __x) const 
{ return _M_t . find (__x) == _M_t . end () ? 0 : 1 ; } 
# 793 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
iterator 
find (const key_type & __x) 
{ return _M_t . find (__x) ; } 

const_iterator 
find (const key_type & __x) const 
{ return _M_t . find (__x) ; } 
# 828 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
iterator 
lower_bound (const key_type & __x) 
{ return _M_t . lower_bound (__x) ; } 

const_iterator 
lower_bound (const key_type & __x) const 
{ return _M_t . lower_bound (__x) ; } 
# 858 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
iterator 
upper_bound (const key_type & __x) 
{ return _M_t . upper_bound (__x) ; } 

const_iterator 
upper_bound (const key_type & __x) const 
{ return _M_t . upper_bound (__x) ; } 
# 897 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
std :: pair < iterator , iterator > 
equal_range (const key_type & __x) 
{ return _M_t . equal_range (__x) ; } 

std :: pair < const_iterator , const_iterator > 
equal_range (const key_type & __x) const 
{ return _M_t . equal_range (__x) ; } 
# 920 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _K1 , typename _C1 , typename _A1 > 
friend bool 
operator == (const set < _K1 , _C1 , _A1 > & , const set < _K1 , _C1 , _A1 > &) ; 

template < typename _K1 , typename _C1 , typename _A1 > 
friend bool 
operator < (const set < _K1 , _C1 , _A1 > & , const set < _K1 , _C1 , _A1 > &) ; 
} ;
# 977 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator == (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return __x . _M_t == __y . _M_t ; } 
# 994 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator < (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return __x . _M_t < __y . _M_t ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator != (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator > (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator <= (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator >= (const set < _Key , _Compare , _Alloc > & __x , 
const set < _Key , _Compare , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline void 
swap (set < _Key , _Compare , _Alloc > & __x , set < _Key , _Compare , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 1057 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_set.h" 3
}
# 64 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
namespace std { 




template < typename _Key, typename _Compare, typename _Alloc >
    class set;
# 94 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _Key , typename _Compare = std :: less < _Key > , 
typename _Alloc = std :: allocator < _Key > > 
class multiset 
{ 
# 110 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
static_assert (is_same < typename remove_cv < _Key > :: type , _Key > :: value , 
"std::multiset must have a non-const, non-volatile value_type") ; 
# 118
public : 

typedef _Key key_type ; 
typedef _Key value_type ; 
typedef _Compare key_compare ; 
typedef _Compare value_compare ; 
typedef _Alloc allocator_type ; 

private : 

typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Key > :: other _Key_alloc_type ; 

typedef _Rb_tree < key_type , value_type , _Identity < value_type > , 
key_compare , _Key_alloc_type > _Rep_type ; 

_Rep_type _M_t ; 

typedef __gnu_cxx :: __alloc_traits < _Key_alloc_type > _Alloc_traits ; 

public : 
typedef typename _Alloc_traits :: pointer pointer ; 
typedef typename _Alloc_traits :: const_pointer const_pointer ; 
typedef typename _Alloc_traits :: reference reference ; 
typedef typename _Alloc_traits :: const_reference const_reference ; 



typedef typename _Rep_type :: const_iterator iterator ; 
typedef typename _Rep_type :: const_iterator const_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator reverse_iterator ; 
typedef typename _Rep_type :: const_reverse_iterator const_reverse_iterator ; 
typedef typename _Rep_type :: size_type size_type ; 
typedef typename _Rep_type :: difference_type difference_type ; 
# 164 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset () = default ; 
# 172
explicit 
multiset (const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) { } 
# 186 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _InputIterator > 
multiset (_InputIterator __first , _InputIterator __last) 
: _M_t () 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 202 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _InputIterator > 
multiset (_InputIterator __first , _InputIterator __last , 
const _Compare & __comp , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 218 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset (const multiset &) = default ; 
# 227 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset (multiset &&) = default ; 
# 239 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset (initializer_list < value_type > __l , 
const _Compare & __comp = _Compare () , 
const allocator_type & __a = allocator_type ()) 
: _M_t (__comp , _Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__l . begin () , __l . end ()) ; } 


explicit 
multiset (const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) { } 


multiset (const multiset & __m , const allocator_type & __a) 
: _M_t (__m . _M_t , _Key_alloc_type (__a)) { } 


multiset (multiset && __m , const allocator_type & __a) 
noexcept (is_nothrow_copy_constructible < _Compare > :: value 
&& _Alloc_traits :: _S_always_equal ()) 
: _M_t (std :: move (__m . _M_t) , _Key_alloc_type (__a)) { } 


multiset (initializer_list < value_type > __l , const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__l . begin () , __l . end ()) ; } 


template < typename _InputIterator > 
multiset (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a) 
: _M_t (_Key_alloc_type (__a)) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 277
~ multiset () = default ; 
# 293 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset & 
operator = (const multiset &) = default ; 


multiset & 
operator = (multiset &&) = default ; 
# 311 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
multiset & 
operator = (initializer_list < value_type > __l) 
{ 
_M_t . _M_assign_equal (__l . begin () , __l . end ()) ; 
return * this ; 
} 
# 322
key_compare 
key_comp () const 
{ return _M_t . key_comp () ; } 

value_compare 
value_comp () const 
{ return _M_t . key_comp () ; } 

allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_M_t . get_allocator ()) ; } 
# 339
iterator 
begin () const noexcept 
{ return _M_t . begin () ; } 
# 348
iterator 
end () const noexcept 
{ return _M_t . end () ; } 
# 357
reverse_iterator 
rbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 366
reverse_iterator 
rend () const noexcept 
{ return _M_t . rend () ; } 
# 376
iterator 
cbegin () const noexcept 
{ return _M_t . begin () ; } 
# 385
iterator 
cend () const noexcept 
{ return _M_t . end () ; } 
# 394
reverse_iterator 
crbegin () const noexcept 
{ return _M_t . rbegin () ; } 
# 403
reverse_iterator 
crend () const noexcept 
{ return _M_t . rend () ; } 



bool 
empty () const noexcept 
{ return _M_t . empty () ; } 


size_type 
size () const noexcept 
{ return _M_t . size () ; } 


size_type 
max_size () const noexcept 
{ return _M_t . max_size () ; } 
# 436 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
void 
swap (multiset & __x) 
noexcept (__is_nothrow_swappable < _Compare > :: value) 
{ _M_t . swap (__x . _M_t) ; } 
# 455 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename ... _Args > 
iterator 
emplace (_Args && ... __args) 
{ return _M_t . _M_emplace_equal (std :: forward < _Args > (__args) ...) ; } 
# 481 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename ... _Args > 
iterator 
emplace_hint (const_iterator __pos , _Args && ... __args) 
{ 
return _M_t . _M_emplace_hint_equal (__pos , 
std :: forward < _Args > (__args) ...) ; 
} 
# 501 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
iterator 
insert (const value_type & __x) 
{ return _M_t . _M_insert_equal (__x) ; } 


iterator 
insert (value_type && __x) 
{ return _M_t . _M_insert_equal (std :: move (__x)) ; } 
# 531 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
iterator 
insert (const_iterator __position , const value_type & __x) 
{ return _M_t . _M_insert_equal_ (__position , __x) ; } 


iterator 
insert (const_iterator __position , value_type && __x) 
{ return _M_t . _M_insert_equal_ (__position , std :: move (__x)) ; } 
# 549 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _InputIterator > 
void 
insert (_InputIterator __first , _InputIterator __last) 
{ _M_t . _M_insert_range_equal (__first , __last) ; } 
# 562 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
void 
insert (initializer_list < value_type > __l) 
{ this -> insert (__l . begin () , __l . end ()) ; } 
# 637 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __position) 
{ return _M_t . erase (__position) ; } 
# 668 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
size_type 
erase (const key_type & __x) 
{ return _M_t . erase (__x) ; } 
# 689 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
__attribute ((__abi_tag__ ("cxx11"))) 
iterator 
erase (const_iterator __first , const_iterator __last) 
{ return _M_t . erase (__first , __last) ; } 
# 717 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
void 
clear () noexcept 
{ _M_t . clear () ; } 
# 729 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
size_type 
count (const key_type & __x) const 
{ return _M_t . count (__x) ; } 
# 774 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
iterator 
find (const key_type & __x) 
{ return _M_t . find (__x) ; } 

const_iterator 
find (const key_type & __x) const 
{ return _M_t . find (__x) ; } 
# 809 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
iterator 
lower_bound (const key_type & __x) 
{ return _M_t . lower_bound (__x) ; } 

const_iterator 
lower_bound (const key_type & __x) const 
{ return _M_t . lower_bound (__x) ; } 
# 839 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
iterator 
upper_bound (const key_type & __x) 
{ return _M_t . upper_bound (__x) ; } 

const_iterator 
upper_bound (const key_type & __x) const 
{ return _M_t . upper_bound (__x) ; } 
# 878 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
std :: pair < iterator , iterator > 
equal_range (const key_type & __x) 
{ return _M_t . equal_range (__x) ; } 

std :: pair < const_iterator , const_iterator > 
equal_range (const key_type & __x) const 
{ return _M_t . equal_range (__x) ; } 
# 901 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _K1 , typename _C1 , typename _A1 > 
friend bool 
operator == (const multiset < _K1 , _C1 , _A1 > & , 
const multiset < _K1 , _C1 , _A1 > &) ; 

template < typename _K1 , typename _C1 , typename _A1 > 
friend bool 
operator < (const multiset < _K1 , _C1 , _A1 > & , 
const multiset < _K1 , _C1 , _A1 > &) ; 
} ;
# 962 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator == (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return __x . _M_t == __y . _M_t ; } 
# 979 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator < (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return __x . _M_t < __y . _M_t ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator != (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator > (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator <= (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline bool 
operator >= (const multiset < _Key , _Compare , _Alloc > & __x , 
const multiset < _Key , _Compare , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Key , typename _Compare , typename _Alloc > 
inline void 
swap (multiset < _Key , _Compare , _Alloc > & __x , 
multiset < _Key , _Compare , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 1045 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_multiset.h" 3
}
# 59 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
void operator<<(const testing::internal::Secret &, int); 

namespace testing { 
# 89 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
class __attribute((visibility("default"))) Message { 



typedef std::ostream &(*BasicNarrowIoManip)(std::ostream &); 



public: Message(); 


Message(const Message &msg) : ss_(new std::stringstream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(51 + 0 + 1U - 1);
((*ss_) << msg.GetString()); 
} 


explicit Message(const char *str) : ss_(new std::stringstream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(52 + 0 + 1U - 1);
((*ss_) << str); 
} 
# 118 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
template < typename T > 
inline Message & operator << (const T & val) { 
# 134 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
using :: operator << ; 
* ss_ << val ; 
return * this ; 
} 
# 152 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
template < typename T > 
inline Message & operator << (T * const & pointer) { 
if (pointer == nullptr) { 
* ss_ << "(null)" ; 
} else { 
* ss_ << pointer ; 
} 
return * this ; 
} 
# 169 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
Message &operator<<(BasicNarrowIoManip val) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(53 + 0 + 1U - 1);
((*ss_) << val); cpptestFastCoverageStmt(53 + 0 + 2U - 1);
return *this; 
} 


Message &operator<<(bool b) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(55 + 0 + 1U - 1);
return (*this << (b ? "true" : ("false"))); 
} 



Message &operator<<(const wchar_t * wide_c_str); 
Message &operator<<(wchar_t * wide_c_str); 




Message &operator<<(const std::wstring & wstr); 
# 200 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
std::string GetString() const; 
# 227 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-message.h"
private: const internal::scoped_ptr< std::__cxx11::basic_stringstream< char> >  ss_; 



void operator=(const Message &); 
}; 


inline std::ostream &operator<<(std::ostream &os, const Message &sb) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(56 + 0 + 1U - 1);
return (os << sb.GetString()); 
} 

namespace internal { 
# 245
template < typename T > 
std :: string StreamableToString (const T & streamable) { 
return (Message () << streamable) . GetString () ; 
} 

}
}
# 54 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-string.h"
namespace testing { 
namespace internal { 


class __attribute((visibility("default"))) String { 
# 69 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-string.h"
public: static const char *CloneCString(const char * c_str); 
# 102 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-string.h"
static bool CStringEquals(const char * lhs, const char * rhs); 
# 108
static std::string ShowWideCString(const wchar_t * wide_c_str); 
# 116
static bool WideCStringEquals(const wchar_t * lhs, const wchar_t * rhs); 
# 124
static bool CaseInsensitiveCStringEquals(const char * lhs, const char * rhs); 
# 139 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-string.h"
static bool CaseInsensitiveWideCStringEquals(const wchar_t * lhs, const wchar_t * rhs); 




static bool EndsWithCaseInsensitive(const std::string & str, const std::string & suffix); 



static std::string FormatIntWidth2(int value); 


static std::string FormatHexInt(int value); 


static std::string FormatByte(unsigned char value); 


private: String(); 
}; 



__attribute((visibility("default"))) std::string StringStreamToString(std::stringstream * stream); 

}
}
# 48 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-filepath.h"
namespace testing { 
namespace internal { 
# 62 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-filepath.h"
class __attribute((visibility("default"))) FilePath { 

public: FilePath() : pathname_("") { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(57 + 0 + 1U - 1);} 
FilePath(const FilePath &rhs) : pathname_(rhs.pathname_) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(58 + 0 + 1U - 1);} 

explicit FilePath(const std::string &pathname) : pathname_(pathname) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(59 + 0 + 1U - 1);
this->Normalize(); 
} 

FilePath &operator=(const FilePath &rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(60 + 0 + 1U - 1);
this->Set(rhs); cpptestFastCoverageStmt(60 + 0 + 2U - 1);
return *this; 
} 

void Set(const FilePath &rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(62 + 0 + 1U - 1);
(pathname_ = rhs.pathname_); 
} 

const std::string &string() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(63 + 0 + 1U - 1);return pathname_; } 
const char *c_str() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(64 + 0 + 1U - 1);return (pathname_).c_str(); } 


static FilePath GetCurrentDir(); 
# 90
static FilePath MakeFileName(const FilePath & directory, const FilePath & base_name, int number, const char * extension); 
# 98
static FilePath ConcatPaths(const FilePath & directory, const FilePath & relative_path); 
# 109 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-filepath.h"
static FilePath GenerateUniqueFileName(const FilePath & directory, const FilePath & base_name, const char * extension); 




bool IsEmpty() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(65 + 0 + 1U - 1);return (pathname_).empty(); } 




FilePath RemoveTrailingPathSeparator() const; 
# 127
FilePath RemoveDirectoryName() const; 
# 135
FilePath RemoveFileName() const; 
# 141
FilePath RemoveExtension(const char * extension) const; 
# 147
bool CreateDirectoriesRecursively() const; 
# 153
bool CreateFolder() const; 



bool FileOrDirectoryExists() const; 



bool DirectoryExists() const; 




bool IsDirectory() const; 



bool IsRootDirectory() const; 


bool IsAbsolutePath() const; 
# 196 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-filepath.h"
private: void Normalize(); 




const char *FindLastPathSeparator() const; 

std::string pathname_; 
}; 

}
}
# 46 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
#pragma GCC visibility push ( default )
# 34 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\cxxabi_tweaks.h" 3
namespace __cxxabiv1 { 

extern "C" {
# 46 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\cxxabi_tweaks.h" 3
__extension__ typedef long long __guard __attribute((mode(__DI__))); 


typedef void __cxa_vec_ctor_return_type; 


typedef void __cxa_cdtor_return_type; 


}
}
# 55 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
namespace __cxxabiv1 { 

extern "C" {



typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *); 



void *__cxa_vec_new(size_t __element_count, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __constructor, __cxa_cdtor_type __destructor); 




void *__cxa_vec_new2(size_t __element_count, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __constructor, __cxa_cdtor_type __destructor, void *(* __alloc)(size_t), void (* __dealloc)(void *)); 
# 76
void *__cxa_vec_new3(size_t __element_count, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __constructor, __cxa_cdtor_type __destructor, void *(* __alloc)(size_t), void (* __dealloc)(void *, size_t)); 
# 83
__cxa_vec_ctor_return_type __cxa_vec_ctor(void * __array_address, size_t __element_count, size_t __element_size, __cxa_cdtor_type __constructor, __cxa_cdtor_type __destructor); 




__cxa_vec_ctor_return_type __cxa_vec_cctor(void * __dest_array, void * __src_array, size_t __element_count, size_t __element_size, __cxa_cdtor_return_type (* __constructor)(void *, void *), __cxa_cdtor_type __destructor); 
# 95
void __cxa_vec_dtor(void * __array_address, size_t __element_count, size_t __element_size, __cxa_cdtor_type __destructor); 



void __cxa_vec_cleanup(void * __array_address, size_t __element_count, size_t __s, __cxa_cdtor_type __destructor) noexcept; 




void __cxa_vec_delete(void * __array_address, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __destructor); 



void __cxa_vec_delete2(void * __array_address, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __destructor, void (* __dealloc)(void *)); 




void __cxa_vec_delete3(void * __array_address, size_t __element_size, size_t __padding_size, __cxa_cdtor_type __destructor, void (* __dealloc)(void *, size_t)); 




int __cxa_guard_acquire(__guard *); 


void __cxa_guard_release(__guard *) noexcept; 


void __cxa_guard_abort(__guard *) noexcept; 



int __cxa_atexit(void (*)(void *), void *, void *) noexcept; 


int __cxa_finalize(void *); 



int __cxa_thread_atexit(void (*)(void *), void *, void *) noexcept; 



void __cxa_pure_virtual() __attribute((__noreturn__)); 


void __cxa_deleted_virtual() __attribute((__noreturn__)); 



void __cxa_bad_cast() __attribute((__noreturn__)); 


void __cxa_bad_typeid() __attribute((__noreturn__)); 


void __cxa_throw_bad_array_new_length() __attribute((__noreturn__)); 
# 196 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
char *__cxa_demangle(const char * __mangled_name, char * __output_buffer, size_t * __length, int * __status); 



}
}
# 208
namespace __cxxabiv1 { 


class __fundamental_type_info : public std::type_info { 



public: explicit __fundamental_type_info(const char *__n) : std::type_info(__n) { } 


virtual ~__fundamental_type_info(); 
}; 


class __array_type_info : public std::type_info { 



public: explicit __array_type_info(const char *__n) : std::type_info(__n) { } 


virtual ~__array_type_info(); 
}; 


class __function_type_info : public std::type_info { 



public: explicit __function_type_info(const char *__n) : std::type_info(__n) { } 


virtual ~__function_type_info(); 




protected: virtual bool __is_function_p() const; 
}; 


class __enum_type_info : public std::type_info { 



public: explicit __enum_type_info(const char *__n) : std::type_info(__n) { } 


virtual ~__enum_type_info(); 
}; 


class __pbase_type_info : public std::type_info { 


public: unsigned __flags; 
const std::type_info *__pointee; 


explicit __pbase_type_info(const char *__n, int __quals, const std::type_info *
__type) : std::type_info(__n), __flags(__quals), __pointee(__type) 

{ } 


virtual ~__pbase_type_info(); 


enum __masks { 

__const_mask = 0x1, 
__volatile_mask, 
__restrict_mask = 0x4, 
__incomplete_mask = 0x8, 
__incomplete_class_mask = 0x10, 
__transaction_safe_mask = 0x20, 
__noexcept_mask = 0x40
}; 


protected: __pbase_type_info(const __pbase_type_info &); 


__pbase_type_info &operator=(const __pbase_type_info &); 



virtual bool __do_catch(const std::type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 



inline virtual bool __pointer_catch(const __pbase_type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 

}; 


inline bool __pbase_type_info::__pointer_catch(const __pbase_type_info *thrown_type, void **
thr_obj, unsigned 
outer) const 
{ 
return (__pointee)->__do_catch(thrown_type->__pointee, thr_obj, outer + 2); 
} 


class __pointer_type_info : public __pbase_type_info { 



public: explicit __pointer_type_info(const char *__n, int __quals, const std::type_info *
__type) : __pbase_type_info(__n, __quals, __type) 
{ } 



virtual ~__pointer_type_info(); 




protected: virtual bool __is_pointer_p() const; 


virtual bool __pointer_catch(const __pbase_type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 

}; 

class __class_type_info; 


class __pointer_to_member_type_info : public __pbase_type_info { 


public: __class_type_info *__context; 


explicit __pointer_to_member_type_info(const char *__n, int __quals, const std::type_info *
__type, __class_type_info *
__klass) : __pbase_type_info(__n, __quals, __type), __context(__klass) 
{ } 


virtual ~__pointer_to_member_type_info(); 


protected: __pointer_to_member_type_info(const __pointer_to_member_type_info &); 


__pointer_to_member_type_info &operator=(const __pointer_to_member_type_info &); 



virtual bool __pointer_catch(const __pbase_type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 

}; 


class __base_class_type_info { 


public: const __class_type_info *__base_type; 



long __offset_flags; 


enum __offset_flags_masks { 

__virtual_mask = 0x1, 
__public_mask, 
__hwm_bit = 2, 
__offset_shift = 8
}; 



bool __is_virtual_p() const 
{ return __offset_flags & __virtual_mask; } 


bool __is_public_p() const 
{ return __offset_flags & __public_mask; } 


ptrdiff_t __offset() const 
{ 



return static_cast< ptrdiff_t>(__offset_flags) >> __offset_shift; 
} 
}; 


class __class_type_info : public std::type_info { 



public: explicit __class_type_info(const char *__n) : std::type_info(__n) { } 


virtual ~__class_type_info(); 
# 416
enum __sub_kind { 


__unknown, 



__not_contained, 


__contained_ambig, 


__contained_virtual_mask = __base_class_type_info::__virtual_mask, 


__contained_public_mask, 


__contained_mask = (1 << __base_class_type_info::__hwm_bit), 

__contained_private = __contained_mask, 
__contained_public = (__contained_mask | (__contained_public_mask))
}; 

struct __upcast_result; 
struct __dyncast_result; 




protected: virtual bool __do_upcast(const __class_type_info * __dst_type, void ** __obj_ptr) const; 


virtual bool __do_catch(const std::type_info * __thr_type, void ** __thr_obj, unsigned __outer) const; 
# 457
public: virtual bool __do_upcast(const __class_type_info * __dst, const void * __obj, __upcast_result & __result) const; 
# 467
inline __sub_kind __find_public_src(ptrdiff_t __src2dst, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr) const; 
# 479 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
virtual bool __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path, const __class_type_info * __dst_type, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr, __dyncast_result & __result) const; 
# 489
virtual __sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr) const; 


}; 


class __si_class_type_info : public __class_type_info { 


public: const __class_type_info *__base_type; 


explicit __si_class_type_info(const char *__n, const __class_type_info *__base) : __class_type_info(__n), __base_type(__base) 
{ } 


virtual ~__si_class_type_info(); 


protected: __si_class_type_info(const __si_class_type_info &); 


__si_class_type_info &operator=(const __si_class_type_info &); 



virtual bool __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path, const __class_type_info * __dst_type, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr, __dyncast_result & __result) const; 
# 521
virtual __sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void * __obj_ptr, const __class_type_info * __src_type, const void * __sub_ptr) const; 




virtual bool __do_upcast(const __class_type_info * __dst, const void * __obj, __upcast_result & __result) const; 

}; 


class __vmi_class_type_info : public __class_type_info { 


public: unsigned __flags; 
unsigned __base_count; 




__base_class_type_info __base_info[1]; 


explicit __vmi_class_type_info(const char *__n, int ___flags) : __class_type_info(__n), __flags(___flags), __base_count((0)) 
{ } 


virtual ~__vmi_class_type_info(); 


enum __flags_masks { 

__non_diamond_repeat_mask = 0x1, 
__diamond_shaped_mask, 
__flags_unknown_mask = 0x10
}; 




protected: virtual bool __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path, const __class_type_info * __dst_type, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr, __dyncast_result & __result) const; 
# 566
virtual __sub_kind __do_find_public_src(ptrdiff_t __src2dst, const void * __obj_ptr, const __class_type_info * __src_type, const void * __src_ptr) const; 




virtual bool __do_upcast(const __class_type_info * __dst, const void * __obj, __upcast_result & __result) const; 

}; 


struct __cxa_exception; 
struct __cxa_refcounted_exception; 
struct __cxa_dependent_exception; 
struct __cxa_eh_globals; 

extern "C" {
# 592 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
void *__dynamic_cast(const void * __src_ptr, const __class_type_info * __src_type, const __class_type_info * __dst_type, ptrdiff_t __src2dst); 
# 605 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
__cxa_eh_globals *__cxa_get_globals() noexcept __attribute((const)); 


__cxa_eh_globals *__cxa_get_globals_fast() noexcept __attribute((const)); 



void __cxa_free_exception(void *) noexcept; 



void __cxa_throw(void *, std::type_info *, void ( __attribute((__thiscall__))*)(void *) ) __attribute((__noreturn__)); 




void *__cxa_get_exception_ptr(void *) noexcept __attribute((__pure__)); 


void *__cxa_begin_catch(void *) noexcept; 


void __cxa_end_catch(); 


void __cxa_rethrow() __attribute((__noreturn__)); 




std::type_info *__cxa_current_exception_type() noexcept __attribute((__pure__)); 
# 641
__cxa_dependent_exception *__cxa_allocate_dependent_exception() noexcept; 



void __cxa_free_dependent_exception(__cxa_dependent_exception *) noexcept; 

}



class __foreign_exception { 

virtual ~__foreign_exception() throw(); 
virtual void __pure_dummy() = 0; 
}; 

}
# 679 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx { 
# 696 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cxxabi.h" 3
class recursive_init_error : public std::exception { 


public: recursive_init_error() noexcept; 
virtual ~recursive_init_error() noexcept; 
}; 
}


#pragma GCC visibility pop
# 58 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
namespace testing { 
namespace internal { 
# 65
inline std::string CanonicalizeForStdLibVersioning(std::string s) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(66 + 0 + 1U - 1);
static const char prefix[] = "std::__"; 
if (((void)cpptestFastCoverageStmt(66 + 0 + 2U - 1), s.compare(0, strlen(prefix), prefix) == 0)) { cpptestFastCoverageStmt(66 + 0 + 3U - 1);
std::__cxx11::basic_string< char> ::size_type end = s.find("::", strlen(prefix)); 
if (((void)cpptestFastCoverageStmt(66 + 0 + 4U - 1), end != s.npos)) { cpptestFastCoverageStmt(66 + 0 + 5U - 1);

s.erase(strlen("std"), end - strlen("std")); 
}  
}  cpptestFastCoverageStmt(66 + 0 + 6U - 1);
return s; 
} 




template < typename T > 
std :: string GetTypeName () { 


const char * const name = typeid (T) . name () ; 

int status = 0 ; 



using abi :: __cxa_demangle ; 

char * const readable_name = __cxa_demangle (name , nullptr , nullptr , & status) ; 
const std :: string name_str (status == 0 ? readable_name : name) ; 
free (readable_name) ; 
return CanonicalizeForStdLibVersioning (name_str) ; 
# 105 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
} 
# 113
template < typename T1, typename T2 >
struct AssertTypeEq;

template < typename T > 
struct AssertTypeEq < T , T > { 
typedef bool type ; 
} ;
# 125
struct None { }; 
# 135 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
struct Types0 { }; 



template < typename T1 > 
struct Types1 { 
typedef T1 Head ; 
typedef Types0 Tail ; 
} ;
template < typename T1 , typename T2 > 
struct Types2 { 
typedef T1 Head ; 
typedef Types1 < T2 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 > 
struct Types3 { 
typedef T1 Head ; 
typedef Types2 < T2 , T3 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 > 
struct Types4 { 
typedef T1 Head ; 
typedef Types3 < T2 , T3 , T4 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
struct Types5 { 
typedef T1 Head ; 
typedef Types4 < T2 , T3 , T4 , T5 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
struct Types6 { 
typedef T1 Head ; 
typedef Types5 < T2 , T3 , T4 , T5 , T6 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
struct Types7 { 
typedef T1 Head ; 
typedef Types6 < T2 , T3 , T4 , T5 , T6 , T7 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
struct Types8 { 
typedef T1 Head ; 
typedef Types7 < T2 , T3 , T4 , T5 , T6 , T7 , T8 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
struct Types9 { 
typedef T1 Head ; 
typedef Types8 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
struct Types10 { 
typedef T1 Head ; 
typedef Types9 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 > 
struct Types11 { 
typedef T1 Head ; 
typedef Types10 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 > 
struct Types12 { 
typedef T1 Head ; 
typedef Types11 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 > 
struct Types13 { 
typedef T1 Head ; 
typedef Types12 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 > 
struct Types14 { 
typedef T1 Head ; 
typedef Types13 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 > 
struct Types15 { 
typedef T1 Head ; 
typedef Types14 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 > 
struct Types16 { 
typedef T1 Head ; 
typedef Types15 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 > 
struct Types17 { 
typedef T1 Head ; 
typedef Types16 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 > 
struct Types18 { 
typedef T1 Head ; 
typedef Types17 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 > 
struct Types19 { 
typedef T1 Head ; 
typedef Types18 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 > 
struct Types20 { 
typedef T1 Head ; 
typedef Types19 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 > 
struct Types21 { 
typedef T1 Head ; 
typedef Types20 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 > 
struct Types22 { 
typedef T1 Head ; 
typedef Types21 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 > 
struct Types23 { 
typedef T1 Head ; 
typedef Types22 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 > 
struct Types24 { 
typedef T1 Head ; 
typedef Types23 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 > 
struct Types25 { 
typedef T1 Head ; 
typedef Types24 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 > 
struct Types26 { 
typedef T1 Head ; 
typedef Types25 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 > 
struct Types27 { 
typedef T1 Head ; 
typedef Types26 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 > 
struct Types28 { 
typedef T1 Head ; 
typedef Types27 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 > 
struct Types29 { 
typedef T1 Head ; 
typedef Types28 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 > 
struct Types30 { 
typedef T1 Head ; 
typedef Types29 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 > 
struct Types31 { 
typedef T1 Head ; 
typedef Types30 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 > 
struct Types32 { 
typedef T1 Head ; 
typedef Types31 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 > 
struct Types33 { 
typedef T1 Head ; 
typedef Types32 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 > 
struct Types34 { 
typedef T1 Head ; 
typedef Types33 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 > 
struct Types35 { 
typedef T1 Head ; 
typedef Types34 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 > 
struct Types36 { 
typedef T1 Head ; 
typedef Types35 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 > 
struct Types37 { 
typedef T1 Head ; 
typedef Types36 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 > 
struct Types38 { 
typedef T1 Head ; 
typedef Types37 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 > 
struct Types39 { 
typedef T1 Head ; 
typedef Types38 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 > 
struct Types40 { 
typedef T1 Head ; 
typedef Types39 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 > 
struct Types41 { 
typedef T1 Head ; 
typedef Types40 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 > 
struct Types42 { 
typedef T1 Head ; 
typedef Types41 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 > 
struct Types43 { 
typedef T1 Head ; 
typedef Types42 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 > 
struct Types44 { 
typedef T1 Head ; 
typedef Types43 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 > 
struct Types45 { 
typedef T1 Head ; 
typedef Types44 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 > 
struct Types46 { 
typedef T1 Head ; 
typedef Types45 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 > 
struct Types47 { 
typedef T1 Head ; 
typedef Types46 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 > 
struct Types48 { 
typedef T1 Head ; 
typedef Types47 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 > 
struct Types49 { 
typedef T1 Head ; 
typedef Types48 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 , T49 > Tail ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 , typename T50 > 
struct Types50 { 
typedef T1 Head ; 
typedef Types49 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 , T49 , T50 > Tail ; 
} ;


}
# 745 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
template < typename T1 = internal :: None , typename T2 = internal :: None , 
typename T3 = internal :: None , typename T4 = internal :: None , 
typename T5 = internal :: None , typename T6 = internal :: None , 
typename T7 = internal :: None , typename T8 = internal :: None , 
typename T9 = internal :: None , typename T10 = internal :: None , 
typename T11 = internal :: None , typename T12 = internal :: None , 
typename T13 = internal :: None , typename T14 = internal :: None , 
typename T15 = internal :: None , typename T16 = internal :: None , 
typename T17 = internal :: None , typename T18 = internal :: None , 
typename T19 = internal :: None , typename T20 = internal :: None , 
typename T21 = internal :: None , typename T22 = internal :: None , 
typename T23 = internal :: None , typename T24 = internal :: None , 
typename T25 = internal :: None , typename T26 = internal :: None , 
typename T27 = internal :: None , typename T28 = internal :: None , 
typename T29 = internal :: None , typename T30 = internal :: None , 
typename T31 = internal :: None , typename T32 = internal :: None , 
typename T33 = internal :: None , typename T34 = internal :: None , 
typename T35 = internal :: None , typename T36 = internal :: None , 
typename T37 = internal :: None , typename T38 = internal :: None , 
typename T39 = internal :: None , typename T40 = internal :: None , 
typename T41 = internal :: None , typename T42 = internal :: None , 
typename T43 = internal :: None , typename T44 = internal :: None , 
typename T45 = internal :: None , typename T46 = internal :: None , 
typename T47 = internal :: None , typename T48 = internal :: None , 
typename T49 = internal :: None , typename T50 = internal :: None > 
struct Types { 
typedef internal :: Types50 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 , T50 > type ; 
} ;


template<> struct Types< internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None, internal::None>  { 
# 791
typedef internal::Types0 type; 
}; 
template < typename T1 > 
struct Types < T1 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types1 < T1 > type ; 
} ;
template < typename T1 , typename T2 > 
struct Types < T1 , T2 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types2 < T1 , T2 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 > 
struct Types < T1 , T2 , T3 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types3 < T1 , T2 , T3 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 > 
struct Types < T1 , T2 , T3 , T4 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types4 < T1 , T2 , T3 , T4 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
struct Types < T1 , T2 , T3 , T4 , T5 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types5 < T1 , T2 , T3 , T4 , T5 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types6 < T1 , T2 , T3 , T4 , T5 , T6 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types7 < T1 , T2 , T3 , T4 , T5 , T6 , T7 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types8 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types9 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types10 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types11 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types12 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types13 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types14 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types15 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types16 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types17 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types18 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types19 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types20 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types21 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types22 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types23 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types24 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types25 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types26 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types27 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types28 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types29 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types30 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types31 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types32 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types33 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types34 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types35 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types36 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types37 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types38 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types39 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types40 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types41 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , internal :: None , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types42 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types43 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None , internal :: None > { 
typedef internal :: Types44 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , 
internal :: None , internal :: None , internal :: None , internal :: None , 
internal :: None > { 
typedef internal :: Types45 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , 
T46 , internal :: None , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types46 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , 
T46 , T47 , internal :: None , internal :: None , internal :: None > { 
typedef internal :: Types47 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 , T47 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , 
T46 , T47 , T48 , internal :: None , internal :: None > { 
typedef internal :: Types48 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 > type ; 
} ;
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 > 
struct Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , 
T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , 
T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , 
T46 , T47 , T48 , T49 , internal :: None > { 
typedef internal :: Types49 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 > type ; 
} ;

namespace internal { 
# 1649 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
template < template < typename T > class Tmpl > 
struct TemplateSel { 
template < typename T > 
struct Bind { 
typedef Tmpl < T > type ; 
} ; 
} ;
# 1664 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
template < typename T > 
struct NoneT { } ;
# 1675 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
struct Templates0 { }; 



template < template < typename T > class T1 > 
struct Templates1 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates0 Tail ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 > 
struct Templates2 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates1 < T2 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 > 
struct Templates3 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates2 < T2 , T3 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 > 
struct Templates4 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates3 < T2 , T3 , T4 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 > 
struct Templates5 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates4 < T2 , T3 , T4 , T5 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 > 
struct Templates6 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates5 < T2 , T3 , T4 , T5 , T6 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 > 
struct Templates7 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates6 < T2 , T3 , T4 , T5 , T6 , T7 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 > 
struct Templates8 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates7 < T2 , T3 , T4 , T5 , T6 , T7 , T8 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 > 
struct Templates9 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates8 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 > 
struct Templates10 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates9 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 > 
struct Templates11 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates10 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 > 
struct Templates12 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates11 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 > 
struct Templates13 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates12 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 > 
struct Templates14 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates13 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 > 
struct Templates15 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates14 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 > 
struct Templates16 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates15 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 > 
struct Templates17 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates16 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 > 
struct Templates18 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates17 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 > 
struct Templates19 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates18 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 > 
struct Templates20 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates19 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 > 
struct Templates21 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates20 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 > 
struct Templates22 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates21 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 > 
struct Templates23 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates22 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 > 
struct Templates24 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates23 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 > 
struct Templates25 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates24 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 > 
struct Templates26 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates25 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 > 
struct Templates27 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates26 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 > 
struct Templates28 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates27 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 > 
struct Templates29 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates28 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 > 
struct Templates30 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates29 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 > 
struct Templates31 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates30 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 > 
struct Templates32 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates31 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 > 
struct Templates33 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates32 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 > 
struct Templates34 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates33 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 > 
struct Templates35 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates34 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 > 
struct Templates36 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates35 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 > 
struct Templates37 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates36 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 > 
struct Templates38 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates37 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 > 
struct Templates39 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates38 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 > 
struct Templates40 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates39 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 > 
struct Templates41 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates40 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 > 
struct Templates42 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates41 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 > 
struct Templates43 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates42 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 > 
struct Templates44 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates43 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 > 
struct Templates45 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates44 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 > 
struct Templates46 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates45 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 , T46 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 > 
struct Templates47 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates46 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 , T46 , T47 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 , template < typename T > class T48 > 
struct Templates48 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates47 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 , T46 , T47 , T48 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 , template < typename T > class T48 , 
template < typename T > class T49 > 
struct Templates49 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates48 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 , T46 , T47 , T48 , T49 > Tail ; 
} ;

template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 , template < typename T > class T48 , 
template < typename T > class T49 , template < typename T > class T50 > 
struct Templates50 { 
typedef TemplateSel < T1 > Head ; 
typedef Templates49 < T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 , T44 , T45 , T46 , T47 , T48 , T49 , T50 > Tail ; 
} ;
# 2453 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-type-util.h"
template < template < typename T > class T1 = NoneT , template < typename T > class T2 = NoneT , 
template < typename T > class T3 = NoneT , template < typename T > class T4 = NoneT , 
template < typename T > class T5 = NoneT , template < typename T > class T6 = NoneT , 
template < typename T > class T7 = NoneT , template < typename T > class T8 = NoneT , 
template < typename T > class T9 = NoneT , template < typename T > class T10 = NoneT , 
template < typename T > class T11 = NoneT , template < typename T > class T12 = NoneT , 
template < typename T > class T13 = NoneT , template < typename T > class T14 = NoneT , 
template < typename T > class T15 = NoneT , template < typename T > class T16 = NoneT , 
template < typename T > class T17 = NoneT , template < typename T > class T18 = NoneT , 
template < typename T > class T19 = NoneT , template < typename T > class T20 = NoneT , 
template < typename T > class T21 = NoneT , template < typename T > class T22 = NoneT , 
template < typename T > class T23 = NoneT , template < typename T > class T24 = NoneT , 
template < typename T > class T25 = NoneT , template < typename T > class T26 = NoneT , 
template < typename T > class T27 = NoneT , template < typename T > class T28 = NoneT , 
template < typename T > class T29 = NoneT , template < typename T > class T30 = NoneT , 
template < typename T > class T31 = NoneT , template < typename T > class T32 = NoneT , 
template < typename T > class T33 = NoneT , template < typename T > class T34 = NoneT , 
template < typename T > class T35 = NoneT , template < typename T > class T36 = NoneT , 
template < typename T > class T37 = NoneT , template < typename T > class T38 = NoneT , 
template < typename T > class T39 = NoneT , template < typename T > class T40 = NoneT , 
template < typename T > class T41 = NoneT , template < typename T > class T42 = NoneT , 
template < typename T > class T43 = NoneT , template < typename T > class T44 = NoneT , 
template < typename T > class T45 = NoneT , template < typename T > class T46 = NoneT , 
template < typename T > class T47 = NoneT , template < typename T > class T48 = NoneT , 
template < typename T > class T49 = NoneT , template < typename T > class T50 = NoneT > 
struct Templates { 
typedef Templates50 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 , T50 > type ; 
} ;


template<> struct Templates< NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT>  { 
# 2492
typedef Templates0 type; 
}; 
template < template < typename T > class T1 > 
struct Templates < T1 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT > { 
typedef Templates1 < T1 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 > 
struct Templates < T1 , T2 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT > { 
typedef Templates2 < T1 , T2 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 > 
struct Templates < T1 , T2 , T3 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates3 < T1 , T2 , T3 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 > 
struct Templates < T1 , T2 , T3 , T4 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates4 < T1 , T2 , T3 , T4 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates5 < T1 , T2 , T3 , T4 , T5 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates6 < T1 , T2 , T3 , T4 , T5 , T6 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates7 < T1 , T2 , T3 , T4 , T5 , T6 , T7 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates8 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates9 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates10 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates11 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates12 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates13 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates14 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates15 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates16 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates17 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT > { 
typedef Templates18 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT > { 
typedef Templates19 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT > { 
typedef Templates20 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT > { 
typedef Templates21 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT > { 
typedef Templates22 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT > { 
typedef Templates23 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT > { 
typedef Templates24 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT > { 
typedef Templates25 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT > { 
typedef Templates26 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT > { 
typedef Templates27 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT > { 
typedef Templates28 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT > { 
typedef Templates29 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates30 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates31 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates32 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates33 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates34 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates35 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates36 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , NoneT , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates37 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , NoneT , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates38 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates39 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , NoneT , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates40 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , NoneT , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates41 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , NoneT , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates42 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates43 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
NoneT , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates44 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
T45 , NoneT , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates45 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
T45 , T46 , NoneT , NoneT , NoneT , NoneT > { 
typedef Templates46 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 , T46 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
T45 , T46 , T47 , NoneT , NoneT , NoneT > { 
typedef Templates47 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 , T46 , T47 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 , template < typename T > class T48 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
T45 , T46 , T47 , T48 , NoneT , NoneT > { 
typedef Templates48 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 , T46 , T47 , T48 > type ; 
} ;
template < template < typename T > class T1 , template < typename T > class T2 , template < typename T > class T3 , 
template < typename T > class T4 , template < typename T > class T5 , template < typename T > class T6 , 
template < typename T > class T7 , template < typename T > class T8 , template < typename T > class T9 , 
template < typename T > class T10 , template < typename T > class T11 , template < typename T > class T12 , 
template < typename T > class T13 , template < typename T > class T14 , template < typename T > class T15 , 
template < typename T > class T16 , template < typename T > class T17 , template < typename T > class T18 , 
template < typename T > class T19 , template < typename T > class T20 , template < typename T > class T21 , 
template < typename T > class T22 , template < typename T > class T23 , template < typename T > class T24 , 
template < typename T > class T25 , template < typename T > class T26 , template < typename T > class T27 , 
template < typename T > class T28 , template < typename T > class T29 , template < typename T > class T30 , 
template < typename T > class T31 , template < typename T > class T32 , template < typename T > class T33 , 
template < typename T > class T34 , template < typename T > class T35 , template < typename T > class T36 , 
template < typename T > class T37 , template < typename T > class T38 , template < typename T > class T39 , 
template < typename T > class T40 , template < typename T > class T41 , template < typename T > class T42 , 
template < typename T > class T43 , template < typename T > class T44 , template < typename T > class T45 , 
template < typename T > class T46 , template < typename T > class T47 , template < typename T > class T48 , 
template < typename T > class T49 > 
struct Templates < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , 
T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , 
T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , 
T45 , T46 , T47 , T48 , T49 , NoneT > { 
typedef Templates49 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 > type ; 
} ;
# 3318
template < typename T > 
struct TypeList { 
typedef Types1 < T > type ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 , typename T50 > 
struct TypeList < Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 , T49 , T50 > > { 
typedef typename Types < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 , T50 > :: type type ; 
} ;



}
}
# 82 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
class ProtocolMessage; 
namespace proto2 { class Message; }

namespace testing { 



class AssertionResult; 
class Message; 
class Test; 
class TestInfo; 
class TestPartResult; 
class UnitTest; 

template < typename T >
:: std :: string PrintToString ( const T & value );

namespace internal { 

struct TraceInfo; 
class TestInfoImpl; 
class UnitTestImpl; 



__attribute((visibility("default"))) extern const char kStackTraceMarker[]; 
# 123 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
char IsNullLiteralHelper(Secret * p); 
char (&IsNullLiteralHelper(...))[2]; 
# 139 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
__attribute((visibility("default"))) std::string AppendUserMessage(const std::string & gtest_msg, const Message & user_msg); 
# 153 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
class __attribute((visibility("default"))) GoogleTestFailureException : public std::runtime_error { 

public: explicit GoogleTestFailureException(const TestPartResult & failure); 
}; 
# 162
namespace edit_distance { 
# 168
enum EditType { kMatch, kAdd, kRemove, kReplace}; 
__attribute((visibility("default"))) std::vector< EditType>  CalculateOptimalEdits(const std::vector< unsigned>  & left, const std::vector< unsigned>  & right); 



__attribute((visibility("default"))) std::vector< EditType>  CalculateOptimalEdits(const std::vector< std::__cxx11::basic_string< char> >  & left, const std::vector< std::__cxx11::basic_string< char> >  & right); 




__attribute((visibility("default"))) std::string CreateUnifiedDiff(const std::vector< std::__cxx11::basic_string< char> >  & left, const std::vector< std::__cxx11::basic_string< char> >  & right, size_t context = 2); 



}
# 188
__attribute((visibility("default"))) std::string DiffStrings(const std::string & left, const std::string & right, size_t * total_line_count); 
# 207 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
__attribute((visibility("default"))) AssertionResult EqFailure(const char * expected_expression, const char * actual_expression, const std::string & expected_value, const std::string & actual_value, bool ignoring_case); 
# 214
__attribute((visibility("default"))) std::string GetBoolAssertionFailureMessage(const AssertionResult & assertion_result, const char * expression_text, const char * actual_predicate_value, const char * expected_predicate_value); 
# 249 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
template < typename RawType > 
class FloatingPoint { 
public : 


typedef typename TypeWithSize < sizeof (RawType) > :: UInt Bits ; 




static const size_t kBitCount = 8 * sizeof (RawType) ; 


static const size_t kFractionBitCount = 
std :: numeric_limits < RawType > :: digits - 1 ; 


static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount ; 


static const Bits kSignBitMask = static_cast < Bits > (1) << (kBitCount - 1) ; 


static const Bits kFractionBitMask = 
~ static_cast < Bits > (0) >> (kExponentBitCount + 1) ; 


static const Bits kExponentBitMask = ~ (kSignBitMask | kFractionBitMask) ; 
# 290 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
static const size_t kMaxUlps = 4 ; 
# 298
explicit FloatingPoint (const RawType & x) { u_ . value_ = x ; } 
# 305
static RawType ReinterpretBits (const Bits bits) { 
FloatingPoint fp (0) ; 
fp . u_ . bits_ = bits ; 
return fp . u_ . value_ ; 
} 


static RawType Infinity () { 
return ReinterpretBits (kExponentBitMask) ; 
} 


static RawType Max () ; 




const Bits & bits () const { return u_ . bits_ ; } 


Bits exponent_bits () const { return kExponentBitMask & u_ . bits_ ; } 


Bits fraction_bits () const { return kFractionBitMask & u_ . bits_ ; } 


Bits sign_bit () const { return kSignBitMask & u_ . bits_ ; } 


bool is_nan () const { 


return (exponent_bits () == kExponentBitMask) && (fraction_bits () != 0) ; 
} 
# 346
bool AlmostEquals (const FloatingPoint & rhs) const { 


if (is_nan () || rhs . is_nan ()) return false ; 

return DistanceBetweenSignAndMagnitudeNumbers (u_ . bits_ , rhs . u_ . bits_) 
<= kMaxUlps ; 
} 

private : 

union FloatingPointUnion { 
RawType value_ ; 
Bits bits_ ; 
} ; 
# 377 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
static Bits SignAndMagnitudeToBiased (const Bits & sam) { 
if (kSignBitMask & sam) { 

return ~ sam + 1 ; 
} else { 

return kSignBitMask | sam ; 
} 
} 



static Bits DistanceBetweenSignAndMagnitudeNumbers (const Bits & sam1 , 
const Bits & sam2) { 
const Bits biased1 = SignAndMagnitudeToBiased (sam1) ; 
const Bits biased2 = SignAndMagnitudeToBiased (sam2) ; 
return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1) ; 
} 

FloatingPointUnion u_ ; 
} ;




template<> inline float FloatingPoint< float> ::Max() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(72 + 0 + 1U - 1);return (3.402823466e+38F); } 

template<> inline double FloatingPoint< double> ::Max() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(73 + 0 + 1U - 1);return (double)(1.7976931348623157e+308L); } 



typedef FloatingPoint< float>  Float; 
typedef FloatingPoint< double>  Double; 
# 417
typedef const void *TypeId; 

template < typename T > 
class TypeIdHelper { 
public : 



static bool dummy_ ; 
} ;

template < typename T >
bool TypeIdHelper < T > :: dummy_ = false;




template < typename T > 
TypeId GetTypeId () { 




return & (TypeIdHelper < T > :: dummy_) ; 
} 
# 448
__attribute((visibility("default"))) TypeId GetTestTypeId(); 



class TestFactoryBase { 

public: virtual ~TestFactoryBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(74 + 0 + 1U - 1);} 



virtual Test *CreateTest() = 0; 


protected: TestFactoryBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(75 + 0 + 1U - 1);} 


private: TestFactoryBase(const TestFactoryBase &) = delete;void operator=(const TestFactoryBase &) = delete;
}; 



template < class TestClass > 
class TestFactoryImpl : public TestFactoryBase { 
public : 
virtual Test * CreateTest () { return new TestClass ; } 
} ;
# 481
__attribute((visibility("default"))) AssertionResult IsHRESULTSuccess(const char * expr, long hr); 

__attribute((visibility("default"))) AssertionResult IsHRESULTFailure(const char * expr, long hr); 
# 489
typedef void (*SetUpTestCaseFunc)(void); 
typedef void (*TearDownTestCaseFunc)(void); 

struct CodeLocation { 
CodeLocation(const std::string &a_file, int a_line) : file(a_file), line(a_line) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(76 + 0 + 1U - 1);} 

std::string file; 
int line; 
}; 
# 518 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
__attribute((visibility("default"))) TestInfo *MakeAndRegisterTestInfo(const char * test_case_name, const char * name, const char * type_param, const char * value_param, CodeLocation code_location, TypeId fixture_class_id, SetUpTestCaseFunc set_up_tc, TearDownTestCaseFunc tear_down_tc, TestFactoryBase * factory); 
# 532
__attribute((visibility("default"))) bool SkipPrefix(const char * prefix, const char ** pstr); 
# 540
class __attribute((visibility("default"))) TypedTestCasePState { 

public: TypedTestCasePState() : registered_(false) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(77 + 0 + 1U - 1);} 




bool AddTestName(const char *file, int line, const char *case_name, const char *
test_name) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(78 + 0 + 1U - 1), registered_)) { cpptestFastCoverageStmt(78 + 0 + 2U - 1);
fprintf((&((_iob)[2])), "%s Test %s must be defined before REGISTER_TYPED_TEST_CASE_P(%s, ...).\n", (FormatFileLocation(file, line)).c_str(), test_name, case_name); cpptestFastCoverageStmt(78 + 0 + 3U - 1);
# 553 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
fflush((&((_iob)[2]))); cpptestFastCoverageStmt(78 + 0 + 4U - 1);
# 554 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
posix::Abort(); 
}  cpptestFastCoverageStmt(78 + 0 + 5U - 1);
(registered_tests_).insert(::std::make_pair(test_name, CodeLocation(file, line))); cpptestFastCoverageStmt(78 + 0 + 6U - 1);

return true; 
} 

bool TestExists(const std::string &test_name) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(84 + 0 + 1U - 1);
return (registered_tests_).count(test_name) > 0; 
} 

const CodeLocation &GetCodeLocation(const std::string &test_name) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(85 + 0 + 1U - 1);
std::map< std::__cxx11::basic_string< char> , CodeLocation> ::const_iterator it = (registered_tests_).find(test_name); 
switch (((void)cpptestFastCoverageStmt(85 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(85 + 0 + 3U - 1), ::testing::internal::IsTrue((it != (registered_tests_).end())))) {cpptestFastCoverageStmt(85 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(85 + 0 + 5U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/g" "test-internal.h", 567).GetStream() << ("Condition it != registered_tests_.end() failed. ")); }  }  cpptestFastCoverageStmt(85 + 0 + 6U - 1);
return it->second; 
} 




const char *VerifyRegisteredTestNames(const char * file, int line, const char * registered_tests); 



private: typedef std::map< std::__cxx11::basic_string< char> , CodeLocation>  RegisteredTestsMap; 

bool registered_; 
RegisteredTestsMap registered_tests_; 
}; 
# 588
inline const char *SkipComma(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(91 + 0 + 1U - 1);
const char *comma = strchr(str, ','); 
if (((void)cpptestFastCoverageStmt(91 + 0 + 2U - 1), comma == (nullptr))) { cpptestFastCoverageStmt(91 + 0 + 3U - 1);
return nullptr; 
}  
while (((void)cpptestFastCoverageStmt(91 + 0 + 4U - 1), IsSpace(*(++comma)))) { cpptestFastCoverageStmt(91 + 0 + 5U - 1);}  cpptestFastCoverageStmt(91 + 0 + 6U - 1);
return comma; 
} 



inline std::string GetPrefixUntilComma(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(97 + 0 + 1U - 1);
const char *comma = strchr(str, ','); cpptestFastCoverageStmt(97 + 0 + 2U - 1);
return ((comma == (nullptr)) ? str : std::string(str, comma)); 
} 



void SplitString(const std::string & str, char delimiter, std::vector< std::__cxx11::basic_string< char> >  * dest); 




struct DefaultNameGenerator { 
template < typename T > 
static std :: string GetName (int i) { 
return StreamableToString (i) ; 
} 
}; 

template < typename Provided = DefaultNameGenerator > 
struct NameGeneratorSelector { 
typedef Provided type ; 
} ;

template < typename NameGenerator > 
void GenerateNamesRecursively (Types0 , std :: vector < std :: string > * , int) { } 

template < typename NameGenerator , typename Types > 
void GenerateNamesRecursively (Types , std :: vector < std :: string > * result , int i) { 
result -> push_back (NameGenerator :: template GetName < typename Types :: Head > (i)) ; 
GenerateNamesRecursively < NameGenerator > (typename Types :: Tail () , result , 
i + 1) ; 
} 

template < typename NameGenerator , typename Types > 
std :: vector < std :: string > GenerateNames () { 
std :: vector < std :: string > result ; 
GenerateNamesRecursively < NameGenerator > (Types () , & result , 0) ; 
return result ; 
} 
# 647 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
template < template < typename T > class Fixture , class TestSel , typename Types > 
class TypeParameterizedTest { 
public : 




static bool Register (const char * prefix , const CodeLocation & code_location , 
const char * case_name , const char * test_names , int index , 
const std :: vector < std :: string > & type_names = 
GenerateNames < DefaultNameGenerator , Types > ()) { 
typedef typename Types :: Head Type ; 
typedef Fixture < Type > FixtureClass ; 
typedef typename TestSel :: template Bind < Type > :: type TestClass ; 



MakeAndRegisterTestInfo (
(std :: string (prefix) + (prefix [ 0 ] == '\0' ? "" : "/") + case_name + 
"/" + type_names [ index ]) 
. c_str () , 
StripTrailingSpaces (GetPrefixUntilComma (test_names)) . c_str () , 
GetTypeName < Type > () . c_str () , 
nullptr , 
code_location , GetTypeId < FixtureClass > () , TestClass :: SetUpTestCase , 
TestClass :: TearDownTestCase , new TestFactoryImpl < TestClass >) ; 


return TypeParameterizedTest < Fixture , TestSel , 
typename Types :: Tail > :: Register (prefix , 
code_location , 
case_name , 
test_names , 
index + 1 , 
type_names) ; 
} 
} ;


template < template < typename T > class Fixture , class TestSel > 
class TypeParameterizedTest < Fixture , TestSel , Types0 > { 
public : 
static bool Register (const char * , const CodeLocation & , 
const char * , const char * , 
int , 
const std :: vector < std :: string > & = 
std :: vector < std :: string > ()) { 
return true ; 
} 
} ;
# 702
template < template < typename T > class Fixture , typename Tests , typename Types > 
class TypeParameterizedTestCase { 
public : 
static bool Register (const char * prefix , CodeLocation code_location , 
const TypedTestCasePState * state , const char * case_name , 
const char * test_names , 
const std :: vector < std :: string > & type_names = 
GenerateNames < DefaultNameGenerator , Types > ()) { 
std :: string test_name = StripTrailingSpaces (
GetPrefixUntilComma (test_names)) ; 
if (! state -> TestExists (test_name)) { 
fprintf (
# 713 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h" 3
(& _iob [ 2 ]) 
# 713 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
, "Failed to get code location for test %s.%s at %s." , 
case_name , test_name . c_str () , 
FormatFileLocation (code_location . file . c_str () , 
code_location . line) . c_str ()) ; 
fflush (
# 717 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h" 3
(& _iob [ 2 ]) 
# 717 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
) ; 
posix :: Abort () ; 
} 
const CodeLocation & test_location = state -> GetCodeLocation (test_name) ; 

typedef typename Tests :: Head Head ; 


TypeParameterizedTest < Fixture , Head , Types > :: Register (
prefix , test_location , case_name , test_names , 0 , type_names) ; 


return TypeParameterizedTestCase < Fixture , typename Tests :: Tail , 
Types > :: Register (prefix , code_location , 
state , case_name , 
SkipComma (test_names) , 
type_names) ; 
} 
} ;


template < template < typename T > class Fixture , typename Types > 
class TypeParameterizedTestCase < Fixture , Templates0 , Types > { 
public : 
static bool Register (const char * , const CodeLocation & , 
const TypedTestCasePState * , 
const char * , const char * , 
const std :: vector < std :: string > & = 
std :: vector < std :: string > ()) { 
return true ; 
} 
} ;
# 762 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
__attribute((visibility("default"))) std::string GetCurrentOsStackTraceExceptTop(UnitTest * unit_test, int skip_count); 
# 769
__attribute((visibility("default"))) bool AlwaysTrue(); 


inline bool AlwaysFalse() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(99 + 0 + 1U - 1);return !AlwaysTrue(); } 




struct __attribute((visibility("default"))) ConstCharPtr { 
ConstCharPtr(const char *str) : value(str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(100 + 0 + 1U - 1);} 
operator bool() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(101 + 0 + 1U - 1);return true; } 
const char *value; 
}; 
# 788
class __attribute((visibility("default"))) Random { 

public: static const UInt32 kMaxRange = (1U << 31); 

explicit Random(UInt32 seed) : state_(seed) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(102 + 0 + 1U - 1);} 

void Reseed(UInt32 seed) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(103 + 0 + 1U - 1);state_ = seed; } 



UInt32 Generate(UInt32 range); 


private: UInt32 state_; 
Random(const Random &) = delete;void operator=(const Random &) = delete;
}; 



template < typename T1, typename T2 >
struct CompileAssertTypesEqual;

template < typename T > 
struct CompileAssertTypesEqual < T , T > { 
} ;




template < typename T > 
struct RemoveReference { typedef T type ; } ;
template < typename T > 
struct RemoveReference < T & > { typedef T type ; } ;
# 830 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
template < typename T > 
struct RemoveConst { typedef T type ; } ;
template < typename T > 
struct RemoveConst < const T > { typedef T type ; } ;




template < typename T , size_t N > 
struct RemoveConst < const T [ N ] > { 
typedef typename RemoveConst < T > :: type type [ N ] ; 
} ;
# 865 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
template < typename From , typename To > 
class ImplicitlyConvertible { 
private : 
# 874
static typename AddReference < From > :: type MakeFrom () ; 
# 886 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
static char Helper (To) ; 
static char (& Helper (...)) [ 2 ] ; 



public : 
# 902 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
static const bool value = 
sizeof (Helper (ImplicitlyConvertible :: MakeFrom ())) == 1 ; 


} ;
template < typename From, typename To >
const bool ImplicitlyConvertible < From, To > :: value;




template < typename T > 
struct IsAProtocolMessage 
: public bool_constant < 
ImplicitlyConvertible < const T * , const :: ProtocolMessage * > :: value || 
ImplicitlyConvertible < const T * , const :: proto2 :: Message * > :: value > { 
} ;
# 944 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
typedef int IsContainer; 
template < class C , 
class Iterator = decltype (:: std :: declval < const C & > () . begin ()) , 
class = decltype (:: std :: declval < const C & > () . end ()) , 
class = decltype (++ :: std :: declval < Iterator & > ()) , 
class = decltype (* :: std :: declval < Iterator > ()) , 
class = typename C :: const_iterator > 
IsContainer IsContainerTest (int) { 
return 0 ; 
} 

typedef char IsNotContainer; 
template < class C > 
IsNotContainer IsContainerTest (long) { return '\0' ; } 
# 963
template < typename T > 
struct IsHashTable { 
private : 
template < typename U > 
static char test (typename U :: hasher * , typename U :: reverse_iterator *) ; 
template < typename U > 
static int test (typename U :: hasher * , ...) ; 
template < typename U > 
static char test (...) ; 

public : 
static const bool value = sizeof (test < T > (nullptr , nullptr)) == sizeof (int) ; 
} ;

template < typename T >
const bool IsHashTable < T > :: value;

template < typename T > 
struct VoidT { 
typedef void value_type ; 
} ;

template < typename T , typename = void > 
struct HasValueType : false_type { } ;
template < typename T > 
struct HasValueType < T , VoidT < typename T :: value_type > > : true_type { 
} ;

template < typename C,
          bool = sizeof ( IsContainerTest < C > ( 0 ) ) == sizeof ( IsContainer ),
          bool = HasValueType < C > :: value >
struct IsRecursiveContainerImpl;

template < typename C , bool HV > 
struct IsRecursiveContainerImpl < C , false , HV > : public false_type { } ;
# 1003
template < typename C > 
struct IsRecursiveContainerImpl < C , true , false > : public false_type { } ;

template < typename C > 
struct IsRecursiveContainerImpl < C , true , true > { 
typedef typename IteratorTraits < typename C :: const_iterator > :: value_type 
value_type ; 
typedef is_same < value_type , C > type ; 
} ;
# 1019
template < typename C > 
struct IsRecursiveContainer : public IsRecursiveContainerImpl < C > :: type { } ;
# 1026
template < bool > struct EnableIf;
template<> struct EnableIf< true>  { typedef void type; }; 
# 1035
template < typename T, typename U >
bool ArrayEq ( const T * lhs, size_t size, const U * rhs );


template < typename T , typename U > 
inline bool ArrayEq (const T & lhs , const U & rhs) { return lhs == rhs ; } 


template < typename T , typename U , size_t N > 
inline bool ArrayEq (const T (& lhs) [ N ] , const U (& rhs) [ N ]) { 
return internal :: ArrayEq (lhs , N , rhs) ; 
} 




template < typename T , typename U > 
bool ArrayEq (const T * lhs , size_t size , const U * rhs) { 
for (size_t i = 0 ; i != size ; i ++) { 
if (! internal :: ArrayEq (lhs [ i ] , rhs [ i ])) 
return false ; 
} 
return true ; 
} 



template < typename Iter , typename Element > 
Iter ArrayAwareFind (Iter begin , Iter end , const Element & elem) { 
for (Iter it = begin ; it != end ; ++ it) { 
if (internal :: ArrayEq (* it , elem)) 
return it ; 
} 
return end ; 
} 
# 1075
template < typename T, typename U >
void CopyArray ( const T * from, size_t size, U * to );


template < typename T , typename U > 
inline void CopyArray (const T & from , U * to) { * to = from ; } 


template < typename T , typename U , size_t N > 
inline void CopyArray (const T (& from) [ N ] , U (* to) [ N ]) { 
internal :: CopyArray (from , N , * to) ; 
} 




template < typename T , typename U > 
void CopyArray (const T * from , size_t size , U * to) { 
for (size_t i = 0 ; i != size ; i ++) { 
internal :: CopyArray (from [ i ] , to + i) ; 
} 
} 
# 1102
struct RelationToSourceReference { }; 
struct RelationToSourceCopy { }; 
# 1113 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-internal.h"
template < typename Element > 
class NativeArray { 
public : 

typedef Element value_type ; 
typedef Element * iterator ; 
typedef const Element * const_iterator ; 


NativeArray (const Element * array , size_t count , RelationToSourceReference) { 
InitRef (array , count) ; 
} 


NativeArray (const Element * array , size_t count , RelationToSourceCopy) { 
InitCopy (array , count) ; 
} 


NativeArray (const NativeArray & rhs) { 
(this ->* rhs . clone_) (rhs . array_ , rhs . size_) ; 
} 

~ NativeArray () { 
if (clone_ != & NativeArray :: InitRef) 
delete [ ] array_ ; 
} 


size_t size () const { return size_ ; } 
const_iterator begin () const { return array_ ; } 
const_iterator end () const { return array_ + size_ ; } 
bool operator == (const NativeArray & rhs) const { 
return size () == rhs . size () && 
ArrayEq (begin () , size () , rhs . begin ()) ; 
} 

private : 
enum { 
kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper < 
Element , typename :: testing :: internal :: RemoveConst < typename :: testing :: internal :: RemoveReference < Element > :: type > :: type > :: value 
} ; 


void InitCopy (const Element * array , size_t a_size) { 
Element * const copy = new Element [ a_size ] ; 
CopyArray (array , a_size , copy) ; 
array_ = copy ; 
size_ = a_size ; 
clone_ = & NativeArray :: InitCopy ; 
} 


void InitRef (const Element * array , size_t a_size) { 
array_ = array ; 
size_ = a_size ; 
clone_ = & NativeArray :: InitRef ; 
} 

const Element * array_ ; 
size_t size_ ; 
void (NativeArray :: * clone_) (const Element * , size_t) ; 

void operator = (NativeArray const &) = delete ; 
} ;

}
}
# 43 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h"
namespace testing { 
namespace internal { 

__attribute((visibility("default"))) extern std::string FLAGS_gtest_internal_run_death_test; 


const char kDeathTestStyleFlag[] = "death_test_style"; 
const char kDeathTestUseFork[] = "death_test_use_fork"; 
const char kInternalRunDeathTestFlag[] = "internal_run_death_test"; 
# 71 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h"
class __attribute((visibility("default"))) DeathTest { 
# 81 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h"
public: static bool Create(const char * statement, const RE * regex, const char * file, int line, DeathTest ** test); 

DeathTest(); 
virtual ~DeathTest() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(104 + 0 + 1U - 1);} 


class ReturnSentinel { 

public: explicit ReturnSentinel(DeathTest *test) : test_(test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(105 + 0 + 1U - 1);} 
~ReturnSentinel() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(106 + 0 + 1U - 1);(test_)->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); } 

private: DeathTest *const test_; 
ReturnSentinel(const ReturnSentinel &) = delete;void operator=(const ReturnSentinel &) = delete;
} __attribute((unused)); 
# 101
enum TestRole { OVERSEE_TEST, EXECUTE_TEST}; 


enum AbortReason { 
TEST_ENCOUNTERED_RETURN_STATEMENT, 
TEST_THREW_EXCEPTION, 
TEST_DID_NOT_DIE
}; 


virtual TestRole AssumeRole() = 0; 


virtual int Wait() = 0; 
# 123 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h"
virtual bool Passed(bool exit_status_ok) = 0; 


virtual void Abort(AbortReason reason) = 0; 



static const char *LastMessage(); 

static void set_last_death_test_message(const std::string & message); 



private: static std::string last_death_test_message_; 

DeathTest(const DeathTest &) = delete;void operator=(const DeathTest &) = delete;
}; 




class DeathTestFactory { 

public: virtual ~DeathTestFactory() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(107 + 0 + 1U - 1);} 
virtual bool Create(const char * statement, const RE * regex, const char * file, int line, DeathTest ** test) = 0; 

}; 


class DefaultDeathTestFactory : public DeathTestFactory { 

public: virtual bool Create(const char * statement, const RE * regex, const char * file, int line, DeathTest ** test); 

}; 



__attribute((visibility("default"))) bool ExitedUnsuccessfully(int exit_status); 
# 242 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-death-test-internal.h"
class InternalRunDeathTestFlag { 

public: InternalRunDeathTestFlag(const std::string &a_file, int 
a_line, int 
an_index, int 
a_write_fd) : file_(a_file), line_(a_line), index_(an_index), write_fd_(a_write_fd) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(108 + 0 + 1U - 1);} 

~InternalRunDeathTestFlag() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(109 + 0 + 1U - 1), write_fd_ >= 0)) {cpptestFastCoverageStmt(109 + 0 + 2U - 1);
posix::Close(write_fd_); }  
} 

const std::string &file() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(111 + 0 + 1U - 1);return file_; } 
int line() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(112 + 0 + 1U - 1);return line_; } 
int index() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(113 + 0 + 1U - 1);return index_; } 
int write_fd() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(114 + 0 + 1U - 1);return write_fd_; } 


private: std::string file_; 
int line_; 
int index_; 
int write_fd_; 

InternalRunDeathTestFlag(const InternalRunDeathTestFlag &) = delete;void operator=(const InternalRunDeathTestFlag &) = delete;
}; 




InternalRunDeathTestFlag *ParseInternalRunDeathTestFlag(); 



}
}
# 43 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-death-test.h"
namespace testing { 
# 50
__attribute((visibility("default"))) extern std::string FLAGS_gtest_death_test_style; 



namespace internal { 
# 61
__attribute((visibility("default"))) bool InDeathTestChild(); 

}
# 191 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-death-test.h"
class __attribute((visibility("default"))) ExitedWithCode { 

public: explicit ExitedWithCode(int exit_code); 
bool operator()(int exit_status) const; 


private: void operator=(const ExitedWithCode & other); 

const int exit_code_; 
}; 
# 342 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-death-test.h"
}
# 37 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stream_iterator.h" 3
namespace std { 
# 47
template < typename _Tp , typename _CharT = char , 
typename _Traits = char_traits < _CharT > , typename _Dist = ptrdiff_t > 
class istream_iterator 
: public iterator < input_iterator_tag , _Tp , _Dist , const _Tp * , const _Tp & > 
{ 
public : 
typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef basic_istream < _CharT , _Traits > istream_type ; 

private : 
istream_type * _M_stream ; 
_Tp _M_value ; 
bool _M_ok ; 

public : 

constexpr istream_iterator () 
: _M_stream (0) , _M_value () , _M_ok (false) { } 


istream_iterator (istream_type & __s) 
: _M_stream (std :: __addressof (__s)) 
{ _M_read () ; } 

istream_iterator (const istream_iterator & __obj) 
: _M_stream (__obj . _M_stream) , _M_value (__obj . _M_value) , 
_M_ok (__obj . _M_ok) 
{ } 


istream_iterator & operator = (const istream_iterator &) = default ; 


const _Tp & 
operator * () const 
{ 


; 
return _M_value ; 
} 

const _Tp * 
operator -> () const { return std :: __addressof ((operator * ())) ; } 

istream_iterator & 
operator ++ () 
{ 


; 
_M_read () ; 
return * this ; 
} 

istream_iterator 
operator ++ (int) 
{ 


; 
istream_iterator __tmp = * this ; 
_M_read () ; 
return __tmp ; 
} 

bool 
_M_equal (const istream_iterator & __x) const 
{ return (_M_ok == __x . _M_ok) && (! _M_ok || _M_stream == __x . _M_stream) ; } 

private : 
void 
_M_read () 
{ 
_M_ok = (_M_stream && * _M_stream) ? true : false ; 
if (_M_ok) 
{ 
* _M_stream >> _M_value ; 
_M_ok = * _M_stream ? true : false ; 
} 
} 
} ;


template < typename _Tp , typename _CharT , typename _Traits , typename _Dist > 
inline bool 
operator == (const istream_iterator < _Tp , _CharT , _Traits , _Dist > & __x , 
const istream_iterator < _Tp , _CharT , _Traits , _Dist > & __y) 
{ return __x . _M_equal (__y) ; } 


template < class _Tp , class _CharT , class _Traits , class _Dist > 
inline bool 
operator != (const istream_iterator < _Tp , _CharT , _Traits , _Dist > & __x , 
const istream_iterator < _Tp , _CharT , _Traits , _Dist > & __y) 
{ return ! __x . _M_equal (__y) ; } 
# 156 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stream_iterator.h" 3
template < typename _Tp , typename _CharT = char , 
typename _Traits = char_traits < _CharT > > 
class ostream_iterator 
: public iterator < output_iterator_tag , void , void , void , void > 
{ 
public : 


typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef basic_ostream < _CharT , _Traits > ostream_type ; 


private : 
ostream_type * _M_stream ; 
const _CharT * _M_string ; 

public : 

ostream_iterator (ostream_type & __s) 
: _M_stream (std :: __addressof (__s)) , _M_string (0) { } 
# 188 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stream_iterator.h" 3
ostream_iterator (ostream_type & __s , const _CharT * __c) 
: _M_stream (& __s) , _M_string (__c) { } 


ostream_iterator (const ostream_iterator & __obj) 
: _M_stream (__obj . _M_stream) , _M_string (__obj . _M_string) { } 


ostream_iterator & operator = (const ostream_iterator &) = default ; 




ostream_iterator & 
operator = (const _Tp & __value) 
{ 


; 
* _M_stream << __value ; 
if (_M_string) * _M_stream << _M_string ; 
return * this ; 
} 

ostream_iterator & 
operator * () 
{ return * this ; } 

ostream_iterator & 
operator ++ () 
{ return * this ; } 

ostream_iterator & 
operator ++ (int) 
{ return * this ; } 
} ;




}
# 23 "d:\\mingw\\mingw\\include\\assert.h" 3
extern "C" {
# 48 "d:\\mingw\\mingw\\include\\assert.h" 3
}
# 76 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
namespace testing { 
namespace internal { 


__attribute((visibility("default"))) extern Mutex g_linked_ptr_mutex; 
# 89 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
class linked_ptr_internal { 


public: void join_new() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(115 + 0 + 1U - 1);
next_ = this; 
} 
# 108 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
void join(const linked_ptr_internal *ptr) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(116 + 0 + 1U - 1);
MutexLock lock(&g_linked_ptr_mutex); cpptestFastCoverageStmt(116 + 0 + 2U - 1);

const linked_ptr_internal *p = ptr; 
while (((void)cpptestFastCoverageStmt(116 + 0 + 3U - 1), p->next_ != ptr)) { cpptestFastCoverageStmt(116 + 0 + 4U - 1);
# 114 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h" 3
((void)0); cpptestFastCoverageStmt(116 + 0 + 5U - 1);
# 117 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
p = p->next_; 
}  cpptestFastCoverageStmt(116 + 0 + 6U - 1);
p->next_ = this; cpptestFastCoverageStmt(116 + 0 + 7U - 1);
next_ = ptr; 
} 



bool depart() 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(123 + 0 + 1U - 1);
MutexLock lock(&g_linked_ptr_mutex); 

if (((void)cpptestFastCoverageStmt(123 + 0 + 2U - 1), next_ == this)) {cpptestFastCoverageStmt(123 + 0 + 3U - 1);return true; }  cpptestFastCoverageStmt(123 + 0 + 4U - 1);
const linked_ptr_internal *p = next_; 
while (((void)cpptestFastCoverageStmt(123 + 0 + 5U - 1), p->next_ != this)) { cpptestFastCoverageStmt(123 + 0 + 6U - 1);
# 132 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h" 3
((void)0); cpptestFastCoverageStmt(123 + 0 + 7U - 1);
# 135 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
p = p->next_; 
}  cpptestFastCoverageStmt(123 + 0 + 8U - 1);
p->next_ = next_; cpptestFastCoverageStmt(123 + 0 + 9U - 1);
return false; 
} 


private: mutable const linked_ptr_internal *next_; 
}; 

template < typename T > 
class linked_ptr { 
public : 
typedef T element_type ; 



explicit linked_ptr (T * ptr = nullptr) { capture (ptr) ; } 
~ linked_ptr () { depart () ; } 


template < typename U > linked_ptr (linked_ptr < U > const & ptr) { copy (& ptr) ; } 
linked_ptr (linked_ptr const & ptr) { 
# 158 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h" 3
((void) 0) 
# 158 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-linked_ptr.h"
; 
copy (& ptr) ; 
} 


template < typename U > linked_ptr & operator = (linked_ptr < U > const & ptr) { 
depart () ; 
copy (& ptr) ; 
return * this ; 
} 

linked_ptr & operator = (linked_ptr const & ptr) { 
if (& ptr != this) { 
depart () ; 
copy (& ptr) ; 
} 
return * this ; 
} 


void reset (T * ptr = nullptr) { 
depart () ; 
capture (ptr) ; 
} 
T * get () const { return value_ ; } 
T * operator -> () const { return value_ ; } 
T & operator * () const { return * value_ ; } 

bool operator == (T * p) const { return value_ == p ; } 
bool operator != (T * p) const { return value_ != p ; } 
template < typename U > 
bool operator == (linked_ptr < U > const & ptr) const { 
return value_ == ptr . get () ; 
} 
template < typename U > 
bool operator != (linked_ptr < U > const & ptr) const { 
return value_ != ptr . get () ; 
} 

private : 
template < typename U > 
friend class linked_ptr ; 

T * value_ ; 
linked_ptr_internal link_ ; 

void depart () { 
if (link_ . depart ()) delete value_ ; 
} 

void capture (T * ptr) { 
value_ = ptr ; 
link_ . join_new () ; 
} 

template < typename U > void copy (linked_ptr < U > const * ptr) { 
value_ = ptr -> get () ; 
if (value_) 
link_ . join (& ptr -> link_) ; 
else 
link_ . join_new () ; 
} 
} ;

template < typename T > inline 
bool operator == (T * ptr , const linked_ptr < T > & x) { 
return ptr == x . get () ; 
} 

template < typename T > inline 
bool operator != (T * ptr , const linked_ptr < T > & x) { 
return ptr != x . get () ; 
} 




template < typename T > 
linked_ptr < T > make_linked_ptr (T * ptr) { 
return linked_ptr < T > (ptr) ; 
} 

}
}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\refwrap.h" 3
namespace std { 
# 52
template < typename _Res , typename ... _ArgTypes > 
struct _Maybe_unary_or_binary_function { } ;


template < typename _Res , typename _T1 > 
struct _Maybe_unary_or_binary_function < _Res , _T1 > 
: std :: unary_function < _T1 , _Res > { } ;


template < typename _Res , typename _T1 , typename _T2 > 
struct _Maybe_unary_or_binary_function < _Res , _T1 , _T2 > 
: std :: binary_function < _T1 , _T2 , _Res > { } ;

template < typename _Signature >
    struct _Mem_fn_traits;

template < typename _Res , typename _Class , typename ... _ArgTypes > 
struct _Mem_fn_traits_base 
{ 
using __result_type = _Res ; 
using __maybe_type 
= _Maybe_unary_or_binary_function < _Res , _Class * , _ArgTypes ... > ; 
using __arity = integral_constant < size_t , sizeof ... (_ArgTypes) > ; 
} ;
# 97 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\refwrap.h" 3
template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) volatile > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) volatile > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const volatile > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const volatile > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;
template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) & > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) & > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const & > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const & > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) volatile & > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) volatile & > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const volatile & > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const volatile & > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;
template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) && > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) && > : _Mem_fn_traits_base < _Res , _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const && > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const && > : _Mem_fn_traits_base < _Res , const _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) volatile && > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) volatile && > : _Mem_fn_traits_base < _Res , volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ...) const volatile && > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = false_type ; } ;template < typename _Res , typename _Class , typename ... _ArgTypes > struct _Mem_fn_traits < _Res (_Class :: *) (_ArgTypes ... ...) const volatile && > : _Mem_fn_traits_base < _Res , const volatile _Class , _ArgTypes ... > { using __vararg = true_type ; } ;
# 111 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\refwrap.h" 3
template < typename _Functor , typename = __void_t < > > 
struct _Maybe_get_result_type 
{ } ;

template < typename _Functor > 
struct _Maybe_get_result_type < _Functor , 
__void_t < typename _Functor :: result_type > > 
{ typedef typename _Functor :: result_type result_type ; } ;
# 124
template < typename _Functor > 
struct _Weak_result_type_impl 
: _Maybe_get_result_type < _Functor > 
{ } ;


template < typename _Res , typename ... _ArgTypes > 
struct _Weak_result_type_impl < _Res (_ArgTypes ...) > 
{ typedef _Res result_type ; } ;


template < typename _Res , typename ... _ArgTypes > 
struct _Weak_result_type_impl < _Res (_ArgTypes ... ...) > 
{ typedef _Res result_type ; } ;


template < typename _Res , typename ... _ArgTypes > 
struct _Weak_result_type_impl < _Res (*) (_ArgTypes ...) > 
{ typedef _Res result_type ; } ;


template < typename _Res , typename ... _ArgTypes > 
struct 
_Weak_result_type_impl < _Res (*) (_ArgTypes ... ...) > 
{ typedef _Res result_type ; } ;


template < typename _Functor , 
bool = is_member_function_pointer < _Functor > :: value > 
struct _Weak_result_type_memfun 
: _Weak_result_type_impl < _Functor > 
{ } ;


template < typename _MemFunPtr > 
struct _Weak_result_type_memfun < _MemFunPtr , true > 
{ 
using result_type = typename _Mem_fn_traits < _MemFunPtr > :: __result_type ; 
} ;


template < typename _Func , typename _Class > 
struct _Weak_result_type_memfun < _Func _Class :: * , false > 
{ } ;
# 173
template < typename _Functor > 
struct _Weak_result_type 
: _Weak_result_type_memfun < typename remove_cv < _Functor > :: type > 
{ } ;



template < typename _Tp , typename = __void_t < > > 
struct _Refwrap_base_arg1 
{ } ;


template < typename _Tp > 
struct _Refwrap_base_arg1 < _Tp , 
__void_t < typename _Tp :: argument_type > > 
{ 
typedef typename _Tp :: argument_type argument_type ; 
} ;


template < typename _Tp , typename = __void_t < > > 
struct _Refwrap_base_arg2 
{ } ;


template < typename _Tp > 
struct _Refwrap_base_arg2 < _Tp , 
__void_t < typename _Tp :: first_argument_type , 
typename _Tp :: second_argument_type > > 
{ 
typedef typename _Tp :: first_argument_type first_argument_type ; 
typedef typename _Tp :: second_argument_type second_argument_type ; 
} ;
# 213
template < typename _Tp > 
struct _Reference_wrapper_base 
: _Weak_result_type < _Tp > , _Refwrap_base_arg1 < _Tp > , _Refwrap_base_arg2 < _Tp > 
{ } ;


template < typename _Res , typename _T1 > 
struct _Reference_wrapper_base < _Res (_T1) > 
: unary_function < _T1 , _Res > 
{ } ;

template < typename _Res , typename _T1 > 
struct _Reference_wrapper_base < _Res (_T1) const > 
: unary_function < _T1 , _Res > 
{ } ;

template < typename _Res , typename _T1 > 
struct _Reference_wrapper_base < _Res (_T1) volatile > 
: unary_function < _T1 , _Res > 
{ } ;

template < typename _Res , typename _T1 > 
struct _Reference_wrapper_base < _Res (_T1) const volatile > 
: unary_function < _T1 , _Res > 
{ } ;


template < typename _Res , typename _T1 , typename _T2 > 
struct _Reference_wrapper_base < _Res (_T1 , _T2) > 
: binary_function < _T1 , _T2 , _Res > 
{ } ;

template < typename _Res , typename _T1 , typename _T2 > 
struct _Reference_wrapper_base < _Res (_T1 , _T2) const > 
: binary_function < _T1 , _T2 , _Res > 
{ } ;

template < typename _Res , typename _T1 , typename _T2 > 
struct _Reference_wrapper_base < _Res (_T1 , _T2) volatile > 
: binary_function < _T1 , _T2 , _Res > 
{ } ;

template < typename _Res , typename _T1 , typename _T2 > 
struct _Reference_wrapper_base < _Res (_T1 , _T2) const volatile > 
: binary_function < _T1 , _T2 , _Res > 
{ } ;


template < typename _Res , typename _T1 > 
struct _Reference_wrapper_base < _Res (*) (_T1) > 
: unary_function < _T1 , _Res > 
{ } ;


template < typename _Res , typename _T1 , typename _T2 > 
struct _Reference_wrapper_base < _Res (*) (_T1 , _T2) > 
: binary_function < _T1 , _T2 , _Res > 
{ } ;

template < typename _Tp , bool = is_member_function_pointer < _Tp > :: value > 
struct _Reference_wrapper_base_memfun 
: _Reference_wrapper_base < _Tp > 
{ } ;

template < typename _MemFunPtr > 
struct _Reference_wrapper_base_memfun < _MemFunPtr , true > 
: _Mem_fn_traits < _MemFunPtr > :: __maybe_type 
{ 
using result_type = typename _Mem_fn_traits < _MemFunPtr > :: __result_type ; 
} ;
# 290
template < typename _Tp > 
class reference_wrapper 



: public _Reference_wrapper_base_memfun < typename remove_cv < _Tp > :: type > 

{ 
_Tp * _M_data ; 

static _Tp * _S_fun (_Tp & __r) noexcept { return std :: __addressof (__r) ; } 
static void _S_fun (_Tp &&) = delete ; 

template < typename _Up , typename _Up2 = __remove_cvref_t < _Up > > 
using __not_same 
= typename enable_if < ! is_same < reference_wrapper , _Up2 > :: value > :: type ; 

public : 
typedef _Tp type ; 




template < typename _Up , typename = __not_same < _Up > , typename 
= decltype (reference_wrapper :: _S_fun (std :: declval < _Up > ())) > 
reference_wrapper (_Up && __uref) 
noexcept (noexcept (reference_wrapper :: _S_fun (std :: declval < _Up > ()))) 
: _M_data (reference_wrapper :: _S_fun (std :: forward < _Up > (__uref))) 
{ } 

reference_wrapper (const reference_wrapper &) = default ; 

reference_wrapper & 
operator = (const reference_wrapper &) = default ; 

operator _Tp & () const noexcept 
{ return this -> get () ; } 

_Tp & 
get () const noexcept 
{ return * _M_data ; } 

template < typename ... _Args > 
typename result_of < _Tp & (_Args && ...) > :: type 
operator () (_Args && ... __args) const 
{ 



return std :: __invoke (get () , std :: forward < _Args > (__args) ...) ; 
} 
} ;
# 349
template < typename _Tp > 
inline reference_wrapper < _Tp > 
ref (_Tp & __t) noexcept 
{ return reference_wrapper < _Tp > (__t) ; } 


template < typename _Tp > 
inline reference_wrapper < const _Tp > 
cref (const _Tp & __t) noexcept 
{ return reference_wrapper < const _Tp > (__t) ; } 

template < typename _Tp > 
void ref (const _Tp &&) = delete ; ;

template < typename _Tp > 
void cref (const _Tp &&) = delete ; ;


template < typename _Tp > 
inline reference_wrapper < _Tp > 
ref (reference_wrapper < _Tp > __t) noexcept 
{ return __t ; } 


template < typename _Tp > 
inline reference_wrapper < const _Tp > 
cref (reference_wrapper < _Tp > __t) noexcept 
{ return { __t . get () } ; } 




}
# 47 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
namespace std { 
# 56
class bad_function_call : public exception { 


public: virtual ~bad_function_call() noexcept; 

virtual const char *what() const noexcept; 
}; 
# 70
template < typename _Tp > 
struct __is_location_invariant 
: is_trivially_copyable < _Tp > :: type 
{ } ;

class _Undefined_class; 

union _Nocopy_types { 

void *_M_object; 
const void *_M_const_object; 
void (*_M_function_pointer)(void); 
void (_Undefined_class::*_M_member_pointer)(void); 
}; 

union [[gnu::may_alias]] _Any_data { 

void *_M_access() { return &((_M_pod_data)[0]); } 
const void *_M_access() const { return &((_M_pod_data)[0]); } 

template < typename _Tp > 
_Tp & 
_M_access () 
{ return * static_cast < _Tp * > (_M_access ()) ; } 

template < typename _Tp > 
const _Tp & 
_M_access () const 
{ return * static_cast < const _Tp * > (_M_access ()) ; } 

_Nocopy_types _M_unused; 
char _M_pod_data[sizeof(_Nocopy_types)]; 
}; 

enum _Manager_operation { 

__get_type_info, 
__get_functor_ptr, 
__clone_functor, 
__destroy_functor
}; 



template < typename _Tp > 
struct _Simple_type_wrapper 
{ 
_Simple_type_wrapper (_Tp __value) : __value (__value) { } 

_Tp __value ; 
} ;

template < typename _Tp > 
struct __is_location_invariant < _Simple_type_wrapper < _Tp > > 
: __is_location_invariant < _Tp > 
{ } ;

template < typename _Signature >
    class function;


class _Function_base { 


public: static const size_t _M_max_size = sizeof(_Nocopy_types); 
static const size_t _M_max_align = __alignof__(_Nocopy_types); 

template < typename _Functor > 
class _Base_manager 
{ 
protected : 
static const bool __stored_locally = 
(__is_location_invariant < _Functor > :: value 
&& sizeof (_Functor) <= _M_max_size 
&& __alignof__ (_Functor) <= _M_max_align 
&& (_M_max_align % __alignof__ (_Functor) == 0)) ; 

typedef integral_constant < bool , __stored_locally > _Local_storage ; 


static _Functor * 
_M_get_pointer (const _Any_data & __source) 
{ 
if (__stored_locally) 
{ 
const _Functor & __f = __source . _M_access < _Functor > () ; 
return const_cast < _Functor * > (std :: __addressof (__f)) ; 
} 
else 
return __source . _M_access < _Functor * > () ; 
} 



static void 
_M_clone (_Any_data & __dest , const _Any_data & __source , true_type) 
{ 
:: new (__dest . _M_access ()) _Functor (__source . _M_access < _Functor > ()) ; 
} 



static void 
_M_clone (_Any_data & __dest , const _Any_data & __source , false_type) 
{ 
__dest . _M_access < _Functor * > () = 
new _Functor (* __source . _M_access < const _Functor * > ()) ; 
} 



static void 
_M_destroy (_Any_data & __victim , true_type) 
{ 
__victim . _M_access < _Functor > () . ~ _Functor () ; 
} 


static void 
_M_destroy (_Any_data & __victim , false_type) 
{ 
delete __victim . _M_access < _Functor * > () ; 
} 

public : 
static bool 
_M_manager (_Any_data & __dest , const _Any_data & __source , 
_Manager_operation __op) 
{ 
switch (__op) 
{ 

case __get_type_info : 
__dest . _M_access < const type_info * > () = & typeid (_Functor) ; 
break ; 

case __get_functor_ptr : 
__dest . _M_access < _Functor * > () = _M_get_pointer (__source) ; 
break ; 

case __clone_functor : 
_M_clone (__dest , __source , _Local_storage ()) ; 
break ; 

case __destroy_functor : 
_M_destroy (__dest , _Local_storage ()) ; 
break ; 
} 
return false ; 
} 

static void 
_M_init_functor (_Any_data & __functor , _Functor && __f) 
{ _M_init_functor (__functor , std :: move (__f) , _Local_storage ()) ; } 

template < typename _Signature > 
static bool 
_M_not_empty_function (const function < _Signature > & __f) 
{ return static_cast < bool > (__f) ; } 

template < typename _Tp > 
static bool 
_M_not_empty_function (_Tp * __fp) 
{ return __fp != nullptr ; } 

template < typename _Class , typename _Tp > 
static bool 
_M_not_empty_function (_Tp _Class :: * __mp) 
{ return __mp != nullptr ; } 

template < typename _Tp > 
static bool 
_M_not_empty_function (const _Tp &) 
{ return true ; } 

private : 
static void 
_M_init_functor (_Any_data & __functor , _Functor && __f , true_type) 
{ :: new (__functor . _M_access ()) _Functor (std :: move (__f)) ; } 

static void 
_M_init_functor (_Any_data & __functor , _Functor && __f , false_type) 
{ __functor . _M_access < _Functor * > () = new _Functor (std :: move (__f)) ; } 
} ;

_Function_base() : _M_manager((nullptr)) { } 

~_Function_base() 
{ 
if (_M_manager) 
(_M_manager)(_M_functor, _M_functor, __destroy_functor);   
} 

bool _M_empty() const { return !_M_manager; } 

typedef bool (*_Manager_type)(_Any_data &, const _Any_data &, _Manager_operation); 


_Any_data _M_functor; 
_Manager_type _M_manager; 
}; 

template < typename _Signature, typename _Functor >
    class _Function_handler;

template < typename _Res , typename _Functor , typename ... _ArgTypes > 
class _Function_handler < _Res (_ArgTypes ...) , _Functor > 
: public _Function_base :: _Base_manager < _Functor > 
{ 
typedef _Function_base :: _Base_manager < _Functor > _Base ; 

public : 
static _Res 
_M_invoke (const _Any_data & __functor , _ArgTypes && ... __args) 
{ 
return (* _Base :: _M_get_pointer (__functor)) (
std :: forward < _ArgTypes > (__args) ...) ; 
} 
} ;

template < typename _Functor , typename ... _ArgTypes > 
class _Function_handler < void (_ArgTypes ...) , _Functor > 
: public _Function_base :: _Base_manager < _Functor > 
{ 
typedef _Function_base :: _Base_manager < _Functor > _Base ; 

public : 
static void 
_M_invoke (const _Any_data & __functor , _ArgTypes && ... __args) 
{ 
(* _Base :: _M_get_pointer (__functor)) (
std :: forward < _ArgTypes > (__args) ...) ; 
} 
} ;

template < typename _Class , typename _Member , typename _Res , 
typename ... _ArgTypes > 
class _Function_handler < _Res (_ArgTypes ...) , _Member _Class :: * > 
: public _Function_handler < void (_ArgTypes ...) , _Member _Class :: * > 
{ 
typedef _Function_handler < void (_ArgTypes ...) , _Member _Class :: * > 
_Base ; 

public : 
static _Res 
_M_invoke (const _Any_data & __functor , _ArgTypes && ... __args) 
{ 
return std :: __invoke (_Base :: _M_get_pointer (__functor) -> __value , 
std :: forward < _ArgTypes > (__args) ...) ; 
} 
} ;

template < typename _Class , typename _Member , typename ... _ArgTypes > 
class _Function_handler < void (_ArgTypes ...) , _Member _Class :: * > 
: public _Function_base :: _Base_manager < 
_Simple_type_wrapper < _Member _Class :: * > > 
{ 
typedef _Member _Class :: * _Functor ; 
typedef _Simple_type_wrapper < _Functor > _Wrapper ; 
typedef _Function_base :: _Base_manager < _Wrapper > _Base ; 

public : 
static bool 
_M_manager (_Any_data & __dest , const _Any_data & __source , 
_Manager_operation __op) 
{ 
switch (__op) 
{ 

case __get_type_info : 
__dest . _M_access < const type_info * > () = & typeid (_Functor) ; 
break ; 

case __get_functor_ptr : 
__dest . _M_access < _Functor * > () = 
& _Base :: _M_get_pointer (__source) -> __value ; 
break ; 

default : 
_Base :: _M_manager (__dest , __source , __op) ; 
} 
return false ; 
} 

static void 
_M_invoke (const _Any_data & __functor , _ArgTypes && ... __args) 
{ 
std :: __invoke (_Base :: _M_get_pointer (__functor) -> __value , 
std :: forward < _ArgTypes > (__args) ...) ; 
} 
} ;

template < typename _From, typename _To >
    using __check_func_return_type
      = __or_ < is_void < _To >, is_same < _From, _To >, is_convertible < _From, _To >>;
# 372
template < typename _Res , typename ... _ArgTypes > 
class function < _Res (_ArgTypes ...) > 
: public _Maybe_unary_or_binary_function < _Res , _ArgTypes ... > , 
private _Function_base 
{ 
template < typename _Func , 
typename _Res2 = typename result_of < _Func & (_ArgTypes ...) > :: type > 
struct _Callable : __check_func_return_type < _Res2 , _Res > { } ; 



template < typename _Tp > 
struct _Callable < function , _Tp > : false_type { } ; 

template < typename _Cond , typename _Tp > 
using _Requires = typename enable_if < _Cond :: value , _Tp > :: type ; 

public : 
typedef _Res result_type ; 
# 398
function () noexcept 
: _Function_base () { } 
# 405
function (nullptr_t) noexcept 
: _Function_base () { } 
# 416 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
function (const function & __x) ; 
# 425 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
function (function && __x) noexcept : _Function_base () 
{ 
__x . swap (* this) ; 
} 
# 446 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Functor , 
typename = _Requires < __not_ < is_same < _Functor , function > > , void > , 
typename = _Requires < _Callable < _Functor > , void > > 
function (_Functor) ; 
# 463 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
function & 
operator = (const function & __x) 
{ 
function (__x) . swap (* this) ; 
return * this ; 
} 
# 481 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
function & 
operator = (function && __x) noexcept 
{ 
function (std :: move (__x)) . swap (* this) ; 
return * this ; 
} 
# 495 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
function & 
operator = (nullptr_t) noexcept 
{ 
if (_M_manager) 
{ 
_M_manager (_M_functor , _M_functor , __destroy_functor) ; 
_M_manager = nullptr ; 
_M_invoker = nullptr ; 
} 
return * this ; 
} 
# 523 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Functor > 
_Requires < _Callable < typename decay < _Functor > :: type > , function & > 
operator = (_Functor && __f) 
{ 
function (std :: forward < _Functor > (__f)) . swap (* this) ; 
return * this ; 
} 


template < typename _Functor > 
function & 
operator = (reference_wrapper < _Functor > __f) noexcept 
{ 
function (__f) . swap (* this) ; 
return * this ; 
} 
# 549 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
void swap (function & __x) noexcept 
{ 
std :: swap (_M_functor , __x . _M_functor) ; 
std :: swap (_M_manager , __x . _M_manager) ; 
std :: swap (_M_invoker , __x . _M_invoker) ; 
} 
# 566 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
explicit operator bool () const noexcept 
{ return ! _M_empty () ; } 
# 579 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
_Res operator () (_ArgTypes ... __args) const ; 
# 592 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
const type_info & target_type () const noexcept ; 
# 605 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Functor > _Functor * target () noexcept ; 

template < typename _Functor > const _Functor * target () const noexcept ; 



private : 
using _Invoker_type = _Res (*) (const _Any_data & , _ArgTypes && ...) ; 
_Invoker_type _M_invoker ; 
} ;
# 654 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Res , typename ... _ArgTypes > 
function < _Res (_ArgTypes ...) > :: 
function (const function & __x) 
: _Function_base () 
{ 
if (static_cast < bool > (__x)) 
{ 
__x . _M_manager (_M_functor , __x . _M_functor , __clone_functor) ; 
_M_invoker = __x . _M_invoker ; 
_M_manager = __x . _M_manager ; 
} 
} 

template < typename _Res , typename ... _ArgTypes > 
template < typename _Functor , typename , typename > 
function < _Res (_ArgTypes ...) > :: 
function (_Functor __f) 
: _Function_base () 
{ 
typedef _Function_handler < _Res (_ArgTypes ...) , _Functor > _My_handler ; 

if (_My_handler :: _M_not_empty_function (__f)) 
{ 
_My_handler :: _M_init_functor (_M_functor , std :: move (__f)) ; 
_M_invoker = & _My_handler :: _M_invoke ; 
_M_manager = & _My_handler :: _M_manager ; 
} 
} 

template < typename _Res , typename ... _ArgTypes > 
_Res 
function < _Res (_ArgTypes ...) > :: 
operator () (_ArgTypes ... __args) const 
{ 
if (_M_empty ()) 
__throw_bad_function_call () ; 
return _M_invoker (_M_functor , std :: forward < _ArgTypes > (__args) ...) ; 
} 


template < typename _Res , typename ... _ArgTypes > 
const type_info & 
function < _Res (_ArgTypes ...) > :: 
target_type () const noexcept 
{ 
if (_M_manager) 
{ 
_Any_data __typeinfo_result ; 
_M_manager (__typeinfo_result , _M_functor , __get_type_info) ; 
return * __typeinfo_result . _M_access < const type_info * > () ; 
} 
else 
return typeid (void) ; 
} 

template < typename _Res , typename ... _ArgTypes > 
template < typename _Functor > 
_Functor * 
function < _Res (_ArgTypes ...) > :: 
target () noexcept 
{ 
const function * __const_this = this ; 
const _Functor * __func = __const_this -> template target < _Functor > () ; 
return const_cast < _Functor * > (__func) ; 
} 

template < typename _Res , typename ... _ArgTypes > 
template < typename _Functor > 
const _Functor * 
function < _Res (_ArgTypes ...) > :: 
target () const noexcept 
{ 
if (typeid (_Functor) == target_type () && _M_manager) 
{ 
_Any_data __ptr ; 
_M_manager (__ptr , _M_functor , __get_functor_ptr) ; 
return __ptr . _M_access < const _Functor * > () ; 
} 
else 
return nullptr ; 
} 
# 746 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Res , typename ... _Args > 
inline bool 
operator == (const function < _Res (_Args ...) > & __f , nullptr_t) noexcept 
{ return ! static_cast < bool > (__f) ; } 


template < typename _Res , typename ... _Args > 
inline bool 
operator == (nullptr_t , const function < _Res (_Args ...) > & __f) noexcept 
{ return ! static_cast < bool > (__f) ; } 
# 764 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Res , typename ... _Args > 
inline bool 
operator != (const function < _Res (_Args ...) > & __f , nullptr_t) noexcept 
{ return static_cast < bool > (__f) ; } 


template < typename _Res , typename ... _Args > 
inline bool 
operator != (nullptr_t , const function < _Res (_Args ...) > & __f) noexcept 
{ return static_cast < bool > (__f) ; } 
# 785 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
template < typename _Res , typename ... _Args > 
inline void 
swap (function < _Res (_Args ...) > & __x , function < _Res (_Args ...) > & __y) noexcept 
{ __x . swap (__y) ; } 
# 805 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\std_function.h" 3
}
# 68 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
namespace std { 
# 86 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename _MemFunPtr , 
bool __is_mem_fn = is_member_function_pointer < _MemFunPtr > :: value > 
class _Mem_fn_base 
: public _Mem_fn_traits < _MemFunPtr > :: __maybe_type 
{ 
using _Traits = _Mem_fn_traits < _MemFunPtr > ; 

using _Arity = typename _Traits :: __arity ; 
using _Varargs = typename _Traits :: __vararg ; 

template < typename _Func , typename ... _BoundArgs > 
friend struct _Bind_check_arity ; 

_MemFunPtr _M_pmf ; 

public : 

using result_type = typename _Traits :: __result_type ; 

explicit constexpr 
_Mem_fn_base (_MemFunPtr __pmf) noexcept : _M_pmf (__pmf) { } 

template < typename ... _Args > 
auto 
operator () (_Args && ... __args) const 
noexcept (noexcept (
std :: __invoke (_M_pmf , std :: forward < _Args > (__args) ...))) 
-> decltype (std :: __invoke (_M_pmf , std :: forward < _Args > (__args) ...)) 
{ return std :: __invoke (_M_pmf , std :: forward < _Args > (__args) ...) ; } 
} ;


template < typename _MemObjPtr > 
class _Mem_fn_base < _MemObjPtr , false > 
{ 
using _Arity = integral_constant < size_t , 0 > ; 
using _Varargs = false_type ; 

template < typename _Func , typename ... _BoundArgs > 
friend struct _Bind_check_arity ; 

_MemObjPtr _M_pm ; 

public : 
explicit constexpr 
_Mem_fn_base (_MemObjPtr __pm) noexcept : _M_pm (__pm) { } 

template < typename _Tp > 
auto 
operator () (_Tp && __obj) const 
noexcept (noexcept (std :: __invoke (_M_pm , std :: forward < _Tp > (__obj)))) 
-> decltype (std :: __invoke (_M_pm , std :: forward < _Tp > (__obj))) 
{ return std :: __invoke (_M_pm , std :: forward < _Tp > (__obj)) ; } 
} ;

template < typename _MemberPointer >
    struct _Mem_fn;

template < typename _Res , typename _Class > 
struct _Mem_fn < _Res _Class :: * > 
: _Mem_fn_base < _Res _Class :: * > 
{ 
using _Mem_fn_base < _Res _Class :: * > :: _Mem_fn_base ; 
} ;
# 158 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename _Tp , typename _Class > 
inline _Mem_fn < _Tp _Class :: * > 
mem_fn (_Tp _Class :: * __pm) noexcept 
{ 
return _Mem_fn < _Tp _Class :: * > (__pm) ; 
} 
# 173 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename _Tp > 
struct is_bind_expression 
: public false_type { } ;
# 184 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename _Tp > 
struct is_placeholder 
: public integral_constant < int , 0 > 
{ } ;
# 199 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < int _Num > struct _Placeholder { } ;
# 205
namespace placeholders { 
# 211
extern const _Placeholder< 1>  _1; 
extern const _Placeholder< 2>  _2; 
extern const _Placeholder< 3>  _3; 
extern const _Placeholder< 4>  _4; 
extern const _Placeholder< 5>  _5; 
extern const _Placeholder< 6>  _6; 
extern const _Placeholder< 7>  _7; 
extern const _Placeholder< 8>  _8; 
extern const _Placeholder< 9>  _9; 
extern const _Placeholder< 10>  _10; 
extern const _Placeholder< 11>  _11; 
extern const _Placeholder< 12>  _12; 
extern const _Placeholder< 13>  _13; 
extern const _Placeholder< 14>  _14; 
extern const _Placeholder< 15>  _15; 
extern const _Placeholder< 16>  _16; 
extern const _Placeholder< 17>  _17; 
extern const _Placeholder< 18>  _18; 
extern const _Placeholder< 19>  _19; 
extern const _Placeholder< 20>  _20; 
extern const _Placeholder< 21>  _21; 
extern const _Placeholder< 22>  _22; 
extern const _Placeholder< 23>  _23; 
extern const _Placeholder< 24>  _24; 
extern const _Placeholder< 25>  _25; 
extern const _Placeholder< 26>  _26; 
extern const _Placeholder< 27>  _27; 
extern const _Placeholder< 28>  _28; 
extern const _Placeholder< 29>  _29; 
}
# 247
template < int _Num > 
struct is_placeholder < _Placeholder < _Num > > 
: public integral_constant < int , _Num > 
{ } ;

template < int _Num > 
struct is_placeholder < const _Placeholder < _Num > > 
: public integral_constant < int , _Num > 
{ } ;



template < std :: size_t __i, typename _Tuple >
    using _Safe_tuple_element_t
      = typename enable_if < ( __i < tuple_size < _Tuple > :: value ),
      tuple_element < __i, _Tuple >> :: type :: type;
# 275 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename _Arg,
    bool _IsBindExp = is_bind_expression < _Arg > :: value,
    bool _IsPlaceholder = ( is_placeholder < _Arg > :: value > 0 ) >
    class _Mu;
# 285
template < typename _Tp > 
class _Mu < reference_wrapper < _Tp > , false , false > 
{ 
public : 




template < typename _CVRef , typename _Tuple > 
_Tp & 
operator () (_CVRef & __arg , _Tuple &) const volatile 
{ return __arg . get () ; } 
} ;
# 305
template < typename _Arg > 
class _Mu < _Arg , true , false > 
{ 
public : 
template < typename _CVArg , typename ... _Args > 
auto 
operator () (_CVArg & __arg , 
tuple < _Args ... > & __tuple) const volatile 
-> decltype (__arg (declval < _Args > () ...)) 
{ 

typedef typename _Build_index_tuple < sizeof ... (_Args) > :: __type 
_Indexes ; 
return this -> __call (__arg , __tuple , _Indexes ()) ; 
} 

private : 


template < typename _CVArg , typename ... _Args , std :: size_t ... _Indexes > 
auto 
__call (_CVArg & __arg , tuple < _Args ... > & __tuple , 
const _Index_tuple < _Indexes ... > &) const volatile 
-> decltype (__arg (declval < _Args > () ...)) 
{ 
return __arg (std :: get < _Indexes > (std :: move (__tuple)) ...) ; 
} 
} ;
# 339
template < typename _Arg > 
class _Mu < _Arg , false , true > 
{ 
public : 
template < typename _Tuple > 
_Safe_tuple_element_t < (is_placeholder < _Arg > :: value - 1) , _Tuple > && 
operator () (const volatile _Arg & , _Tuple & __tuple) const volatile 
{ 
return 
:: std :: get < (is_placeholder < _Arg > :: value - 1) > (std :: move (__tuple)) ; 
} 
} ;
# 357
template < typename _Arg > 
class _Mu < _Arg , false , false > 
{ 
public : 
template < typename _CVArg , typename _Tuple > 
_CVArg && 
operator () (_CVArg && __arg , _Tuple &) const volatile 
{ return std :: forward < _CVArg > (__arg) ; } 
} ;


template < std :: size_t _Ind , typename ... _Tp > 
inline auto 
__volget (volatile tuple < _Tp ... > & __tuple) 
-> __tuple_element_t < _Ind , tuple < _Tp ... > > volatile & 
{ return std :: get < _Ind > (const_cast < tuple < _Tp ... > & > (__tuple)) ; } 


template < std :: size_t _Ind , typename ... _Tp > 
inline auto 
__volget (const volatile tuple < _Tp ... > & __tuple) 
-> __tuple_element_t < _Ind , tuple < _Tp ... > > const volatile & 
{ return std :: get < _Ind > (const_cast < const tuple < _Tp ... > & > (__tuple)) ; } 


template < typename _Signature >
    struct _Bind;

template < typename _Functor , typename ... _Bound_args > 
class _Bind < _Functor (_Bound_args ...) > 
: public _Weak_result_type < _Functor > 
{ 
typedef typename _Build_index_tuple < sizeof ... (_Bound_args) > :: __type 
_Bound_indexes ; 

_Functor _M_f ; 
tuple < _Bound_args ... > _M_bound_args ; 


template < typename _Result , typename ... _Args , std :: size_t ... _Indexes > 
_Result 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) 
{ 
return std :: __invoke (_M_f , 
_Mu < _Bound_args > () (std :: get < _Indexes > (_M_bound_args) , __args) ...
) ; 
} 


template < typename _Result , typename ... _Args , std :: size_t ... _Indexes > 
_Result 
__call_c (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) const 
{ 
return std :: __invoke (_M_f , 
_Mu < _Bound_args > () (std :: get < _Indexes > (_M_bound_args) , __args) ...
) ; 
} 


template < typename _Result , typename ... _Args , std :: size_t ... _Indexes > 
_Result 
__call_v (tuple < _Args ... > && __args , 
_Index_tuple < _Indexes ... >) volatile 
{ 
return std :: __invoke (_M_f , 
_Mu < _Bound_args > () (__volget < _Indexes > (_M_bound_args) , __args) ...
) ; 
} 


template < typename _Result , typename ... _Args , std :: size_t ... _Indexes > 
_Result 
__call_c_v (tuple < _Args ... > && __args , 
_Index_tuple < _Indexes ... >) const volatile 
{ 
return std :: __invoke (_M_f , 
_Mu < _Bound_args > () (__volget < _Indexes > (_M_bound_args) , __args) ...
) ; 
} 

template < typename _BoundArg , typename _CallArgs > 
using _Mu_type = decltype (
_Mu < typename remove_cv < _BoundArg > :: type > () (
std :: declval < _BoundArg & > () , std :: declval < _CallArgs & > ())) ; 

template < typename _Fn , typename _CallArgs , typename ... _BArgs > 
using _Res_type_impl 
= typename result_of < _Fn & (_Mu_type < _BArgs , _CallArgs > && ...) > :: type ; 

template < typename _CallArgs > 
using _Res_type = _Res_type_impl < _Functor , _CallArgs , _Bound_args ... > ; 

template < typename _CallArgs > 
using __dependent = typename 
enable_if < bool (tuple_size < _CallArgs > :: value + 1) , _Functor > :: type ; 

template < typename _CallArgs , template < class > class __cv_quals > 
using _Res_type_cv = _Res_type_impl < 
typename __cv_quals < __dependent < _CallArgs > > :: type , 
_CallArgs , 
typename __cv_quals < _Bound_args > :: type ... > ; 

public : 
template < typename ... _Args > 
explicit _Bind (const _Functor & __f , _Args && ... __args) 
: _M_f (__f) , _M_bound_args (std :: forward < _Args > (__args) ...) 
{ } 

template < typename ... _Args > 
explicit _Bind (_Functor && __f , _Args && ... __args) 
: _M_f (std :: move (__f)) , _M_bound_args (std :: forward < _Args > (__args) ...) 
{ } 

_Bind (const _Bind &) = default ; 

_Bind (_Bind && __b) 
: _M_f (std :: move (__b . _M_f)) , _M_bound_args (std :: move (__b . _M_bound_args)) 
{ } 


template < typename ... _Args , 
typename _Result = _Res_type < tuple < _Args ... > > > 
_Result 
operator () (_Args && ... __args) 
{ 
return this -> __call < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 


template < typename ... _Args , 
typename _Result = _Res_type_cv < tuple < _Args ... > , add_const > > 
_Result 
operator () (_Args && ... __args) const 
{ 
return this -> __call_c < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 
# 505 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
template < typename ... _Args , 
typename _Result = _Res_type_cv < tuple < _Args ... > , add_volatile > > 

_Result 
operator () (_Args && ... __args) volatile 
{ 
return this -> __call_v < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 


template < typename ... _Args , 
typename _Result = _Res_type_cv < tuple < _Args ... > , add_cv > > 

_Result 
operator () (_Args && ... __args) const volatile 
{ 
return this -> __call_c_v < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 
} ;


template < typename _Result, typename _Signature >
    struct _Bind_result;

template < typename _Result , typename _Functor , typename ... _Bound_args > 
class _Bind_result < _Result , _Functor (_Bound_args ...) > 
{ 
typedef typename _Build_index_tuple < sizeof ... (_Bound_args) > :: __type 
_Bound_indexes ; 

_Functor _M_f ; 
tuple < _Bound_args ... > _M_bound_args ; 


template < typename _Res > 
using __enable_if_void 
= typename enable_if < is_void < _Res > { } > :: type ; 

template < typename _Res > 
using __disable_if_void 
= typename enable_if < ! is_void < _Res > { } , _Result > :: type ; 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__disable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) 
{ 
return std :: __invoke (_M_f , _Mu < _Bound_args > () 
(std :: get < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__enable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) 
{ 
std :: __invoke (_M_f , _Mu < _Bound_args > () 
(std :: get < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__disable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) const 
{ 
return std :: __invoke (_M_f , _Mu < _Bound_args > () 
(std :: get < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__enable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) const 
{ 
std :: __invoke (_M_f , _Mu < _Bound_args > () 
(std :: get < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__disable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) volatile 
{ 
return std :: __invoke (_M_f , _Mu < _Bound_args > () 
(__volget < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__enable_if_void < _Res > 
__call (tuple < _Args ... > && __args , _Index_tuple < _Indexes ... >) volatile 
{ 
std :: __invoke (_M_f , _Mu < _Bound_args > () 
(__volget < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__disable_if_void < _Res > 
__call (tuple < _Args ... > && __args , 
_Index_tuple < _Indexes ... >) const volatile 
{ 
return std :: __invoke (_M_f , _Mu < _Bound_args > () 
(__volget < _Indexes > (_M_bound_args) , __args) ...) ; 
} 


template < typename _Res , typename ... _Args , std :: size_t ... _Indexes > 
__enable_if_void < _Res > 
__call (tuple < _Args ... > && __args , 
_Index_tuple < _Indexes ... >) const volatile 
{ 
std :: __invoke (_M_f , _Mu < _Bound_args > () 
(__volget < _Indexes > (_M_bound_args) , __args) ...) ; 
} 

public : 
typedef _Result result_type ; 

template < typename ... _Args > 
explicit _Bind_result (const _Functor & __f , _Args && ... __args) 
: _M_f (__f) , _M_bound_args (std :: forward < _Args > (__args) ...) 
{ } 

template < typename ... _Args > 
explicit _Bind_result (_Functor && __f , _Args && ... __args) 
: _M_f (std :: move (__f)) , _M_bound_args (std :: forward < _Args > (__args) ...) 
{ } 

_Bind_result (const _Bind_result &) = default ; 

_Bind_result (_Bind_result && __b) 
: _M_f (std :: move (__b . _M_f)) , _M_bound_args (std :: move (__b . _M_bound_args)) 
{ } 


template < typename ... _Args > 
result_type 
operator () (_Args && ... __args) 
{ 
return this -> __call < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 


template < typename ... _Args > 
result_type 
operator () (_Args && ... __args) const 
{ 
return this -> __call < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 


template < typename ... _Args > 

result_type 
operator () (_Args && ... __args) volatile 
{ 
return this -> __call < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 


template < typename ... _Args > 

result_type 
operator () (_Args && ... __args) const volatile 
{ 
return this -> __call < _Result > (
std :: forward_as_tuple (std :: forward < _Args > (__args) ...) , 
_Bound_indexes ()) ; 
} 
} ;
# 692
template < typename _Signature > 
struct is_bind_expression < _Bind < _Signature > > 
: public true_type { } ;
# 700
template < typename _Signature > 
struct is_bind_expression < const _Bind < _Signature > > 
: public true_type { } ;
# 708
template < typename _Signature > 
struct is_bind_expression < volatile _Bind < _Signature > > 
: public true_type { } ;
# 716
template < typename _Signature > 
struct is_bind_expression < const volatile _Bind < _Signature > > 
: public true_type { } ;
# 724
template < typename _Result , typename _Signature > 
struct is_bind_expression < _Bind_result < _Result , _Signature > > 
: public true_type { } ;
# 732
template < typename _Result , typename _Signature > 
struct is_bind_expression < const _Bind_result < _Result , _Signature > > 
: public true_type { } ;
# 740
template < typename _Result , typename _Signature > 
struct is_bind_expression < volatile _Bind_result < _Result , _Signature > > 
: public true_type { } ;
# 748
template < typename _Result , typename _Signature > 
struct is_bind_expression < const volatile _Bind_result < _Result , _Signature > > 
: public true_type { } ;

template < typename _Func , typename ... _BoundArgs > 
struct _Bind_check_arity { } ;

template < typename _Ret , typename ... _Args , typename ... _BoundArgs > 
struct _Bind_check_arity < _Ret (*) (_Args ...) , _BoundArgs ... > 
{ 
static_assert (sizeof ... (_BoundArgs) == sizeof ... (_Args) , 
"Wrong number of arguments for function") ; 
} ;

template < typename _Ret , typename ... _Args , typename ... _BoundArgs > 
struct _Bind_check_arity < _Ret (*) (_Args ... ...) , _BoundArgs ... > 
{ 
static_assert (sizeof ... (_BoundArgs) >= sizeof ... (_Args) , 
"Wrong number of arguments for function") ; 
} ;

template < typename _Tp , typename _Class , typename ... _BoundArgs > 
struct _Bind_check_arity < _Tp _Class :: * , _BoundArgs ... > 
{ 
using _Arity = typename _Mem_fn < _Tp _Class :: * > :: _Arity ; 
using _Varargs = typename _Mem_fn < _Tp _Class :: * > :: _Varargs ; 
static_assert (_Varargs :: value 
? sizeof ... (_BoundArgs) >= _Arity :: value + 1 
: sizeof ... (_BoundArgs) == _Arity :: value + 1 , 
"Wrong number of arguments for pointer-to-member") ; 
} ;




template < typename _Tp, typename _Tp2 = typename decay < _Tp > :: type >
    using __is_socketlike = __or_ < is_integral < _Tp2 >, is_enum < _Tp2 >>;

template < bool _SocketLike , typename _Func , typename ... _BoundArgs > 
struct _Bind_helper 
: _Bind_check_arity < typename decay < _Func > :: type , _BoundArgs ... > 
{ 
typedef typename decay < _Func > :: type __func_type ; 
typedef _Bind < __func_type (typename decay < _BoundArgs > :: type ...) > type ; 
} ;




template < typename _Func , typename ... _BoundArgs > 
struct _Bind_helper < true , _Func , _BoundArgs ... > 
{ } ;
# 805
template < typename _Func , typename ... _BoundArgs > 
inline typename 
_Bind_helper < __is_socketlike < _Func > :: value , _Func , _BoundArgs ... > :: type 
bind (_Func && __f , _BoundArgs && ... __args) 
{ 
typedef _Bind_helper < false , _Func , _BoundArgs ... > __helper_type ; 
return typename __helper_type :: type (std :: forward < _Func > (__f) , 
std :: forward < _BoundArgs > (__args) ...) ; 
} 

template < typename _Result , typename _Func , typename ... _BoundArgs > 
struct _Bindres_helper 
: _Bind_check_arity < typename decay < _Func > :: type , _BoundArgs ... > 
{ 
typedef typename decay < _Func > :: type __functor_type ; 
typedef _Bind_result < _Result , 
__functor_type (typename decay < _BoundArgs > :: type ...) > 
type ; 
} ;
# 829
template < typename _Result , typename _Func , typename ... _BoundArgs > 
inline 
typename _Bindres_helper < _Result , _Func , _BoundArgs ... > :: type 
bind (_Func && __f , _BoundArgs && ... __args) 
{ 
typedef _Bindres_helper < _Result , _Func , _BoundArgs ... > __helper_type ; 
return typename __helper_type :: type (std :: forward < _Func > (__f) , 
std :: forward < _BoundArgs > (__args) ...) ; 
} 
# 1294 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\functional" 3
}
# 122 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
namespace testing { 



namespace internal2 { 



__attribute((visibility("default"))) void PrintBytesInObjectTo(const unsigned char * obj_bytes, size_t count, std::ostream * os); 
# 136
enum TypeKind { 
kProtobuf, 
kConvertibleToInteger, 
# 144
kOtherType
}; 
# 151
template < typename T , TypeKind kTypeKind > 
class TypeWithoutFormatter { 
public : 

static void PrintValue (const T & value , :: std :: ostream * os) { 
PrintBytesInObjectTo (static_cast < const unsigned char * > (
reinterpret_cast < const void * > (& value)) , 
sizeof (value) , os) ; 
} 
} ;




const size_t kProtobufOneLinerMaxLength = (50); 

template < typename T > 
class TypeWithoutFormatter < T , kProtobuf > { 
public : 
static void PrintValue (const T & value , :: std :: ostream * os) { 
std :: string pretty_str = value . ShortDebugString () ; 
if (pretty_str . length () > kProtobufOneLinerMaxLength) { 
pretty_str = "\n" + value . DebugString () ; 
} 
* os << ("<" + pretty_str + ">") ; 
} 
} ;

template < typename T > 
class TypeWithoutFormatter < T , kConvertibleToInteger > { 
public : 
# 189
static void PrintValue (const T & value , :: std :: ostream * os) { 
const internal :: BiggestInt kBigInt = value ; 
* os << kBigInt ; 
} 
} ;
# 232 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename Char , typename CharTraits , typename T > 
:: std :: basic_ostream < Char , CharTraits > & operator << (
:: std :: basic_ostream < Char , CharTraits > & os , const T & x) { 
TypeWithoutFormatter < T , (internal :: IsAProtocolMessage < T > :: value 
? kProtobuf 
: internal :: ImplicitlyConvertible < 
const T & , internal :: BiggestInt > :: value 
? kConvertibleToInteger 
: 
# 247
kOtherType) > :: PrintValue (x , & os) ; 
return os ; 
} 

}
}



namespace testing_internal { 



template < typename T > 
void DefaultPrintNonContainerTo (const T & value , :: std :: ostream * os) { 
# 273 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
using namespace :: testing :: internal2 ; 
# 288 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
* os << value ; 
} 

}

namespace testing { 
namespace internal { 
# 311 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename ToPrint , typename OtherOperand > 
class FormatForComparison { 
public : 
static :: std :: string Format (const ToPrint & value) { 
return :: testing :: PrintToString (value) ; 
} 
} ;


template < typename ToPrint , size_t N , typename OtherOperand > 
class FormatForComparison < ToPrint [ N ] , OtherOperand > { 
public : 
static :: std :: string Format (const ToPrint * value) { 
return FormatForComparison < const ToPrint * , OtherOperand > :: Format (value) ; 
} 
} ;
# 340 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename OtherOperand > class FormatForComparison < char * , OtherOperand > { public : static :: std :: string Format (char * value) { return :: testing :: PrintToString (static_cast < const void * > (value)) ; } } ;
template < typename OtherOperand > class FormatForComparison < const char * , OtherOperand > { public : static :: std :: string Format (const char * value) { return :: testing :: PrintToString (static_cast < const void * > (value)) ; } } ;
template < typename OtherOperand > class FormatForComparison < wchar_t * , OtherOperand > { public : static :: std :: string Format (wchar_t * value) { return :: testing :: PrintToString (static_cast < const void * > (value)) ; } } ;
template < typename OtherOperand > class FormatForComparison < const wchar_t * , OtherOperand > { public : static :: std :: string Format (const wchar_t * value) { return :: testing :: PrintToString (static_cast < const void * > (value)) ; } } ;
# 359 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template<> class FormatForComparison< char *, std::__cxx11::basic_string< char> >  { public: static std::string Format(char *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(132 + 0 + 1U - 1);return ::testing::PrintToString(value); } }; 
template<> class FormatForComparison< const char *, std::__cxx11::basic_string< char> >  { public: static std::string Format(const char *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(133 + 0 + 1U - 1);return ::testing::PrintToString(value); } }; 
# 373 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template<> class FormatForComparison< wchar_t *, std::__cxx11::basic_string< wchar_t> >  { public: static std::string Format(wchar_t *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(134 + 0 + 1U - 1);return ::testing::PrintToString(value); } }; 
template<> class FormatForComparison< const wchar_t *, std::__cxx11::basic_string< wchar_t> >  { public: static std::string Format(const wchar_t *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(135 + 0 + 1U - 1);return ::testing::PrintToString(value); } }; 
# 387 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename T1 , typename T2 > 
std :: string FormatForComparisonFailureMessage (
const T1 & value , const T2 &) { 
return FormatForComparison < T1 , T2 > :: Format (value) ; 
} 
# 400 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename T >
class UniversalPrinter;

template < typename T >
void UniversalPrint ( const T & value, :: std :: ostream * os );

enum DefaultPrinterType { 
kPrintContainer, 
kPrintPointer, 
kPrintFunctionPointer, 
kPrintOther
}; 
template < DefaultPrinterType type > struct WrapPrinterType { } ;



template < typename C > 
void DefaultPrintTo (WrapPrinterType < kPrintContainer > , 
const C & container , :: std :: ostream * os) { 
const size_t kMaxCount = 32 ; 
* os << '{' ; 
size_t count = 0 ; 
for (typename C :: const_iterator it = container . begin () ; 
it != container . end () ; ++ it , ++ count) { 
if (count > 0) { 
* os << ',' ; 
if (count == kMaxCount) { 
* os << " ..." ; 
break ; 
} 
} 
* os << ' ' ; 


internal :: UniversalPrint (* it , os) ; 
} 

if (count > 0) { 
* os << ' ' ; 
} 
* os << '}' ; 
} 
# 449
template < typename T > 
void DefaultPrintTo (WrapPrinterType < kPrintPointer > , 
T * p , :: std :: ostream * os) { 
if (p == nullptr) { 
* os << "NULL" ; 
} else { 



* os << p ; 
} 
} 
template < typename T > 
void DefaultPrintTo (WrapPrinterType < kPrintFunctionPointer > , 
T * p , :: std :: ostream * os) { 
if (p == nullptr) { 
* os << "NULL" ; 
} else { 



* os << reinterpret_cast < const void * > (p) ; 
} 
} 



template < typename T > 
void DefaultPrintTo (WrapPrinterType < kPrintOther > , 
const T & value , :: std :: ostream * os) { 
:: testing_internal :: DefaultPrintNonContainerTo (value , os) ; 
} 
# 493 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename T > 
void PrintTo (const T & value , :: std :: ostream * os) { 
# 514 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
DefaultPrintTo (
WrapPrinterType < 
(sizeof (IsContainerTest < T > (0)) == sizeof (IsContainer)) && 
! IsRecursiveContainer < T > :: value 
? kPrintContainer 
: ! is_pointer < T > :: value 
? kPrintOther 
: std :: is_function < typename std :: remove_pointer < T > :: type > :: value 
? kPrintFunctionPointer 
: kPrintPointer > () , 
value , os) ; 
} 
# 532
__attribute((visibility("default"))) void PrintTo(unsigned char c, std::ostream * os); 
__attribute((visibility("default"))) void PrintTo(signed char c, std::ostream * os); 
inline void PrintTo(char c, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(136 + 0 + 1U - 1);



PrintTo(static_cast< unsigned char>(c), os); 
} 


inline void PrintTo(bool x, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(137 + 0 + 1U - 1);
(*os << (x ? "true" : ("false"))); 
} 
# 553 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
__attribute((visibility("default"))) void PrintTo(wchar_t wc, std::ostream * os); 


__attribute((visibility("default"))) void PrintTo(const char * s, std::ostream * os); 
inline void PrintTo(char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(138 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const char *> (s), os); 
} 



inline void PrintTo(const signed char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(139 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const void *> (s), os); 
} 
inline void PrintTo(signed char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(140 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const void *> (s), os); 
} 
inline void PrintTo(const unsigned char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(141 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const void *> (s), os); 
} 
inline void PrintTo(unsigned char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(142 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const void *> (s), os); 
} 
# 583 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
__attribute((visibility("default"))) void PrintTo(const wchar_t * s, std::ostream * os); 
inline void PrintTo(wchar_t *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(143 + 0 + 1U - 1);
PrintTo(ImplicitCast_< const wchar_t *> (s), os); 
} 
# 594
template < typename T > 
void PrintRawArrayTo (const T a [ ] , size_t count , :: std :: ostream * os) { 
UniversalPrint (a [ 0 ] , os) ; 
for (size_t i = 1 ; i != count ; i ++) { 
* os << ", " ; 
UniversalPrint (a [ i ] , os) ; 
} 
} 
# 611 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
__attribute((visibility("default"))) void PrintStringTo(const std::string & s, std::ostream * os); 
inline void PrintTo(const std::string &s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(144 + 0 + 1U - 1);
PrintStringTo(s, os); 
} 
# 625 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
__attribute((visibility("default"))) void PrintWideStringTo(const std::wstring & s, std::ostream * os); 
inline void PrintTo(const std::wstring &s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(145 + 0 + 1U - 1);
PrintWideStringTo(s, os); 
} 
# 638 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
inline void PrintTo(std::nullptr_t, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(146 + 0 + 1U - 1);(*os << ("(nullptr)")); } 

template < typename T > 
void PrintTo (std :: reference_wrapper < T > ref , :: std :: ostream * os) { 

PrintTo (ref . get () , os) ; 
} 




template < typename T >
void PrintTupleTo ( const T & t, :: std :: ostream * os );
# 662 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
inline void PrintTo(const std::tr1::tuple< >  &t, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(147 + 0 + 1U - 1);
PrintTupleTo(t, os); 
} 

template < typename T1 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 > & t , :: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 > & t , :: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 > & t , :: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 > & t , :: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 , T6 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
void PrintTo (const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
void PrintTo (
const :: std :: tr1 :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > & t , 
:: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 



template < typename ... Types > 
void PrintTo (const :: std :: tuple < Types ... > & t , :: std :: ostream * os) { 
PrintTupleTo (t , os) ; 
} 



template < typename T1 , typename T2 > 
void PrintTo (const :: std :: pair < T1 , T2 > & value , :: std :: ostream * os) { 
* os << '(' ; 


UniversalPrinter < T1 > :: Print (value . first , os) ; 
* os << ", " ; 
UniversalPrinter < T2 > :: Print (value . second , os) ; 
* os << ')' ; 
} 



template < typename T > 
class UniversalPrinter { 
public : 
# 760
static void Print (const T & value , :: std :: ostream * os) { 
# 769 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
PrintTo (value , os) ; 
} 


} ;
# 819 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename T > 
void UniversalPrintArray (const T * begin , size_t len , :: std :: ostream * os) { 
if (len == 0) { 
* os << "{}" ; 
} else { 
* os << "{ " ; 
const size_t kThreshold = 18 ; 
const size_t kChunkSize = 8 ; 




if (len <= kThreshold) { 
PrintRawArrayTo (begin , len , os) ; 
} else { 
PrintRawArrayTo (begin , kChunkSize , os) ; 
* os << ", ..., " ; 
PrintRawArrayTo (begin + len - kChunkSize , kChunkSize , os) ; 
} 
* os << " }" ; 
} 
} 

__attribute((visibility("default"))) void UniversalPrintArray(const char * begin, size_t len, std::ostream * os); 



__attribute((visibility("default"))) void UniversalPrintArray(const wchar_t * begin, size_t len, std::ostream * os); 



template < typename T , size_t N > 
class UniversalPrinter < T [ N ] > { 
public : 


static void Print (const T (& a) [ N ] , :: std :: ostream * os) { 
UniversalPrintArray (a , N , os) ; 
} 
} ;


template < typename T > 
class UniversalPrinter < T & > { 
public : 




static void Print (const T & value , :: std :: ostream * os) { 


* os << "@" << reinterpret_cast < const void * > (& value) << " " ; 


UniversalPrint (value , os) ; 
} 


} ;
# 884
template < typename T > 
class UniversalTersePrinter { 
public : 
static void Print (const T & value , :: std :: ostream * os) { 
UniversalPrint (value , os) ; 
} 
} ;
template < typename T > 
class UniversalTersePrinter < T & > { 
public : 
static void Print (const T & value , :: std :: ostream * os) { 
UniversalPrint (value , os) ; 
} 
} ;
template < typename T , size_t N > 
class UniversalTersePrinter < T [ N ] > { 
public : 
static void Print (const T (& value) [ N ] , :: std :: ostream * os) { 
UniversalPrinter < T [ N ] > :: Print (value , os) ; 
} 
} ;

template<> class UniversalTersePrinter< const char *>  { 

public: static void Print(const char *str, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(148 + 0 + 1U - 1), str == (nullptr))) { cpptestFastCoverageStmt(148 + 0 + 2U - 1);
(*os << ("NULL")); 
} else { cpptestFastCoverageStmt(148 + 0 + 3U - 1);
UniversalPrint(((std::__cxx11::basic_string< char> )(str)), os); 
}  
} 
}; 

template<> class UniversalTersePrinter< char *>  { 

public: static void Print(char *str, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(151 + 0 + 1U - 1);
UniversalTersePrinter< const char *> ::Print(str, os); 
} 
}; 



template<> class UniversalTersePrinter< const wchar_t *>  { 

public: static void Print(const wchar_t *str, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(152 + 0 + 1U - 1), str == (nullptr))) { cpptestFastCoverageStmt(152 + 0 + 2U - 1);
(*os << ("NULL")); 
} else { cpptestFastCoverageStmt(152 + 0 + 3U - 1);
UniversalPrint(((std::__cxx11::basic_string< wchar_t> )(str)), os); 
}  
} 
}; 



template<> class UniversalTersePrinter< wchar_t *>  { 

public: static void Print(wchar_t *str, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(155 + 0 + 1U - 1);
UniversalTersePrinter< const wchar_t *> ::Print(str, os); 
} 
}; 

template < typename T > 
void UniversalTersePrint (const T & value , :: std :: ostream * os) { 
UniversalTersePrinter < T > :: Print (value , os) ; 
} 
# 955
template < typename T > 
void UniversalPrint (const T & value , :: std :: ostream * os) { 


typedef T T1 ; 
UniversalPrinter < T1 > :: Print (value , os) ; 
} 

typedef std::vector< std::__cxx11::basic_string< char> >  Strings; 
# 972 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename TupleT >
struct TuplePolicy;


template < typename TupleT > 
struct TuplePolicy { 
typedef TupleT Tuple ; 
static const size_t tuple_size = :: std :: tr1 :: tuple_size < Tuple > :: value ; 

template < size_t I > 
struct tuple_element : :: std :: tr1 :: tuple_element < static_cast < int > (I) , Tuple > { 
} ; 

template < size_t I > 
static typename AddReference < const typename :: std :: tr1 :: tuple_element < 
static_cast < int > (I) , Tuple > :: type > :: type 
get (const Tuple & tuple) { 
return :: std :: tr1 :: get < I > (tuple) ; 
} 
} ;
template < typename TupleT >
const size_t TuplePolicy < TupleT > :: tuple_size;



template < typename ... Types > 
struct TuplePolicy < :: std :: tuple < Types ... > > { 
typedef :: std :: tuple < Types ... > Tuple ; 
static const size_t tuple_size = :: std :: tuple_size < Tuple > :: value ; 

template < size_t I > 
struct tuple_element : :: std :: tuple_element < I , Tuple > { } ; 

template < size_t I > 
static const typename :: std :: tuple_element < I , Tuple > :: type & get (
const Tuple & tuple) { 
return :: std :: get < I > (tuple) ; 
} 
} ;
template < typename ... Types >
const size_t TuplePolicy < :: std :: tuple < Types ... > > :: tuple_size;
# 1024 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < size_t N > 
struct TuplePrefixPrinter { 

template < typename Tuple > 
static void PrintPrefixTo (const Tuple & t , :: std :: ostream * os) { 
TuplePrefixPrinter < N - 1 > :: PrintPrefixTo (t , os) ; 

if (N > 1) { 

* os << ", " ; 
} 
UniversalPrinter < 
typename TuplePolicy < Tuple > :: template tuple_element < N - 1 > :: type > 
:: Print (TuplePolicy < Tuple > :: template get < N - 1 > (t) , os) ; 
} 



template < typename Tuple > 
static void TersePrintPrefixToStrings (const Tuple & t , Strings * strings) { 
TuplePrefixPrinter < N - 1 > :: TersePrintPrefixToStrings (t , strings) ; 
:: std :: stringstream ss ; 
UniversalTersePrint (TuplePolicy < Tuple > :: template get < N - 1 > (t) , & ss) ; 
strings -> push_back (ss . str ()) ; 
} 
} ;



template<> struct TuplePrefixPrinter< 0U>  { 
template < typename Tuple > 
static void PrintPrefixTo (const Tuple & , :: std :: ostream *) { } 

template < typename Tuple > 
static void TersePrintPrefixToStrings (const Tuple & , Strings *) { } 
}; 



template < typename Tuple > 
void PrintTupleTo (const Tuple & t , :: std :: ostream * os) { 
* os << "(" ; 
TuplePrefixPrinter < TuplePolicy < Tuple > :: tuple_size > :: PrintPrefixTo (t , os) ; 
* os << ")" ; 
} 




template < typename Tuple > 
Strings UniversalTersePrintTupleFieldsToStrings (const Tuple & value) { 
Strings result ; 
TuplePrefixPrinter < TuplePolicy < Tuple > :: tuple_size > :: 
TersePrintPrefixToStrings (value , & result) ; 
return result ; 
} 


}
# 1094 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-printers.h"
template < typename T > 
:: std :: string PrintToString (const T & value) { 
:: std :: stringstream ss ; 
internal :: UniversalTersePrinter < T > :: Print (value , & ss) ; 
return ss . str () ; 
} 

}
# 50 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h"
namespace testing { 



template < class ParamType > 
struct TestParamInfo { 
TestParamInfo (const ParamType & a_param , size_t an_index) : 
param (a_param) , 
index (an_index) { } 
ParamType param ; 
size_t index ; 
} ;



struct PrintToStringParamName { 
template < class ParamType > 
std :: string operator () (const TestParamInfo < ParamType > & info) const { 
return PrintToString (info . param) ; 
} 
}; 

namespace internal { 
# 80
__attribute((visibility("default"))) void ReportInvalidTestCaseType(const char * test_case_name, CodeLocation code_location); 


template < typename > class ParamGeneratorInterface;
template < typename > class ParamGenerator;



template < typename T > 
class ParamIteratorInterface { 
public : 
virtual ~ ParamIteratorInterface () { } 



virtual const ParamGeneratorInterface < T > * BaseGenerator () const = 0 ; 




virtual void Advance () = 0 ; 


virtual ParamIteratorInterface * Clone () const = 0 ; 




virtual const T * Current () const = 0 ; 



virtual bool Equals (const ParamIteratorInterface & other) const = 0 ; 
} ;




template < typename T > 
class ParamIterator { 
public : 
typedef T value_type ; 
typedef const T & reference ; 
typedef ptrdiff_t difference_type ; 


ParamIterator (const ParamIterator & other) : impl_ (other . impl_ -> Clone ()) { } 
ParamIterator & operator = (const ParamIterator & other) { 
if (this != & other) 
impl_ . reset (other . impl_ -> Clone ()) ; 
return * this ; 
} 

const T & operator * () const { return * impl_ -> Current () ; } 
const T * operator -> () const { return impl_ -> Current () ; } 

ParamIterator & operator ++ () { 
impl_ -> Advance () ; 
return * this ; 
} 

ParamIterator operator ++ (int) { 
ParamIteratorInterface < T > * clone = impl_ -> Clone () ; 
impl_ -> Advance () ; 
return ParamIterator (clone) ; 
} 
bool operator == (const ParamIterator & other) const { 
return impl_ . get () == other . impl_ . get () || impl_ -> Equals (* other . impl_) ; 
} 
bool operator != (const ParamIterator & other) const { 
return ! (* this == other) ; 
} 

private : 
friend class ParamGenerator < T > ; 
explicit ParamIterator (ParamIteratorInterface < T > * impl) : impl_ (impl) { } 
scoped_ptr < ParamIteratorInterface < T > > impl_ ; 
} ;



template < typename T > 
class ParamGeneratorInterface { 
public : 
typedef T ParamType ; 

virtual ~ ParamGeneratorInterface () { } 


virtual ParamIteratorInterface < T > * Begin () const = 0 ; 
virtual ParamIteratorInterface < T > * End () const = 0 ; 
} ;
# 178
template < typename T > 
class ParamGenerator { 
public : 
typedef ParamIterator < T > iterator ; 

explicit ParamGenerator (ParamGeneratorInterface < T > * impl) : impl_ (impl) { } 
ParamGenerator (const ParamGenerator & other) : impl_ (other . impl_) { } 

ParamGenerator & operator = (const ParamGenerator & other) { 
impl_ = other . impl_ ; 
return * this ; 
} 

iterator begin () const { return iterator (impl_ -> Begin ()) ; } 
iterator end () const { return iterator (impl_ -> End ()) ; } 

private : 
linked_ptr < const ParamGeneratorInterface < T > > impl_ ; 
} ;
# 202
template < typename T , typename IncrementT > 
class RangeGenerator : public ParamGeneratorInterface < T > { 
public : 
RangeGenerator (T begin , T end , IncrementT step) 
: begin_ (begin) , end_ (end) , 
step_ (step) , end_index_ (CalculateEndIndex (begin , end , step)) { } 
virtual ~ RangeGenerator () { } 

virtual ParamIteratorInterface < T > * Begin () const { 
return new Iterator (this , begin_ , 0 , step_) ; 
} 
virtual ParamIteratorInterface < T > * End () const { 
return new Iterator (this , end_ , end_index_ , step_) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < T > { 
public : 
Iterator (const ParamGeneratorInterface < T > * base , T value , int index , 
IncrementT step) 
: base_ (base) , value_ (value) , index_ (index) , step_ (step) { } 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < T > * BaseGenerator () const { 
return base_ ; 
} 
virtual void Advance () { 
value_ = static_cast < T > (value_ + step_) ; 
index_ ++ ; 
} 
virtual ParamIteratorInterface < T > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const T * Current () const { return & value_ ; } 
virtual bool Equals (const ParamIteratorInterface < T > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h" , 239) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const int other_index = 
CheckedDowncastToActualType < const Iterator > (& other) -> index_ ; 
return index_ == other_index ; 
} 

private : 
Iterator (const Iterator & other) 
: ParamIteratorInterface < T > () , 
base_ (other . base_) , value_ (other . value_) , index_ (other . index_) , 
step_ (other . step_) { } 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < T > * const base_ ; 
T value_ ; 
int index_ ; 
const IncrementT step_ ; 
} ; 

static int CalculateEndIndex (const T & begin , 
const T & end , 
const IncrementT & step) { 
int end_index = 0 ; 
for (T i = begin ; i < end ; i = static_cast < T > (i + step)) 
end_index ++ ; 
return end_index ; 
} 


void operator = (const RangeGenerator & other) ; 

const T begin_ ; 
const T end_ ; 
const IncrementT step_ ; 


const int end_index_ ; 
} ;
# 287
template < typename T > 
class ValuesInIteratorRangeGenerator : public ParamGeneratorInterface < T > { 
public : 
template < typename ForwardIterator > 
ValuesInIteratorRangeGenerator (ForwardIterator begin , ForwardIterator end) 
: container_ (begin , end) { } 
virtual ~ ValuesInIteratorRangeGenerator () { } 

virtual ParamIteratorInterface < T > * Begin () const { 
return new Iterator (this , container_ . begin ()) ; 
} 
virtual ParamIteratorInterface < T > * End () const { 
return new Iterator (this , container_ . end ()) ; 
} 

private : 
typedef typename :: std :: vector < T > ContainerType ; 

class Iterator : public ParamIteratorInterface < T > { 
public : 
Iterator (const ParamGeneratorInterface < T > * base , 
typename ContainerType :: const_iterator iterator) 
: base_ (base) , iterator_ (iterator) { } 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < T > * BaseGenerator () const { 
return base_ ; 
} 
virtual void Advance () { 
++ iterator_ ; 
value_ . reset () ; 
} 
virtual ParamIteratorInterface < T > * Clone () const { 
return new Iterator (* this) ; 
} 
# 329
virtual const T * Current () const { 
if (value_ . get () == nullptr) value_ . reset (new T (* iterator_)) ; 
return value_ . get () ; 
} 
virtual bool Equals (const ParamIteratorInterface < T > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h" , 336) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
return iterator_ == 
CheckedDowncastToActualType < const Iterator > (& other) -> iterator_ ; 
} 

private : 
Iterator (const Iterator & other) 


: ParamIteratorInterface < T > () , 
base_ (other . base_) , 
iterator_ (other . iterator_) { } 

const ParamGeneratorInterface < T > * const base_ ; 
typename ContainerType :: const_iterator iterator_ ; 
# 358
mutable scoped_ptr < const T > value_ ; 
} ; 


void operator = (const ValuesInIteratorRangeGenerator & other) ; 

const ContainerType container_ ; 
} ;
# 371
template < class ParamType > 
std :: string DefaultParamName (const TestParamInfo < ParamType > & info) { 
Message name_stream ; 
name_stream << info . index ; 
return name_stream . GetString () ; 
} 
# 383
template < class ParamType , class ParamNameGenFunctor > 
ParamNameGenFunctor GetParamNameGen (ParamNameGenFunctor func) { 
return func ; 
} 

template < class ParamType > 
struct ParamNameGenFunc { 
typedef std :: string Type (const TestParamInfo < ParamType > &) ; 
} ;

template < class ParamType > 
typename ParamNameGenFunc < ParamType > :: Type * GetParamNameGen () { 
return DefaultParamName ; 
} 
# 402
template < class TestClass > 
class ParameterizedTestFactory : public TestFactoryBase { 
public : 
typedef typename TestClass :: ParamType ParamType ; 
explicit ParameterizedTestFactory (ParamType parameter) : 
parameter_ (parameter) { } 
virtual Test * CreateTest () { 
TestClass :: SetParam (& parameter_) ; 
return new TestClass () ; 
} 

private : 
const ParamType parameter_ ; 

ParameterizedTestFactory (ParameterizedTestFactory const &) = delete ; void operator = (ParameterizedTestFactory const &) = delete ; 
} ;
# 423
template < class ParamType > 
class TestMetaFactoryBase { 
public : 
virtual ~ TestMetaFactoryBase () { } 

virtual TestFactoryBase * CreateTestFactory (ParamType parameter) = 0 ; 
} ;
# 439 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h"
template < class TestCase > 
class TestMetaFactory 
: public TestMetaFactoryBase < typename TestCase :: ParamType > { 
public : 
typedef typename TestCase :: ParamType ParamType ; 

TestMetaFactory () { } 

virtual TestFactoryBase * CreateTestFactory (ParamType parameter) { 
return new ParameterizedTestFactory < TestCase > (parameter) ; 
} 

private : 
TestMetaFactory (TestMetaFactory const &) = delete ; void operator = (TestMetaFactory const &) = delete ; 
} ;
# 465 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h"
class ParameterizedTestCaseInfoBase { 

public: virtual ~ParameterizedTestCaseInfoBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(156 + 0 + 1U - 1);} 


virtual const std::string &GetTestCaseName() const = 0; 

virtual TypeId GetTestCaseTypeId() const = 0; 




virtual void RegisterTests() = 0; 


protected: ParameterizedTestCaseInfoBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(157 + 0 + 1U - 1);} 


private: ParameterizedTestCaseInfoBase(const ParameterizedTestCaseInfoBase &) = delete;void operator=(const ParameterizedTestCaseInfoBase &) = delete;
}; 
# 493 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h"
template < class TestCase > 
class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase { 
public : 



typedef typename TestCase :: ParamType ParamType ; 

typedef ParamGenerator < ParamType > (GeneratorCreationFunc) () ; 
typedef typename ParamNameGenFunc < ParamType > :: Type ParamNameGeneratorFunc ; 

explicit ParameterizedTestCaseInfo (
const char * name , CodeLocation code_location) 
: test_case_name_ (name) , code_location_ (code_location) { } 


virtual const std :: string & GetTestCaseName () const { return test_case_name_ ; } 

virtual TypeId GetTestCaseTypeId () const { return GetTypeId < TestCase > () ; } 
# 518
void AddTestPattern (const char * test_case_name , 
const char * test_base_name , 
TestMetaFactoryBase < ParamType > * meta_factory) { 
tests_ . push_back (linked_ptr < TestInfo > (new TestInfo (test_case_name , 
test_base_name , 
meta_factory))) ; 
} 


int AddTestCaseInstantiation (const std :: string & instantiation_name , 
GeneratorCreationFunc * func , 
ParamNameGeneratorFunc * name_func , 
const char * file , int line) { 
instantiations_ . push_back (
InstantiationInfo (instantiation_name , func , name_func , file , line)) ; 
return 0 ; 
} 
# 540
virtual void RegisterTests () { 
for (typename TestInfoContainer :: iterator test_it = tests_ . begin () ; 
test_it != tests_ . end () ; ++ test_it) { 
linked_ptr < TestInfo > test_info = * test_it ; 
for (typename InstantiationContainer :: iterator gen_it = 
instantiations_ . begin () ; gen_it != instantiations_ . end () ; 
++ gen_it) { 
const std :: string & instantiation_name = gen_it -> name ; 
ParamGenerator < ParamType > generator ((* gen_it -> generator) ()) ; 
ParamNameGeneratorFunc * name_func = gen_it -> name_func ; 
const char * file = gen_it -> file ; 
int line = gen_it -> line ; 

std :: string test_case_name ; 
if (! instantiation_name . empty ()) 
test_case_name = instantiation_name + "/" ; 
test_case_name += test_info -> test_case_base_name ; 

size_t i = 0 ; 
std :: set < std :: string > test_param_names ; 
for (typename ParamGenerator < ParamType > :: iterator param_it = 
generator . begin () ; 
param_it != generator . end () ; ++ param_it , ++ i) { 
Message test_name_stream ; 

std :: string param_name = name_func (
TestParamInfo < ParamType > (* param_it , i)) ; 

switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (IsValidParamName (param_name))) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h" , 568) . GetStream () << "Condition " "IsValidParamName(param_name)" " failed. " 
<< "Parameterized test name '" << param_name 
<< "' is invalid, in " << file 
<< " line " << line << std :: endl ; 

switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (test_param_names . count (param_name) == 0)) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util.h" , 573) . GetStream () << "Condition " "test_param_names.count(param_name) == 0" " failed. " 
<< "Duplicate parameterized test name '" << param_name 
<< "', in " << file << " line " << line << std :: endl ; 

test_param_names . insert (param_name) ; 

test_name_stream << test_info -> test_base_name << "/" << param_name ; 
MakeAndRegisterTestInfo (
test_case_name . c_str () , test_name_stream . GetString () . c_str () , 
nullptr , 
PrintToString (* param_it) . c_str () , code_location_ , 
GetTestCaseTypeId () , TestCase :: SetUpTestCase , 
TestCase :: TearDownTestCase , 
test_info -> test_meta_factory -> CreateTestFactory (* param_it)) ; 
} 
} 
} 
} 

private : 


struct TestInfo { 
TestInfo (const char * a_test_case_base_name , 
const char * a_test_base_name , 
TestMetaFactoryBase < ParamType > * a_test_meta_factory) : 
test_case_base_name (a_test_case_base_name) , 
test_base_name (a_test_base_name) , 
test_meta_factory (a_test_meta_factory) { } 

const std :: string test_case_base_name ; 
const std :: string test_base_name ; 
const scoped_ptr < TestMetaFactoryBase < ParamType > > test_meta_factory ; 
} ; 
typedef :: std :: vector < linked_ptr < TestInfo > > TestInfoContainer ; 



struct InstantiationInfo { 
InstantiationInfo (const std :: string & name_in , 
GeneratorCreationFunc * generator_in , 
ParamNameGeneratorFunc * name_func_in , 
const char * file_in , 
int line_in) 
: name (name_in) , 
generator (generator_in) , 
name_func (name_func_in) , 
file (file_in) , 
line (line_in) { } 

std :: string name ; 
GeneratorCreationFunc * generator ; 
ParamNameGeneratorFunc * name_func ; 
const char * file ; 
int line ; 
} ; 
typedef :: std :: vector < InstantiationInfo > InstantiationContainer ; 

static bool IsValidParamName (const std :: string & name) { 

if (name . empty ()) 
return false ; 


for (std :: string :: size_type index = 0 ; index < name . size () ; ++ index) { 
if (! isalnum (name [ index ]) && name [ index ] != '_') 
return false ; 
} 

return true ; 
} 

const std :: string test_case_name_ ; 
CodeLocation code_location_ ; 
TestInfoContainer tests_ ; 
InstantiationContainer instantiations_ ; 

ParameterizedTestCaseInfo (ParameterizedTestCaseInfo const &) = delete ; void operator = (ParameterizedTestCaseInfo const &) = delete ; 
} ;
# 659
class ParameterizedTestCaseRegistry { 

public: ParameterizedTestCaseRegistry() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(158 + 0 + 1U - 1);} 
~ParameterizedTestCaseRegistry() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(159 + 0 + 1U - 1);
for (std::vector< ParameterizedTestCaseInfoBase *> ::iterator it = (test_case_infos_).begin(); ((void)cpptestFastCoverageStmt(159 + 0 + 2U - 1), it != (test_case_infos_).end()); ((void)cpptestFastCoverageStmt(159 + 0 + 3U - 1), ++it)) 
{ cpptestFastCoverageStmt(159 + 0 + 4U - 1);
delete (*it); 
}  
} 



template < class TestCase > 
ParameterizedTestCaseInfo < TestCase > * GetTestCasePatternHolder (
const char * test_case_name , 
CodeLocation code_location) { 
ParameterizedTestCaseInfo < TestCase > * typed_test_info = nullptr ; 
for (TestCaseInfoContainer :: iterator it = test_case_infos_ . begin () ; 
it != test_case_infos_ . end () ; ++ it) { 
if ((* it) -> GetTestCaseName () == test_case_name) { 
if ((* it) -> GetTestCaseTypeId () != GetTypeId < TestCase > ()) { 



ReportInvalidTestCaseType (test_case_name , code_location) ; 
posix :: Abort () ; 
} else { 



typed_test_info = CheckedDowncastToActualType < 
ParameterizedTestCaseInfo < TestCase > > (* it) ; 
} 
break ; 
} 
} 
if (typed_test_info == nullptr) { 
typed_test_info = new ParameterizedTestCaseInfo < TestCase > (
test_case_name , code_location) ; 
test_case_infos_ . push_back (typed_test_info) ; 
} 
return typed_test_info ; 
} 
void RegisterTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(163 + 0 + 1U - 1);
for (std::vector< ParameterizedTestCaseInfoBase *> ::iterator it = (test_case_infos_).begin(); ((void)cpptestFastCoverageStmt(163 + 0 + 2U - 1), it != (test_case_infos_).end()); ((void)cpptestFastCoverageStmt(163 + 0 + 3U - 1), ++it)) 
{ cpptestFastCoverageStmt(163 + 0 + 4U - 1);
((*it))->RegisterTests(); 
}  
} 


private: typedef std::vector< ParameterizedTestCaseInfoBase *>  TestCaseInfoContainer; 

TestCaseInfoContainer test_case_infos_; 

ParameterizedTestCaseRegistry(const ParameterizedTestCaseRegistry &) = delete;void operator=(const ParameterizedTestCaseRegistry &) = delete;
}; 

}
}
# 53 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
namespace testing { 



template < typename ForwardIterator >
internal :: ParamGenerator <
  typename :: testing :: internal :: IteratorTraits < ForwardIterator > :: value_type >
ValuesIn ( ForwardIterator begin, ForwardIterator end );

template < typename T, size_t N >
internal :: ParamGenerator < T > ValuesIn ( const T ( & array ) [ N ] );

template < class Container >
internal :: ParamGenerator < typename Container :: value_type > ValuesIn (
    const Container & container );

namespace internal { 


template < typename T1 > 
class ValueArray1 { 
public : 
explicit ValueArray1 (T1 v1) : v1_ (v1) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) } ; 
return ValuesIn (array) ; 
} 

ValueArray1 (const ValueArray1 & other) : v1_ (other . v1_) { } 

private : 

void operator = (const ValueArray1 & other) ; 

const T1 v1_ ; 
} ;

template < typename T1 , typename T2 > 
class ValueArray2 { 
public : 
ValueArray2 (T1 v1 , T2 v2) : v1_ (v1) , v2_ (v2) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) } ; 
return ValuesIn (array) ; 
} 

ValueArray2 (const ValueArray2 & other) : v1_ (other . v1_) , v2_ (other . v2_) { } 

private : 

void operator = (const ValueArray2 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
} ;

template < typename T1 , typename T2 , typename T3 > 
class ValueArray3 { 
public : 
ValueArray3 (T1 v1 , T2 v2 , T3 v3) : v1_ (v1) , v2_ (v2) , v3_ (v3) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) } ; 
return ValuesIn (array) ; 
} 

ValueArray3 (const ValueArray3 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) { } 

private : 

void operator = (const ValueArray3 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 > 
class ValueArray4 { 
public : 
ValueArray4 (T1 v1 , T2 v2 , T3 v3 , T4 v4) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) } ; 
return ValuesIn (array) ; 
} 

ValueArray4 (const ValueArray4 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) { } 

private : 

void operator = (const ValueArray4 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
class ValueArray5 { 
public : 
ValueArray5 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) } ; 
return ValuesIn (array) ; 
} 

ValueArray5 (const ValueArray5 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) { } 

private : 

void operator = (const ValueArray5 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
class ValueArray6 { 
public : 
ValueArray6 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) } ; 
return ValuesIn (array) ; 
} 

ValueArray6 (const ValueArray6 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) { } 

private : 

void operator = (const ValueArray6 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
class ValueArray7 { 
public : 
ValueArray7 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) } ; 
return ValuesIn (array) ; 
} 

ValueArray7 (const ValueArray7 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) { } 

private : 

void operator = (const ValueArray7 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
class ValueArray8 { 
public : 
ValueArray8 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) } ; 
return ValuesIn (array) ; 
} 

ValueArray8 (const ValueArray8 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) { } 

private : 

void operator = (const ValueArray8 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
class ValueArray9 { 
public : 
ValueArray9 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , 
T9 v9) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) } ; 
return ValuesIn (array) ; 
} 

ValueArray9 (const ValueArray9 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) { } 

private : 

void operator = (const ValueArray9 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
class ValueArray10 { 
public : 
ValueArray10 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) } ; 
return ValuesIn (array) ; 
} 

ValueArray10 (const ValueArray10 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) { } 

private : 

void operator = (const ValueArray10 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 > 
class ValueArray11 { 
public : 
ValueArray11 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , 
v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) } ; 
return ValuesIn (array) ; 
} 

ValueArray11 (const ValueArray11 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) { } 

private : 

void operator = (const ValueArray11 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 > 
class ValueArray12 { 
public : 
ValueArray12 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , 
v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) } ; 
return ValuesIn (array) ; 
} 

ValueArray12 (const ValueArray12 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) { } 

private : 

void operator = (const ValueArray12 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 > 
class ValueArray13 { 
public : 
ValueArray13 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , 
v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , 
v12_ (v12) , v13_ (v13) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) } ; 
return ValuesIn (array) ; 
} 

ValueArray13 (const ValueArray13 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) { } 

private : 

void operator = (const ValueArray13 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 > 
class ValueArray14 { 
public : 
ValueArray14 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) } ; 
return ValuesIn (array) ; 
} 

ValueArray14 (const ValueArray14 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) { } 

private : 

void operator = (const ValueArray14 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 > 
class ValueArray15 { 
public : 
ValueArray15 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) } ; 
return ValuesIn (array) ; 
} 

ValueArray15 (const ValueArray15 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) { } 

private : 

void operator = (const ValueArray15 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 > 
class ValueArray16 { 
public : 
ValueArray16 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , 
v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , 
v16_ (v16) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) } ; 
return ValuesIn (array) ; 
} 

ValueArray16 (const ValueArray16 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) { } 

private : 

void operator = (const ValueArray16 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 > 
class ValueArray17 { 
public : 
ValueArray17 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , 
T17 v17) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) } ; 
return ValuesIn (array) ; 
} 

ValueArray17 (const ValueArray17 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) { } 

private : 

void operator = (const ValueArray17 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 > 
class ValueArray18 { 
public : 
ValueArray18 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) } ; 
return ValuesIn (array) ; 
} 

ValueArray18 (const ValueArray18 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) { } 

private : 

void operator = (const ValueArray18 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 > 
class ValueArray19 { 
public : 
ValueArray19 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , 
v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , 
v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) } ; 
return ValuesIn (array) ; 
} 

ValueArray19 (const ValueArray19 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) { } 

private : 

void operator = (const ValueArray19 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 > 
class ValueArray20 { 
public : 
ValueArray20 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , 
v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , 
v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , 
v19_ (v19) , v20_ (v20) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) } ; 
return ValuesIn (array) ; 
} 

ValueArray20 (const ValueArray20 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) { } 

private : 

void operator = (const ValueArray20 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 > 
class ValueArray21 { 
public : 
ValueArray21 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , 
v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , 
v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , 
v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) } ; 
return ValuesIn (array) ; 
} 

ValueArray21 (const ValueArray21 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) { } 

private : 

void operator = (const ValueArray21 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 > 
class ValueArray22 { 
public : 
ValueArray22 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) } ; 
return ValuesIn (array) ; 
} 

ValueArray22 (const ValueArray22 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) { } 

private : 

void operator = (const ValueArray22 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 > 
class ValueArray23 { 
public : 
ValueArray23 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) } ; 
return ValuesIn (array) ; 
} 

ValueArray23 (const ValueArray23 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) { } 

private : 

void operator = (const ValueArray23 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 > 
class ValueArray24 { 
public : 
ValueArray24 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , 
v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , 
v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , 
v22_ (v22) , v23_ (v23) , v24_ (v24) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) } ; 
return ValuesIn (array) ; 
} 

ValueArray24 (const ValueArray24 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) { } 

private : 

void operator = (const ValueArray24 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 > 
class ValueArray25 { 
public : 
ValueArray25 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , 
T25 v25) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) } ; 
return ValuesIn (array) ; 
} 

ValueArray25 (const ValueArray25 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) { } 

private : 

void operator = (const ValueArray25 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 > 
class ValueArray26 { 
public : 
ValueArray26 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) } ; 
return ValuesIn (array) ; 
} 

ValueArray26 (const ValueArray26 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) { } 

private : 

void operator = (const ValueArray26 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 > 
class ValueArray27 { 
public : 
ValueArray27 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , 
v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , 
v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , 
v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , 
v26_ (v26) , v27_ (v27) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) } ; 
return ValuesIn (array) ; 
} 

ValueArray27 (const ValueArray27 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) { } 

private : 

void operator = (const ValueArray27 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 > 
class ValueArray28 { 
public : 
ValueArray28 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , 
v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , 
v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , 
v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , 
v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) } ; 
return ValuesIn (array) ; 
} 

ValueArray28 (const ValueArray28 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) { } 

private : 

void operator = (const ValueArray28 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 > 
class ValueArray29 { 
public : 
ValueArray29 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , 
v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , 
v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , 
v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , 
v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) } ; 
return ValuesIn (array) ; 
} 

ValueArray29 (const ValueArray29 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) { } 

private : 

void operator = (const ValueArray29 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 > 
class ValueArray30 { 
public : 
ValueArray30 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) } ; 
return ValuesIn (array) ; 
} 

ValueArray30 (const ValueArray30 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) { } 

private : 

void operator = (const ValueArray30 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 > 
class ValueArray31 { 
public : 
ValueArray31 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) , v31_ (v31) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) } ; 
return ValuesIn (array) ; 
} 

ValueArray31 (const ValueArray31 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) { } 

private : 

void operator = (const ValueArray31 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 > 
class ValueArray32 { 
public : 
ValueArray32 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , 
v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , 
v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , 
v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , 
v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) } ; 
return ValuesIn (array) ; 
} 

ValueArray32 (const ValueArray32 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) { } 

private : 

void operator = (const ValueArray32 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 > 
class ValueArray33 { 
public : 
ValueArray33 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , 
T33 v33) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) } ; 
return ValuesIn (array) ; 
} 

ValueArray33 (const ValueArray33 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) { } 

private : 

void operator = (const ValueArray33 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 > 
class ValueArray34 { 
public : 
ValueArray34 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) , v34_ (v34) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) } ; 
return ValuesIn (array) ; 
} 

ValueArray34 (const ValueArray34 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) { } 

private : 

void operator = (const ValueArray34 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 > 
class ValueArray35 { 
public : 
ValueArray35 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , 
v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , 
v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , 
v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , 
v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , 
v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) } ; 
return ValuesIn (array) ; 
} 

ValueArray35 (const ValueArray35 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) { } 

private : 

void operator = (const ValueArray35 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 > 
class ValueArray36 { 
public : 
ValueArray36 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , 
v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , 
v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , 
v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , 
v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , 
v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) } ; 
return ValuesIn (array) ; 
} 

ValueArray36 (const ValueArray36 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) { } 

private : 

void operator = (const ValueArray36 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 > 
class ValueArray37 { 
public : 
ValueArray37 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , 
v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , 
v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , 
v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , 
v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , 
v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) , 
v36_ (v36) , v37_ (v37) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) } ; 
return ValuesIn (array) ; 
} 

ValueArray37 (const ValueArray37 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) { } 

private : 

void operator = (const ValueArray37 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 > 
class ValueArray38 { 
public : 
ValueArray38 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , 
v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) } ; 
return ValuesIn (array) ; 
} 

ValueArray38 (const ValueArray38 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) { } 

private : 

void operator = (const ValueArray38 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 > 
class ValueArray39 { 
public : 
ValueArray39 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , 
v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) } ; 
return ValuesIn (array) ; 
} 

ValueArray39 (const ValueArray39 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) { } 

private : 

void operator = (const ValueArray39 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 > 
class ValueArray40 { 
public : 
ValueArray40 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , 
v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , 
v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , 
v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , 
v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , 
v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) , 
v40_ (v40) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) } ; 
return ValuesIn (array) ; 
} 

ValueArray40 (const ValueArray40 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) { } 

private : 

void operator = (const ValueArray40 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 > 
class ValueArray41 { 
public : 
ValueArray41 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , 
T41 v41) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , 
v39_ (v39) , v40_ (v40) , v41_ (v41) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) } ; 
return ValuesIn (array) ; 
} 

ValueArray41 (const ValueArray41 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) { } 

private : 

void operator = (const ValueArray41 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 > 
class ValueArray42 { 
public : 
ValueArray42 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , 
v39_ (v39) , v40_ (v40) , v41_ (v41) , v42_ (v42) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) } ; 
return ValuesIn (array) ; 
} 

ValueArray42 (const ValueArray42 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) { } 

private : 

void operator = (const ValueArray42 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 > 
class ValueArray43 { 
public : 
ValueArray43 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , 
v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , 
v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , 
v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , 
v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , 
v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , 
v38_ (v38) , v39_ (v39) , v40_ (v40) , v41_ (v41) , v42_ (v42) , v43_ (v43) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) } ; 
return ValuesIn (array) ; 
} 

ValueArray43 (const ValueArray43 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) { } 

private : 

void operator = (const ValueArray43 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 > 
class ValueArray44 { 
public : 
ValueArray44 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , 
v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , 
v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , 
v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , 
v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , 
v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , 
v37_ (v37) , v38_ (v38) , v39_ (v39) , v40_ (v40) , v41_ (v41) , v42_ (v42) , 
v43_ (v43) , v44_ (v44) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) } ; 
return ValuesIn (array) ; 
} 

ValueArray44 (const ValueArray44 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) { } 

private : 

void operator = (const ValueArray44 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 > 
class ValueArray45 { 
public : 
ValueArray45 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , 
v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , 
v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , v17_ (v17) , 
v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , v23_ (v23) , 
v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , v29_ (v29) , 
v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , v35_ (v35) , 
v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) , v40_ (v40) , v41_ (v41) , 
v42_ (v42) , v43_ (v43) , v44_ (v44) , v45_ (v45) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) } ; 
return ValuesIn (array) ; 
} 

ValueArray45 (const ValueArray45 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) { } 

private : 

void operator = (const ValueArray45 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 > 
class ValueArray46 { 
public : 
ValueArray46 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46) : v1_ (v1) , v2_ (v2) , v3_ (v3) , 
v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , 
v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) , v40_ (v40) , 
v41_ (v41) , v42_ (v42) , v43_ (v43) , v44_ (v44) , v45_ (v45) , v46_ (v46) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) , static_cast < T > (v46_) } ; 
return ValuesIn (array) ; 
} 

ValueArray46 (const ValueArray46 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) , v46_ (other . v46_) { } 

private : 

void operator = (const ValueArray46 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
const T46 v46_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 > 
class ValueArray47 { 
public : 
ValueArray47 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47) : v1_ (v1) , v2_ (v2) , 
v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , v10_ (v10) , 
v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , v16_ (v16) , 
v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , v22_ (v22) , 
v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , v28_ (v28) , 
v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , v34_ (v34) , 
v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) , v40_ (v40) , 
v41_ (v41) , v42_ (v42) , v43_ (v43) , v44_ (v44) , v45_ (v45) , v46_ (v46) , 
v47_ (v47) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) , static_cast < T > (v46_) , static_cast < T > (v47_) } ; 
return ValuesIn (array) ; 
} 

ValueArray47 (const ValueArray47 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) , v46_ (other . v46_) , 
v47_ (other . v47_) { } 

private : 

void operator = (const ValueArray47 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
const T46 v46_ ; 
const T47 v47_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 > 
class ValueArray48 { 
public : 
ValueArray48 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47 , T48 v48) : v1_ (v1) , 
v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , v8_ (v8) , v9_ (v9) , 
v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , v15_ (v15) , 
v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , v21_ (v21) , 
v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , v27_ (v27) , 
v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , v33_ (v33) , 
v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , v39_ (v39) , 
v40_ (v40) , v41_ (v41) , v42_ (v42) , v43_ (v43) , v44_ (v44) , v45_ (v45) , 
v46_ (v46) , v47_ (v47) , v48_ (v48) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) , static_cast < T > (v46_) , static_cast < T > (v47_) , 
static_cast < T > (v48_) } ; 
return ValuesIn (array) ; 
} 

ValueArray48 (const ValueArray48 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) , v46_ (other . v46_) , 
v47_ (other . v47_) , v48_ (other . v48_) { } 

private : 

void operator = (const ValueArray48 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
const T46 v46_ ; 
const T47 v47_ ; 
const T48 v48_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 > 
class ValueArray49 { 
public : 
ValueArray49 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47 , T48 v48 , 
T49 v49) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , 
v39_ (v39) , v40_ (v40) , v41_ (v41) , v42_ (v42) , v43_ (v43) , v44_ (v44) , 
v45_ (v45) , v46_ (v46) , v47_ (v47) , v48_ (v48) , v49_ (v49) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) , static_cast < T > (v46_) , static_cast < T > (v47_) , 
static_cast < T > (v48_) , static_cast < T > (v49_) } ; 
return ValuesIn (array) ; 
} 

ValueArray49 (const ValueArray49 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) , v46_ (other . v46_) , 
v47_ (other . v47_) , v48_ (other . v48_) , v49_ (other . v49_) { } 

private : 

void operator = (const ValueArray49 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
const T46 v46_ ; 
const T47 v47_ ; 
const T48 v48_ ; 
const T49 v49_ ; 
} ;

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 , typename T50 > 
class ValueArray50 { 
public : 
ValueArray50 (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47 , T48 v48 , T49 v49 , 
T50 v50) : v1_ (v1) , v2_ (v2) , v3_ (v3) , v4_ (v4) , v5_ (v5) , v6_ (v6) , v7_ (v7) , 
v8_ (v8) , v9_ (v9) , v10_ (v10) , v11_ (v11) , v12_ (v12) , v13_ (v13) , v14_ (v14) , 
v15_ (v15) , v16_ (v16) , v17_ (v17) , v18_ (v18) , v19_ (v19) , v20_ (v20) , 
v21_ (v21) , v22_ (v22) , v23_ (v23) , v24_ (v24) , v25_ (v25) , v26_ (v26) , 
v27_ (v27) , v28_ (v28) , v29_ (v29) , v30_ (v30) , v31_ (v31) , v32_ (v32) , 
v33_ (v33) , v34_ (v34) , v35_ (v35) , v36_ (v36) , v37_ (v37) , v38_ (v38) , 
v39_ (v39) , v40_ (v40) , v41_ (v41) , v42_ (v42) , v43_ (v43) , v44_ (v44) , 
v45_ (v45) , v46_ (v46) , v47_ (v47) , v48_ (v48) , v49_ (v49) , v50_ (v50) { } 

template < typename T > 
operator ParamGenerator < T > () const { 
const T array [ ] = { static_cast < T > (v1_) , static_cast < T > (v2_) , 
static_cast < T > (v3_) , static_cast < T > (v4_) , static_cast < T > (v5_) , 
static_cast < T > (v6_) , static_cast < T > (v7_) , static_cast < T > (v8_) , 
static_cast < T > (v9_) , static_cast < T > (v10_) , static_cast < T > (v11_) , 
static_cast < T > (v12_) , static_cast < T > (v13_) , static_cast < T > (v14_) , 
static_cast < T > (v15_) , static_cast < T > (v16_) , static_cast < T > (v17_) , 
static_cast < T > (v18_) , static_cast < T > (v19_) , static_cast < T > (v20_) , 
static_cast < T > (v21_) , static_cast < T > (v22_) , static_cast < T > (v23_) , 
static_cast < T > (v24_) , static_cast < T > (v25_) , static_cast < T > (v26_) , 
static_cast < T > (v27_) , static_cast < T > (v28_) , static_cast < T > (v29_) , 
static_cast < T > (v30_) , static_cast < T > (v31_) , static_cast < T > (v32_) , 
static_cast < T > (v33_) , static_cast < T > (v34_) , static_cast < T > (v35_) , 
static_cast < T > (v36_) , static_cast < T > (v37_) , static_cast < T > (v38_) , 
static_cast < T > (v39_) , static_cast < T > (v40_) , static_cast < T > (v41_) , 
static_cast < T > (v42_) , static_cast < T > (v43_) , static_cast < T > (v44_) , 
static_cast < T > (v45_) , static_cast < T > (v46_) , static_cast < T > (v47_) , 
static_cast < T > (v48_) , static_cast < T > (v49_) , static_cast < T > (v50_) } ; 
return ValuesIn (array) ; 
} 

ValueArray50 (const ValueArray50 & other) : v1_ (other . v1_) , v2_ (other . v2_) , 
v3_ (other . v3_) , v4_ (other . v4_) , v5_ (other . v5_) , v6_ (other . v6_) , 
v7_ (other . v7_) , v8_ (other . v8_) , v9_ (other . v9_) , v10_ (other . v10_) , 
v11_ (other . v11_) , v12_ (other . v12_) , v13_ (other . v13_) , v14_ (other . v14_) , 
v15_ (other . v15_) , v16_ (other . v16_) , v17_ (other . v17_) , v18_ (other . v18_) , 
v19_ (other . v19_) , v20_ (other . v20_) , v21_ (other . v21_) , v22_ (other . v22_) , 
v23_ (other . v23_) , v24_ (other . v24_) , v25_ (other . v25_) , v26_ (other . v26_) , 
v27_ (other . v27_) , v28_ (other . v28_) , v29_ (other . v29_) , v30_ (other . v30_) , 
v31_ (other . v31_) , v32_ (other . v32_) , v33_ (other . v33_) , v34_ (other . v34_) , 
v35_ (other . v35_) , v36_ (other . v36_) , v37_ (other . v37_) , v38_ (other . v38_) , 
v39_ (other . v39_) , v40_ (other . v40_) , v41_ (other . v41_) , v42_ (other . v42_) , 
v43_ (other . v43_) , v44_ (other . v44_) , v45_ (other . v45_) , v46_ (other . v46_) , 
v47_ (other . v47_) , v48_ (other . v48_) , v49_ (other . v49_) , v50_ (other . v50_) { } 

private : 

void operator = (const ValueArray50 & other) ; 

const T1 v1_ ; 
const T2 v2_ ; 
const T3 v3_ ; 
const T4 v4_ ; 
const T5 v5_ ; 
const T6 v6_ ; 
const T7 v7_ ; 
const T8 v8_ ; 
const T9 v9_ ; 
const T10 v10_ ; 
const T11 v11_ ; 
const T12 v12_ ; 
const T13 v13_ ; 
const T14 v14_ ; 
const T15 v15_ ; 
const T16 v16_ ; 
const T17 v17_ ; 
const T18 v18_ ; 
const T19 v19_ ; 
const T20 v20_ ; 
const T21 v21_ ; 
const T22 v22_ ; 
const T23 v23_ ; 
const T24 v24_ ; 
const T25 v25_ ; 
const T26 v26_ ; 
const T27 v27_ ; 
const T28 v28_ ; 
const T29 v29_ ; 
const T30 v30_ ; 
const T31 v31_ ; 
const T32 v32_ ; 
const T33 v33_ ; 
const T34 v34_ ; 
const T35 v35_ ; 
const T36 v36_ ; 
const T37 v37_ ; 
const T38 v38_ ; 
const T39 v39_ ; 
const T40 v40_ ; 
const T41 v41_ ; 
const T42 v42_ ; 
const T43 v43_ ; 
const T44 v44_ ; 
const T45 v45_ ; 
const T46 v46_ ; 
const T47 v47_ ; 
const T48 v48_ ; 
const T49 v49_ ; 
const T50 v50_ ; 
} ;
# 3569
template < typename T1 , typename T2 > 
class CartesianProductGenerator2 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 > ParamType ; 

CartesianProductGenerator2 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2) 
: g1_ (g1) , g2_ (g2) { } 
virtual ~ CartesianProductGenerator2 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 3608 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 3608 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current2_ ; 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 3623) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator2 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
} ;


template < typename T1 , typename T2 , typename T3 > 
class CartesianProductGenerator3 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 > ParamType ; 

CartesianProductGenerator3 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) { } 
virtual ~ CartesianProductGenerator3 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 3727 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 3727 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current3_ ; 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 3746) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator3 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 > 
class CartesianProductGenerator4 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 > ParamType ; 

CartesianProductGenerator4 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) { } 
virtual ~ CartesianProductGenerator4 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 3864 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 3864 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current4_ ; 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 3887) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator4 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
class CartesianProductGenerator5 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 > ParamType ; 

CartesianProductGenerator5 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) { } 
virtual ~ CartesianProductGenerator5 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 4018 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 4018 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current5_ ; 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 4045) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator5 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
class CartesianProductGenerator6 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , 
T6 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 > ParamType ; 

CartesianProductGenerator6 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5 , 
const ParamGenerator < T6 > & g6) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) { } 
virtual ~ CartesianProductGenerator6 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin () , g6_ , g6_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end () , g6_ , g6_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5 , 
const ParamGenerator < T6 > & g6 , 
const typename ParamGenerator < T6 > :: iterator & current6) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) , 
begin6_ (g6 . begin ()) , end6_ (g6 . end ()) , current6_ (current6) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 4191 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 4191 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current6_ ; 
if (current6_ == end6_) { 
current6_ = begin6_ ; 
++ current5_ ; 
} 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 4222) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_ && 
current6_ == typed_other -> current6_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) , 
begin6_ (other . begin6_) , 
end6_ (other . end6_) , 
current6_ (other . current6_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_ , * current6_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ || 
current6_ == end6_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
const typename ParamGenerator < T6 > :: iterator begin6_ ; 
const typename ParamGenerator < T6 > :: iterator end6_ ; 
typename ParamGenerator < T6 > :: iterator current6_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator6 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
const ParamGenerator < T6 > g6_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
class CartesianProductGenerator7 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , 
T7 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 > ParamType ; 

CartesianProductGenerator7 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5 , 
const ParamGenerator < T6 > & g6 , const ParamGenerator < T7 > & g7) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) { } 
virtual ~ CartesianProductGenerator7 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin () , g6_ , g6_ . begin () , g7_ , 
g7_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end () , g6_ , g6_ . end () , g7_ , g7_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5 , 
const ParamGenerator < T6 > & g6 , 
const typename ParamGenerator < T6 > :: iterator & current6 , 
const ParamGenerator < T7 > & g7 , 
const typename ParamGenerator < T7 > :: iterator & current7) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) , 
begin6_ (g6 . begin ()) , end6_ (g6 . end ()) , current6_ (current6) , 
begin7_ (g7 . begin ()) , end7_ (g7 . end ()) , current7_ (current7) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 4381 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 4381 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current7_ ; 
if (current7_ == end7_) { 
current7_ = begin7_ ; 
++ current6_ ; 
} 
if (current6_ == end6_) { 
current6_ = begin6_ ; 
++ current5_ ; 
} 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 4416) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_ && 
current6_ == typed_other -> current6_ && 
current7_ == typed_other -> current7_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) , 
begin6_ (other . begin6_) , 
end6_ (other . end6_) , 
current6_ (other . current6_) , 
begin7_ (other . begin7_) , 
end7_ (other . end7_) , 
current7_ (other . current7_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_ , * current6_ , * current7_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ || 
current6_ == end6_ || 
current7_ == end7_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
const typename ParamGenerator < T6 > :: iterator begin6_ ; 
const typename ParamGenerator < T6 > :: iterator end6_ ; 
typename ParamGenerator < T6 > :: iterator current6_ ; 
const typename ParamGenerator < T7 > :: iterator begin7_ ; 
const typename ParamGenerator < T7 > :: iterator end7_ ; 
typename ParamGenerator < T7 > :: iterator current7_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator7 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
const ParamGenerator < T6 > g6_ ; 
const ParamGenerator < T7 > g7_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
class CartesianProductGenerator8 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , 
T7 , T8 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > ParamType ; 

CartesianProductGenerator8 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5 , 
const ParamGenerator < T6 > & g6 , const ParamGenerator < T7 > & g7 , 
const ParamGenerator < T8 > & g8) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , 
g8_ (g8) { } 
virtual ~ CartesianProductGenerator8 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin () , g6_ , g6_ . begin () , g7_ , 
g7_ . begin () , g8_ , g8_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end () , g6_ , g6_ . end () , g7_ , g7_ . end () , g8_ , 
g8_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5 , 
const ParamGenerator < T6 > & g6 , 
const typename ParamGenerator < T6 > :: iterator & current6 , 
const ParamGenerator < T7 > & g7 , 
const typename ParamGenerator < T7 > :: iterator & current7 , 
const ParamGenerator < T8 > & g8 , 
const typename ParamGenerator < T8 > :: iterator & current8) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) , 
begin6_ (g6 . begin ()) , end6_ (g6 . end ()) , current6_ (current6) , 
begin7_ (g7 . begin ()) , end7_ (g7 . end ()) , current7_ (current7) , 
begin8_ (g8 . begin ()) , end8_ (g8 . end ()) , current8_ (current8) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 4590 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 4590 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current8_ ; 
if (current8_ == end8_) { 
current8_ = begin8_ ; 
++ current7_ ; 
} 
if (current7_ == end7_) { 
current7_ = begin7_ ; 
++ current6_ ; 
} 
if (current6_ == end6_) { 
current6_ = begin6_ ; 
++ current5_ ; 
} 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 4629) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_ && 
current6_ == typed_other -> current6_ && 
current7_ == typed_other -> current7_ && 
current8_ == typed_other -> current8_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) , 
begin6_ (other . begin6_) , 
end6_ (other . end6_) , 
current6_ (other . current6_) , 
begin7_ (other . begin7_) , 
end7_ (other . end7_) , 
current7_ (other . current7_) , 
begin8_ (other . begin8_) , 
end8_ (other . end8_) , 
current8_ (other . current8_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_ , * current6_ , * current7_ , * current8_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ || 
current6_ == end6_ || 
current7_ == end7_ || 
current8_ == end8_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
const typename ParamGenerator < T6 > :: iterator begin6_ ; 
const typename ParamGenerator < T6 > :: iterator end6_ ; 
typename ParamGenerator < T6 > :: iterator current6_ ; 
const typename ParamGenerator < T7 > :: iterator begin7_ ; 
const typename ParamGenerator < T7 > :: iterator end7_ ; 
typename ParamGenerator < T7 > :: iterator current7_ ; 
const typename ParamGenerator < T8 > :: iterator begin8_ ; 
const typename ParamGenerator < T8 > :: iterator end8_ ; 
typename ParamGenerator < T8 > :: iterator current8_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator8 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
const ParamGenerator < T6 > g6_ ; 
const ParamGenerator < T7 > g7_ ; 
const ParamGenerator < T8 > g8_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
class CartesianProductGenerator9 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , 
T7 , T8 , T9 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > ParamType ; 

CartesianProductGenerator9 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5 , 
const ParamGenerator < T6 > & g6 , const ParamGenerator < T7 > & g7 , 
const ParamGenerator < T8 > & g8 , const ParamGenerator < T9 > & g9) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , g8_ (g8) , 
g9_ (g9) { } 
virtual ~ CartesianProductGenerator9 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin () , g6_ , g6_ . begin () , g7_ , 
g7_ . begin () , g8_ , g8_ . begin () , g9_ , g9_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end () , g6_ , g6_ . end () , g7_ , g7_ . end () , g8_ , 
g8_ . end () , g9_ , g9_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5 , 
const ParamGenerator < T6 > & g6 , 
const typename ParamGenerator < T6 > :: iterator & current6 , 
const ParamGenerator < T7 > & g7 , 
const typename ParamGenerator < T7 > :: iterator & current7 , 
const ParamGenerator < T8 > & g8 , 
const typename ParamGenerator < T8 > :: iterator & current8 , 
const ParamGenerator < T9 > & g9 , 
const typename ParamGenerator < T9 > :: iterator & current9) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) , 
begin6_ (g6 . begin ()) , end6_ (g6 . end ()) , current6_ (current6) , 
begin7_ (g7 . begin ()) , end7_ (g7 . end ()) , current7_ (current7) , 
begin8_ (g8 . begin ()) , end8_ (g8 . end ()) , current8_ (current8) , 
begin9_ (g9 . begin ()) , end9_ (g9 . end ()) , current9_ (current9) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 4815 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 4815 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current9_ ; 
if (current9_ == end9_) { 
current9_ = begin9_ ; 
++ current8_ ; 
} 
if (current8_ == end8_) { 
current8_ = begin8_ ; 
++ current7_ ; 
} 
if (current7_ == end7_) { 
current7_ = begin7_ ; 
++ current6_ ; 
} 
if (current6_ == end6_) { 
current6_ = begin6_ ; 
++ current5_ ; 
} 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 4858) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_ && 
current6_ == typed_other -> current6_ && 
current7_ == typed_other -> current7_ && 
current8_ == typed_other -> current8_ && 
current9_ == typed_other -> current9_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) , 
begin6_ (other . begin6_) , 
end6_ (other . end6_) , 
current6_ (other . current6_) , 
begin7_ (other . begin7_) , 
end7_ (other . end7_) , 
current7_ (other . current7_) , 
begin8_ (other . begin8_) , 
end8_ (other . end8_) , 
current8_ (other . current8_) , 
begin9_ (other . begin9_) , 
end9_ (other . end9_) , 
current9_ (other . current9_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_ , * current6_ , * current7_ , * current8_ , 
* current9_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ || 
current6_ == end6_ || 
current7_ == end7_ || 
current8_ == end8_ || 
current9_ == end9_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
const typename ParamGenerator < T6 > :: iterator begin6_ ; 
const typename ParamGenerator < T6 > :: iterator end6_ ; 
typename ParamGenerator < T6 > :: iterator current6_ ; 
const typename ParamGenerator < T7 > :: iterator begin7_ ; 
const typename ParamGenerator < T7 > :: iterator end7_ ; 
typename ParamGenerator < T7 > :: iterator current7_ ; 
const typename ParamGenerator < T8 > :: iterator begin8_ ; 
const typename ParamGenerator < T8 > :: iterator end8_ ; 
typename ParamGenerator < T8 > :: iterator current8_ ; 
const typename ParamGenerator < T9 > :: iterator begin9_ ; 
const typename ParamGenerator < T9 > :: iterator end9_ ; 
typename ParamGenerator < T9 > :: iterator current9_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator9 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
const ParamGenerator < T6 > g6_ ; 
const ParamGenerator < T7 > g7_ ; 
const ParamGenerator < T8 > g8_ ; 
const ParamGenerator < T9 > g9_ ; 
} ;


template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
class CartesianProductGenerator10 
: public ParamGeneratorInterface < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , 
T7 , T8 , T9 , T10 > > { 
public : 
typedef :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > ParamType ; 

CartesianProductGenerator10 (const ParamGenerator < T1 > & g1 , 
const ParamGenerator < T2 > & g2 , const ParamGenerator < T3 > & g3 , 
const ParamGenerator < T4 > & g4 , const ParamGenerator < T5 > & g5 , 
const ParamGenerator < T6 > & g6 , const ParamGenerator < T7 > & g7 , 
const ParamGenerator < T8 > & g8 , const ParamGenerator < T9 > & g9 , 
const ParamGenerator < T10 > & g10) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , g8_ (g8) , 
g9_ (g9) , g10_ (g10) { } 
virtual ~ CartesianProductGenerator10 () { } 

virtual ParamIteratorInterface < ParamType > * Begin () const { 
return new Iterator (this , g1_ , g1_ . begin () , g2_ , g2_ . begin () , g3_ , 
g3_ . begin () , g4_ , g4_ . begin () , g5_ , g5_ . begin () , g6_ , g6_ . begin () , g7_ , 
g7_ . begin () , g8_ , g8_ . begin () , g9_ , g9_ . begin () , g10_ , g10_ . begin ()) ; 
} 
virtual ParamIteratorInterface < ParamType > * End () const { 
return new Iterator (this , g1_ , g1_ . end () , g2_ , g2_ . end () , g3_ , g3_ . end () , 
g4_ , g4_ . end () , g5_ , g5_ . end () , g6_ , g6_ . end () , g7_ , g7_ . end () , g8_ , 
g8_ . end () , g9_ , g9_ . end () , g10_ , g10_ . end ()) ; 
} 

private : 
class Iterator : public ParamIteratorInterface < ParamType > { 
public : 
Iterator (const ParamGeneratorInterface < ParamType > * base , 
const ParamGenerator < T1 > & g1 , 
const typename ParamGenerator < T1 > :: iterator & current1 , 
const ParamGenerator < T2 > & g2 , 
const typename ParamGenerator < T2 > :: iterator & current2 , 
const ParamGenerator < T3 > & g3 , 
const typename ParamGenerator < T3 > :: iterator & current3 , 
const ParamGenerator < T4 > & g4 , 
const typename ParamGenerator < T4 > :: iterator & current4 , 
const ParamGenerator < T5 > & g5 , 
const typename ParamGenerator < T5 > :: iterator & current5 , 
const ParamGenerator < T6 > & g6 , 
const typename ParamGenerator < T6 > :: iterator & current6 , 
const ParamGenerator < T7 > & g7 , 
const typename ParamGenerator < T7 > :: iterator & current7 , 
const ParamGenerator < T8 > & g8 , 
const typename ParamGenerator < T8 > :: iterator & current8 , 
const ParamGenerator < T9 > & g9 , 
const typename ParamGenerator < T9 > :: iterator & current9 , 
const ParamGenerator < T10 > & g10 , 
const typename ParamGenerator < T10 > :: iterator & current10) 
: base_ (base) , 
begin1_ (g1 . begin ()) , end1_ (g1 . end ()) , current1_ (current1) , 
begin2_ (g2 . begin ()) , end2_ (g2 . end ()) , current2_ (current2) , 
begin3_ (g3 . begin ()) , end3_ (g3 . end ()) , current3_ (current3) , 
begin4_ (g4 . begin ()) , end4_ (g4 . end ()) , current4_ (current4) , 
begin5_ (g5 . begin ()) , end5_ (g5 . end ()) , current5_ (current5) , 
begin6_ (g6 . begin ()) , end6_ (g6 . end ()) , current6_ (current6) , 
begin7_ (g7 . begin ()) , end7_ (g7 . end ()) , current7_ (current7) , 
begin8_ (g8 . begin ()) , end8_ (g8 . end ()) , current8_ (current8) , 
begin9_ (g9 . begin ()) , end9_ (g9 . end ()) , current9_ (current9) , 
begin10_ (g10 . begin ()) , end10_ (g10 . end ()) , current10_ (current10) { 
ComputeCurrentValue () ; 
} 
virtual ~ Iterator () { } 

virtual const ParamGeneratorInterface < ParamType > * BaseGenerator () const { 
return base_ ; 
} 


virtual void Advance () { 
# 5058 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" 3
((void) 0) 
# 5058 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
; 
++ current10_ ; 
if (current10_ == end10_) { 
current10_ = begin10_ ; 
++ current9_ ; 
} 
if (current9_ == end9_) { 
current9_ = begin9_ ; 
++ current8_ ; 
} 
if (current8_ == end8_) { 
current8_ = begin8_ ; 
++ current7_ ; 
} 
if (current7_ == end7_) { 
current7_ = begin7_ ; 
++ current6_ ; 
} 
if (current6_ == end6_) { 
current6_ = begin6_ ; 
++ current5_ ; 
} 
if (current5_ == end5_) { 
current5_ = begin5_ ; 
++ current4_ ; 
} 
if (current4_ == end4_) { 
current4_ = begin4_ ; 
++ current3_ ; 
} 
if (current3_ == end3_) { 
current3_ = begin3_ ; 
++ current2_ ; 
} 
if (current2_ == end2_) { 
current2_ = begin2_ ; 
++ current1_ ; 
} 
ComputeCurrentValue () ; 
} 
virtual ParamIteratorInterface < ParamType > * Clone () const { 
return new Iterator (* this) ; 
} 
virtual const ParamType * Current () const { return current_value_ . get () ; } 
virtual bool Equals (const ParamIteratorInterface < ParamType > & other) const { 


switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (BaseGenerator () == other . BaseGenerator ())) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h" , 5105) . GetStream () << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. " 
<< "The program attempted to compare iterators " 
<< "from different generators." << std :: endl ; 
const Iterator * typed_other = 
CheckedDowncastToActualType < const Iterator > (& other) ; 



return (AtEnd () && typed_other -> AtEnd ()) || 
(
current1_ == typed_other -> current1_ && 
current2_ == typed_other -> current2_ && 
current3_ == typed_other -> current3_ && 
current4_ == typed_other -> current4_ && 
current5_ == typed_other -> current5_ && 
current6_ == typed_other -> current6_ && 
current7_ == typed_other -> current7_ && 
current8_ == typed_other -> current8_ && 
current9_ == typed_other -> current9_ && 
current10_ == typed_other -> current10_) ; 
} 

private : 
Iterator (const Iterator & other) 
: base_ (other . base_) , 
begin1_ (other . begin1_) , 
end1_ (other . end1_) , 
current1_ (other . current1_) , 
begin2_ (other . begin2_) , 
end2_ (other . end2_) , 
current2_ (other . current2_) , 
begin3_ (other . begin3_) , 
end3_ (other . end3_) , 
current3_ (other . current3_) , 
begin4_ (other . begin4_) , 
end4_ (other . end4_) , 
current4_ (other . current4_) , 
begin5_ (other . begin5_) , 
end5_ (other . end5_) , 
current5_ (other . current5_) , 
begin6_ (other . begin6_) , 
end6_ (other . end6_) , 
current6_ (other . current6_) , 
begin7_ (other . begin7_) , 
end7_ (other . end7_) , 
current7_ (other . current7_) , 
begin8_ (other . begin8_) , 
end8_ (other . end8_) , 
current8_ (other . current8_) , 
begin9_ (other . begin9_) , 
end9_ (other . end9_) , 
current9_ (other . current9_) , 
begin10_ (other . begin10_) , 
end10_ (other . end10_) , 
current10_ (other . current10_) { 
ComputeCurrentValue () ; 
} 

void ComputeCurrentValue () { 
if (! AtEnd ()) 
current_value_ . reset (new ParamType (* current1_ , * current2_ , * current3_ , 
* current4_ , * current5_ , * current6_ , * current7_ , * current8_ , 
* current9_ , * current10_)) ; 
} 
bool AtEnd () const { 


return 
current1_ == end1_ || 
current2_ == end2_ || 
current3_ == end3_ || 
current4_ == end4_ || 
current5_ == end5_ || 
current6_ == end6_ || 
current7_ == end7_ || 
current8_ == end8_ || 
current9_ == end9_ || 
current10_ == end10_ ; 
} 


void operator = (const Iterator & other) ; 

const ParamGeneratorInterface < ParamType > * const base_ ; 


const typename ParamGenerator < T1 > :: iterator begin1_ ; 
const typename ParamGenerator < T1 > :: iterator end1_ ; 
typename ParamGenerator < T1 > :: iterator current1_ ; 
const typename ParamGenerator < T2 > :: iterator begin2_ ; 
const typename ParamGenerator < T2 > :: iterator end2_ ; 
typename ParamGenerator < T2 > :: iterator current2_ ; 
const typename ParamGenerator < T3 > :: iterator begin3_ ; 
const typename ParamGenerator < T3 > :: iterator end3_ ; 
typename ParamGenerator < T3 > :: iterator current3_ ; 
const typename ParamGenerator < T4 > :: iterator begin4_ ; 
const typename ParamGenerator < T4 > :: iterator end4_ ; 
typename ParamGenerator < T4 > :: iterator current4_ ; 
const typename ParamGenerator < T5 > :: iterator begin5_ ; 
const typename ParamGenerator < T5 > :: iterator end5_ ; 
typename ParamGenerator < T5 > :: iterator current5_ ; 
const typename ParamGenerator < T6 > :: iterator begin6_ ; 
const typename ParamGenerator < T6 > :: iterator end6_ ; 
typename ParamGenerator < T6 > :: iterator current6_ ; 
const typename ParamGenerator < T7 > :: iterator begin7_ ; 
const typename ParamGenerator < T7 > :: iterator end7_ ; 
typename ParamGenerator < T7 > :: iterator current7_ ; 
const typename ParamGenerator < T8 > :: iterator begin8_ ; 
const typename ParamGenerator < T8 > :: iterator end8_ ; 
typename ParamGenerator < T8 > :: iterator current8_ ; 
const typename ParamGenerator < T9 > :: iterator begin9_ ; 
const typename ParamGenerator < T9 > :: iterator end9_ ; 
typename ParamGenerator < T9 > :: iterator current9_ ; 
const typename ParamGenerator < T10 > :: iterator begin10_ ; 
const typename ParamGenerator < T10 > :: iterator end10_ ; 
typename ParamGenerator < T10 > :: iterator current10_ ; 
linked_ptr < ParamType > current_value_ ; 
} ; 


void operator = (const CartesianProductGenerator10 & other) ; 

const ParamGenerator < T1 > g1_ ; 
const ParamGenerator < T2 > g2_ ; 
const ParamGenerator < T3 > g3_ ; 
const ParamGenerator < T4 > g4_ ; 
const ParamGenerator < T5 > g5_ ; 
const ParamGenerator < T6 > g6_ ; 
const ParamGenerator < T7 > g7_ ; 
const ParamGenerator < T8 > g8_ ; 
const ParamGenerator < T9 > g9_ ; 
const ParamGenerator < T10 > g10_ ; 
} ;
# 5246 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/internal/gtest-param-util-generated.h"
template < class Generator1 , class Generator2 > 
class CartesianProductHolder2 { 
public : 
CartesianProductHolder2 (const Generator1 & g1 , const Generator2 & g2) 
: g1_ (g1) , g2_ (g2) { } 
template < typename T1 , typename T2 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 > > (
new CartesianProductGenerator2 < T1 , T2 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_))) ; 
} 

private : 

void operator = (const CartesianProductHolder2 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 > 
class CartesianProductHolder3 { 
public : 
CartesianProductHolder3 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) { } 
template < typename T1 , typename T2 , typename T3 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 > > (
new CartesianProductGenerator3 < T1 , T2 , T3 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_))) ; 
} 

private : 

void operator = (const CartesianProductHolder3 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 > 
class CartesianProductHolder4 { 
public : 
CartesianProductHolder4 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 > > (
new CartesianProductGenerator4 < T1 , T2 , T3 , T4 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_))) ; 
} 

private : 

void operator = (const CartesianProductHolder4 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 > 
class CartesianProductHolder5 { 
public : 
CartesianProductHolder5 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 > > (
new CartesianProductGenerator5 < T1 , T2 , T3 , T4 , T5 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_))) ; 
} 

private : 

void operator = (const CartesianProductHolder5 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 , class Generator6 > 
class CartesianProductHolder6 { 
public : 
CartesianProductHolder6 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5 , 
const Generator6 & g6) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 > > (
new CartesianProductGenerator6 < T1 , T2 , T3 , T4 , T5 , T6 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_) , 
static_cast < ParamGenerator < T6 > > (g6_))) ; 
} 

private : 

void operator = (const CartesianProductHolder6 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
const Generator6 g6_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 , class Generator6 , class Generator7 > 
class CartesianProductHolder7 { 
public : 
CartesianProductHolder7 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5 , 
const Generator6 & g6 , const Generator7 & g7) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , 
T7 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 > > (
new CartesianProductGenerator7 < T1 , T2 , T3 , T4 , T5 , T6 , T7 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_) , 
static_cast < ParamGenerator < T6 > > (g6_) , 
static_cast < ParamGenerator < T7 > > (g7_))) ; 
} 

private : 

void operator = (const CartesianProductHolder7 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
const Generator6 g6_ ; 
const Generator7 g7_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 , class Generator6 , class Generator7 , 
class Generator8 > 
class CartesianProductHolder8 { 
public : 
CartesianProductHolder8 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5 , 
const Generator6 & g6 , const Generator7 & g7 , const Generator8 & g8) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , 
g8_ (g8) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , 
T8 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > > (
new CartesianProductGenerator8 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_) , 
static_cast < ParamGenerator < T6 > > (g6_) , 
static_cast < ParamGenerator < T7 > > (g7_) , 
static_cast < ParamGenerator < T8 > > (g8_))) ; 
} 

private : 

void operator = (const CartesianProductHolder8 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
const Generator6 g6_ ; 
const Generator7 g7_ ; 
const Generator8 g8_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 , class Generator6 , class Generator7 , 
class Generator8 , class Generator9 > 
class CartesianProductHolder9 { 
public : 
CartesianProductHolder9 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5 , 
const Generator6 & g6 , const Generator7 & g7 , const Generator8 & g8 , 
const Generator9 & g9) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , g8_ (g8) , 
g9_ (g9) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , 
T9 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , 
T9 > > (
new CartesianProductGenerator9 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_) , 
static_cast < ParamGenerator < T6 > > (g6_) , 
static_cast < ParamGenerator < T7 > > (g7_) , 
static_cast < ParamGenerator < T8 > > (g8_) , 
static_cast < ParamGenerator < T9 > > (g9_))) ; 
} 

private : 

void operator = (const CartesianProductHolder9 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
const Generator6 g6_ ; 
const Generator7 g7_ ; 
const Generator8 g8_ ; 
const Generator9 g9_ ; 
} ;

template < class Generator1 , class Generator2 , class Generator3 , 
class Generator4 , class Generator5 , class Generator6 , class Generator7 , 
class Generator8 , class Generator9 , class Generator10 > 
class CartesianProductHolder10 { 
public : 
CartesianProductHolder10 (const Generator1 & g1 , const Generator2 & g2 , 
const Generator3 & g3 , const Generator4 & g4 , const Generator5 & g5 , 
const Generator6 & g6 , const Generator7 & g7 , const Generator8 & g8 , 
const Generator9 & g9 , const Generator10 & g10) 
: g1_ (g1) , g2_ (g2) , g3_ (g3) , g4_ (g4) , g5_ (g5) , g6_ (g6) , g7_ (g7) , g8_ (g8) , 
g9_ (g9) , g10_ (g10) { } 
template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
operator ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , 
T10 > > () const { 
return ParamGenerator < :: testing :: tuple < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , 
T10 > > (
new CartesianProductGenerator10 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , 
T10 > (
static_cast < ParamGenerator < T1 > > (g1_) , 
static_cast < ParamGenerator < T2 > > (g2_) , 
static_cast < ParamGenerator < T3 > > (g3_) , 
static_cast < ParamGenerator < T4 > > (g4_) , 
static_cast < ParamGenerator < T5 > > (g5_) , 
static_cast < ParamGenerator < T6 > > (g6_) , 
static_cast < ParamGenerator < T7 > > (g7_) , 
static_cast < ParamGenerator < T8 > > (g8_) , 
static_cast < ParamGenerator < T9 > > (g9_) , 
static_cast < ParamGenerator < T10 > > (g10_))) ; 
} 

private : 

void operator = (const CartesianProductHolder10 & other) ; 

const Generator1 g1_ ; 
const Generator2 g2_ ; 
const Generator3 g3_ ; 
const Generator4 g4_ ; 
const Generator5 g5_ ; 
const Generator6 g6_ ; 
const Generator7 g7_ ; 
const Generator8 g8_ ; 
const Generator9 g9_ ; 
const Generator10 g10_ ; 
} ;



}
}
# 191 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
namespace testing { 
# 235 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
template < typename T , typename IncrementT > 
internal :: ParamGenerator < T > Range (T start , T end , IncrementT step) { 
return internal :: ParamGenerator < T > (
new internal :: RangeGenerator < T , IncrementT > (start , end , step)) ; 
} 

template < typename T > 
internal :: ParamGenerator < T > Range (T start , T end) { 
return Range (start , end , 1) ; 
} 
# 301 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
template < typename ForwardIterator > 
internal :: ParamGenerator < 
typename :: testing :: internal :: IteratorTraits < ForwardIterator > :: value_type > 
ValuesIn (ForwardIterator begin , ForwardIterator end) { 
typedef typename :: testing :: internal :: IteratorTraits < ForwardIterator > 
:: value_type ParamType ; 
return internal :: ParamGenerator < ParamType > (
new internal :: ValuesInIteratorRangeGenerator < ParamType > (begin , end)) ; 
} 

template < typename T , size_t N > 
internal :: ParamGenerator < T > ValuesIn (const T (& array) [ N ]) { 
return ValuesIn (array , array + N) ; 
} 

template < class Container > 
internal :: ParamGenerator < typename Container :: value_type > ValuesIn (
const Container & container) { 
return ValuesIn (container . begin () , container . end ()) ; 
} 
# 341 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
template < typename T1 > 
internal :: ValueArray1 < T1 > Values (T1 v1) { 
return internal :: ValueArray1 < T1 > (v1) ; 
} 

template < typename T1 , typename T2 > 
internal :: ValueArray2 < T1 , T2 > Values (T1 v1 , T2 v2) { 
return internal :: ValueArray2 < T1 , T2 > (v1 , v2) ; 
} 

template < typename T1 , typename T2 , typename T3 > 
internal :: ValueArray3 < T1 , T2 , T3 > Values (T1 v1 , T2 v2 , T3 v3) { 
return internal :: ValueArray3 < T1 , T2 , T3 > (v1 , v2 , v3) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 > 
internal :: ValueArray4 < T1 , T2 , T3 , T4 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4) { 
return internal :: ValueArray4 < T1 , T2 , T3 , T4 > (v1 , v2 , v3 , v4) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > 
internal :: ValueArray5 < T1 , T2 , T3 , T4 , T5 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5) { 
return internal :: ValueArray5 < T1 , T2 , T3 , T4 , T5 > (v1 , v2 , v3 , v4 , v5) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 > 
internal :: ValueArray6 < T1 , T2 , T3 , T4 , T5 , T6 > Values (T1 v1 , T2 v2 , T3 v3 , 
T4 v4 , T5 v5 , T6 v6) { 
return internal :: ValueArray6 < T1 , T2 , T3 , T4 , T5 , T6 > (v1 , v2 , v3 , v4 , v5 , v6) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 > 
internal :: ValueArray7 < T1 , T2 , T3 , T4 , T5 , T6 , T7 > Values (T1 v1 , T2 v2 , T3 v3 , 
T4 v4 , T5 v5 , T6 v6 , T7 v7) { 
return internal :: ValueArray7 < T1 , T2 , T3 , T4 , T5 , T6 , T7 > (v1 , v2 , v3 , v4 , v5 , 
v6 , v7) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 > 
internal :: ValueArray8 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8) { 
return internal :: ValueArray8 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 > (v1 , v2 , v3 , v4 , 
v5 , v6 , v7 , v8) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 > 
internal :: ValueArray9 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9) { 
return internal :: ValueArray9 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 > (v1 , v2 , v3 , 
v4 , v5 , v6 , v7 , v8 , v9) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 > 
internal :: ValueArray10 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > Values (T1 v1 , 
T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10) { 
return internal :: ValueArray10 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 > (v1 , 
v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 > 
internal :: ValueArray11 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , 
T11 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11) { 
return internal :: ValueArray11 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , 
T11 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 > 
internal :: ValueArray12 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12) { 
return internal :: ValueArray12 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 > 
internal :: ValueArray13 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , 
T13 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13) { 
return internal :: ValueArray13 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 > 
internal :: ValueArray14 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14) { 
return internal :: ValueArray14 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , 
v14) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 > 
internal :: ValueArray15 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , 
T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15) { 
return internal :: ValueArray15 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , 
v13 , v14 , v15) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 > 
internal :: ValueArray16 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16) { 
return internal :: ValueArray16 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , 
v12 , v13 , v14 , v15 , v16) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 > 
internal :: ValueArray17 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17) { 
return internal :: ValueArray17 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , 
v11 , v12 , v13 , v14 , v15 , v16 , v17) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 > 
internal :: ValueArray18 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , 
T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18) { 
return internal :: ValueArray18 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , 
v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 > 
internal :: ValueArray19 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , 
T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , 
T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19) { 
return internal :: ValueArray19 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , 
v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 > 
internal :: ValueArray20 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , 
T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20) { 
return internal :: ValueArray20 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , 
v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 > 
internal :: ValueArray21 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , 
T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21) { 
return internal :: ValueArray21 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 > (v1 , v2 , v3 , v4 , v5 , v6 , 
v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 > 
internal :: ValueArray22 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 > Values (T1 v1 , T2 v2 , T3 v3 , 
T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22) { 
return internal :: ValueArray22 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 > (v1 , v2 , v3 , v4 , 
v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , 
v20 , v21 , v22) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 > 
internal :: ValueArray23 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22 , T23 v23) { 
return internal :: ValueArray23 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 > (v1 , v2 , v3 , 
v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , 
v20 , v21 , v22 , v23) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 > 
internal :: ValueArray24 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22 , T23 v23 , T24 v24) { 
return internal :: ValueArray24 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 > (v1 , v2 , 
v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , 
v19 , v20 , v21 , v22 , v23 , v24) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 > 
internal :: ValueArray25 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > Values (T1 v1 , 
T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , 
T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , 
T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25) { 
return internal :: ValueArray25 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 > (v1 , 
v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , 
v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 > 
internal :: ValueArray26 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26) { 
return internal :: ValueArray26 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , 
v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 > 
internal :: ValueArray27 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , 
T27 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27) { 
return internal :: ValueArray27 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , 
v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 > 
internal :: ValueArray28 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , 
T28 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28) { 
return internal :: ValueArray28 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , 
v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , 
v28) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 > 
internal :: ValueArray29 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29) { 
return internal :: ValueArray29 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , 
v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , 
v27 , v28 , v29) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 > 
internal :: ValueArray30 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , 
T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , 
T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , 
T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30) { 
return internal :: ValueArray30 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , 
v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , 
v26 , v27 , v28 , v29 , v30) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 > 
internal :: ValueArray31 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31) { 
return internal :: ValueArray31 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , 
v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , 
v25 , v26 , v27 , v28 , v29 , v30 , v31) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 > 
internal :: ValueArray32 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , 
T32 v32) { 
return internal :: ValueArray32 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , 
v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , 
v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 > 
internal :: ValueArray33 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , 
T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , 
T32 v32 , T33 v33) { 
return internal :: ValueArray33 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , 
v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , 
v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 > 
internal :: ValueArray34 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , 
T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , 
T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , 
T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , 
T31 v31 , T32 v32 , T33 v33 , T34 v34) { 
return internal :: ValueArray34 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , 
v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , 
v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 > 
internal :: ValueArray35 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , 
T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , 
T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , 
T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35) { 
return internal :: ValueArray35 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 > (v1 , v2 , v3 , v4 , v5 , v6 , 
v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , 
v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 > 
internal :: ValueArray36 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , 
T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , 
T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , 
T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36) { 
return internal :: ValueArray36 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 > (v1 , v2 , v3 , v4 , 
v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , 
v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , 
v34 , v35 , v36) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 > 
internal :: ValueArray37 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > Values (T1 v1 , T2 v2 , T3 v3 , 
T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , 
T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , 
T37 v37) { 
return internal :: ValueArray37 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 > (v1 , v2 , v3 , 
v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , 
v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , 
v34 , v35 , v36 , v37) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 > 
internal :: ValueArray38 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , 
T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , 
T37 v37 , T38 v38) { 
return internal :: ValueArray38 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 > (v1 , v2 , 
v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , 
v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , 
v33 , v34 , v35 , v36 , v37 , v38) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 > 
internal :: ValueArray39 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > Values (T1 v1 , T2 v2 , 
T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , 
T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , 
T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , 
T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , 
T37 v37 , T38 v38 , T39 v39) { 
return internal :: ValueArray39 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 > (v1 , 
v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , 
v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , 
v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 > 
internal :: ValueArray40 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 > Values (T1 v1 , 
T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , 
T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , 
T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , 
T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , 
T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40) { 
return internal :: ValueArray40 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , 
v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , 
v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 > 
internal :: ValueArray41 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , 
T41 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41) { 
return internal :: ValueArray41 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , 
v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , 
v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40 , v41) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 > 
internal :: ValueArray42 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , 
T42 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42) { 
return internal :: ValueArray42 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , 
v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , 
v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40 , v41 , 
v42) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 > 
internal :: ValueArray43 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , 
T43 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43) { 
return internal :: ValueArray43 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , 
v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , 
v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40 , 
v41 , v42 , v43) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 > 
internal :: ValueArray44 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , 
T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , T17 v17 , 
T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , T25 v25 , 
T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , T33 v33 , 
T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , T41 v41 , 
T42 v42 , T43 v43 , T44 v44) { 
return internal :: ValueArray44 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , 
v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , 
v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , 
v40 , v41 , v42 , v43 , v44) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 > 
internal :: ValueArray45 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , T8 v8 , 
T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , T16 v16 , 
T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , T24 v24 , 
T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , T32 v32 , 
T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , T40 v40 , 
T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45) { 
return internal :: ValueArray45 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , 
v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , 
v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , 
v39 , v40 , v41 , v42 , v43 , v44 , v45) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 > 
internal :: ValueArray46 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , 
T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , 
T40 v40 , T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46) { 
return internal :: ValueArray46 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 , T46 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , 
v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , 
v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , 
v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 > 
internal :: ValueArray47 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , T7 v7 , 
T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , 
T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , 
T40 v40 , T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47) { 
return internal :: ValueArray47 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , 
v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , 
v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , 
v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 > 
internal :: ValueArray48 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , T6 v6 , 
T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , T15 v15 , 
T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , T23 v23 , 
T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , T31 v31 , 
T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , T39 v39 , 
T40 v40 , T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , T47 v47 , 
T48 v48) { 
return internal :: ValueArray48 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 > (v1 , v2 , v3 , v4 , v5 , v6 , v7 , 
v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , 
v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , 
v37 , v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47 , v48) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 > 
internal :: ValueArray49 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 , T49 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , T5 v5 , 
T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , T14 v14 , 
T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , T22 v22 , 
T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , T30 v30 , 
T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , T38 v38 , 
T39 v39 , T40 v40 , T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45 , T46 v46 , 
T47 v47 , T48 v48 , T49 v49) { 
return internal :: ValueArray49 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 > (v1 , v2 , v3 , v4 , v5 , v6 , 
v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , 
v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , 
v36 , v37 , v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47 , v48 , v49) ; 
} 

template < typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , 
typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , 
typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , 
typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , 
typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , 
typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , 
typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , 
typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , 
typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , 
typename T46 , typename T47 , typename T48 , typename T49 , typename T50 > 
internal :: ValueArray50 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , 
T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , 
T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , 
T44 , T45 , T46 , T47 , T48 , T49 , T50 > Values (T1 v1 , T2 v2 , T3 v3 , T4 v4 , 
T5 v5 , T6 v6 , T7 v7 , T8 v8 , T9 v9 , T10 v10 , T11 v11 , T12 v12 , T13 v13 , 
T14 v14 , T15 v15 , T16 v16 , T17 v17 , T18 v18 , T19 v19 , T20 v20 , T21 v21 , 
T22 v22 , T23 v23 , T24 v24 , T25 v25 , T26 v26 , T27 v27 , T28 v28 , T29 v29 , 
T30 v30 , T31 v31 , T32 v32 , T33 v33 , T34 v34 , T35 v35 , T36 v36 , T37 v37 , 
T38 v38 , T39 v39 , T40 v40 , T41 v41 , T42 v42 , T43 v43 , T44 v44 , T45 v45 , 
T46 v46 , T47 v47 , T48 v48 , T49 v49 , T50 v50) { 
return internal :: ValueArray50 < T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , 
T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , 
T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , 
T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49 , T50 > (v1 , v2 , v3 , v4 , 
v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , 
v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , 
v34 , v35 , v36 , v37 , v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47 , 
v48 , v49 , v50) ; 
} 
# 1214 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
inline internal::ParamGenerator< bool>  Bool() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(167 + 0 + 1U - 1);
return (Values(false, true)); 
} 
# 1267 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
template < typename Generator1 , typename Generator2 > 
internal :: CartesianProductHolder2 < Generator1 , Generator2 > Combine (
const Generator1 & g1 , const Generator2 & g2) { 
return internal :: CartesianProductHolder2 < Generator1 , Generator2 > (
g1 , g2) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 > 
internal :: CartesianProductHolder3 < Generator1 , Generator2 , Generator3 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3) { 
return internal :: CartesianProductHolder3 < Generator1 , Generator2 , Generator3 > (
g1 , g2 , g3) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 > 
internal :: CartesianProductHolder4 < Generator1 , Generator2 , Generator3 , 
Generator4 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4) { 
return internal :: CartesianProductHolder4 < Generator1 , Generator2 , Generator3 , 
Generator4 > (
g1 , g2 , g3 , g4) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 > 
internal :: CartesianProductHolder5 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5) { 
return internal :: CartesianProductHolder5 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 > (
g1 , g2 , g3 , g4 , g5) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 , typename Generator6 > 
internal :: CartesianProductHolder6 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5 , const Generator6 & g6) { 
return internal :: CartesianProductHolder6 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 > (
g1 , g2 , g3 , g4 , g5 , g6) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 , typename Generator6 , 
typename Generator7 > 
internal :: CartesianProductHolder7 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5 , const Generator6 & g6 , 
const Generator7 & g7) { 
return internal :: CartesianProductHolder7 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 > (
g1 , g2 , g3 , g4 , g5 , g6 , g7) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 , typename Generator6 , 
typename Generator7 , typename Generator8 > 
internal :: CartesianProductHolder8 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5 , const Generator6 & g6 , 
const Generator7 & g7 , const Generator8 & g8) { 
return internal :: CartesianProductHolder8 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 > (
g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 , typename Generator6 , 
typename Generator7 , typename Generator8 , typename Generator9 > 
internal :: CartesianProductHolder9 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 , 
Generator9 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5 , const Generator6 & g6 , 
const Generator7 & g7 , const Generator8 & g8 , const Generator9 & g9) { 
return internal :: CartesianProductHolder9 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 , Generator9 > (
g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9) ; 
} 

template < typename Generator1 , typename Generator2 , typename Generator3 , 
typename Generator4 , typename Generator5 , typename Generator6 , 
typename Generator7 , typename Generator8 , typename Generator9 , 
typename Generator10 > 
internal :: CartesianProductHolder10 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 , Generator9 , 
Generator10 > Combine (
const Generator1 & g1 , const Generator2 & g2 , const Generator3 & g3 , 
const Generator4 & g4 , const Generator5 & g5 , const Generator6 & g6 , 
const Generator7 & g7 , const Generator8 & g8 , const Generator9 & g9 , 
const Generator10 & g10) { 
return internal :: CartesianProductHolder10 < Generator1 , Generator2 , Generator3 , 
Generator4 , Generator5 , Generator6 , Generator7 , Generator8 , Generator9 , 
Generator10 > (
g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , g10) ; 
} 
# 1432 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-param-test.h"
}
# 43 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-test-part.h"
namespace testing { 
# 49
class __attribute((visibility("default"))) TestPartResult { 



public: enum Type { 
kSuccess, 
kNonFatalFailure, 
kFatalFailure, 
kSkip
}; 




TestPartResult(Type a_type, const char *a_file_name, int a_line_number, const char *
a_message) : type_(a_type), file_name_((a_file_name == (nullptr)) ? "" : a_file_name), line_number_(a_line_number), summary_(ExtractSummary(a_message)), message_(a_message) 




{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(168 + 0 + 1U - 1);} 


Type type() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(169 + 0 + 1U - 1);return type_; } 



const char *file_name() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(170 + 0 + 1U - 1);
return (file_name_).empty() ? nullptr : (file_name_).c_str(); 
} 



int line_number() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(171 + 0 + 1U - 1);return line_number_; } 


const char *summary() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(172 + 0 + 1U - 1);return (summary_).c_str(); } 


const char *message() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(173 + 0 + 1U - 1);return (message_).c_str(); } 


bool skipped() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(174 + 0 + 1U - 1);return type_ == kSkip; } 


bool passed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(175 + 0 + 1U - 1);return type_ == kSuccess; } 


bool nonfatally_failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(176 + 0 + 1U - 1);return type_ == kNonFatalFailure; } 


bool fatally_failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(177 + 0 + 1U - 1);return type_ == kFatalFailure; } 


bool failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(178 + 0 + 1U - 1);return this->fatally_failed() || this->nonfatally_failed(); } 


private: Type type_; 



static std::string ExtractSummary(const char * message); 



std::string file_name_; 


int line_number_; 
std::string summary_; 
std::string message_; 
}; 


std::ostream &operator<<(std::ostream & os, const TestPartResult & result); 
# 129
class __attribute((visibility("default"))) TestPartResultArray { 

public: TestPartResultArray() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(179 + 0 + 1U - 1);} 


void Append(const TestPartResult & result); 


const TestPartResult &GetTestPartResult(int index) const; 


int size() const; 


private: std::vector< TestPartResult>  array_; 

TestPartResultArray(const TestPartResultArray &) = delete;void operator=(const TestPartResultArray &) = delete;
}; 


class __attribute((visibility("default"))) TestPartResultReporterInterface { 

public: virtual ~TestPartResultReporterInterface() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(180 + 0 + 1U - 1);} 

virtual void ReportTestPartResult(const TestPartResult & result) = 0; 
}; 

namespace internal { 
# 164
class __attribute((visibility("default"))) HasNewFatalFailureHelper : public TestPartResultReporterInterface { 


public: HasNewFatalFailureHelper(); 
virtual ~HasNewFatalFailureHelper(); 
virtual void ReportTestPartResult(const TestPartResult & result); 
bool has_new_fatal_failure() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(181 + 0 + 1U - 1);return has_new_fatal_failure_; } 

private: bool has_new_fatal_failure_; 
TestPartResultReporterInterface *original_reporter_; 

HasNewFatalFailureHelper(const HasNewFatalFailureHelper &) = delete;void operator=(const HasNewFatalFailureHelper &) = delete;
}; 

}

}
# 87 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
namespace testing { 
# 101 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
__attribute((visibility("default"))) extern bool FLAGS_gtest_also_run_disabled_tests; 


__attribute((visibility("default"))) extern bool FLAGS_gtest_break_on_failure; 



__attribute((visibility("default"))) extern bool FLAGS_gtest_catch_exceptions; 




__attribute((visibility("default"))) extern std::string FLAGS_gtest_color; 



__attribute((visibility("default"))) extern std::string FLAGS_gtest_filter; 



__attribute((visibility("default"))) extern bool FLAGS_gtest_install_failure_signal_handler; 



__attribute((visibility("default"))) extern bool FLAGS_gtest_list_tests; 



__attribute((visibility("default"))) extern std::string FLAGS_gtest_output; 



__attribute((visibility("default"))) extern bool FLAGS_gtest_print_time; 


__attribute((visibility("default"))) extern bool FLAGS_gtest_print_utf8; 


__attribute((visibility("default"))) extern internal::Int32 FLAGS_gtest_random_seed; 



__attribute((visibility("default"))) extern internal::Int32 FLAGS_gtest_repeat; 



__attribute((visibility("default"))) extern bool FLAGS_gtest_show_internal_stack_frames; 


__attribute((visibility("default"))) extern bool FLAGS_gtest_shuffle; 



__attribute((visibility("default"))) extern internal::Int32 FLAGS_gtest_stack_trace_depth; 




__attribute((visibility("default"))) extern bool FLAGS_gtest_throw_on_failure; 




__attribute((visibility("default"))) extern std::string FLAGS_gtest_stream_result_to; 


__attribute((visibility("default"))) extern std::string FLAGS_gtest_flagfile; 



const int kMaxStackTraceDepth = 100; 

namespace internal { 

class AssertHelper; 
class DefaultGlobalTestPartResultReporter; 
class ExecDeathTest; 
class NoExecDeathTest; 
class FinalSuccessChecker; 
class GTestFlagSaver; 
class StreamingListenerTest; 
class TestResultAccessor; 
class TestEventListenersAccessor; 
class TestEventRepeater; 
class UnitTestRecordPropertyTestHelper; 
class WindowsDeathTest; 
class FuchsiaDeathTest; 
inline UnitTestImpl *GetUnitTestImpl(); 
void ReportFailureInUnknownLocation(TestPartResult::Type result_type, const std::string & message); 


}




class Test; 
class TestCase; 
class TestInfo; 
class UnitTest; 
# 281 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class __attribute((visibility("default"))) AssertionResult { 



public: AssertionResult(const AssertionResult & other); 
# 298 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
template < typename T > 
explicit AssertionResult (
const T & success , 
typename internal :: EnableIf < 
! internal :: ImplicitlyConvertible < T , AssertionResult > :: value > :: type * 

= nullptr) 
: success_ (success) { } 
# 312
AssertionResult &operator=(AssertionResult other) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(182 + 0 + 1U - 1);
this->swap(other); cpptestFastCoverageStmt(182 + 0 + 2U - 1);
return *this; 
} 


operator bool() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(184 + 0 + 1U - 1);return success_; } 


AssertionResult operator!() const; 
# 327
const char *message() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(185 + 0 + 1U - 1);
return ((message_).get() != (nullptr)) ? message_->c_str() : (""); 
} 


const char *failure_message() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(186 + 0 + 1U - 1);return this->message(); } 


template < typename T > AssertionResult & operator << (const T & value) { 
AppendMessage (Message () << value) ; 
return * this ; 
} 



AssertionResult &operator<<(std::ostream &(*
basic_manipulator)(std::ostream & stream)) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(187 + 0 + 1U - 1);
this->AppendMessage((Message() << basic_manipulator)); cpptestFastCoverageStmt(187 + 0 + 2U - 1);
return *this; 
} 



private: void AppendMessage(const Message &a_message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(189 + 0 + 1U - 1), (message_).get() == (nullptr))) {cpptestFastCoverageStmt(189 + 0 + 2U - 1);(message_).reset(new std::string); }  cpptestFastCoverageStmt(189 + 0 + 3U - 1);
message_->append((a_message.GetString()).c_str()); 
} 


void swap(AssertionResult & other); 


bool success_; 




internal::scoped_ptr< std::__cxx11::basic_string< char> >  message_; 
}; 


__attribute((visibility("default"))) AssertionResult AssertionSuccess(); 


__attribute((visibility("default"))) AssertionResult AssertionFailure(); 



__attribute((visibility("default"))) AssertionResult AssertionFailure(const Message & msg); 

}
# 42 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
namespace testing { 
# 84 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
template < typename Pred , 
typename T1 > 
AssertionResult AssertPred1Helper (const char * pred_text , 
const char * e1 , 
Pred pred , 
const T1 & v1) { 
if (pred (v1)) return AssertionSuccess () ; 

return AssertionFailure () << pred_text << "(" 
<< e1 << ") evaluates to false, where" 
<< "\n" << e1 << " evaluates to " << v1 ; 
} 
# 125 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
template < typename Pred , 
typename T1 , 
typename T2 > 
AssertionResult AssertPred2Helper (const char * pred_text , 
const char * e1 , 
const char * e2 , 
Pred pred , 
const T1 & v1 , 
const T2 & v2) { 
if (pred (v1 , v2)) return AssertionSuccess () ; 

return AssertionFailure () << pred_text << "(" 
<< e1 << ", " 
<< e2 << ") evaluates to false, where" 
<< "\n" << e1 << " evaluates to " << v1 
<< "\n" << e2 << " evaluates to " << v2 ; 
} 
# 173 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
template < typename Pred , 
typename T1 , 
typename T2 , 
typename T3 > 
AssertionResult AssertPred3Helper (const char * pred_text , 
const char * e1 , 
const char * e2 , 
const char * e3 , 
Pred pred , 
const T1 & v1 , 
const T2 & v2 , 
const T3 & v3) { 
if (pred (v1 , v2 , v3)) return AssertionSuccess () ; 

return AssertionFailure () << pred_text << "(" 
<< e1 << ", " 
<< e2 << ", " 
<< e3 << ") evaluates to false, where" 
<< "\n" << e1 << " evaluates to " << v1 
<< "\n" << e2 << " evaluates to " << v2 
<< "\n" << e3 << " evaluates to " << v3 ; 
} 
# 228 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
template < typename Pred , 
typename T1 , 
typename T2 , 
typename T3 , 
typename T4 > 
AssertionResult AssertPred4Helper (const char * pred_text , 
const char * e1 , 
const char * e2 , 
const char * e3 , 
const char * e4 , 
Pred pred , 
const T1 & v1 , 
const T2 & v2 , 
const T3 & v3 , 
const T4 & v4) { 
if (pred (v1 , v2 , v3 , v4)) return AssertionSuccess () ; 

return AssertionFailure () << pred_text << "(" 
<< e1 << ", " 
<< e2 << ", " 
<< e3 << ", " 
<< e4 << ") evaluates to false, where" 
<< "\n" << e1 << " evaluates to " << v1 
<< "\n" << e2 << " evaluates to " << v2 
<< "\n" << e3 << " evaluates to " << v3 
<< "\n" << e4 << " evaluates to " << v4 ; 
} 
# 290 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
template < typename Pred , 
typename T1 , 
typename T2 , 
typename T3 , 
typename T4 , 
typename T5 > 
AssertionResult AssertPred5Helper (const char * pred_text , 
const char * e1 , 
const char * e2 , 
const char * e3 , 
const char * e4 , 
const char * e5 , 
Pred pred , 
const T1 & v1 , 
const T2 & v2 , 
const T3 & v3 , 
const T4 & v4 , 
const T5 & v5) { 
if (pred (v1 , v2 , v3 , v4 , v5)) return AssertionSuccess () ; 

return AssertionFailure () << pred_text << "(" 
<< e1 << ", " 
<< e2 << ", " 
<< e3 << ", " 
<< e4 << ", " 
<< e5 << ") evaluates to false, where" 
<< "\n" << e1 << " evaluates to " << v1 
<< "\n" << e2 << " evaluates to " << v2 
<< "\n" << e3 << " evaluates to " << v3 
<< "\n" << e4 << " evaluates to " << v4 
<< "\n" << e5 << " evaluates to " << v5 ; 
} 
# 357 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest_pred_impl.h"
}
# 384 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
namespace testing { 
# 409 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class __attribute((visibility("default"))) Test { 

friend class TestInfo; 



public: typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc; 
typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc; 


virtual ~Test(); 
# 427
static void SetUpTestCase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(192 + 0 + 1U - 1);} 
# 435
static void TearDownTestCase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(193 + 0 + 1U - 1);} 


static bool HasFatalFailure(); 


static bool HasNonfatalFailure(); 


static bool IsSkipped(); 



static bool HasFailure() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(194 + 0 + 1U - 1);return HasFatalFailure() || HasNonfatalFailure(); } 
# 463 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
static void RecordProperty(const std::string & key, const std::string & value); 
static void RecordProperty(const std::string & key, int value); 



protected: Test(); 


virtual void SetUp(); 


virtual void TearDown(); 




private: static bool HasSameFixtureClass(); 
# 487
virtual void TestBody() = 0; 


void Run(); 



void DeleteSelf_() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(195 + 0 + 1U - 1);delete this; } 

const internal::scoped_ptr< internal::GTestFlagSaver>  gtest_flag_saver_; 
# 514 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
struct Setup_should_be_spelled_SetUp { }; 
virtual Setup_should_be_spelled_SetUp *Setup() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(196 + 0 + 1U - 1);return nullptr; } 


Test(const Test &) = delete;void operator=(const Test &) = delete;
}; 

typedef internal::TimeInMillis TimeInMillis; 
# 527
class TestProperty { 




public: TestProperty(const std::string &a_key, const std::string &a_value) : key_(a_key), value_(a_value) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(197 + 0 + 1U - 1);
} 


const char *key() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(198 + 0 + 1U - 1);
return (key_).c_str(); 
} 


const char *value() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(199 + 0 + 1U - 1);
return (value_).c_str(); 
} 


void SetValue(const std::string &new_value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(200 + 0 + 1U - 1);
(value_ = new_value); 
} 



private: std::string key_; 

std::string value_; 
}; 
# 564
class __attribute((visibility("default"))) TestResult { 


public: TestResult(); 


~TestResult(); 



int total_part_count() const; 


int test_property_count() const; 


bool Passed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(201 + 0 + 1U - 1);return !this->Skipped() && !this->Failed(); } 


bool Skipped() const; 


bool Failed() const; 


bool HasFatalFailure() const; 


bool HasNonfatalFailure() const; 


TimeInMillis elapsed_time() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(202 + 0 + 1U - 1);return elapsed_time_; } 



const TestPartResult &GetTestPartResult(int i) const; 




const TestProperty &GetTestProperty(int i) const; 


friend class TestInfo; 
friend class TestCase; 
friend class UnitTest; 
friend class internal::DefaultGlobalTestPartResultReporter; 
friend class internal::ExecDeathTest; 
friend class internal::TestResultAccessor; 
friend class internal::UnitTestImpl; 
friend class internal::WindowsDeathTest; 
friend class internal::FuchsiaDeathTest; 


private: const std::vector< TestPartResult>  &test_part_results() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(203 + 0 + 1U - 1);
return test_part_results_; 
} 


const std::vector< TestProperty>  &test_properties() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(204 + 0 + 1U - 1);
return test_properties_; 
} 


void set_elapsed_time(TimeInMillis elapsed) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(205 + 0 + 1U - 1);elapsed_time_ = elapsed; } 
# 636
void RecordProperty(const std::string & xml_element, const TestProperty & test_property); 
# 642
static bool ValidateTestProperty(const std::string & xml_element, const TestProperty & test_property); 



void AddTestPartResult(const TestPartResult & test_part_result); 


int death_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(206 + 0 + 1U - 1);return death_test_count_; } 


int increment_death_test_count() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(207 + 0 + 1U - 1);return ++death_test_count_; } 


void ClearTestPartResults(); 


void Clear(); 



internal::Mutex test_properites_mutex_; 


std::vector< TestPartResult>  test_part_results_; 

std::vector< TestProperty>  test_properties_; 

int death_test_count_; 

TimeInMillis elapsed_time_; 


TestResult(const TestResult &) = delete;void operator=(const TestResult &) = delete;
}; 
# 688 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class __attribute((visibility("default"))) TestInfo { 



public: ~TestInfo(); 


const char *test_case_name() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(208 + 0 + 1U - 1);return (test_case_name_).c_str(); } 


const char *name() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(209 + 0 + 1U - 1);return (name_).c_str(); } 



const char *type_param() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(210 + 0 + 1U - 1), (type_param_).get() != (nullptr))) {cpptestFastCoverageStmt(210 + 0 + 2U - 1);return type_param_->c_str(); }  cpptestFastCoverageStmt(210 + 0 + 3U - 1);
return nullptr; 
} 



const char *value_param() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(213 + 0 + 1U - 1), (value_param_).get() != (nullptr))) {cpptestFastCoverageStmt(213 + 0 + 2U - 1);return value_param_->c_str(); }  cpptestFastCoverageStmt(213 + 0 + 3U - 1);
return nullptr; 
} 


const char *file() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(216 + 0 + 1U - 1);return ((location_).file).c_str(); } 


int line() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(217 + 0 + 1U - 1);return (location_).line; } 


bool is_in_another_shard() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(218 + 0 + 1U - 1);return is_in_another_shard_; } 
# 739 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
bool should_run() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(219 + 0 + 1U - 1);return should_run_; } 


bool is_reportable() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(220 + 0 + 1U - 1);


return matches_filter_ && !is_in_another_shard_; 
} 


const TestResult *result() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(221 + 0 + 1U - 1);return &(result_); } 



friend class internal::DefaultDeathTestFactory; 

friend class Test; 
friend class TestCase; 
friend class internal::UnitTestImpl; 
friend class internal::StreamingListenerTest; 
friend TestInfo *internal::MakeAndRegisterTestInfo(const char * test_case_name, const char * name, const char * type_param, const char * value_param, testing::internal::CodeLocation code_location, testing::internal::TypeId fixture_class_id, testing::Test::SetUpTestCaseFunc set_up_tc, testing::Test::TearDownTestCaseFunc tear_down_tc, testing::internal::TestFactoryBase * factory); 
# 772
private: TestInfo(const std::string & test_case_name, const std::string & name, const char * a_type_param, const char * a_value_param, internal::CodeLocation a_code_location, internal::TypeId fixture_class_id, internal::TestFactoryBase * factory); 
# 782
int increment_death_test_count() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(222 + 0 + 1U - 1);
return (result_).increment_death_test_count(); 
} 



void Run(); 

static void ClearTestResult(TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(223 + 0 + 1U - 1);
(test_info->result_).Clear(); 
} 


const std::string test_case_name_; 
const std::string name_; 


const internal::scoped_ptr< const std::__cxx11::basic_string< char> >  type_param_; 


const internal::scoped_ptr< const std::__cxx11::basic_string< char> >  value_param_; 
internal::CodeLocation location_; 
const internal::TypeId fixture_class_id_; 
bool should_run_; 
bool is_disabled_; 
bool matches_filter_; 

bool is_in_another_shard_; 
internal::TestFactoryBase *const factory_; 




TestResult result_; 

TestInfo(const TestInfo &) = delete;void operator=(const TestInfo &) = delete;
}; 




class __attribute((visibility("default"))) TestCase { 
# 837 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
public: TestCase(const char * name, const char * a_type_param, Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc tear_down_tc); 




virtual ~TestCase(); 


const char *name() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(224 + 0 + 1U - 1);return (name_).c_str(); } 



const char *type_param() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(225 + 0 + 1U - 1), (type_param_).get() != (nullptr))) {cpptestFastCoverageStmt(225 + 0 + 2U - 1);return type_param_->c_str(); }  cpptestFastCoverageStmt(225 + 0 + 3U - 1);
return nullptr; 
} 


bool should_run() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(228 + 0 + 1U - 1);return should_run_; } 


int successful_test_count() const; 


int skipped_test_count() const; 


int failed_test_count() const; 


int reportable_disabled_test_count() const; 


int disabled_test_count() const; 


int reportable_test_count() const; 


int test_to_run_count() const; 


int total_test_count() const; 


bool Passed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(229 + 0 + 1U - 1);return !this->Failed(); } 


bool Failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(230 + 0 + 1U - 1);return this->failed_test_count() > 0; } 


TimeInMillis elapsed_time() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(231 + 0 + 1U - 1);return elapsed_time_; } 



const TestInfo *GetTestInfo(int i) const; 



const TestResult &ad_hoc_test_result() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(232 + 0 + 1U - 1);return ad_hoc_test_result_; } 


friend class Test; 
friend class internal::UnitTestImpl; 


private: std::vector< TestInfo *>  &test_info_list() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(233 + 0 + 1U - 1);return test_info_list_; } 


const std::vector< TestInfo *>  &test_info_list() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(234 + 0 + 1U - 1);
return test_info_list_; 
} 



TestInfo *GetMutableTestInfo(int i); 


void set_should_run(bool should) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(235 + 0 + 1U - 1);should_run_ = should; } 



void AddTestInfo(TestInfo * test_info); 


void ClearResult(); 


static void ClearTestCaseResult(TestCase *test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(236 + 0 + 1U - 1);
test_case->ClearResult(); 
} 


void Run(); 



void RunSetUpTestCase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(237 + 0 + 1U - 1);(*(set_up_tc_))(); } 



void RunTearDownTestCase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(238 + 0 + 1U - 1);(*(tear_down_tc_))(); } 


static bool TestPassed(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(239 + 0 + 1U - 1);
return test_info->should_run() && test_info->result()->Passed(); 
} 


static bool TestSkipped(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(240 + 0 + 1U - 1);
return test_info->should_run() && test_info->result()->Skipped(); 
} 


static bool TestFailed(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(241 + 0 + 1U - 1);
return test_info->should_run() && test_info->result()->Failed(); 
} 



static bool TestReportableDisabled(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(242 + 0 + 1U - 1);
return test_info->is_reportable() && test_info->is_disabled_; 
} 


static bool TestDisabled(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(243 + 0 + 1U - 1);
return test_info->is_disabled_; 
} 


static bool TestReportable(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(244 + 0 + 1U - 1);
return test_info->is_reportable(); 
} 


static bool ShouldRunTest(const TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(245 + 0 + 1U - 1);
return test_info->should_run(); 
} 


void ShuffleTests(internal::Random * random); 


void UnshuffleTests(); 


std::string name_; 


const internal::scoped_ptr< const std::__cxx11::basic_string< char> >  type_param_; 


std::vector< TestInfo *>  test_info_list_; 



std::vector< int>  test_indices_; 

Test::SetUpTestCaseFunc set_up_tc_; 

Test::TearDownTestCaseFunc tear_down_tc_; 

bool should_run_; 

TimeInMillis elapsed_time_; 


TestResult ad_hoc_test_result_; 


TestCase(const TestCase &) = delete;void operator=(const TestCase &) = delete;
}; 
# 1024 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class Environment { 


public: virtual ~Environment() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(246 + 0 + 1U - 1);} 


virtual void SetUp() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(247 + 0 + 1U - 1);} 


virtual void TearDown() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(248 + 0 + 1U - 1);} 



private: struct Setup_should_be_spelled_SetUp { }; 
virtual Setup_should_be_spelled_SetUp *Setup() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(249 + 0 + 1U - 1);return nullptr; } 
}; 




class __attribute((visibility("default"))) AssertionException : public internal::GoogleTestFailureException { 


public: explicit AssertionException(const TestPartResult &result) : internal::GoogleTestFailureException(result) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(250 + 0 + 1U - 1);} 
}; 
# 1055
class TestEventListener { 

public: virtual ~TestEventListener() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(251 + 0 + 1U - 1);} 


virtual void OnTestProgramStart(const UnitTest & unit_test) = 0; 




virtual void OnTestIterationStart(const UnitTest & unit_test, int iteration) = 0; 



virtual void OnEnvironmentsSetUpStart(const UnitTest & unit_test) = 0; 


virtual void OnEnvironmentsSetUpEnd(const UnitTest & unit_test) = 0; 


virtual void OnTestCaseStart(const TestCase & test_case) = 0; 


virtual void OnTestStart(const TestInfo & test_info) = 0; 




virtual void OnTestPartResult(const TestPartResult & test_part_result) = 0; 


virtual void OnTestEnd(const TestInfo & test_info) = 0; 


virtual void OnTestCaseEnd(const TestCase & test_case) = 0; 


virtual void OnEnvironmentsTearDownStart(const UnitTest & unit_test) = 0; 


virtual void OnEnvironmentsTearDownEnd(const UnitTest & unit_test) = 0; 


virtual void OnTestIterationEnd(const UnitTest & unit_test, int iteration) = 0; 



virtual void OnTestProgramEnd(const UnitTest & unit_test) = 0; 
}; 
# 1110
class EmptyTestEventListener : public TestEventListener { 

public: virtual void OnTestProgramStart(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(252 + 0 + 1U - 1);} 
virtual void OnTestIterationStart(const UnitTest &, int) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(253 + 0 + 1U - 1);} 
virtual void OnEnvironmentsSetUpStart(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(254 + 0 + 1U - 1);} 
virtual void OnEnvironmentsSetUpEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(255 + 0 + 1U - 1);} 
virtual void OnTestCaseStart(const TestCase &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(256 + 0 + 1U - 1);} 
virtual void OnTestStart(const TestInfo &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(257 + 0 + 1U - 1);} 
virtual void OnTestPartResult(const TestPartResult &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(258 + 0 + 1U - 1);} 
virtual void OnTestEnd(const TestInfo &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(259 + 0 + 1U - 1);} 
virtual void OnTestCaseEnd(const TestCase &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(260 + 0 + 1U - 1);} 
virtual void OnEnvironmentsTearDownStart(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(261 + 0 + 1U - 1);} 
virtual void OnEnvironmentsTearDownEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(262 + 0 + 1U - 1);} 
virtual void OnTestIterationEnd(const UnitTest &, int) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(263 + 0 + 1U - 1);} 
virtual void OnTestProgramEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(264 + 0 + 1U - 1);} 
}; 


class __attribute((visibility("default"))) TestEventListeners { 

public: TestEventListeners(); 
~TestEventListeners(); 




void Append(TestEventListener * listener); 




TestEventListener *Release(TestEventListener * listener); 
# 1150
TestEventListener *default_result_printer() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(265 + 0 + 1U - 1);
return default_result_printer_; 
} 
# 1161 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
TestEventListener *default_xml_generator() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(266 + 0 + 1U - 1);
return default_xml_generator_; 
} 


friend class TestCase; 
friend class TestInfo; 
friend class internal::DefaultGlobalTestPartResultReporter; 
friend class internal::NoExecDeathTest; 
friend class internal::TestEventListenersAccessor; 
friend class internal::UnitTestImpl; 



private: TestEventListener *repeater(); 
# 1182
void SetDefaultResultPrinter(TestEventListener * listener); 
# 1189
void SetDefaultXmlGenerator(TestEventListener * listener); 



bool EventForwardingEnabled() const; 
void SuppressEventForwarding(); 


internal::TestEventRepeater *repeater_; 

TestEventListener *default_result_printer_; 

TestEventListener *default_xml_generator_; 


TestEventListeners(const TestEventListeners &) = delete;void operator=(const TestEventListeners &) = delete;
}; 
# 1217 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class __attribute((visibility("default"))) UnitTest { 




public: static UnitTest *GetInstance(); 
# 1230
int Run() __attribute((warn_unused_result)); 



const char *original_working_dir() const; 



const TestCase *current_test_case() const; 




const TestInfo *current_test_info() const; 



int random_seed() const; 
# 1253
internal::ParameterizedTestCaseRegistry &parameterized_test_registry(); 



int successful_test_case_count() const; 


int failed_test_case_count() const; 


int total_test_case_count() const; 



int test_case_to_run_count() const; 


int successful_test_count() const; 


int skipped_test_count() const; 


int failed_test_count() const; 


int reportable_disabled_test_count() const; 


int disabled_test_count() const; 


int reportable_test_count() const; 


int total_test_count() const; 


int test_to_run_count() const; 



TimeInMillis start_timestamp() const; 


TimeInMillis elapsed_time() const; 


bool Passed() const; 



bool Failed() const; 



const TestCase *GetTestCase(int i) const; 



const TestResult &ad_hoc_test_result() const; 



TestEventListeners &listeners(); 
# 1329 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
private: Environment *AddEnvironment(Environment * env); 
# 1335
void AddTestPartResult(TestPartResult::Type result_type, const char * file_name, int line_number, const std::string & message, const std::string & os_stack_trace); 
# 1347
void RecordProperty(const std::string & key, const std::string & value); 



TestCase *GetMutableTestCase(int i); 


internal::UnitTestImpl *impl() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(267 + 0 + 1U - 1);return impl_; } 
const internal::UnitTestImpl *impl() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(268 + 0 + 1U - 1);return impl_; } 



friend class ScopedTrace; 
friend class Test; 
friend class internal::AssertHelper; 
friend class internal::StreamingListenerTest; 
friend class internal::UnitTestRecordPropertyTestHelper; 
friend inline Environment *AddGlobalTestEnvironment(testing::Environment * env); 
friend inline internal::UnitTestImpl *internal::GetUnitTestImpl(); 
friend void internal::ReportFailureInUnknownLocation(testing::TestPartResult::Type result_type, const std::string & message); 




UnitTest(); 


virtual ~UnitTest(); 



void PushGTestTrace(const internal::TraceInfo & trace); 



void PopGTestTrace(); 




mutable internal::Mutex mutex_; 
# 1393
internal::UnitTestImpl *impl_; 


UnitTest(const UnitTest &) = delete;void operator=(const UnitTest &) = delete;
}; 
# 1417 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
inline Environment *AddGlobalTestEnvironment(Environment *env) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(269 + 0 + 1U - 1);
return UnitTest::GetInstance()->AddEnvironment(env); 
} 
# 1430 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
__attribute((visibility("default"))) void InitGoogleTest(int * argc, char ** argv); 



__attribute((visibility("default"))) void InitGoogleTest(int * argc, wchar_t ** argv); 

namespace internal { 




template < typename T1 , typename T2 > 
AssertionResult CmpHelperEQFailure (const char * lhs_expression , 
const char * rhs_expression , 
const T1 & lhs , const T2 & rhs) { 
return EqFailure (lhs_expression , 
rhs_expression , 
FormatForComparisonFailureMessage (lhs , rhs) , 
FormatForComparisonFailureMessage (rhs , lhs) , 
false) ; 
} 


template < typename T1 , typename T2 > 
AssertionResult CmpHelperEQ (const char * lhs_expression , 
const char * rhs_expression , 
const T1 & lhs , 
const T2 & rhs) { 
if (lhs == rhs) { 
return AssertionSuccess () ; 
} 

return CmpHelperEQFailure (lhs_expression , rhs_expression , lhs , rhs) ; 
} 




__attribute((visibility("default"))) AssertionResult CmpHelperEQ(const char * lhs_expression, const char * rhs_expression, BiggestInt lhs, BiggestInt rhs); 
# 1477
template < bool lhs_is_null_literal > 
class EqHelper { 
public : 

template < typename T1 , typename T2 > 
static AssertionResult Compare (const char * lhs_expression , 
const char * rhs_expression , 
const T1 & lhs , 
const T2 & rhs) { 
return CmpHelperEQ (lhs_expression , rhs_expression , lhs , rhs) ; 
} 
# 1495
static AssertionResult Compare (const char * lhs_expression , 
const char * rhs_expression , 
BiggestInt lhs , 
BiggestInt rhs) { 
return CmpHelperEQ (lhs_expression , rhs_expression , lhs , rhs) ; 
} 
} ;




template<> class EqHelper< true>  { 
# 1512
public: template < typename T1 , typename T2 > 
static AssertionResult Compare (
const char * lhs_expression , const char * rhs_expression , const T1 & lhs , 
const T2 & rhs , 
# 1521
typename EnableIf < ! is_pointer < T2 > :: value > :: type * = nullptr) { 
return CmpHelperEQ (lhs_expression , rhs_expression , lhs , rhs) ; 
} 



template < typename T > 
static AssertionResult Compare (
const char * lhs_expression , 
const char * rhs_expression , 
# 1537
Secret * , 
T * rhs) { 

return CmpHelperEQ (lhs_expression , rhs_expression , static_cast < T * > (nullptr) , 
rhs) ; 
} 
}; 




template < typename T1 , typename T2 > 
AssertionResult CmpHelperOpFailure (const char * expr1 , const char * expr2 , 
const T1 & val1 , const T2 & val2 , 
const char * op) { 
return AssertionFailure () 
<< "Expected: (" << expr1 << ") " << op << " (" << expr2 
<< "), actual: " << FormatForComparisonFailureMessage (val1 , val2) 
<< " vs " << FormatForComparisonFailureMessage (val2 , val1) ; 
} 
# 1585 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
template < typename T1 , typename T2 > AssertionResult CmpHelperNE (const char * expr1 , const char * expr2 , const T1 & val1 , const T2 & val2) { if (val1 != val2) { return AssertionSuccess () ; } else { return CmpHelperOpFailure (expr1 , expr2 , val1 , val2 , "!=") ; } } __attribute((visibility("default"))) AssertionResult CmpHelperNE(const char * expr1, const char * expr2, BiggestInt val1, BiggestInt val2); 

template < typename T1 , typename T2 > AssertionResult CmpHelperLE (const char * expr1 , const char * expr2 , const T1 & val1 , const T2 & val2) { if (val1 <= val2) { return AssertionSuccess () ; } else { return CmpHelperOpFailure (expr1 , expr2 , val1 , val2 , "<=") ; } } __attribute((visibility("default"))) AssertionResult CmpHelperLE(const char * expr1, const char * expr2, BiggestInt val1, BiggestInt val2); 

template < typename T1 , typename T2 > AssertionResult CmpHelperLT (const char * expr1 , const char * expr2 , const T1 & val1 , const T2 & val2) { if (val1 < val2) { return AssertionSuccess () ; } else { return CmpHelperOpFailure (expr1 , expr2 , val1 , val2 , "<") ; } } __attribute((visibility("default"))) AssertionResult CmpHelperLT(const char * expr1, const char * expr2, BiggestInt val1, BiggestInt val2); 

template < typename T1 , typename T2 > AssertionResult CmpHelperGE (const char * expr1 , const char * expr2 , const T1 & val1 , const T2 & val2) { if (val1 >= val2) { return AssertionSuccess () ; } else { return CmpHelperOpFailure (expr1 , expr2 , val1 , val2 , ">=") ; } } __attribute((visibility("default"))) AssertionResult CmpHelperGE(const char * expr1, const char * expr2, BiggestInt val1, BiggestInt val2); 

template < typename T1 , typename T2 > AssertionResult CmpHelperGT (const char * expr1 , const char * expr2 , const T1 & val1 , const T2 & val2) { if (val1 > val2) { return AssertionSuccess () ; } else { return CmpHelperOpFailure (expr1 , expr2 , val1 , val2 , ">") ; } } __attribute((visibility("default"))) AssertionResult CmpHelperGT(const char * expr1, const char * expr2, BiggestInt val1, BiggestInt val2); 
# 1600
__attribute((visibility("default"))) AssertionResult CmpHelperSTREQ(const char * s1_expression, const char * s2_expression, const char * s1, const char * s2); 
# 1608
__attribute((visibility("default"))) AssertionResult CmpHelperSTRCASEEQ(const char * s1_expression, const char * s2_expression, const char * s1, const char * s2); 
# 1616
__attribute((visibility("default"))) AssertionResult CmpHelperSTRNE(const char * s1_expression, const char * s2_expression, const char * s1, const char * s2); 
# 1624
__attribute((visibility("default"))) AssertionResult CmpHelperSTRCASENE(const char * s1_expression, const char * s2_expression, const char * s1, const char * s2); 
# 1633
__attribute((visibility("default"))) AssertionResult CmpHelperSTREQ(const char * s1_expression, const char * s2_expression, const wchar_t * s1, const wchar_t * s2); 
# 1641
__attribute((visibility("default"))) AssertionResult CmpHelperSTRNE(const char * s1_expression, const char * s2_expression, const wchar_t * s1, const wchar_t * s2); 




}
# 1656 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
__attribute((visibility("default"))) AssertionResult IsSubstring(const char * needle_expr, const char * haystack_expr, const char * needle, const char * haystack); 


__attribute((visibility("default"))) AssertionResult IsSubstring(const char * needle_expr, const char * haystack_expr, const wchar_t * needle, const wchar_t * haystack); 


__attribute((visibility("default"))) AssertionResult IsNotSubstring(const char * needle_expr, const char * haystack_expr, const char * needle, const char * haystack); 


__attribute((visibility("default"))) AssertionResult IsNotSubstring(const char * needle_expr, const char * haystack_expr, const wchar_t * needle, const wchar_t * haystack); 


__attribute((visibility("default"))) AssertionResult IsSubstring(const char * needle_expr, const char * haystack_expr, const std::string & needle, const std::string & haystack); 


__attribute((visibility("default"))) AssertionResult IsNotSubstring(const char * needle_expr, const char * haystack_expr, const std::string & needle, const std::string & haystack); 




__attribute((visibility("default"))) AssertionResult IsSubstring(const char * needle_expr, const char * haystack_expr, const std::wstring & needle, const std::wstring & haystack); 


__attribute((visibility("default"))) AssertionResult IsNotSubstring(const char * needle_expr, const char * haystack_expr, const std::wstring & needle, const std::wstring & haystack); 




namespace internal { 
# 1693 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
template < typename RawType > 
AssertionResult CmpHelperFloatingPointEQ (const char * lhs_expression , 
const char * rhs_expression , 
RawType lhs_value , 
RawType rhs_value) { 
const FloatingPoint < RawType > lhs (lhs_value) , rhs (rhs_value) ; 

if (lhs . AlmostEquals (rhs)) { 
return AssertionSuccess () ; 
} 

:: std :: stringstream lhs_ss ; 
lhs_ss << std :: setprecision (std :: numeric_limits < RawType > :: digits10 + 2) 
<< lhs_value ; 

:: std :: stringstream rhs_ss ; 
rhs_ss << std :: setprecision (std :: numeric_limits < RawType > :: digits10 + 2) 
<< rhs_value ; 

return EqFailure (lhs_expression , 
rhs_expression , 
StringStreamToString (& lhs_ss) , 
StringStreamToString (& rhs_ss) , 
false) ; 
} 




__attribute((visibility("default"))) AssertionResult DoubleNearPredFormat(const char * expr1, const char * expr2, const char * abs_error_expr, double val1, double val2, double abs_error); 
# 1731
class __attribute((visibility("default"))) AssertHelper { 


public: AssertHelper(TestPartResult::Type type, const char * file, int line, const char * message); 



~AssertHelper(); 



void operator=(const Message & message) const; 
# 1749
private: struct AssertHelperData { 
AssertHelperData(TestPartResult::Type t, const char *
srcfile, int 
line_num, const char *
msg) : type(t), file(srcfile), line(line_num), message(msg) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(270 + 0 + 1U - 1);} 

const TestPartResult::Type type; 
const char *const file; 
const int line; 
const std::string message; 


private: AssertHelperData(const AssertHelperData &) = delete;void operator=(const AssertHelperData &) = delete;
}; 

AssertHelperData *const data_; 

AssertHelper(const AssertHelper &) = delete;void operator=(const AssertHelper &) = delete;
}; 

enum GTestColor { COLOR_DEFAULT, COLOR_RED, COLOR_GREEN, COLOR_YELLOW}; 

__attribute((visibility("default"))) __attribute((__format__(__printf__, 2, 3))) void ColoredPrintf(GTestColor color, const char * fmt, ...); 



}
# 1812 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
template < typename T > 
class WithParamInterface { 
public : 
typedef T ParamType ; 
virtual ~ WithParamInterface () { } 



static const ParamType & GetParam () { 
switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (parameter_ != nullptr)) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h" , 1821) . GetStream () << "Condition " "parameter_ != nullptr" " failed. " 
<< "GetParam() can only be called inside a value-parameterized test " 
<< "-- did you intend to write TEST_P instead of TEST_F?" ; 
return * parameter_ ; 
} 

private : 


static void SetParam (const ParamType * parameter) { 
parameter_ = parameter ; 
} 


static const ParamType * parameter_ ; 


template < class TestClass > friend class internal :: ParameterizedTestFactory ; 
} ;

template < typename T >
const T * WithParamInterface < T > :: parameter_ = nullptr;




template < typename T > 
class TestWithParam : public Test , public WithParamInterface < T > { 
} ;
# 2122 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
__attribute((visibility("default"))) AssertionResult FloatLE(const char * expr1, const char * expr2, float val1, float val2); 

__attribute((visibility("default"))) AssertionResult DoubleLE(const char * expr1, const char * expr2, double val1, double val2); 
# 2178 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
class __attribute((visibility("default"))) ScopedTrace { 
# 2185
public: template < typename T > 
ScopedTrace (const char * file , int line , const T & message) { 
PushTrace (file , line , (Message () << message) . GetString ()) ; 
} 


ScopedTrace(const char *file, int line, const char *message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(271 + 0 + 1U - 1);
this->PushTrace(file, line, (message) ? message : ("(null)")); 
} 
# 2201
ScopedTrace(const char *file, int line, const std::string &message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(272 + 0 + 1U - 1);
this->PushTrace(file, line, message); 
} 
# 2209
~ScopedTrace(); 


private: void PushTrace(const char * file, int line, std::string message); 

ScopedTrace(const ScopedTrace &) = delete;void operator=(const ScopedTrace &) = delete;
} __attribute((unused)); 
# 2269 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
template < typename T1 , typename T2 > 
bool StaticAssertTypeEq () { 
(void) internal :: StaticAssertTypeEqHelper < T1 , T2 > () ; 
return true ; 
} 
# 2342 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
__attribute((visibility("default"))) std::string TempDir(); 
# 2348
}
# 2358 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest.h"
inline int RUN_ALL_TESTS() __attribute((warn_unused_result)); 

inline int RUN_ALL_TESTS() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(273 + 0 + 1U - 1);
return ::testing::UnitTest::GetInstance()->Run(); 
} 
# 44 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-spi.h"
namespace testing { 
# 55 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/include/gtest/gtest-spi.h"
class __attribute((visibility("default"))) ScopedFakeTestPartResultReporter : public TestPartResultReporterInterface { 



public: enum InterceptMode { 
INTERCEPT_ONLY_CURRENT_THREAD, 
INTERCEPT_ALL_THREADS
}; 
# 68
explicit ScopedFakeTestPartResultReporter(TestPartResultArray * result); 


ScopedFakeTestPartResultReporter(InterceptMode intercept_mode, TestPartResultArray * result); 



virtual ~ScopedFakeTestPartResultReporter(); 
# 82
virtual void ReportTestPartResult(const TestPartResult & result); 

private: void Init(); 

const InterceptMode intercept_mode_; 
TestPartResultReporterInterface *old_reporter_; 
TestPartResultArray *const result_; 

ScopedFakeTestPartResultReporter(const ScopedFakeTestPartResultReporter &) = delete;void operator=(const ScopedFakeTestPartResultReporter &) = delete;
}; 

namespace internal { 
# 100
class __attribute((visibility("default"))) SingleFailureChecker { 


public: SingleFailureChecker(const TestPartResultArray * results, TestPartResult::Type type, const std::string & substr); 

~SingleFailureChecker(); 

private: const TestPartResultArray *const results_; 
const TestPartResult::Type type_; 
const std::string substr_; 

SingleFailureChecker(const SingleFailureChecker &) = delete;void operator=(const SingleFailureChecker &) = delete;
}; 

}

}
# 111 "d:\\mingw\\mingw\\include\\math.h" 3
extern "C" {
# 151 "d:\\mingw\\mingw\\include\\math.h" 3
struct _exception { 

int type; 
char *name; 
double arg1; 
double arg2; 
double retval; 
}; 

__attribute((__cdecl__)) double sin(double); 
__attribute((__cdecl__)) double cos(double); 
__attribute((__cdecl__)) double tan(double); 
__attribute((__cdecl__)) double sinh(double); 
__attribute((__cdecl__)) double cosh(double); 
__attribute((__cdecl__)) double tanh(double); 
__attribute((__cdecl__)) double asin(double); 
__attribute((__cdecl__)) double acos(double); 
__attribute((__cdecl__)) double atan(double); 
__attribute((__cdecl__)) double atan2(double, double); 
__attribute((__cdecl__)) double exp(double); 
__attribute((__cdecl__)) double log(double); 
__attribute((__cdecl__)) double log10(double); 
__attribute((__cdecl__)) double pow(double, double); 
__attribute((__cdecl__)) double sqrt(double); 
__attribute((__cdecl__)) double ceil(double); 
__attribute((__cdecl__)) double floor(double); 
__attribute((__cdecl__)) double fabs(double); 
__attribute((__cdecl__)) double ldexp(double, int); 
__attribute((__cdecl__)) double frexp(double, int *); 
__attribute((__cdecl__)) double modf(double, double *); 
__attribute((__cdecl__)) double fmod(double, double); 
# 225 "d:\\mingw\\mingw\\include\\math.h" 3
struct _complex { 




double x; 
double y; 
}; 

__attribute((__cdecl__)) double _cabs(_complex); 

__attribute((__cdecl__)) double _hypot(double, double); 
__attribute((__cdecl__)) double _j0(double); 
__attribute((__cdecl__)) double _j1(double); 
__attribute((__cdecl__)) double _jn(int, double); 
__attribute((__cdecl__)) double _y0(double); 
__attribute((__cdecl__)) double _y1(double); 
__attribute((__cdecl__)) double _yn(int, double); 
__attribute((__cdecl__)) int _matherr(_exception *); 
# 252 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) double _chgsign(double); 
__attribute((__cdecl__)) double _copysign(double, double); 
__attribute((__cdecl__)) double _logb(double); 
__attribute((__cdecl__)) double _nextafter(double, double); 
__attribute((__cdecl__)) double _scalb(double, long); 

__attribute((__cdecl__)) int _finite(double); 
__attribute((__cdecl__)) int _fpclass(double); 
__attribute((__cdecl__)) int _isnan(double); 
# 269 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) double j0(double); 
__attribute((__cdecl__)) double j1(double); 
__attribute((__cdecl__)) double jn(int, double); 
__attribute((__cdecl__)) double y0(double); 
__attribute((__cdecl__)) double y1(double); 
__attribute((__cdecl__)) double yn(int, double); 

__attribute((__cdecl__)) double chgsign(double); 
# 285 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) int finite(double); 
__attribute((__cdecl__)) int fpclass(double); 
# 355 "d:\\mingw\\mingw\\include\\math.h" 3
typedef long double float_t; 
typedef long double double_t; 
# 391 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) extern int __fpclassifyf(float); 
__attribute((__cdecl__)) extern int __fpclassify(double); 
__attribute((__cdecl__)) extern inline int __fpclassifyl(long double); 


__attribute((__cdecl__)) inline int __fpclassifyl(long double x) { 
unsigned short sw; 
__asm__ ("fxam; fstsw %%ax;" : "=a" (sw): "t" (x)); 
return sw & ((0x100 | 0x400) | 0x4000); 
} 
# 417 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) extern inline int __isnan(double); 
__attribute((__cdecl__)) extern inline int __isnanf(float); 
__attribute((__cdecl__)) extern inline int __isnanl(long double); 

__attribute((__cdecl__)) inline int __isnan(double _x) 
{ 
unsigned short sw; 
__asm__ ("fxam;"
    "fstsw %%ax": "=a" (sw) : "t" (_x)); 
return (sw & ((((0x100 | 0x400) | (0x100 | 0x400)) | 0x4000) | (0x400 | 0x4000))) == 0x100; 

} 

__attribute((__cdecl__)) inline int __isnanf(float _x) 
{ 
unsigned short sw; 
__asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x)); 
return (sw & ((((0x100 | 0x400) | (0x100 | 0x400)) | 0x4000) | (0x400 | 0x4000))) == 0x100; 

} 

__attribute((__cdecl__)) inline int __isnanl(long double _x) 
{ 
unsigned short sw; 
__asm__ ("fxam;"
     "fstsw %%ax": "=a" (sw) : "t" (_x)); 
return (sw & ((((0x100 | 0x400) | (0x100 | 0x400)) | 0x4000) | (0x400 | 0x4000))) == 0x100; 

} 
# 457 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) extern inline int __signbit(double); 
__attribute((__cdecl__)) extern inline int __signbitf(float); 
__attribute((__cdecl__)) extern inline int __signbitl(long double); 

__attribute((__cdecl__)) inline int __signbit(double x) { 
unsigned short stw; 
__asm__ ( "fxam; fstsw %%ax;": "=a" (stw) : "t" (x)); 
return (stw & 0x200) != 0; 
} 

__attribute((__cdecl__)) inline int __signbitf(float x) { 
unsigned short stw; 
__asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x)); 
return (stw & 0x200) != 0; 
} 

__attribute((__cdecl__)) inline int __signbitl(long double x) { 
unsigned short stw; 
__asm__ ("fxam; fstsw %%ax;": "=a" (stw) : "t" (x)); 
return (stw & 0x200) != 0; 
} 
# 486 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) extern float sinf(float); 
__attribute((__cdecl__)) extern long double sinl(long double); 

__attribute((__cdecl__)) extern float cosf(float); 
__attribute((__cdecl__)) extern long double cosl(long double); 

__attribute((__cdecl__)) extern float tanf(float); 
__attribute((__cdecl__)) extern long double tanl(long double); 

__attribute((__cdecl__)) extern float asinf(float); 
__attribute((__cdecl__)) extern long double asinl(long double); 

__attribute((__cdecl__)) extern float acosf(float); 
__attribute((__cdecl__)) extern long double acosl(long double); 

__attribute((__cdecl__)) extern float atanf(float); 
__attribute((__cdecl__)) extern long double atanl(long double); 

__attribute((__cdecl__)) extern float atan2f(float, float); 
__attribute((__cdecl__)) extern long double atan2l(long double, long double); 



__attribute((__cdecl__)) extern inline float sinhf(float); 

__attribute((__cdecl__)) inline float sinhf(float x) 
{ return (float)sinh(x); } 

__attribute((__cdecl__)) extern long double sinhl(long double); 

__attribute((__cdecl__)) extern inline float coshf(float); 

__attribute((__cdecl__)) inline float coshf(float x) 
{ return (float)cosh(x); } 

__attribute((__cdecl__)) extern long double coshl(long double); 

__attribute((__cdecl__)) extern inline float tanhf(float); 

__attribute((__cdecl__)) inline float tanhf(float x) 
{ return (float)tanh(x); } 

__attribute((__cdecl__)) extern long double tanhl(long double); 



__attribute((__cdecl__)) extern double acosh(double); 
__attribute((__cdecl__)) extern float acoshf(float); 
__attribute((__cdecl__)) extern long double acoshl(long double); 


__attribute((__cdecl__)) extern double asinh(double); 
__attribute((__cdecl__)) extern float asinhf(float); 
__attribute((__cdecl__)) extern long double asinhl(long double); 


__attribute((__cdecl__)) extern double atanh(double); 
__attribute((__cdecl__)) extern float atanhf(float); 
__attribute((__cdecl__)) extern long double atanhl(long double); 



__attribute((__cdecl__)) extern inline float expf(float); 

__attribute((__cdecl__)) inline float expf(float x) 
{ return (float)exp(x); } 

__attribute((__cdecl__)) extern long double expl(long double); 


__attribute((__cdecl__)) extern double exp2(double); 
__attribute((__cdecl__)) extern float exp2f(float); 
__attribute((__cdecl__)) extern long double exp2l(long double); 



__attribute((__cdecl__)) extern double expm1(double); 
__attribute((__cdecl__)) extern float expm1f(float); 
__attribute((__cdecl__)) extern long double expm1l(long double); 


__attribute((__cdecl__)) extern inline float frexpf(float, int *); 

__attribute((__cdecl__)) inline float frexpf(float x, int *expn) 
{ return (float)frexp(x, expn); } 

__attribute((__cdecl__)) extern long double frexpl(long double, int *); 




__attribute((__cdecl__)) extern int ilogb(double); 
__attribute((__cdecl__)) extern int ilogbf(float); 
__attribute((__cdecl__)) extern int ilogbl(long double); 


__attribute((__cdecl__)) extern inline float ldexpf(float, int); 

__attribute((__cdecl__)) inline float ldexpf(float x, int expn) 
{ return (float)ldexp(x, expn); } 

__attribute((__cdecl__)) extern long double ldexpl(long double, int); 


__attribute((__cdecl__)) extern float logf(float); 
__attribute((__cdecl__)) extern long double logl(long double); 


__attribute((__cdecl__)) extern float log10f(float); 
__attribute((__cdecl__)) extern long double log10l(long double); 


__attribute((__cdecl__)) extern double log1p(double); 
__attribute((__cdecl__)) extern float log1pf(float); 
__attribute((__cdecl__)) extern long double log1pl(long double); 


__attribute((__cdecl__)) extern double log2(double); 
__attribute((__cdecl__)) extern float log2f(float); 
__attribute((__cdecl__)) extern long double log2l(long double); 


__attribute((__cdecl__)) extern inline double logb(double); 
__attribute((__cdecl__)) extern inline float logbf(float); 
__attribute((__cdecl__)) extern inline long double logbl(long double); 
# 617
__attribute((__cdecl__)) inline double logb(double x) 
{ 
double res; 
__asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x)); 
return res; 
} 

__attribute((__cdecl__)) inline float logbf(float x) 
{ 
float res; 
__asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x)); 
return res; 
} 

__attribute((__cdecl__)) inline long double logbl(long double x) 
{ 
long double res; 
__asm__ ("fxtract\n\t"
       "fstp	%%st" : "=t" (res) : "0" (x)); 
return res; 
} 




__attribute((__cdecl__)) extern float modff(float, float *); 
__attribute((__cdecl__)) extern long double modfl(long double, long double *); 


__attribute((__cdecl__)) extern double scalbn(double, int); 
__attribute((__cdecl__)) extern float scalbnf(float, int); 
__attribute((__cdecl__)) extern long double scalbnl(long double, int); 

__attribute((__cdecl__)) extern double scalbln(double, long); 
__attribute((__cdecl__)) extern float scalblnf(float, long); 
__attribute((__cdecl__)) extern long double scalblnl(long double, long); 



__attribute((__cdecl__)) extern double cbrt(double); 
__attribute((__cdecl__)) extern float cbrtf(float); 
__attribute((__cdecl__)) extern long double cbrtl(long double); 


__attribute((__cdecl__)) extern float fabsf(float x); 
__attribute((__cdecl__)) extern long double fabsl(long double x); 


__attribute((__cdecl__)) extern double hypot(double, double); 
__attribute((__cdecl__)) extern float hypotf(float, float); 
__attribute((__cdecl__)) extern long double hypotl(long double, long double); 


__attribute((__cdecl__)) extern float powf(float, float); 
__attribute((__cdecl__)) extern long double powl(long double, long double); 


__attribute((__cdecl__)) extern float sqrtf(float); 
__attribute((__cdecl__)) extern long double sqrtl(long double); 


__attribute((__cdecl__)) extern double erf(double); 
__attribute((__cdecl__)) extern float erff(float); 
__attribute((__cdecl__)) extern long double erfl(long double); 


__attribute((__cdecl__)) extern double erfc(double); 
__attribute((__cdecl__)) extern float erfcf(float); 
__attribute((__cdecl__)) extern long double erfcl(long double); 


__attribute((__cdecl__)) extern double lgamma(double); 
__attribute((__cdecl__)) extern float lgammaf(float); 
__attribute((__cdecl__)) extern long double lgammal(long double); 


__attribute((__cdecl__)) extern double tgamma(double); 
__attribute((__cdecl__)) extern float tgammaf(float); 
__attribute((__cdecl__)) extern long double tgammal(long double); 


__attribute((__cdecl__)) extern float ceilf(float); 
__attribute((__cdecl__)) extern long double ceill(long double); 


__attribute((__cdecl__)) extern float floorf(float); 
__attribute((__cdecl__)) extern long double floorl(long double); 


__attribute((__cdecl__)) extern double nearbyint(double); 
__attribute((__cdecl__)) extern float nearbyintf(float); 
__attribute((__cdecl__)) extern long double nearbyintl(long double); 



__attribute((__cdecl__)) extern inline double rint(double); 
__attribute((__cdecl__)) extern inline float rintf(float); 
__attribute((__cdecl__)) extern inline long double rintl(long double); 


__attribute((__cdecl__)) extern inline long lrint(double); 
__attribute((__cdecl__)) extern inline long lrintf(float); 
__attribute((__cdecl__)) extern inline long lrintl(long double); 

__attribute((__cdecl__)) extern inline long long llrint(double); 
__attribute((__cdecl__)) extern inline long long llrintf(float); 
__attribute((__cdecl__)) extern inline long long llrintl(long double); 
# 732
__attribute((__cdecl__)) inline double rint(double x) 
{ 
double retval; 
__asm__ ("frndint;": "=t" (retval) : "0" (x)); 
return retval; 
} 

__attribute((__cdecl__)) inline float rintf(float x) 
{ 
float retval; 
__asm__ ("frndint;" : "=t" (retval) : "0" (x) ); 
return retval; 
} 

__attribute((__cdecl__)) inline long double rintl(long double x) 
{ 
long double retval; 
__asm__ ("frndint;" : "=t" (retval) : "0" (x) ); 
return retval; 
} 

__attribute((__cdecl__)) inline long lrint(double x) 
{ 
long retval; 
__asm__ volatile ("fistpl %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 

__attribute((__cdecl__)) inline long lrintf(float x) 
{ 
long retval; 
__asm__ volatile ("fistpl %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 

__attribute((__cdecl__)) inline long lrintl(long double x) 
{ 
long retval; 
__asm__ volatile ("fistpl %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 

__attribute((__cdecl__)) inline long long llrint(double x) 
{ 
long long retval; 
__asm__ volatile ("fistpll %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 

__attribute((__cdecl__)) inline long long llrintf(float x) 
{ 
long long retval; 
__asm__ volatile ("fistpll %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 

__attribute((__cdecl__)) inline long long llrintl(long double x) 
{ 
long long retval; 
__asm__ volatile ("fistpll %0" : "=m" (retval) : "t" (x) : "st"); 

return retval; 
} 
# 805
__attribute((__cdecl__)) extern double round(double); 
__attribute((__cdecl__)) extern float roundf(float); 
__attribute((__cdecl__)) extern long double roundl(long double); 


__attribute((__cdecl__)) extern long lround(double); 
__attribute((__cdecl__)) extern long lroundf(float); 
__attribute((__cdecl__)) extern long lroundl(long double); 

__attribute((__cdecl__)) extern long long llround(double); 
__attribute((__cdecl__)) extern long long llroundf(float); 
__attribute((__cdecl__)) extern long long llroundl(long double); 



__attribute((__cdecl__)) extern double trunc(double); 
__attribute((__cdecl__)) extern float truncf(float); 
__attribute((__cdecl__)) extern long double truncl(long double); 


__attribute((__cdecl__)) extern float fmodf(float, float); 
__attribute((__cdecl__)) extern long double fmodl(long double, long double); 


__attribute((__cdecl__)) extern double remainder(double, double); 
__attribute((__cdecl__)) extern float remainderf(float, float); 
__attribute((__cdecl__)) extern long double remainderl(long double, long double); 


__attribute((__cdecl__)) extern double remquo(double, double, int *); 
__attribute((__cdecl__)) extern float remquof(float, float, int *); 
__attribute((__cdecl__)) extern long double remquol(long double, long double, int *); 


__attribute((__cdecl__)) extern double copysign(double, double); 
__attribute((__cdecl__)) extern float copysignf(float, float); 
__attribute((__cdecl__)) extern long double copysignl(long double, long double); 


__attribute((__cdecl__)) extern double nan(const char * tagp); 
__attribute((__cdecl__)) extern float nanf(const char * tagp); 
__attribute((__cdecl__)) extern long double nanl(const char * tagp); 
# 855 "d:\\mingw\\mingw\\include\\math.h" 3
__attribute((__cdecl__)) extern double nextafter(double, double); 
__attribute((__cdecl__)) extern float nextafterf(float, float); 
__attribute((__cdecl__)) extern long double nextafterl(long double, long double); 


__attribute((__cdecl__)) extern double nexttoward(double, long double); 
__attribute((__cdecl__)) extern float nexttowardf(float, long double); 
__attribute((__cdecl__)) extern long double nexttowardl(long double, long double); 



__attribute((__cdecl__)) extern double fdim(double x, double y); 
__attribute((__cdecl__)) extern float fdimf(float x, float y); 
__attribute((__cdecl__)) extern long double fdiml(long double x, long double y); 
# 876
__attribute((__cdecl__)) extern double fmax(double, double); 
__attribute((__cdecl__)) extern float fmaxf(float, float); 
__attribute((__cdecl__)) extern long double fmaxl(long double, long double); 


__attribute((__cdecl__)) extern double fmin(double, double); 
__attribute((__cdecl__)) extern float fminf(float, float); 
__attribute((__cdecl__)) extern long double fminl(long double, long double); 



__attribute((__cdecl__)) extern double fma(double, double, double); 
__attribute((__cdecl__)) extern float fmaf(float, float, float); 
__attribute((__cdecl__)) extern long double fmal(long double, long double, long double); 
# 931 "d:\\mingw\\mingw\\include\\math.h" 3
}
# 77 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cmath" 3
extern "C++" {

namespace std { 



using ::acos;



constexpr float acos(float __x) 
{ return __builtin_acosf(__x); } 


constexpr long double acos(long double __x) 
{ return __builtin_acosl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
acos (_Tp __x) 
{ return __builtin_acos (__x) ; } 

using ::asin;



constexpr float asin(float __x) 
{ return __builtin_asinf(__x); } 


constexpr long double asin(long double __x) 
{ return __builtin_asinl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
asin (_Tp __x) 
{ return __builtin_asin (__x) ; } 

using ::atan;



constexpr float atan(float __x) 
{ return __builtin_atanf(__x); } 


constexpr long double atan(long double __x) 
{ return __builtin_atanl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
atan (_Tp __x) 
{ return __builtin_atan (__x) ; } 

using ::atan2;



constexpr float atan2(float __y, float __x) 
{ return __builtin_atan2f(__y, __x); } 


constexpr long double atan2(long double __y, long double __x) 
{ return __builtin_atan2l(__y, __x); } 


template < typename _Tp , typename _Up > 
inline constexpr 
typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
atan2 (_Tp __y , _Up __x) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return atan2 (__type (__y) , __type (__x)) ; 
} 

using ::ceil;



constexpr float ceil(float __x) 
{ return __builtin_ceilf(__x); } 


constexpr long double ceil(long double __x) 
{ return __builtin_ceill(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
ceil (_Tp __x) 
{ return __builtin_ceil (__x) ; } 

using ::cos;



constexpr float cos(float __x) 
{ return __builtin_cosf(__x); } 


constexpr long double cos(long double __x) 
{ return __builtin_cosl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
cos (_Tp __x) 
{ return __builtin_cos (__x) ; } 

using ::cosh;



constexpr float cosh(float __x) 
{ return __builtin_coshf(__x); } 


constexpr long double cosh(long double __x) 
{ return __builtin_coshl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
cosh (_Tp __x) 
{ return __builtin_cosh (__x) ; } 

using ::exp;



constexpr float exp(float __x) 
{ return __builtin_expf(__x); } 


constexpr long double exp(long double __x) 
{ return __builtin_expl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
exp (_Tp __x) 
{ return __builtin_exp (__x) ; } 

using ::fabs;



constexpr float fabs(float __x) 
{ return __builtin_fabsf(__x); } 


constexpr long double fabs(long double __x) 
{ return __builtin_fabsl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
fabs (_Tp __x) 
{ return __builtin_fabs (__x) ; } 

using ::floor;



constexpr float floor(float __x) 
{ return __builtin_floorf(__x); } 


constexpr long double floor(long double __x) 
{ return __builtin_floorl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
floor (_Tp __x) 
{ return __builtin_floor (__x) ; } 

using ::fmod;



constexpr float fmod(float __x, float __y) 
{ return __builtin_fmodf(__x, __y); } 


constexpr long double fmod(long double __x, long double __y) 
{ return __builtin_fmodl(__x, __y); } 


template < typename _Tp , typename _Up > 
inline constexpr 
typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
fmod (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return fmod (__type (__x) , __type (__y)) ; 
} 

using ::frexp;



inline float frexp(float __x, int *__exp) 
{ return __builtin_frexpf(__x, __exp); } 


inline long double frexp(long double __x, int *__exp) 
{ return __builtin_frexpl(__x, __exp); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
frexp (_Tp __x , int * __exp) 
{ return __builtin_frexp (__x , __exp) ; } 

using ::ldexp;



constexpr float ldexp(float __x, int __exp) 
{ return __builtin_ldexpf(__x, __exp); } 


constexpr long double ldexp(long double __x, int __exp) 
{ return __builtin_ldexpl(__x, __exp); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
ldexp (_Tp __x , int __exp) 
{ return __builtin_ldexp (__x , __exp) ; } 

using ::log;



constexpr float log(float __x) 
{ return __builtin_logf(__x); } 


constexpr long double log(long double __x) 
{ return __builtin_logl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
log (_Tp __x) 
{ return __builtin_log (__x) ; } 

using ::log10;



constexpr float log10(float __x) 
{ return __builtin_log10f(__x); } 


constexpr long double log10(long double __x) 
{ return __builtin_log10l(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
log10 (_Tp __x) 
{ return __builtin_log10 (__x) ; } 

using ::modf;



inline float modf(float __x, float *__iptr) 
{ return __builtin_modff(__x, __iptr); } 


inline long double modf(long double __x, long double *__iptr) 
{ return __builtin_modfl(__x, __iptr); } 


using ::pow;



constexpr float pow(float __x, float __y) 
{ return __builtin_powf(__x, __y); } 


constexpr long double pow(long double __x, long double __y) 
{ return __builtin_powl(__x, __y); } 
# 412 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cmath" 3
template < typename _Tp , typename _Up > 
inline constexpr 
typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
pow (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return pow (__type (__x) , __type (__y)) ; 
} 

using ::sin;



constexpr float sin(float __x) 
{ return __builtin_sinf(__x); } 


constexpr long double sin(long double __x) 
{ return __builtin_sinl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
sin (_Tp __x) 
{ return __builtin_sin (__x) ; } 

using ::sinh;



constexpr float sinh(float __x) 
{ return __builtin_sinhf(__x); } 


constexpr long double sinh(long double __x) 
{ return __builtin_sinhl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
sinh (_Tp __x) 
{ return __builtin_sinh (__x) ; } 

using ::sqrt;



constexpr float sqrt(float __x) 
{ return __builtin_sqrtf(__x); } 


constexpr long double sqrt(long double __x) 
{ return __builtin_sqrtl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
sqrt (_Tp __x) 
{ return __builtin_sqrt (__x) ; } 

using ::tan;



constexpr float tan(float __x) 
{ return __builtin_tanf(__x); } 


constexpr long double tan(long double __x) 
{ return __builtin_tanl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
tan (_Tp __x) 
{ return __builtin_tan (__x) ; } 

using ::tanh;



constexpr float tanh(float __x) 
{ return __builtin_tanhf(__x); } 


constexpr long double tanh(long double __x) 
{ return __builtin_tanhl(__x); } 


template < typename _Tp > 
inline constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
tanh (_Tp __x) 
{ return __builtin_tanh (__x) ; } 
# 537 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cmath" 3
constexpr int fpclassify(float __x) 
{ return __builtin_fpclassify(0x100, (0x100 | 0x400), 0x400, (0x400 | 0x4000), 0x4000, __x); 
} 


constexpr int fpclassify(double __x) 
{ return __builtin_fpclassify(0x100, (0x100 | 0x400), 0x400, (0x400 | 0x4000), 0x4000, __x); 
} 


constexpr int fpclassify(long double __x) 
{ return __builtin_fpclassify(0x100, (0x100 | 0x400), 0x400, (0x400 | 0x4000), 0x4000, __x); 
} 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
int > :: __type 
fpclassify (_Tp __x) 
{ return __x != 0 ? 0x0400 : 0x4000 ; } 




constexpr bool isfinite(float __x) 
{ return __builtin_isfinite(__x); } 


constexpr bool isfinite(double __x) 
{ return __builtin_isfinite(__x); } 


constexpr bool isfinite(long double __x) 
{ return __builtin_isfinite(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
bool > :: __type 
isfinite (_Tp __x) 
{ return true ; } 




constexpr bool isinf(float __x) 
{ return __builtin_isinf(__x); } 
# 592
constexpr bool isinf(double __x) 
{ return __builtin_isinf(__x); } 



constexpr bool isinf(long double __x) 
{ return __builtin_isinf(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
bool > :: __type 
isinf (_Tp __x) 
{ return false ; } 




constexpr bool isnan(float __x) 
{ return __builtin_isnan(__x); } 
# 619
constexpr bool isnan(double __x) 
{ return __builtin_isnan(__x); } 



constexpr bool isnan(long double __x) 
{ return __builtin_isnan(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
bool > :: __type 
isnan (_Tp __x) 
{ return false ; } 




constexpr bool isnormal(float __x) 
{ return __builtin_isnormal(__x); } 


constexpr bool isnormal(double __x) 
{ return __builtin_isnormal(__x); } 


constexpr bool isnormal(long double __x) 
{ return __builtin_isnormal(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
bool > :: __type 
isnormal (_Tp __x) 
{ return __x != 0 ? true : false ; } 
# 661
constexpr bool signbit(float __x) 
{ return __builtin_signbit(__x); } 


constexpr bool signbit(double __x) 
{ return __builtin_signbit(__x); } 


constexpr bool signbit(long double __x) 
{ return __builtin_signbit(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
bool > :: __type 
signbit (_Tp __x) 
{ return __x < 0 ? true : false ; } 




constexpr bool isgreater(float __x, float __y) 
{ return __builtin_isgreater(__x, __y); } 


constexpr bool isgreater(double __x, double __y) 
{ return __builtin_isgreater(__x, __y); } 


constexpr bool isgreater(long double __x, long double __y) 
{ return __builtin_isgreater(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
isgreater (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_isgreater (__type (__x) , __type (__y)) ; 
} 




constexpr bool isgreaterequal(float __x, float __y) 
{ return __builtin_isgreaterequal(__x, __y); } 


constexpr bool isgreaterequal(double __x, double __y) 
{ return __builtin_isgreaterequal(__x, __y); } 


constexpr bool isgreaterequal(long double __x, long double __y) 
{ return __builtin_isgreaterequal(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
isgreaterequal (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_isgreaterequal (__type (__x) , __type (__y)) ; 
} 




constexpr bool isless(float __x, float __y) 
{ return __builtin_isless(__x, __y); } 


constexpr bool isless(double __x, double __y) 
{ return __builtin_isless(__x, __y); } 


constexpr bool isless(long double __x, long double __y) 
{ return __builtin_isless(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
isless (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_isless (__type (__x) , __type (__y)) ; 
} 




constexpr bool islessequal(float __x, float __y) 
{ return __builtin_islessequal(__x, __y); } 


constexpr bool islessequal(double __x, double __y) 
{ return __builtin_islessequal(__x, __y); } 


constexpr bool islessequal(long double __x, long double __y) 
{ return __builtin_islessequal(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
islessequal (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_islessequal (__type (__x) , __type (__y)) ; 
} 




constexpr bool islessgreater(float __x, float __y) 
{ return __builtin_islessgreater(__x, __y); } 


constexpr bool islessgreater(double __x, double __y) 
{ return __builtin_islessgreater(__x, __y); } 


constexpr bool islessgreater(long double __x, long double __y) 
{ return __builtin_islessgreater(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
islessgreater (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_islessgreater (__type (__x) , __type (__y)) ; 
} 




constexpr bool isunordered(float __x, float __y) 
{ return __builtin_isunordered(__x, __y); } 


constexpr bool isunordered(double __x, double __y) 
{ return __builtin_isunordered(__x, __y); } 


constexpr bool isunordered(long double __x, long double __y) 
{ return __builtin_isunordered(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename 
__gnu_cxx :: __enable_if < (__is_arithmetic < _Tp > :: __value 
&& __is_arithmetic < _Up > :: __value) , bool > :: __type 
isunordered (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return __builtin_isunordered (__type (__x) , __type (__y)) ; 
} 
# 1065 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cmath" 3
using ::double_t;
using ::float_t;


using ::acosh;
using ::acoshf;
using ::acoshl;

using ::asinh;
using ::asinhf;
using ::asinhl;

using ::atanh;
using ::atanhf;
using ::atanhl;

using ::cbrt;
using ::cbrtf;
using ::cbrtl;

using ::copysign;
using ::copysignf;
using ::copysignl;

using ::erf;
using ::erff;
using ::erfl;

using ::erfc;
using ::erfcf;
using ::erfcl;

using ::exp2;
using ::exp2f;
using ::exp2l;

using ::expm1;
using ::expm1f;
using ::expm1l;

using ::fdim;
using ::fdimf;
using ::fdiml;

using ::fma;
using ::fmaf;
using ::fmal;

using ::fmax;
using ::fmaxf;
using ::fmaxl;

using ::fmin;
using ::fminf;
using ::fminl;

using ::hypot;
using ::hypotf;
using ::hypotl;

using ::ilogb;
using ::ilogbf;
using ::ilogbl;

using ::lgamma;
using ::lgammaf;
using ::lgammal;


using ::llrint;
using ::llrintf;
using ::llrintl;

using ::llround;
using ::llroundf;
using ::llroundl;


using ::log1p;
using ::log1pf;
using ::log1pl;

using ::log2;
using ::log2f;
using ::log2l;

using ::logb;
using ::logbf;
using ::logbl;

using ::lrint;
using ::lrintf;
using ::lrintl;

using ::lround;
using ::lroundf;
using ::lroundl;

using ::nan;
using ::nanf;
using ::nanl;

using ::nearbyint;
using ::nearbyintf;
using ::nearbyintl;

using ::nextafter;
using ::nextafterf;
using ::nextafterl;

using ::nexttoward;
using ::nexttowardf;
using ::nexttowardl;

using ::remainder;
using ::remainderf;
using ::remainderl;

using ::remquo;
using ::remquof;
using ::remquol;

using ::rint;
using ::rintf;
using ::rintl;

using ::round;
using ::roundf;
using ::roundl;

using ::scalbln;
using ::scalblnf;
using ::scalblnl;

using ::scalbn;
using ::scalbnf;
using ::scalbnl;

using ::tgamma;
using ::tgammaf;
using ::tgammal;

using ::trunc;
using ::truncf;
using ::truncl;




constexpr float acosh(float __x) 
{ return __builtin_acoshf(__x); } 


constexpr long double acosh(long double __x) 
{ return __builtin_acoshl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
acosh (_Tp __x) 
{ return __builtin_acosh (__x) ; } 




constexpr float asinh(float __x) 
{ return __builtin_asinhf(__x); } 


constexpr long double asinh(long double __x) 
{ return __builtin_asinhl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
asinh (_Tp __x) 
{ return __builtin_asinh (__x) ; } 




constexpr float atanh(float __x) 
{ return __builtin_atanhf(__x); } 


constexpr long double atanh(long double __x) 
{ return __builtin_atanhl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
atanh (_Tp __x) 
{ return __builtin_atanh (__x) ; } 




constexpr float cbrt(float __x) 
{ return __builtin_cbrtf(__x); } 


constexpr long double cbrt(long double __x) 
{ return __builtin_cbrtl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
cbrt (_Tp __x) 
{ return __builtin_cbrt (__x) ; } 




constexpr float copysign(float __x, float __y) 
{ return __builtin_copysignf(__x, __y); } 


constexpr long double copysign(long double __x, long double __y) 
{ return __builtin_copysignl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
copysign (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return copysign (__type (__x) , __type (__y)) ; 
} 




constexpr float erf(float __x) 
{ return __builtin_erff(__x); } 


constexpr long double erf(long double __x) 
{ return __builtin_erfl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
erf (_Tp __x) 
{ return __builtin_erf (__x) ; } 




constexpr float erfc(float __x) 
{ return __builtin_erfcf(__x); } 


constexpr long double erfc(long double __x) 
{ return __builtin_erfcl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
erfc (_Tp __x) 
{ return __builtin_erfc (__x) ; } 




constexpr float exp2(float __x) 
{ return __builtin_exp2f(__x); } 


constexpr long double exp2(long double __x) 
{ return __builtin_exp2l(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
exp2 (_Tp __x) 
{ return __builtin_exp2 (__x) ; } 




constexpr float expm1(float __x) 
{ return __builtin_expm1f(__x); } 


constexpr long double expm1(long double __x) 
{ return __builtin_expm1l(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
expm1 (_Tp __x) 
{ return __builtin_expm1 (__x) ; } 




constexpr float fdim(float __x, float __y) 
{ return __builtin_fdimf(__x, __y); } 


constexpr long double fdim(long double __x, long double __y) 
{ return __builtin_fdiml(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
fdim (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return fdim (__type (__x) , __type (__y)) ; 
} 




constexpr float fma(float __x, float __y, float __z) 
{ return __builtin_fmaf(__x, __y, __z); } 


constexpr long double fma(long double __x, long double __y, long double __z) 
{ return __builtin_fmal(__x, __y, __z); } 



template < typename _Tp , typename _Up , typename _Vp > 
constexpr typename __gnu_cxx :: __promote_3 < _Tp , _Up , _Vp > :: __type 
fma (_Tp __x , _Up __y , _Vp __z) 
{ 
typedef typename __gnu_cxx :: __promote_3 < _Tp , _Up , _Vp > :: __type __type ; 
return fma (__type (__x) , __type (__y) , __type (__z)) ; 
} 




constexpr float fmax(float __x, float __y) 
{ return __builtin_fmaxf(__x, __y); } 


constexpr long double fmax(long double __x, long double __y) 
{ return __builtin_fmaxl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
fmax (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return fmax (__type (__x) , __type (__y)) ; 
} 




constexpr float fmin(float __x, float __y) 
{ return __builtin_fminf(__x, __y); } 


constexpr long double fmin(long double __x, long double __y) 
{ return __builtin_fminl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
fmin (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return fmin (__type (__x) , __type (__y)) ; 
} 




constexpr float hypot(float __x, float __y) 
{ return __builtin_hypotf(__x, __y); } 


constexpr long double hypot(long double __x, long double __y) 
{ return __builtin_hypotl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
hypot (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return hypot (__type (__x) , __type (__y)) ; 
} 




constexpr int ilogb(float __x) 
{ return __builtin_ilogbf(__x); } 


constexpr int ilogb(long double __x) 
{ return __builtin_ilogbl(__x); } 



template < typename _Tp > 
constexpr 
typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
int > :: __type 
ilogb (_Tp __x) 
{ return __builtin_ilogb (__x) ; } 




constexpr float lgamma(float __x) 
{ return __builtin_lgammaf(__x); } 


constexpr long double lgamma(long double __x) 
{ return __builtin_lgammal(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
lgamma (_Tp __x) 
{ return __builtin_lgamma (__x) ; } 




constexpr long long llrint(float __x) 
{ return __builtin_llrintf(__x); } 


constexpr long long llrint(long double __x) 
{ return __builtin_llrintl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
long long > :: __type 
llrint (_Tp __x) 
{ return __builtin_llrint (__x) ; } 




constexpr long long llround(float __x) 
{ return __builtin_llroundf(__x); } 


constexpr long long llround(long double __x) 
{ return __builtin_llroundl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
long long > :: __type 
llround (_Tp __x) 
{ return __builtin_llround (__x) ; } 




constexpr float log1p(float __x) 
{ return __builtin_log1pf(__x); } 


constexpr long double log1p(long double __x) 
{ return __builtin_log1pl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
log1p (_Tp __x) 
{ return __builtin_log1p (__x) ; } 
# 1570
constexpr float log2(float __x) 
{ return __builtin_log2f(__x); } 


constexpr long double log2(long double __x) 
{ return __builtin_log2l(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
log2 (_Tp __x) 
{ return __builtin_log2 (__x) ; } 




constexpr float logb(float __x) 
{ return __builtin_logbf(__x); } 


constexpr long double logb(long double __x) 
{ return __builtin_logbl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
logb (_Tp __x) 
{ return __builtin_logb (__x) ; } 




constexpr long lrint(float __x) 
{ return __builtin_lrintf(__x); } 


constexpr long lrint(long double __x) 
{ return __builtin_lrintl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
long > :: __type 
lrint (_Tp __x) 
{ return __builtin_lrint (__x) ; } 




constexpr long lround(float __x) 
{ return __builtin_lroundf(__x); } 


constexpr long lround(long double __x) 
{ return __builtin_lroundl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
long > :: __type 
lround (_Tp __x) 
{ return __builtin_lround (__x) ; } 




constexpr float nearbyint(float __x) 
{ return __builtin_nearbyintf(__x); } 


constexpr long double nearbyint(long double __x) 
{ return __builtin_nearbyintl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
nearbyint (_Tp __x) 
{ return __builtin_nearbyint (__x) ; } 




constexpr float nextafter(float __x, float __y) 
{ return __builtin_nextafterf(__x, __y); } 


constexpr long double nextafter(long double __x, long double __y) 
{ return __builtin_nextafterl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
nextafter (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return nextafter (__type (__x) , __type (__y)) ; 
} 




constexpr float nexttoward(float __x, long double __y) 
{ return __builtin_nexttowardf(__x, __y); } 


constexpr long double nexttoward(long double __x, long double __y) 
{ return __builtin_nexttowardl(__x, __y); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
nexttoward (_Tp __x , long double __y) 
{ return __builtin_nexttoward (__x , __y) ; } 




constexpr float remainder(float __x, float __y) 
{ return __builtin_remainderf(__x, __y); } 


constexpr long double remainder(long double __x, long double __y) 
{ return __builtin_remainderl(__x, __y); } 



template < typename _Tp , typename _Up > 
constexpr typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
remainder (_Tp __x , _Up __y) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return remainder (__type (__x) , __type (__y)) ; 
} 




inline float remquo(float __x, float __y, int *__pquo) 
{ return __builtin_remquof(__x, __y, __pquo); } 


inline long double remquo(long double __x, long double __y, int *__pquo) 
{ return __builtin_remquol(__x, __y, __pquo); } 



template < typename _Tp , typename _Up > 
inline typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type 
remquo (_Tp __x , _Up __y , int * __pquo) 
{ 
typedef typename __gnu_cxx :: __promote_2 < _Tp , _Up > :: __type __type ; 
return remquo (__type (__x) , __type (__y) , __pquo) ; 
} 




constexpr float rint(float __x) 
{ return __builtin_rintf(__x); } 


constexpr long double rint(long double __x) 
{ return __builtin_rintl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
rint (_Tp __x) 
{ return __builtin_rint (__x) ; } 




constexpr float round(float __x) 
{ return __builtin_roundf(__x); } 


constexpr long double round(long double __x) 
{ return __builtin_roundl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
round (_Tp __x) 
{ return __builtin_round (__x) ; } 




constexpr float scalbln(float __x, long __ex) 
{ return __builtin_scalblnf(__x, __ex); } 


constexpr long double scalbln(long double __x, long __ex) 
{ return __builtin_scalblnl(__x, __ex); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
scalbln (_Tp __x , long __ex) 
{ return __builtin_scalbln (__x , __ex) ; } 




constexpr float scalbn(float __x, int __ex) 
{ return __builtin_scalbnf(__x, __ex); } 


constexpr long double scalbn(long double __x, int __ex) 
{ return __builtin_scalbnl(__x, __ex); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
scalbn (_Tp __x , int __ex) 
{ return __builtin_scalbn (__x , __ex) ; } 




constexpr float tgamma(float __x) 
{ return __builtin_tgammaf(__x); } 


constexpr long double tgamma(long double __x) 
{ return __builtin_tgammal(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
tgamma (_Tp __x) 
{ return __builtin_tgamma (__x) ; } 




constexpr float trunc(float __x) 
{ return __builtin_truncf(__x); } 


constexpr long double trunc(long double __x) 
{ return __builtin_truncl(__x); } 



template < typename _Tp > 
constexpr typename __gnu_cxx :: __enable_if < __is_integer < _Tp > :: __value , 
double > :: __type 
trunc (_Tp __x) 
{ return __builtin_trunc (__x) ; } 
# 1924 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\cmath" 3
}
# 1930
}
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\math.h" 3
using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 99 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\stdarg.h" 3
typedef __gnuc_va_list va_list; 
# 40 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\allocated_ptr.h" 3
namespace std { 




template < typename _Alloc > 
struct __allocated_ptr 
{ 
using pointer = typename allocator_traits < _Alloc > :: pointer ; 
using value_type = typename allocator_traits < _Alloc > :: value_type ; 


__allocated_ptr (_Alloc & __a , pointer __ptr) noexcept 
: _M_alloc (std :: __addressof (__a)) , _M_ptr (__ptr) 
{ } 


template < typename _Ptr , 
typename _Req = _Require < is_same < _Ptr , value_type * > > > 
__allocated_ptr (_Alloc & __a , _Ptr __ptr) 
: _M_alloc (std :: __addressof (__a)) , 
_M_ptr (pointer_traits < pointer > :: pointer_to (* __ptr)) 
{ } 


__allocated_ptr (__allocated_ptr && __gd) noexcept 
: _M_alloc (__gd . _M_alloc) , _M_ptr (__gd . _M_ptr) 
{ __gd . _M_ptr = nullptr ; } 


~ __allocated_ptr () 
{ 
if (_M_ptr != nullptr) 
std :: allocator_traits < _Alloc > :: deallocate (* _M_alloc , _M_ptr , 1) ; 
} 


__allocated_ptr & 
operator = (std :: nullptr_t) noexcept 
{ 
_M_ptr = nullptr ; 
return * this ; 
} 


value_type * get () { return std :: __to_address (_M_ptr) ; } 

private : 
_Alloc * _M_alloc ; 
pointer _M_ptr ; 
} ;


template < typename _Alloc > 
__allocated_ptr < _Alloc > 
__allocate_guarded (_Alloc & __a) 
{ 
return { __a , std :: allocator_traits < _Alloc > :: allocate (__a , 1) } ; 
} 


}
# 67 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
namespace std { 



namespace __detail { 
# 80
struct _List_node_base { 

_List_node_base *_M_next; 
_List_node_base *_M_prev; 


static void swap(_List_node_base & __x, _List_node_base & __y) noexcept; 


void _M_transfer(_List_node_base *const __first, _List_node_base *const __last) noexcept; 



void _M_reverse() noexcept; 


void _M_hook(_List_node_base *const __position) noexcept; 


void _M_unhook() noexcept; 
}; 


struct _List_node_header : public _List_node_base { 


size_t _M_size; 


_List_node_header() noexcept 
{ this->_M_init(); } 


_List_node_header(_List_node_header &&__x) noexcept : _List_node_base{__x._M_next, __x._M_prev}, _M_size(__x._M_size) 




{ 
if (__x._M_base()->_M_next == __x._M_base()) 
this->_M_next = (this->_M_prev = this);  else 

{ 
this->_M_next->_M_prev = (this->_M_prev->_M_next = this->_M_base()); 
__x._M_init(); 
}  
} 


void _M_move_nodes(_List_node_header &&__x) 
{ 
_List_node_base *const __xnode = __x._M_base(); 
if (__xnode->_M_next == __xnode) 
this->_M_init();  else 

{ 
_List_node_base *const __node = this->_M_base(); 
__node->_M_next = __xnode->_M_next; 
__node->_M_prev = __xnode->_M_prev; 
__node->_M_next->_M_prev = (__node->_M_prev->_M_next = __node); 

_M_size = __x._M_size; 

__x._M_init(); 
}  
} 



void _M_init() noexcept 
{ 
this->_M_next = (this->_M_prev = this); 

this->_M_size = 0; 

} 


private: _List_node_base *_M_base() { return this; } 
}; 
}




template < typename _Tp > 
struct _List_node : public __detail :: _List_node_base 
{ 

__gnu_cxx :: __aligned_membuf < _Tp > _M_storage ; 
_Tp * _M_valptr () { return _M_storage . _M_ptr () ; } 
_Tp const * _M_valptr () const { return _M_storage . _M_ptr () ; } 
# 177
} ;
# 184
template < typename _Tp > 
struct _List_iterator 
{ 
typedef _List_iterator < _Tp > _Self ; 
typedef _List_node < _Tp > _Node ; 

typedef ptrdiff_t difference_type ; 
typedef std :: bidirectional_iterator_tag iterator_category ; 
typedef _Tp value_type ; 
typedef _Tp * pointer ; 
typedef _Tp & reference ; 

_List_iterator () noexcept 
: _M_node () { } 

explicit 
_List_iterator (__detail :: _List_node_base * __x) noexcept 
: _M_node (__x) { } 

_Self 
_M_const_cast () const noexcept 
{ return * this ; } 


reference 
operator * () const noexcept 
{ return * static_cast < _Node * > (_M_node) -> _M_valptr () ; } 

pointer 
operator -> () const noexcept 
{ return static_cast < _Node * > (_M_node) -> _M_valptr () ; } 

_Self & 
operator ++ () noexcept 
{ 
_M_node = _M_node -> _M_next ; 
return * this ; 
} 

_Self 
operator ++ (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _M_node -> _M_next ; 
return __tmp ; 
} 

_Self & 
operator -- () noexcept 
{ 
_M_node = _M_node -> _M_prev ; 
return * this ; 
} 

_Self 
operator -- (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _M_node -> _M_prev ; 
return __tmp ; 
} 

friend bool 
operator == (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node == __y . _M_node ; } 

friend bool 
operator != (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node != __y . _M_node ; } 


__detail :: _List_node_base * _M_node ; 
} ;
# 263
template < typename _Tp > 
struct _List_const_iterator 
{ 
typedef _List_const_iterator < _Tp > _Self ; 
typedef const _List_node < _Tp > _Node ; 
typedef _List_iterator < _Tp > iterator ; 

typedef ptrdiff_t difference_type ; 
typedef std :: bidirectional_iterator_tag iterator_category ; 
typedef _Tp value_type ; 
typedef const _Tp * pointer ; 
typedef const _Tp & reference ; 

_List_const_iterator () noexcept 
: _M_node () { } 

explicit 
_List_const_iterator (const __detail :: _List_node_base * __x) 
noexcept 
: _M_node (__x) { } 

_List_const_iterator (const iterator & __x) noexcept 
: _M_node (__x . _M_node) { } 

iterator 
_M_const_cast () const noexcept 
{ return iterator (const_cast < __detail :: _List_node_base * > (_M_node)) ; } 


reference 
operator * () const noexcept 
{ return * static_cast < _Node * > (_M_node) -> _M_valptr () ; } 

pointer 
operator -> () const noexcept 
{ return static_cast < _Node * > (_M_node) -> _M_valptr () ; } 

_Self & 
operator ++ () noexcept 
{ 
_M_node = _M_node -> _M_next ; 
return * this ; 
} 

_Self 
operator ++ (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _M_node -> _M_next ; 
return __tmp ; 
} 

_Self & 
operator -- () noexcept 
{ 
_M_node = _M_node -> _M_prev ; 
return * this ; 
} 

_Self 
operator -- (int) noexcept 
{ 
_Self __tmp = * this ; 
_M_node = _M_node -> _M_prev ; 
return __tmp ; 
} 

friend bool 
operator == (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node == __y . _M_node ; } 

friend bool 
operator != (const _Self & __x , const _Self & __y) noexcept 
{ return __x . _M_node != __y . _M_node ; } 


const __detail :: _List_node_base * _M_node ; 
} ;

inline namespace __cxx11 { 

template < typename _Tp , typename _Alloc > 
class _List_base 
{ 
protected : 
typedef typename __gnu_cxx :: __alloc_traits < _Alloc > :: template 
rebind < _Tp > :: other _Tp_alloc_type ; 
typedef __gnu_cxx :: __alloc_traits < _Tp_alloc_type > _Tp_alloc_traits ; 
typedef typename _Tp_alloc_traits :: template 
rebind < _List_node < _Tp > > :: other _Node_alloc_type ; 
typedef __gnu_cxx :: __alloc_traits < _Node_alloc_type > _Node_alloc_traits ; 


static size_t 
_S_distance (const __detail :: _List_node_base * __first , 
const __detail :: _List_node_base * __last) 
{ 
size_t __n = 0 ; 
while (__first != __last) 
{ 
__first = __first -> _M_next ; 
++ __n ; 
} 
return __n ; 
} 


struct _List_impl 
: public _Node_alloc_type 
{ 
__detail :: _List_node_header _M_node ; 

_List_impl () noexcept (is_nothrow_default_constructible < _Node_alloc_type > :: value) 

: _Node_alloc_type () 
{ } 

_List_impl (const _Node_alloc_type & __a) noexcept 
: _Node_alloc_type (__a) 
{ } 


_List_impl (_List_impl &&) = default ; 

_List_impl (_Node_alloc_type && __a , _List_impl && __x) 
: _Node_alloc_type (std :: move (__a)) , _M_node (std :: move (__x . _M_node)) 
{ } 

_List_impl (_Node_alloc_type && __a) noexcept 
: _Node_alloc_type (std :: move (__a)) 
{ } 

} ; 

_List_impl _M_impl ; 


size_t _M_get_size () const { return _M_impl . _M_node . _M_size ; } 

void _M_set_size (size_t __n) { _M_impl . _M_node . _M_size = __n ; } 

void _M_inc_size (size_t __n) { _M_impl . _M_node . _M_size += __n ; } 

void _M_dec_size (size_t __n) { _M_impl . _M_node . _M_size -= __n ; } 


size_t 
_M_distance (const __detail :: _List_node_base * __first , 
const __detail :: _List_node_base * __last) const 
{ return _S_distance (__first , __last) ; } 


size_t _M_node_count () const { return _M_get_size () ; } 
# 436 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
typename _Node_alloc_traits :: pointer 
_M_get_node () 
{ return _Node_alloc_traits :: allocate (_M_impl , 1) ; } 

void 
_M_put_node (typename _Node_alloc_traits :: pointer __p) noexcept 
{ _Node_alloc_traits :: deallocate (_M_impl , __p , 1) ; } 

public : 
typedef _Alloc allocator_type ; 

_Node_alloc_type & 
_M_get_Node_allocator () noexcept 
{ return _M_impl ; } 

const _Node_alloc_type & 
_M_get_Node_allocator () const noexcept 
{ return _M_impl ; } 


_List_base () = default ; 




_List_base (const _Node_alloc_type & __a) noexcept 
: _M_impl (__a) 
{ } 


_List_base (_List_base &&) = default ; 


_List_base (_List_base && __x , _Node_alloc_type && __a) 
: _M_impl (std :: move (__a)) 
{ 
if (__x . _M_get_Node_allocator () == _M_get_Node_allocator ()) 
_M_move_nodes (std :: move (__x)) ; 

} 



_List_base (_Node_alloc_type && __a , _List_base && __x) 
: _M_impl (std :: move (__a) , std :: move (__x . _M_impl)) 
{ } 


_List_base (_Node_alloc_type && __a) 
: _M_impl (std :: move (__a)) 
{ } 

void 
_M_move_nodes (_List_base && __x) 
{ _M_impl . _M_node . _M_move_nodes (std :: move (__x . _M_impl . _M_node)) ; } 



~ _List_base () noexcept 
{ _M_clear () ; } 

void 
_M_clear () noexcept ; 

void 
_M_init () noexcept 
{ this -> _M_impl . _M_node . _M_init () ; } 
} ;
# 551 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _Tp , typename _Alloc = std :: allocator < _Tp > > 
class list : protected _List_base < _Tp , _Alloc > 
{ 
# 564 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
static_assert (is_same < typename remove_cv < _Tp > :: type , _Tp > :: value , 
"std::list must have a non-const, non-volatile value_type") ; 
# 572
typedef _List_base < _Tp , _Alloc > _Base ; 
typedef typename _Base :: _Tp_alloc_type _Tp_alloc_type ; 
typedef typename _Base :: _Tp_alloc_traits _Tp_alloc_traits ; 
typedef typename _Base :: _Node_alloc_type _Node_alloc_type ; 
typedef typename _Base :: _Node_alloc_traits _Node_alloc_traits ; 

public : 
typedef _Tp value_type ; 
typedef typename _Tp_alloc_traits :: pointer pointer ; 
typedef typename _Tp_alloc_traits :: const_pointer const_pointer ; 
typedef typename _Tp_alloc_traits :: reference reference ; 
typedef typename _Tp_alloc_traits :: const_reference const_reference ; 
typedef _List_iterator < _Tp > iterator ; 
typedef _List_const_iterator < _Tp > const_iterator ; 
typedef std :: reverse_iterator < const_iterator > const_reverse_iterator ; 
typedef std :: reverse_iterator < iterator > reverse_iterator ; 
typedef size_t size_type ; 
typedef ptrdiff_t difference_type ; 
typedef _Alloc allocator_type ; 

protected : 


typedef _List_node < _Tp > _Node ; 

using _Base :: _M_impl ; 
using _Base :: _M_put_node ; 
using _Base :: _M_get_node ; 
using _Base :: _M_get_Node_allocator ; 
# 626 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename ... _Args > 
_Node * 
_M_create_node (_Args && ... __args) 
{ 
auto __p = this -> _M_get_node () ; 
auto & __alloc = _M_get_Node_allocator () ; 
__allocated_ptr < _Node_alloc_type > __guard { __alloc , __p } ; 
_Node_alloc_traits :: construct (__alloc , __p -> _M_valptr () , 
std :: forward < _Args > (__args) ...) ; 
__guard = nullptr ; 
return __p ; 
} 



static size_t 
_S_distance (const_iterator __first , const_iterator __last) 
{ return std :: distance (__first , __last) ; } 


size_t 
_M_node_count () const 
{ return this -> _M_get_size () ; } 
# 661 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
public : 
# 669
list () = default ; 
# 678 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
explicit 
list (const allocator_type & __a) noexcept 
: _Base (_Node_alloc_type (__a)) { } 
# 691 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
explicit 
list (size_type __n , const allocator_type & __a = allocator_type ()) 
: _Base (_Node_alloc_type (__a)) 
{ _M_default_initialize (__n) ; } 
# 704 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list (size_type __n , const value_type & __value , 
const allocator_type & __a = allocator_type ()) 
: _Base (_Node_alloc_type (__a)) 
{ _M_fill_initialize (__n , __value) ; } 
# 731 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list (const list & __x) 
: _Base (_Node_alloc_traits :: 
_S_select_on_copy (__x . _M_get_Node_allocator ())) 
{ _M_initialize_dispatch (__x . begin () , __x . end () , __false_type ()) ; } 
# 744 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list (list &&) = default ; 
# 754 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list (initializer_list < value_type > __l , 
const allocator_type & __a = allocator_type ()) 
: _Base (_Node_alloc_type (__a)) 
{ _M_initialize_dispatch (__l . begin () , __l . end () , __false_type ()) ; } 

list (const list & __x , const allocator_type & __a) 
: _Base (_Node_alloc_type (__a)) 
{ _M_initialize_dispatch (__x . begin () , __x . end () , __false_type ()) ; } 

private : 
list (list && __x , const allocator_type & __a , true_type) noexcept 
: _Base (_Node_alloc_type (__a) , std :: move (__x)) 
{ } 

list (list && __x , const allocator_type & __a , false_type) 
: _Base (_Node_alloc_type (__a)) 
{ 
if (__x . _M_get_Node_allocator () == this -> _M_get_Node_allocator ()) 
this -> _M_move_nodes (std :: move (__x)) ; 
else 
insert (begin () , std :: __make_move_if_noexcept_iterator (__x . begin ()) , 
std :: __make_move_if_noexcept_iterator (__x . end ())) ; 
} 

public : 
list (list && __x , const allocator_type & __a) 
noexcept (_Node_alloc_traits :: _S_always_equal ()) 
: list (std :: move (__x) , __a , 
typename _Node_alloc_traits :: is_always_equal { }) 
{ } 
# 797 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
list (_InputIterator __first , _InputIterator __last , 
const allocator_type & __a = allocator_type ()) 
: _Base (_Node_alloc_type (__a)) 
{ _M_initialize_dispatch (__first , __last , __false_type ()) ; } 
# 823 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
~ list () = default ; 
# 834 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list & 
operator = (const list & __x) ; 
# 848 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list & 
operator = (list && __x) 
noexcept (_Node_alloc_traits :: _S_nothrow_move ()) 
{ 
constexpr bool __move_storage = 
_Node_alloc_traits :: _S_propagate_on_move_assign () 
|| _Node_alloc_traits :: _S_always_equal () ; 
_M_move_assign (std :: move (__x) , __bool_constant < __move_storage > ()) ; 
return * this ; 
} 
# 866 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
list & 
operator = (initializer_list < value_type > __l) 
{ 
this -> assign (__l . begin () , __l . end ()) ; 
return * this ; 
} 
# 884 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
assign (size_type __n , const value_type & __val) 
{ _M_fill_assign (__n , __val) ; } 
# 901 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
void 
assign (_InputIterator __first , _InputIterator __last) 
{ _M_assign_dispatch (__first , __last , __false_type ()) ; } 
# 925 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
assign (initializer_list < value_type > __l) 
{ this -> _M_assign_dispatch (__l . begin () , __l . end () , __false_type ()) ; } 



allocator_type 
get_allocator () const noexcept 
{ return allocator_type (_Base :: _M_get_Node_allocator ()) ; } 
# 940
iterator 
begin () noexcept 
{ return iterator (this -> _M_impl . _M_node . _M_next) ; } 
# 949
const_iterator 
begin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_node . _M_next) ; } 
# 958
iterator 
end () noexcept 
{ return iterator (& this -> _M_impl . _M_node) ; } 
# 967
const_iterator 
end () const noexcept 
{ return const_iterator (& this -> _M_impl . _M_node) ; } 
# 976
reverse_iterator 
rbegin () noexcept 
{ return reverse_iterator (end ()) ; } 
# 985
const_reverse_iterator 
rbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 
# 994
reverse_iterator 
rend () noexcept 
{ return reverse_iterator (begin ()) ; } 
# 1003
const_reverse_iterator 
rend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 
# 1013
const_iterator 
cbegin () const noexcept 
{ return const_iterator (this -> _M_impl . _M_node . _M_next) ; } 
# 1022
const_iterator 
cend () const noexcept 
{ return const_iterator (& this -> _M_impl . _M_node) ; } 
# 1031
const_reverse_iterator 
crbegin () const noexcept 
{ return const_reverse_iterator (end ()) ; } 
# 1040
const_reverse_iterator 
crend () const noexcept 
{ return const_reverse_iterator (begin ()) ; } 
# 1050
bool 
empty () const noexcept 
{ return this -> _M_impl . _M_node . _M_next == & this -> _M_impl . _M_node ; } 


size_type 
size () const noexcept 
{ return _M_node_count () ; } 


size_type 
max_size () const noexcept 
{ return _Node_alloc_traits :: max_size (_M_get_Node_allocator ()) ; } 
# 1074 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
resize (size_type __new_size) ; 
# 1087 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
resize (size_type __new_size , const value_type & __x) ; 
# 1109 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
reference 
front () noexcept 
{ return * begin () ; } 
# 1117
const_reference 
front () const noexcept 
{ return * begin () ; } 
# 1125
reference 
back () noexcept 
{ 
iterator __tmp = end () ; 
-- __tmp ; 
return * __tmp ; 
} 
# 1137
const_reference 
back () const noexcept 
{ 
const_iterator __tmp = end () ; 
-- __tmp ; 
return * __tmp ; 
} 
# 1156 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
push_front (const value_type & __x) 
{ this -> _M_insert (begin () , __x) ; } 


void 
push_front (value_type && __x) 
{ this -> _M_insert (begin () , std :: move (__x)) ; } 

template < typename ... _Args > 



void 

emplace_front (_Args && ... __args) 
{ 
this -> _M_insert (begin () , std :: forward < _Args > (__args) ...) ; 



} 
# 1192 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
pop_front () noexcept 
{ this -> _M_erase (begin ()) ; } 
# 1206 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
push_back (const value_type & __x) 
{ this -> _M_insert (end () , __x) ; } 


void 
push_back (value_type && __x) 
{ this -> _M_insert (end () , std :: move (__x)) ; } 

template < typename ... _Args > 



void 

emplace_back (_Args && ... __args) 
{ 
this -> _M_insert (end () , std :: forward < _Args > (__args) ...) ; 



} 
# 1241 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
pop_back () noexcept 
{ this -> _M_erase (iterator (this -> _M_impl . _M_node . _M_prev)) ; } 
# 1258 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename ... _Args > 
iterator 
emplace (const_iterator __position , _Args && ... __args) ; 
# 1273 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 
insert (const_iterator __position , const value_type & __x) ; 
# 1303 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 
insert (const_iterator __position , value_type && __x) 
{ return emplace (__position , std :: move (__x)) ; } 
# 1322 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 
insert (const_iterator __p , initializer_list < value_type > __l) 
{ return this -> insert (__p , __l . begin () , __l . end ()) ; } 
# 1342 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 
insert (const_iterator __position , size_type __n , const value_type & __x) ; 
# 1381 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _InputIterator , 
typename = std :: _RequireInputIter < _InputIterator > > 
iterator 
insert (const_iterator __position , _InputIterator __first , 
_InputIterator __last) ; 
# 1425 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 

erase (const_iterator __position) noexcept ; 
# 1450 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
iterator 

erase (const_iterator __first , const_iterator __last) noexcept 



{ 
while (__first != __last) 
__first = erase (__first) ; 
return __last . _M_const_cast () ; 
} 
# 1473 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
swap (list & __x) noexcept 
{ 
__detail :: _List_node_base :: swap (this -> _M_impl . _M_node , 
__x . _M_impl . _M_node) ; 

size_t __xsize = __x . _M_get_size () ; 
__x . _M_set_size (this -> _M_get_size ()) ; 
this -> _M_set_size (__xsize) ; 

_Node_alloc_traits :: _S_on_swap (this -> _M_get_Node_allocator () , 
__x . _M_get_Node_allocator ()) ; 
} 
# 1493
void 
clear () noexcept 
{ 
_Base :: _M_clear () ; 
_Base :: _M_init () ; 
} 
# 1512 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 

splice (const_iterator __position , list && __x) noexcept 



{ 
if (! __x . empty ()) 
{ 
_M_check_equal_allocators (__x) ; 

this -> _M_transfer (__position . _M_const_cast () , 
__x . begin () , __x . end ()) ; 

this -> _M_inc_size (__x . _M_get_size ()) ; 
__x . _M_set_size (0) ; 
} 
} 


void 
splice (const_iterator __position , list & __x) noexcept 
{ splice (__position , std :: move (__x)) ; } 
# 1548 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
splice (const_iterator __position , list && __x , const_iterator __i) noexcept 
# 1563 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
{ 
iterator __j = __i . _M_const_cast () ; 
++ __j ; 
if (__position == __i || __position == __j) 
return ; 

if (this != std :: __addressof (__x)) 
_M_check_equal_allocators (__x) ; 

this -> _M_transfer (__position . _M_const_cast () , 
__i . _M_const_cast () , __j) ; 

this -> _M_inc_size (1) ; 
__x . _M_dec_size (1) ; 
} 
# 1590 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
splice (const_iterator __position , list & __x , const_iterator __i) noexcept 
{ splice (__position , std :: move (__x) , __i) ; } 
# 1609 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
splice (const_iterator __position , list && __x , const_iterator __first , 
const_iterator __last) noexcept 
# 1629 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
{ 
if (__first != __last) 
{ 
if (this != std :: __addressof (__x)) 
_M_check_equal_allocators (__x) ; 

size_t __n = _S_distance (__first , __last) ; 
this -> _M_inc_size (__n) ; 
__x . _M_dec_size (__n) ; 

this -> _M_transfer (__position . _M_const_cast () , 
__first . _M_const_cast () , 
__last . _M_const_cast ()) ; 
} 
} 
# 1659 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
splice (const_iterator __position , list & __x , const_iterator __first , 
const_iterator __last) noexcept 
{ splice (__position , std :: move (__x) , __first , __last) ; } 


private : 
# 1672
typedef void __remove_return_type ; 


public : 
# 1689 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
__remove_return_type 
remove (const _Tp & __value) ; 
# 1703 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _Predicate > 
__remove_return_type 
remove_if (_Predicate) ; 
# 1718 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
__remove_return_type 
unique () ; 
# 1733 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _BinaryPredicate > 
__remove_return_type 
unique (_BinaryPredicate) ; 
# 1749 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
merge (list && __x) ; 

void 
merge (list & __x) 
{ merge (std :: move (__x)) ; } 
# 1774 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _StrictWeakOrdering > 
void 
merge (list && __x , _StrictWeakOrdering __comp) ; 

template < typename _StrictWeakOrdering > 
void 
merge (list & __x , _StrictWeakOrdering __comp) 
{ merge (std :: move (__x) , __comp) ; } 
# 1793 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
void 
reverse () noexcept 
{ this -> _M_impl . _M_node . _M_reverse () ; } 
# 1803
void 
sort () ; 
# 1812
template < typename _StrictWeakOrdering > 
void 
sort (_StrictWeakOrdering) ; 

protected : 
# 1823
template < typename _Integer > 
void 
_M_initialize_dispatch (_Integer __n , _Integer __x , __true_type) 
{ _M_fill_initialize (static_cast < size_type > (__n) , __x) ; } 


template < typename _InputIterator > 
void 
_M_initialize_dispatch (_InputIterator __first , _InputIterator __last , 
__false_type) 
{ 
for (; __first != __last ; ++ __first) 

emplace_back (* __first) ; 



} 



void 
_M_fill_initialize (size_type __n , const value_type & __x) 
{ 
for (; __n ; -- __n) 
push_back (__x) ; 
} 



void 
_M_default_initialize (size_type __n) 
{ 
for (; __n ; -- __n) 
emplace_back () ; 
} 


void 
_M_default_append (size_type __n) ; 
# 1871 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _Integer > 
void 
_M_assign_dispatch (_Integer __n , _Integer __val , __true_type) 
{ _M_fill_assign (__n , __val) ; } 


template < typename _InputIterator > 
void 
_M_assign_dispatch (_InputIterator __first , _InputIterator __last , 
__false_type) ; 



void 
_M_fill_assign (size_type __n , const value_type & __val) ; 



void 
_M_transfer (iterator __position , iterator __first , iterator __last) 
{ __position . _M_node -> _M_transfer (__first . _M_node , __last . _M_node) ; } 
# 1903 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename ... _Args > 
void 
_M_insert (iterator __position , _Args && ... __args) 
{ 
_Node * __tmp = _M_create_node (std :: forward < _Args > (__args) ...) ; 
__tmp -> _M_hook (__position . _M_node) ; 
this -> _M_inc_size (1) ; 
} 



void 
_M_erase (iterator __position) noexcept 
{ 
this -> _M_dec_size (1) ; 
__position . _M_node -> _M_unhook () ; 
_Node * __n = static_cast < _Node * > (__position . _M_node) ; 

_Node_alloc_traits :: destroy (_M_get_Node_allocator () , __n -> _M_valptr ()) ; 




_M_put_node (__n) ; 
} 


void 
_M_check_equal_allocators (list & __x) noexcept 
{ 
if (std :: __alloc_neq < typename _Base :: _Node_alloc_type > :: 
_S_do_it (_M_get_Node_allocator () , __x . _M_get_Node_allocator ())) 
__builtin_abort () ; 
} 


const_iterator 
_M_resize_pos (size_type & __new_size) const ; 


void 
_M_move_assign (list && __x , true_type) noexcept 
{ 
this -> _M_clear () ; 
this -> _M_move_nodes (std :: move (__x)) ; 
std :: __alloc_on_move (this -> _M_get_Node_allocator () , 
__x . _M_get_Node_allocator ()) ; 
} 

void 
_M_move_assign (list && __x , false_type) 
{ 
if (__x . _M_get_Node_allocator () == this -> _M_get_Node_allocator ()) 
_M_move_assign (std :: move (__x) , true_type { }) ; 
else 


_M_assign_dispatch (std :: __make_move_if_noexcept_iterator (__x . begin ()) , 
std :: __make_move_if_noexcept_iterator (__x . end ()) , 
__false_type { }) ; 
} 

} ;
# 1977 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
}
# 1989 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _Tp , typename _Alloc > 
inline bool 
operator == (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ 

if (__x . size () != __y . size ()) 
return false ; 


typedef typename list < _Tp , _Alloc > :: const_iterator const_iterator ; 
const_iterator __end1 = __x . end () ; 
const_iterator __end2 = __y . end () ; 

const_iterator __i1 = __x . begin () ; 
const_iterator __i2 = __y . begin () ; 
while (__i1 != __end1 && __i2 != __end2 && * __i1 == * __i2) 
{ 
++ __i1 ; 
++ __i2 ; 
} 
return __i1 == __end1 && __i2 == __end2 ; 
} 
# 2023 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\stl_list.h" 3
template < typename _Tp , typename _Alloc > 
inline bool 
operator < (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ return std :: lexicographical_compare (__x . begin () , __x . end () , 
__y . begin () , __y . end ()) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator != (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ return ! (__x == __y) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator > (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ return __y < __x ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator <= (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ return ! (__y < __x) ; } 


template < typename _Tp , typename _Alloc > 
inline bool 
operator >= (const list < _Tp , _Alloc > & __x , const list < _Tp , _Alloc > & __y) 
{ return ! (__x < __y) ; } 


template < typename _Tp , typename _Alloc > 
inline void 
swap (list < _Tp , _Alloc > & __x , list < _Tp , _Alloc > & __y) 
noexcept (noexcept (__x . swap (__y))) 
{ __x . swap (__y) ; } 
# 2065
template < typename _Tp > 
inline ptrdiff_t 
__distance (std :: _List_iterator < _Tp > __first , 
std :: _List_iterator < _Tp > __last , 
input_iterator_tag __tag) 
{ 
typedef std :: _List_const_iterator < _Tp > _CIter ; 
return std :: __distance (_CIter (__first) , _CIter (__last) , __tag) ; 
} 

template < typename _Tp > 
inline ptrdiff_t 
__distance (std :: _List_const_iterator < _Tp > __first , 
std :: _List_const_iterator < _Tp > __last , 
input_iterator_tag) 
{ 
typedef __detail :: _List_node_header _Sentinel ; 
std :: _List_const_iterator < _Tp > __beyond = __last ; 
++ __beyond ; 
const bool __whole = __first == __beyond ; 
if (__builtin_constant_p (__whole) && __whole) 
return static_cast < const _Sentinel * > (__last . _M_node) -> _M_size ; 

ptrdiff_t __n = 0 ; 
while (__first != __last) 
{ 
++ __first ; 
++ __n ; 
} 
return __n ; 
} 



}
# 59 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\list.tcc" 3
namespace std { 




template < typename _Tp , typename _Alloc > 
void 
_List_base < _Tp , _Alloc > :: 
_M_clear () noexcept 
{ 
typedef _List_node < _Tp > _Node ; 
__detail :: _List_node_base * __cur = _M_impl . _M_node . _M_next ; 
while (__cur != & _M_impl . _M_node) 
{ 
_Node * __tmp = static_cast < _Node * > (__cur) ; 
__cur = __tmp -> _M_next ; 
_Tp * __val = __tmp -> _M_valptr () ; 

_Node_alloc_traits :: destroy (_M_get_Node_allocator () , __val) ; 



_M_put_node (__tmp) ; 
} 
} 


template < typename _Tp , typename _Alloc > 
template < typename ... _Args > 
typename list < _Tp , _Alloc > :: iterator 
list < _Tp , _Alloc > :: 
emplace (const_iterator __position , _Args && ... __args) 
{ 
_Node * __tmp = _M_create_node (std :: forward < _Args > (__args) ...) ; 
__tmp -> _M_hook (__position . _M_const_cast () . _M_node) ; 
this -> _M_inc_size (1) ; 
return iterator (__tmp) ; 
} 


template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: iterator 
list < _Tp , _Alloc > :: 

insert (const_iterator __position , const value_type & __x) 



{ 
_Node * __tmp = _M_create_node (__x) ; 
__tmp -> _M_hook (__position . _M_const_cast () . _M_node) ; 
this -> _M_inc_size (1) ; 
return iterator (__tmp) ; 
} 


template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: iterator 
list < _Tp , _Alloc > :: 
insert (const_iterator __position , size_type __n , const value_type & __x) 
{ 
if (__n) 
{ 
list __tmp (__n , __x , get_allocator ()) ; 
iterator __it = __tmp . begin () ; 
splice (__position , __tmp) ; 
return __it ; 
} 
return __position . _M_const_cast () ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _InputIterator , typename > 
typename list < _Tp , _Alloc > :: iterator 
list < _Tp , _Alloc > :: 
insert (const_iterator __position , _InputIterator __first , 
_InputIterator __last) 
{ 
list __tmp (__first , __last , get_allocator ()) ; 
if (! __tmp . empty ()) 
{ 
iterator __it = __tmp . begin () ; 
splice (__position , __tmp) ; 
return __it ; 
} 
return __position . _M_const_cast () ; 
} 


template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: iterator 
list < _Tp , _Alloc > :: 

erase (const_iterator __position) noexcept 



{ 
iterator __ret = iterator (__position . _M_node -> _M_next) ; 
_M_erase (__position . _M_const_cast ()) ; 
return __ret ; 
} 
# 173 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\list.tcc" 3
template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: const_iterator 
list < _Tp , _Alloc > :: 
_M_resize_pos (size_type & __new_size) const 
{ 
const_iterator __i ; 

const size_type __len = size () ; 
if (__new_size < __len) 
{ 
if (__new_size <= __len / 2) 
{ 
__i = begin () ; 
std :: advance (__i , __new_size) ; 
} 
else 
{ 
__i = end () ; 
ptrdiff_t __num_erase = __len - __new_size ; 
std :: advance (__i , - __num_erase) ; 
} 
__new_size = 0 ; 
return __i ; 
} 
else 
__i = end () ; 
# 204
__new_size -= __len ; 
return __i ; 
} 


template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 
_M_default_append (size_type __n) 
{ 
size_type __i = 0 ; 
try 
{ 
for (; __i < __n ; ++ __i) 
emplace_back () ; 
} 
catch (...) 
{ 
for (; __i ; -- __i) 
pop_back () ; 
throw ; 
} 
} 

template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 
resize (size_type __new_size) 
{ 
const_iterator __i = _M_resize_pos (__new_size) ; 
if (__new_size) 
_M_default_append (__new_size) ; 
else 
erase (__i , end ()) ; 
} 

template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 
resize (size_type __new_size , const value_type & __x) 
{ 
const_iterator __i = _M_resize_pos (__new_size) ; 
if (__new_size) 
insert (end () , __new_size , __x) ; 
else 
erase (__i , end ()) ; 
} 
# 265 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\list.tcc" 3
template < typename _Tp , typename _Alloc > 
list < _Tp , _Alloc > & 
list < _Tp , _Alloc > :: 
operator = (const list & __x) 
{ 
if (this != std :: __addressof (__x)) 
{ 

if (_Node_alloc_traits :: _S_propagate_on_copy_assign ()) 
{ 
auto & __this_alloc = this -> _M_get_Node_allocator () ; 
auto & __that_alloc = __x . _M_get_Node_allocator () ; 
if (! _Node_alloc_traits :: _S_always_equal () 
&& __this_alloc != __that_alloc) 
{ 

clear () ; 
} 
std :: __alloc_on_copy (__this_alloc , __that_alloc) ; 
} 

_M_assign_dispatch (__x . begin () , __x . end () , __false_type ()) ; 
} 
return * this ; 
} 

template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 
_M_fill_assign (size_type __n , const value_type & __val) 
{ 
iterator __i = begin () ; 
for (; __i != end () && __n > 0 ; ++ __i , -- __n) 
* __i = __val ; 
if (__n > 0) 
insert (end () , __n , __val) ; 
else 
erase (__i , end ()) ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _InputIterator > 
void 
list < _Tp , _Alloc > :: 
_M_assign_dispatch (_InputIterator __first2 , _InputIterator __last2 , 
__false_type) 
{ 
iterator __first1 = begin () ; 
iterator __last1 = end () ; 
for (; __first1 != __last1 && __first2 != __last2 ; 
++ __first1 , (void) ++ __first2) 
* __first1 = * __first2 ; 
if (__first2 == __last2) 
erase (__first1 , __last1) ; 
else 
insert (__last1 , __first2 , __last2) ; 
} 
# 329
template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: __remove_return_type 
list < _Tp , _Alloc > :: 
remove (const value_type & __value) 
{ 
size_type __removed __attribute__ ((__unused__)) = 0 ; 
iterator __first = begin () ; 
iterator __last = end () ; 
iterator __extra = __last ; 
while (__first != __last) 
{ 
iterator __next = __first ; 
++ __next ; 
if (* __first == __value) 
{ 



if (std :: __addressof (* __first) != std :: __addressof (__value)) 
{ 
_M_erase (__first) ; 
; 
} 
else 
__extra = __first ; 
} 
__first = __next ; 
} 
if (__extra != __last) 
{ 
_M_erase (__extra) ; 
; 
} 
return ; 
} 

template < typename _Tp , typename _Alloc > 
typename list < _Tp , _Alloc > :: __remove_return_type 
list < _Tp , _Alloc > :: 
unique () 
{ 
iterator __first = begin () ; 
iterator __last = end () ; 
if (__first == __last) 
return ; 
size_type __removed __attribute__ ((__unused__)) = 0 ; 
iterator __next = __first ; 
while (++ __next != __last) 
{ 
if (* __first == * __next) 
{ 
_M_erase (__next) ; 
; 
} 
else 
__first = __next ; 
__next = __first ; 
} 
return ; 
} 

template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 

merge (list && __x) 



{ 


if (this != std :: __addressof (__x)) 
{ 
_M_check_equal_allocators (__x) ; 

iterator __first1 = begin () ; 
iterator __last1 = end () ; 
iterator __first2 = __x . begin () ; 
iterator __last2 = __x . end () ; 
const size_t __orig_size = __x . size () ; 
try { 
while (__first1 != __last1 && __first2 != __last2) 
if (* __first2 < * __first1) 
{ 
iterator __next = __first2 ; 
_M_transfer (__first1 , __first2 , ++ __next) ; 
__first2 = __next ; 
} 
else 
++ __first1 ; 
if (__first2 != __last2) 
_M_transfer (__last1 , __first2 , __last2) ; 

this -> _M_inc_size (__x . _M_get_size ()) ; 
__x . _M_set_size (0) ; 
} 
catch (...) 
{ 
const size_t __dist = std :: distance (__first2 , __last2) ; 
this -> _M_inc_size (__orig_size - __dist) ; 
__x . _M_set_size (__dist) ; 
throw ; 
} 
} 
} 

template < typename _Tp , typename _Alloc > 
template < typename _StrictWeakOrdering > 
void 
list < _Tp , _Alloc > :: 

merge (list && __x , _StrictWeakOrdering __comp) 



{ 


if (this != std :: __addressof (__x)) 
{ 
_M_check_equal_allocators (__x) ; 

iterator __first1 = begin () ; 
iterator __last1 = end () ; 
iterator __first2 = __x . begin () ; 
iterator __last2 = __x . end () ; 
const size_t __orig_size = __x . size () ; 
try 
{ 
while (__first1 != __last1 && __first2 != __last2) 
if (__comp (* __first2 , * __first1)) 
{ 
iterator __next = __first2 ; 
_M_transfer (__first1 , __first2 , ++ __next) ; 
__first2 = __next ; 
} 
else 
++ __first1 ; 
if (__first2 != __last2) 
_M_transfer (__last1 , __first2 , __last2) ; 

this -> _M_inc_size (__x . _M_get_size ()) ; 
__x . _M_set_size (0) ; 
} 
catch (...) 
{ 
const size_t __dist = std :: distance (__first2 , __last2) ; 
this -> _M_inc_size (__orig_size - __dist) ; 
__x . _M_set_size (__dist) ; 
throw ; 
} 
} 
} 

template < typename _Tp , typename _Alloc > 
void 
list < _Tp , _Alloc > :: 
sort () 
{ 

if (this -> _M_impl . _M_node . _M_next != & this -> _M_impl . _M_node 
&& this -> _M_impl . _M_node . _M_next -> _M_next != & this -> _M_impl . _M_node) 
{ 
list __carry ; 
list __tmp [ 64 ] ; 
list * __fill = __tmp ; 
list * __counter ; 
try 
{ 
do 
{ 
__carry . splice (__carry . begin () , * this , begin ()) ; 

for (__counter = __tmp ; 
__counter != __fill && ! __counter -> empty () ; 
++ __counter) 
{ 
__counter -> merge (__carry) ; 
__carry . swap (* __counter) ; 
} 
__carry . swap (* __counter) ; 
if (__counter == __fill) 
++ __fill ; 
} 
while (! empty ()) ; 

for (__counter = __tmp + 1 ; __counter != __fill ; ++ __counter) 
__counter -> merge (* (__counter - 1)) ; 
swap (* (__fill - 1)) ; 
} 
catch (...) 
{ 
this -> splice (this -> end () , __carry) ; 
for (int __i = 0 ; __i < sizeof (__tmp) / sizeof (__tmp [ 0 ]) ; ++ __i) 
this -> splice (this -> end () , __tmp [ __i ]) ; 
throw ; 
} 
} 
} 

template < typename _Tp , typename _Alloc > 
template < typename _Predicate > 
typename list < _Tp , _Alloc > :: __remove_return_type 
list < _Tp , _Alloc > :: 
remove_if (_Predicate __pred) 
{ 
size_type __removed __attribute__ ((__unused__)) = 0 ; 
iterator __first = begin () ; 
iterator __last = end () ; 
while (__first != __last) 
{ 
iterator __next = __first ; 
++ __next ; 
if (__pred (* __first)) 
{ 
_M_erase (__first) ; 
; 
} 
__first = __next ; 
} 
return ; 
} 

template < typename _Tp , typename _Alloc > 
template < typename _BinaryPredicate > 
typename list < _Tp , _Alloc > :: __remove_return_type 
list < _Tp , _Alloc > :: 
unique (_BinaryPredicate __binary_pred) 
{ 
iterator __first = begin () ; 
iterator __last = end () ; 
if (__first == __last) 
return ; 
size_type __removed __attribute__ ((__unused__)) = 0 ; 
iterator __next = __first ; 
while (++ __next != __last) 
{ 
if (__binary_pred (* __first , * __next)) 
{ 
_M_erase (__next) ; 
; 
} 
else 
__first = __next ; 
__next = __first ; 
} 
return ; 
} 



template < typename _Tp , typename _Alloc > 
template < typename _StrictWeakOrdering > 
void 
list < _Tp , _Alloc > :: 
sort (_StrictWeakOrdering __comp) 
{ 

if (this -> _M_impl . _M_node . _M_next != & this -> _M_impl . _M_node 
&& this -> _M_impl . _M_node . _M_next -> _M_next != & this -> _M_impl . _M_node) 
{ 
list __carry ; 
list __tmp [ 64 ] ; 
list * __fill = __tmp ; 
list * __counter ; 
try 
{ 
do 
{ 
__carry . splice (__carry . begin () , * this , begin ()) ; 

for (__counter = __tmp ; 
__counter != __fill && ! __counter -> empty () ; 
++ __counter) 
{ 
__counter -> merge (__carry , __comp) ; 
__carry . swap (* __counter) ; 
} 
__carry . swap (* __counter) ; 
if (__counter == __fill) 
++ __fill ; 
} 
while (! empty ()) ; 

for (__counter = __tmp + 1 ; __counter != __fill ; ++ __counter) 
__counter -> merge (* (__counter - 1) , __comp) ; 
swap (* (__fill - 1)) ; 
} 
catch (...) 
{ 
this -> splice (this -> end () , __carry) ; 
for (int __i = 0 ; __i < sizeof (__tmp) / sizeof (__tmp [ 0 ]) ; ++ __i) 
this -> splice (this -> end () , __tmp [ __i ]) ; 
throw ; 
} 
} 
} 



}
# 50 "d:\\mingw\\mingw\\include\\sys\\timeb.h" 3
#pragma pack ( push, 2 )
# 57
struct __attribute((__deprecated__)) timeb { 
time_t time; 
short millitm; 
short timezone; 
short dstflag; 
}; 
# 69
struct _timeb { 
time_t time; 
short millitm; 
short timezone; 
short dstflag; 
}; 
# 83 "d:\\mingw\\mingw\\include\\sys\\timeb.h" 3
struct __timeb32 { 
__time32_t time; 
short millitm; 
short timezone; 
short dstflag; 
}; 

#pragma pack ( pop )

extern "C" {
# 100
#pragma pack ( push, 2 )

struct __timeb64 { 
__time64_t time; 
short millitm; 
short timezone; 
short dstflag; 
}; 

#pragma pack ( pop )

__attribute((__cdecl__)) __attribute((__nothrow__)) void _ftime64(__timeb64 *); 
# 120 "d:\\mingw\\mingw\\include\\sys\\timeb.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) void _ftime(_timeb *); 
# 137 "d:\\mingw\\mingw\\include\\sys\\timeb.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) inline void _ftime32(__timeb32 *__t) { _ftime((_timeb *)(__t)); } 
# 169 "d:\\mingw\\mingw\\include\\sys\\timeb.h" 3
__attribute((__always_inline__)) __attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) inline void ftime(timeb *__t) { _ftime((_timeb *)(__t)); } 


}
# 46 "d:\\mingw\\mingw\\include\\sys\\time.h" 3
extern "C" {
# 55 "d:\\mingw\\mingw\\include\\sys\\time.h" 3
struct timeval { 
# 64
long tv_sec; 
long tv_usec; 
}; 
# 86 "d:\\mingw\\mingw\\include\\sys\\time.h" 3
struct timezone { 
# 94
int tz_minuteswest; 
int tz_dsttime; 
}; 
# 106 "d:\\mingw\\mingw\\include\\sys\\time.h" 3
__attribute((__cdecl__)) __attribute((__nothrow__)) __attribute((__deprecated__)) int gettimeofday(timeval *, void *); 


}
# 44 "d:\\mingw\\mingw\\include\\windef.h" 3
extern "C" {
# 245 "d:\\mingw\\mingw\\include\\windef.h" 3
typedef unsigned long DWORD; 
typedef int WINBOOL, *PWINBOOL, *LPWINBOOL; 



typedef WINBOOL BOOL; 



typedef unsigned char BYTE; 

typedef BOOL *PBOOL, *LPBOOL; 
typedef unsigned short WORD; 
typedef float FLOAT; 
typedef FLOAT *PFLOAT; 
typedef BYTE *PBYTE, *LPBYTE; 
typedef int *PINT, *LPINT; 
typedef WORD *PWORD, *LPWORD; 
typedef long *LPLONG; 
typedef DWORD *PDWORD, *LPDWORD; 
typedef const void *PCVOID, *LPCVOID; 
typedef int INT; 
typedef unsigned UINT, *PUINT, *LPUINT; 
# 51 "d:\\mingw\\mingw\\include\\winnt.h" 3
extern "C" {
# 91 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef char CHAR; 
typedef short SHORT; 
typedef long LONG; 
typedef char CCHAR, *PCCHAR; 
typedef unsigned char UCHAR, *PUCHAR; 
typedef unsigned short USHORT, *PUSHORT; 
typedef unsigned long ULONG, *PULONG; 
typedef char *PSZ; 

typedef void *PVOID, *LPVOID; 
# 106
typedef void *PVOID64; 
# 119 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef wchar_t WCHAR; 
typedef WCHAR *PWCHAR, *LPWCH, *PWCH, *NWPSTR, *LPWSTR, *PWSTR; 
typedef const WCHAR *LPCWCH, *PCWCH, *LPCWSTR, *PCWSTR; 
typedef CHAR *PCHAR, *LPCH, *PCH, *NPSTR, *LPSTR, *PSTR; 
typedef const CHAR *LPCCH, *PCSTR, *LPCSTR; 
# 134 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef CHAR TCHAR; 
typedef CHAR _TCHAR; 


typedef TCHAR TBYTE, *PTCH, *PTBYTE; 
typedef TCHAR *LPTCH, *PTSTR, *LPTSTR, *LP, *PTCHAR; 
typedef const TCHAR *LPCTSTR; 
# 159 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef SHORT *PSHORT; 
typedef LONG *PLONG; 

typedef void *HANDLE; 
# 168
typedef HANDLE *PHANDLE, *LPHANDLE; 
typedef DWORD LCID; 
typedef PDWORD PLCID; 
typedef WORD LANGID; 
# 181 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef long long LONGLONG; 
typedef unsigned long long DWORDLONG; 



typedef LONGLONG *PLONGLONG; 
typedef DWORDLONG *PDWORDLONG; 
typedef DWORDLONG ULONGLONG, *PULONGLONG; 
typedef LONGLONG USN; 
# 199 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef BYTE BOOLEAN, *PBOOLEAN; 

}



typedef BYTE FCHAR; 
typedef WORD FSHORT; 
typedef DWORD FLONG; 
# 48 "d:\\mingw\\mingw\\include\\basetsd.h" 3
extern "C" {

typedef signed char INT8; 
typedef signed short INT16; 
typedef int LONG32, *PLONG32; 

typedef int INT32, *PINT32; 

typedef unsigned char UINT8; 
typedef unsigned short UINT16; 
typedef unsigned ULONG32, *PULONG32; 
typedef unsigned DWORD32, *PDWORD32; 
typedef unsigned UINT32, *PUINT32; 
# 101 "d:\\mingw\\mingw\\include\\basetsd.h" 3
typedef int INT_PTR, *PINT_PTR; 
typedef unsigned UINT_PTR, *PUINT_PTR; 
typedef long LONG_PTR, *PLONG_PTR; 
typedef unsigned long ULONG_PTR, *PULONG_PTR; 
typedef unsigned short UHALF_PTR, *PUHALF_PTR; 
typedef short HALF_PTR, *PHALF_PTR; 
typedef unsigned long HANDLE_PTR; 


typedef ULONG_PTR SIZE_T, *PSIZE_T; 
typedef LONG_PTR SSIZE_T, *PSSIZE_T; 
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR; 
typedef long long LONG64, *PLONG64; 
typedef long long INT64, *PINT64; 
typedef unsigned long long ULONG64, *PULONG64; 
typedef unsigned long long DWORD64, *PDWORD64; 
typedef unsigned long long UINT64, *PUINT64; 

}
# 1788 "d:\\mingw\\mingw\\include\\winnt.h" 3
extern "C" {

typedef DWORD ACCESS_MASK, *PACCESS_MASK; 
# 1803
typedef 
# 1798
struct _GUID { 
unsigned long Data1; 
unsigned short Data2; 
unsigned short Data3; 
unsigned char Data4[8]; 
} GUID, *REFGUID, *LPGUID; 
# 1812
typedef 
# 1807
struct _GENERIC_MAPPING { 
ACCESS_MASK GenericRead; 
ACCESS_MASK GenericWrite; 
ACCESS_MASK GenericExecute; 
ACCESS_MASK GenericAll; 
} GENERIC_MAPPING, *PGENERIC_MAPPING; 
# 1818
typedef 
# 1814
struct _ACE_HEADER { 
BYTE AceType; 
BYTE AceFlags; 
WORD AceSize; 
} ACE_HEADER, *PACE_HEADER; 
# 1824
typedef 
# 1820
struct _ACCESS_ALLOWED_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD SidStart; 
} ACCESS_ALLOWED_ACE, *PACCESS_ALLOWED_ACE; 
# 1830
typedef 
# 1826
struct _ACCESS_DENIED_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD SidStart; 
} ACCESS_DENIED_ACE, *PACCESS_DENIED_ACE; 
# 1836
typedef 
# 1832
struct _SYSTEM_AUDIT_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD SidStart; 
} SYSTEM_AUDIT_ACE; 
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE; 
# 1843
typedef 
# 1839
struct _SYSTEM_ALARM_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD SidStart; 
} SYSTEM_ALARM_ACE, *PSYSTEM_ALARM_ACE; 
# 1852
typedef 
# 1845
struct _ACCESS_ALLOWED_OBJECT_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD Flags; 
GUID ObjectType; 
GUID InheritedObjectType; 
DWORD SidStart; 
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE; 
# 1861
typedef 
# 1854
struct _ACCESS_DENIED_OBJECT_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD Flags; 
GUID ObjectType; 
GUID InheritedObjectType; 
DWORD SidStart; 
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE; 
# 1870
typedef 
# 1863
struct _SYSTEM_AUDIT_OBJECT_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD Flags; 
GUID ObjectType; 
GUID InheritedObjectType; 
DWORD SidStart; 
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE; 
# 1879
typedef 
# 1872
struct _SYSTEM_ALARM_OBJECT_ACE { 
ACE_HEADER Header; 
ACCESS_MASK Mask; 
DWORD Flags; 
GUID ObjectType; 
GUID InheritedObjectType; 
DWORD SidStart; 
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE; 
# 1887
typedef 
# 1881
struct _ACL { 
BYTE AclRevision; 
BYTE Sbz1; 
WORD AclSize; 
WORD AceCount; 
WORD Sbz2; 
} ACL, *PACL; 



typedef 
# 1889
struct _ACL_REVISION_INFORMATION { 
DWORD AclRevision; 
} ACL_REVISION_INFORMATION; 
# 1897
typedef 
# 1893
struct _ACL_SIZE_INFORMATION { 
DWORD AceCount; 
DWORD AclBytesInUse; 
DWORD AclBytesFree; 
} ACL_SIZE_INFORMATION; 
# 1925 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 1915
struct _FLOATING_SAVE_AREA { 
DWORD ControlWord; 
DWORD StatusWord; 
DWORD TagWord; 
DWORD ErrorOffset; 
DWORD ErrorSelector; 
DWORD DataOffset; 
DWORD DataSelector; 
BYTE RegisterArea[80]; 
DWORD Cr0NpxState; 
} FLOATING_SAVE_AREA; 
# 1953
typedef 
# 1927
struct _CONTEXT { 
DWORD ContextFlags; 
DWORD Dr0; 
DWORD Dr1; 
DWORD Dr2; 
DWORD Dr3; 
DWORD Dr6; 
DWORD Dr7; 
FLOATING_SAVE_AREA FloatSave; 
DWORD SegGs; 
DWORD SegFs; 
DWORD SegEs; 
DWORD SegDs; 
DWORD Edi; 
DWORD Esi; 
DWORD Ebx; 
DWORD Edx; 
DWORD Ecx; 
DWORD Eax; 
DWORD Ebp; 
DWORD Eip; 
DWORD SegCs; 
DWORD EFlags; 
DWORD Esp; 
DWORD SegSs; 
BYTE ExtendedRegisters[512]; 
} CONTEXT; 
# 2438 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef CONTEXT *PCONTEXT, *LPCONTEXT; 
# 2447
typedef 
# 2440
struct _EXCEPTION_RECORD { 
DWORD ExceptionCode; 
DWORD ExceptionFlags; 
_EXCEPTION_RECORD *ExceptionRecord; 
PVOID ExceptionAddress; 
DWORD NumberParameters; 
DWORD ExceptionInformation[15]; 
} EXCEPTION_RECORD, *PEXCEPTION_RECORD, *LPEXCEPTION_RECORD; 




typedef 
# 2449
struct _EXCEPTION_POINTERS { 
PEXCEPTION_RECORD ExceptionRecord; 
PCONTEXT ContextRecord; 
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS, *LPEXCEPTION_POINTERS; 
# 2466
typedef 
# 2454
union _LARGE_INTEGER { 

struct { DWORD LowPart; 
LONG HighPart; 
} u; 


struct { DWORD LowPart; 
LONG HighPart; 
}; 

LONGLONG QuadPart; 
} LARGE_INTEGER, *PLARGE_INTEGER; 
# 2480
typedef 
# 2468
union _ULARGE_INTEGER { 

struct { DWORD LowPart; 
DWORD HighPart; 
} u; 


struct { DWORD LowPart; 
DWORD HighPart; 
}; 

ULONGLONG QuadPart; 
} ULARGE_INTEGER, *PULARGE_INTEGER; 




typedef 
# 2482
struct _LUID { 
DWORD LowPart; 
LONG HighPart; 
} LUID, *PLUID; 
#pragma pack ( push, 4 )




typedef 
# 2488
struct _LUID_AND_ATTRIBUTES { 
LUID Luid; 
DWORD Attributes; 
} LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES; 
#pragma pack ( pop )
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1]; 
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY; 
# 2500
typedef 
# 2496
struct _PRIVILEGE_SET { 
DWORD PrivilegeCount; 
DWORD Control; 
LUID_AND_ATTRIBUTES Privilege[1]; 
} PRIVILEGE_SET, *PPRIVILEGE_SET; 
# 2506
typedef 
# 2502
struct _SECURITY_ATTRIBUTES { 
DWORD nLength; 
LPVOID lpSecurityDescriptor; 
BOOL bInheritHandle; 
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES; 
# 2513
typedef 
# 2508
enum _SECURITY_IMPERSONATION_LEVEL { 
SecurityAnonymous, 
SecurityIdentification, 
SecurityImpersonation, 
SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL, *PSECURITY_IMPERSONATION_LEVEL; 
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE, *PSECURITY_CONTEXT_TRACKING_MODE; 
# 2521
typedef 
# 2516
struct _SECURITY_QUALITY_OF_SERVICE { 
DWORD Length; 
SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; 
SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode; 
BOOLEAN EffectiveOnly; 
} SECURITY_QUALITY_OF_SERVICE, *PSECURITY_QUALITY_OF_SERVICE; 
typedef PVOID PACCESS_TOKEN; 
# 2529
typedef 
# 2524
struct _SE_IMPERSONATION_STATE { 
PACCESS_TOKEN Token; 
BOOLEAN CopyOnOpen; 
BOOLEAN EffectiveOnly; 
SECURITY_IMPERSONATION_LEVEL Level; 
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE; 



typedef 
# 2531
struct _SID_IDENTIFIER_AUTHORITY { 
BYTE Value[6]; 
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY, *LPSID_IDENTIFIER_AUTHORITY; 
typedef PVOID PSID; 
# 2541
typedef 
# 2536
struct _SID { 
BYTE Revision; 
BYTE SubAuthorityCount; 
SID_IDENTIFIER_AUTHORITY IdentifierAuthority; 
DWORD SubAuthority[1]; 
} SID, *PISID; 




typedef 
# 2543
struct _SID_AND_ATTRIBUTES { 
PSID Sid; 
DWORD Attributes; 
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES; 
typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1]; 
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY; 
# 2563 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 2560
struct _TOKEN_SOURCE { 
CHAR SourceName[8]; 
LUID SourceIdentifier; 
} TOKEN_SOURCE, *PTOKEN_SOURCE; 
# 2570
typedef 
# 2565
struct _TOKEN_CONTROL { 
LUID TokenId; 
LUID AuthenticationId; 
LUID ModifiedId; 
TOKEN_SOURCE TokenSource; 
} TOKEN_CONTROL, *PTOKEN_CONTROL; 



typedef 
# 2572
struct _TOKEN_DEFAULT_DACL { 
PACL DefaultDacl; 
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL; 




typedef 
# 2576
struct _TOKEN_GROUPS { 
DWORD GroupCount; 
SID_AND_ATTRIBUTES Groups[1]; 
} TOKEN_GROUPS, *PTOKEN_GROUPS, *LPTOKEN_GROUPS; 



typedef 
# 2581
struct _TOKEN_OWNER { 
PSID Owner; 
} TOKEN_OWNER, *PTOKEN_OWNER; 



typedef 
# 2585
struct _TOKEN_PRIMARY_GROUP { 
PSID PrimaryGroup; 
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP; 




typedef 
# 2589
struct _TOKEN_PRIVILEGES { 
DWORD PrivilegeCount; 
LUID_AND_ATTRIBUTES Privileges[1]; 
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES, *LPTOKEN_PRIVILEGES; 




typedef 
# 2594
enum tagTOKEN_TYPE { 
TokenPrimary = 1, 
TokenImpersonation
} TOKEN_TYPE, *PTOKEN_TYPE; 
# 2610
typedef 
# 2599
struct _TOKEN_STATISTICS { 
LUID TokenId; 
LUID AuthenticationId; 
LARGE_INTEGER ExpirationTime; 
TOKEN_TYPE TokenType; 
SECURITY_IMPERSONATION_LEVEL ImpersonationLevel; 
DWORD DynamicCharged; 
DWORD DynamicAvailable; 
DWORD GroupCount; 
DWORD PrivilegeCount; 
LUID ModifiedId; 
} TOKEN_STATISTICS, *PTOKEN_STATISTICS; 



typedef 
# 2612
struct _TOKEN_USER { 
SID_AND_ATTRIBUTES User; 
} TOKEN_USER, *PTOKEN_USER; 
# 2644 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION; 
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL; 
# 2655
typedef 
# 2647
struct _SECURITY_DESCRIPTOR { 
BYTE Revision; 
BYTE Sbz1; 
SECURITY_DESCRIPTOR_CONTROL Control; 
PSID Owner; 
PSID Group; 
PACL Sacl; 
PACL Dacl; 
} SECURITY_DESCRIPTOR, *PSECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR; 
# 2689 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 2657 "d:\\mingw\\mingw\\include\\winnt.h" 3
enum _TOKEN_INFORMATION_CLASS { 
TokenUser = 1, 
TokenGroups, 
TokenPrivileges, 
TokenOwner, 
TokenPrimaryGroup, 
TokenDefaultDacl, 
TokenSource, 
TokenType, 
TokenImpersonationLevel, 
TokenStatistics, 
TokenRestrictedSids, 
TokenSessionId, 
TokenGroupsAndPrivileges, 
TokenSessionReference, 
TokenSandBoxInert, 
TokenAuditPolicy, 
TokenOrigin, 
# 2688 "d:\\mingw\\mingw\\include\\winnt.h" 3
MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS; 
# 2701
typedef 
# 2691
enum _SID_NAME_USE { 
SidTypeUser = 1, 
SidTypeGroup, 
SidTypeDomain, 
SidTypeAlias, 
SidTypeWellKnownGroup, 
SidTypeDeletedAccount, 
SidTypeInvalid, 
SidTypeUnknown, 
SidTypeComputer
} SID_NAME_USE, *PSID_NAME_USE; 
# 2710
typedef 
# 2703
struct _QUOTA_LIMITS { 
SIZE_T PagedPoolLimit; 
SIZE_T NonPagedPoolLimit; 
SIZE_T MinimumWorkingSetSize; 
SIZE_T MaximumWorkingSetSize; 
SIZE_T PagefileLimit; 
LARGE_INTEGER TimeLimit; 
} QUOTA_LIMITS, *PQUOTA_LIMITS; 
# 2719
typedef 
# 2712
struct _IO_COUNTERS { 
ULONGLONG ReadOperationCount; 
ULONGLONG WriteOperationCount; 
ULONGLONG OtherOperationCount; 
ULONGLONG ReadTransferCount; 
ULONGLONG WriteTransferCount; 
ULONGLONG OtherTransferCount; 
} IO_COUNTERS, *PIO_COUNTERS; 
# 2726
typedef 
# 2721
struct _FILE_NOTIFY_INFORMATION { 
DWORD NextEntryOffset; 
DWORD Action; 
DWORD FileNameLength; 
WCHAR FileName[1]; 
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION; 




typedef 
# 2728
struct _TAPE_ERASE { 
DWORD Type; 
BOOLEAN Immediate; 
} TAPE_ERASE, *PTAPE_ERASE; 
# 2745
typedef 
# 2733
struct _TAPE_GET_DRIVE_PARAMETERS { 
BOOLEAN ECC; 
BOOLEAN Compression; 
BOOLEAN DataPadding; 
BOOLEAN ReportSetmarks; 
DWORD DefaultBlockSize; 
DWORD MaximumBlockSize; 
DWORD MinimumBlockSize; 
DWORD MaximumPartitionCount; 
DWORD FeaturesLow; 
DWORD FeaturesHigh; 
DWORD EOTWarningZoneSize; 
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS; 
# 2753
typedef 
# 2747
struct _TAPE_GET_MEDIA_PARAMETERS { 
LARGE_INTEGER Capacity; 
LARGE_INTEGER Remaining; 
DWORD BlockSize; 
DWORD PartitionCount; 
BOOLEAN WriteProtected; 
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS; 
# 2760
typedef 
# 2755
struct _TAPE_GET_POSITION { 
ULONG Type; 
ULONG Partition; 
ULONG OffsetLow; 
ULONG OffsetHigh; 
} TAPE_GET_POSITION, *PTAPE_GET_POSITION; 




typedef 
# 2762
struct _TAPE_PREPARE { 
DWORD Operation; 
BOOLEAN Immediate; 
} TAPE_PREPARE, *PTAPE_PREPARE; 
# 2773
typedef 
# 2767
struct _TAPE_SET_DRIVE_PARAMETERS { 
BOOLEAN ECC; 
BOOLEAN Compression; 
BOOLEAN DataPadding; 
BOOLEAN ReportSetmarks; 
ULONG EOTWarningZoneSize; 
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS; 



typedef 
# 2775
struct _TAPE_SET_MEDIA_PARAMETERS { 
ULONG BlockSize; 
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS; 
# 2784
typedef 
# 2779
struct _TAPE_SET_POSITION { 
DWORD Method; 
DWORD Partition; 
LARGE_INTEGER Offset; 
BOOLEAN Immediate; 
} TAPE_SET_POSITION, *PTAPE_SET_POSITION; 
# 2790
typedef 
# 2786
struct _TAPE_WRITE_MARKS { 
DWORD Type; 
DWORD Count; 
BOOLEAN Immediate; 
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS; 
# 2796
typedef 
# 2792
struct _TAPE_CREATE_PARTITION { 
DWORD Method; 
DWORD Count; 
DWORD Size; 
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION; 
# 2806
typedef 
# 2798
struct _MEMORY_BASIC_INFORMATION { 
PVOID BaseAddress; 
PVOID AllocationBase; 
DWORD AllocationProtect; 
DWORD RegionSize; 
DWORD State; 
DWORD Protect; 
DWORD Type; 
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION; 
# 2812
typedef 
# 2808
struct _MESSAGE_RESOURCE_ENTRY { 
WORD Length; 
WORD Flags; 
BYTE Text[1]; 
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY; 
# 2818
typedef 
# 2814
struct _MESSAGE_RESOURCE_BLOCK { 
DWORD LowId; 
DWORD HighId; 
DWORD OffsetToEntries; 
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK; 




typedef 
# 2820
struct _MESSAGE_RESOURCE_DATA { 
DWORD NumberOfBlocks; 
MESSAGE_RESOURCE_BLOCK Blocks[1]; 
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA; 




typedef 
# 2825
struct _LIST_ENTRY { 
_LIST_ENTRY *Flink; 
_LIST_ENTRY *Blink; 
} LIST_ENTRY, *PLIST_ENTRY; 



typedef 
# 2830
struct _SINGLE_LIST_ENTRY { 
_SINGLE_LIST_ENTRY *Next; 
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY; 
# 2847
typedef 
# 2840
union _SLIST_HEADER { 
ULONGLONG Alignment; 

struct { SINGLE_LIST_ENTRY Next; 
WORD Depth; 
WORD Sequence; 
}; 
} SLIST_HEADER, *PSLIST_HEADER; 
# 2858
typedef 
# 2850
struct _RTL_CRITICAL_SECTION_DEBUG { 
WORD Type; 
WORD CreatorBackTraceIndex; 
struct _RTL_CRITICAL_SECTION *CriticalSection; 
LIST_ENTRY ProcessLocksList; 
DWORD EntryCount; 
DWORD ContentionCount; 
DWORD Spare[2]; 
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG; 
# 2867
typedef 
# 2860
struct _RTL_CRITICAL_SECTION { 
PRTL_CRITICAL_SECTION_DEBUG DebugInfo; 
LONG LockCount; 
LONG RecursionCount; 
HANDLE OwningThread; 
HANDLE LockSemaphore; 
DWORD Reserved; 
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 
# 2886
typedef 
# 2869
struct _EVENTLOGRECORD { 
DWORD Length; 
DWORD Reserved; 
DWORD RecordNumber; 
DWORD TimeGenerated; 
DWORD TimeWritten; 
DWORD EventID; 
WORD EventType; 
WORD NumStrings; 
WORD EventCategory; 
WORD ReservedFlags; 
DWORD ClosingRecordNumber; 
DWORD StringOffset; 
DWORD UserSidLength; 
DWORD UserSidOffset; 
DWORD DataLength; 
DWORD DataOffset; 
} EVENTLOGRECORD, *PEVENTLOGRECORD; 
# 2895
typedef 
# 2888
struct _OSVERSIONINFOA { 
DWORD dwOSVersionInfoSize; 
DWORD dwMajorVersion; 
DWORD dwMinorVersion; 
DWORD dwBuildNumber; 
DWORD dwPlatformId; 
CHAR szCSDVersion[128]; 
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA; 
# 2904
typedef 
# 2897
struct _OSVERSIONINFOW { 
DWORD dwOSVersionInfoSize; 
DWORD dwMajorVersion; 
DWORD dwMinorVersion; 
DWORD dwBuildNumber; 
DWORD dwPlatformId; 
WCHAR szCSDVersion[128]; 
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW; 
# 2918
typedef 
# 2906
struct _OSVERSIONINFOEXA { 
DWORD dwOSVersionInfoSize; 
DWORD dwMajorVersion; 
DWORD dwMinorVersion; 
DWORD dwBuildNumber; 
DWORD dwPlatformId; 
CHAR szCSDVersion[128]; 
WORD wServicePackMajor; 
WORD wServicePackMinor; 
WORD wSuiteMask; 
BYTE wProductType; 
BYTE wReserved; 
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA; 
# 2932
typedef 
# 2920
struct _OSVERSIONINFOEXW { 
DWORD dwOSVersionInfoSize; 
DWORD dwMajorVersion; 
DWORD dwMinorVersion; 
DWORD dwBuildNumber; 
DWORD dwPlatformId; 
WCHAR szCSDVersion[128]; 
WORD wServicePackMajor; 
WORD wServicePackMinor; 
WORD wSuiteMask; 
BYTE wProductType; 
BYTE wReserved; 
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW; 

#pragma pack ( push, 2 )
# 2987
typedef 
# 2935
struct _IMAGE_VXD_HEADER { 
WORD e32_magic; 
BYTE e32_border; 
BYTE e32_worder; 
DWORD e32_level; 
WORD e32_cpu; 
WORD e32_os; 
DWORD e32_ver; 
DWORD e32_mflags; 
DWORD e32_mpages; 
DWORD e32_startobj; 
DWORD e32_eip; 
DWORD e32_stackobj; 
DWORD e32_esp; 
DWORD e32_pagesize; 
DWORD e32_lastpagesize; 
DWORD e32_fixupsize; 
DWORD e32_fixupsum; 
DWORD e32_ldrsize; 
DWORD e32_ldrsum; 
DWORD e32_objtab; 
DWORD e32_objcnt; 
DWORD e32_objmap; 
DWORD e32_itermap; 
DWORD e32_rsrctab; 
DWORD e32_rsrccnt; 
DWORD e32_restab; 
DWORD e32_enttab; 
DWORD e32_dirtab; 
DWORD e32_dircnt; 
DWORD e32_fpagetab; 
DWORD e32_frectab; 
DWORD e32_impmod; 
DWORD e32_impmodcnt; 
DWORD e32_impproc; 
DWORD e32_pagesum; 
DWORD e32_datapage; 
DWORD e32_preload; 
DWORD e32_nrestab; 
DWORD e32_cbnrestab; 
DWORD e32_nressum; 
DWORD e32_autodata; 
DWORD e32_debuginfo; 
DWORD e32_debuglen; 
DWORD e32_instpreload; 
DWORD e32_instdemand; 
DWORD e32_heapsize; 
BYTE e32_res3[12]; 
DWORD e32_winresoff; 
DWORD e32_winreslen; 
WORD e32_devid; 
WORD e32_ddkver; 
} IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER; 
#pragma pack ( pop )

#pragma pack ( push, 4 )
# 2999
typedef 
# 2991
struct _IMAGE_FILE_HEADER { 
WORD Machine; 
WORD NumberOfSections; 
DWORD TimeDateStamp; 
DWORD PointerToSymbolTable; 
DWORD NumberOfSymbols; 
WORD SizeOfOptionalHeader; 
WORD Characteristics; 
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 




typedef 
# 3001
struct _IMAGE_DATA_DIRECTORY { 
DWORD VirtualAddress; 
DWORD Size; 
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 
# 3038
typedef 
# 3006
struct _IMAGE_OPTIONAL_HEADER { 
WORD Magic; 
BYTE MajorLinkerVersion; 
BYTE MinorLinkerVersion; 
DWORD SizeOfCode; 
DWORD SizeOfInitializedData; 
DWORD SizeOfUninitializedData; 
DWORD AddressOfEntryPoint; 
DWORD BaseOfCode; 
DWORD BaseOfData; 
DWORD ImageBase; 
DWORD SectionAlignment; 
DWORD FileAlignment; 
WORD MajorOperatingSystemVersion; 
WORD MinorOperatingSystemVersion; 
WORD MajorImageVersion; 
WORD MinorImageVersion; 
WORD MajorSubsystemVersion; 
WORD MinorSubsystemVersion; 
DWORD Win32VersionValue; 
DWORD SizeOfImage; 
DWORD SizeOfHeaders; 
DWORD CheckSum; 
WORD Subsystem; 
WORD DllCharacteristics; 
DWORD SizeOfStackReserve; 
DWORD SizeOfStackCommit; 
DWORD SizeOfHeapReserve; 
DWORD SizeOfHeapCommit; 
DWORD LoaderFlags; 
DWORD NumberOfRvaAndSizes; 
IMAGE_DATA_DIRECTORY DataDirectory[16]; 
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 
# 3071
typedef 
# 3040
struct _IMAGE_OPTIONAL_HEADER64 { 
WORD Magic; 
BYTE MajorLinkerVersion; 
BYTE MinorLinkerVersion; 
DWORD SizeOfCode; 
DWORD SizeOfInitializedData; 
DWORD SizeOfUninitializedData; 
DWORD AddressOfEntryPoint; 
DWORD BaseOfCode; 
ULONGLONG ImageBase; 
DWORD SectionAlignment; 
DWORD FileAlignment; 
WORD MajorOperatingSystemVersion; 
WORD MinorOperatingSystemVersion; 
WORD MajorImageVersion; 
WORD MinorImageVersion; 
WORD MajorSubsystemVersion; 
WORD MinorSubsystemVersion; 
DWORD Win32VersionValue; 
DWORD SizeOfImage; 
DWORD SizeOfHeaders; 
DWORD CheckSum; 
WORD Subsystem; 
WORD DllCharacteristics; 
ULONGLONG SizeOfStackReserve; 
ULONGLONG SizeOfStackCommit; 
ULONGLONG SizeOfHeapReserve; 
ULONGLONG SizeOfHeapCommit; 
DWORD LoaderFlags; 
DWORD NumberOfRvaAndSizes; 
IMAGE_DATA_DIRECTORY DataDirectory[16]; 
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; 




typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER; 
typedef PIMAGE_OPTIONAL_HEADER32 PIMAGE_OPTIONAL_HEADER; 
# 3094
typedef 
# 3080
struct _IMAGE_ROM_OPTIONAL_HEADER { 
WORD Magic; 
BYTE MajorLinkerVersion; 
BYTE MinorLinkerVersion; 
DWORD SizeOfCode; 
DWORD SizeOfInitializedData; 
DWORD SizeOfUninitializedData; 
DWORD AddressOfEntryPoint; 
DWORD BaseOfCode; 
DWORD BaseOfData; 
DWORD BaseOfBss; 
DWORD GprMask; 
DWORD CprMask[4]; 
DWORD GpValue; 
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER; 
#pragma pack ( pop )

#pragma pack ( push, 2 )
# 3118
typedef 
# 3098
struct _IMAGE_DOS_HEADER { 
WORD e_magic; 
WORD e_cblp; 
WORD e_cp; 
WORD e_crlc; 
WORD e_cparhdr; 
WORD e_minalloc; 
WORD e_maxalloc; 
WORD e_ss; 
WORD e_sp; 
WORD e_csum; 
WORD e_ip; 
WORD e_cs; 
WORD e_lfarlc; 
WORD e_ovno; 
WORD e_res[4]; 
WORD e_oemid; 
WORD e_oeminfo; 
WORD e_res2[10]; 
LONG e_lfanew; 
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 
# 3151
typedef 
# 3120
struct _IMAGE_OS2_HEADER { 
WORD ne_magic; 
CHAR ne_ver; 
CHAR ne_rev; 
WORD ne_enttab; 
WORD ne_cbenttab; 
LONG ne_crc; 
WORD ne_flags; 
WORD ne_autodata; 
WORD ne_heap; 
WORD ne_stack; 
LONG ne_csip; 
LONG ne_sssp; 
WORD ne_cseg; 
WORD ne_cmod; 
WORD ne_cbnrestab; 
WORD ne_segtab; 
WORD ne_rsrctab; 
WORD ne_restab; 
WORD ne_modtab; 
WORD ne_imptab; 
LONG ne_nrestab; 
WORD ne_cmovent; 
WORD ne_align; 
WORD ne_cres; 
BYTE ne_exetyp; 
BYTE ne_flagsothers; 
WORD ne_pretthunks; 
WORD ne_psegrefbytes; 
WORD ne_swaparea; 
WORD ne_expver; 
} IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER; 
#pragma pack ( pop )

#pragma pack ( push, 4 )




typedef 
# 3155
struct _IMAGE_NT_HEADERS { 
DWORD Signature; 
IMAGE_FILE_HEADER FileHeader; 
IMAGE_OPTIONAL_HEADER32 OptionalHeader; 
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 
# 3165
typedef 
# 3161
struct _IMAGE_NT_HEADERS64 { 
DWORD Signature; 
IMAGE_FILE_HEADER FileHeader; 
IMAGE_OPTIONAL_HEADER64 OptionalHeader; 
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; 




typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS; 
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS; 
# 3177
typedef 
# 3174
struct _IMAGE_ROM_HEADERS { 
IMAGE_FILE_HEADER FileHeader; 
IMAGE_ROM_OPTIONAL_HEADER OptionalHeader; 
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS; 
# 3193
typedef 
# 3179
struct _IMAGE_SECTION_HEADER { 
BYTE Name[8]; 

union { DWORD PhysicalAddress; 
DWORD VirtualSize; 
} Misc; 
DWORD VirtualAddress; 
DWORD SizeOfRawData; 
DWORD PointerToRawData; 
DWORD PointerToRelocations; 
DWORD PointerToLinenumbers; 
WORD NumberOfRelocations; 
WORD NumberOfLinenumbers; 
DWORD Characteristics; 
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 
#pragma pack ( pop )

#pragma pack ( push, 2 )
# 3211
typedef 
# 3197
struct _IMAGE_SYMBOL { 

union { BYTE ShortName[8]; 

struct { DWORD Short; 
DWORD Long; 
} Name; 
PBYTE LongName[2]; 
} N; 
DWORD Value; 
SHORT SectionNumber; 
WORD Type; 
BYTE StorageClass; 
BYTE NumberOfAuxSymbols; 
} IMAGE_SYMBOL, *PIMAGE_SYMBOL; 
# 3245
typedef 
# 3213
union _IMAGE_AUX_SYMBOL { 

struct { DWORD TagIndex; 

union { 
struct { WORD Linenumber; 
WORD Size; 
} LnSz; 
DWORD TotalSize; 
} Misc; 

union { 
struct { DWORD PointerToLinenumber; 
DWORD PointerToNextFunction; 
} Function; 

struct { WORD Dimension[4]; 
} Array; 
} FcnAry; 
WORD TvIndex; 
} Sym; 

struct { BYTE Name[18]; 
} File; 

struct { DWORD Length; 
WORD NumberOfRelocations; 
WORD NumberOfLinenumbers; 
DWORD CheckSum; 
SHORT Number; 
BYTE Selection; 
} Section; 
} IMAGE_AUX_SYMBOL, *PIMAGE_AUX_SYMBOL; 
# 3256
typedef 
# 3247
struct _IMAGE_COFF_SYMBOLS_HEADER { 
DWORD NumberOfSymbols; 
DWORD LvaToFirstSymbol; 
DWORD NumberOfLinenumbers; 
DWORD LvaToFirstLinenumber; 
DWORD RvaToFirstByteOfCode; 
DWORD RvaToLastByteOfCode; 
DWORD RvaToFirstByteOfData; 
DWORD RvaToLastByteOfData; 
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER; 
# 3265
typedef 
# 3258
struct _IMAGE_RELOCATION { 

union { DWORD VirtualAddress; 
DWORD RelocCount; 
}; 
DWORD SymbolTableIndex; 
WORD Type; 
} IMAGE_RELOCATION, *PIMAGE_RELOCATION; 
#pragma pack ( pop )

#pragma pack ( push, 4 )



typedef 
# 3269
struct _IMAGE_BASE_RELOCATION { 
DWORD VirtualAddress; 
DWORD SizeOfBlock; 
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION; 
#pragma pack ( pop )

#pragma pack ( push, 2 )
# 3282
typedef 
# 3276
struct _IMAGE_LINENUMBER { 

union { DWORD SymbolTableIndex; 
DWORD VirtualAddress; 
} Type; 
WORD Linenumber; 
} IMAGE_LINENUMBER, *PIMAGE_LINENUMBER; 
#pragma pack ( pop )

#pragma pack ( push, 4 )
# 3294
typedef 
# 3286
struct _IMAGE_ARCHIVE_MEMBER_HEADER { 
BYTE Name[16]; 
BYTE Date[12]; 
BYTE UserID[6]; 
BYTE GroupID[6]; 
BYTE Mode[8]; 
BYTE Size[10]; 
BYTE EndHeader[2]; 
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER; 
# 3308
typedef 
# 3296
struct _IMAGE_EXPORT_DIRECTORY { 
DWORD Characteristics; 
DWORD TimeDateStamp; 
WORD MajorVersion; 
WORD MinorVersion; 
DWORD Name; 
DWORD Base; 
DWORD NumberOfFunctions; 
DWORD NumberOfNames; 
DWORD AddressOfFunctions; 
DWORD AddressOfNames; 
DWORD AddressOfNameOrdinals; 
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 




typedef 
# 3310
struct _IMAGE_IMPORT_BY_NAME { 
WORD Hint; 
BYTE Name[1]; 
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 
# 3322
typedef 
# 3315
struct _IMAGE_THUNK_DATA32 { 

union { DWORD ForwarderString; 
DWORD Function; 
DWORD Ordinal; 
DWORD AddressOfData; 
} u1; 
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32; 
# 3331
typedef 
# 3324
struct _IMAGE_THUNK_DATA64 { 

union { ULONGLONG ForwarderString; 
ULONGLONG Function; 
ULONGLONG Ordinal; 
ULONGLONG AddressOfData; 
} u1; 
} IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64; 




typedef IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA; 
typedef PIMAGE_THUNK_DATA32 PIMAGE_THUNK_DATA; 
# 3349
typedef 
# 3340
struct _IMAGE_IMPORT_DESCRIPTOR { 

union { DWORD Characteristics; 
DWORD OriginalFirstThunk; 
}; 
DWORD TimeDateStamp; 
DWORD ForwarderChain; 
DWORD Name; 
DWORD FirstThunk; 
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR; 
# 3355
typedef 
# 3351
struct _IMAGE_BOUND_IMPORT_DESCRIPTOR { 
DWORD TimeDateStamp; 
WORD OffsetModuleName; 
WORD NumberOfModuleForwarderRefs; 
} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; 
# 3361
typedef 
# 3357
struct _IMAGE_BOUND_FORWARDER_REF { 
DWORD TimeDateStamp; 
WORD OffsetModuleName; 
WORD Reserved; 
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF; 
typedef void ( __attribute((__stdcall__))*PIMAGE_TLS_CALLBACK)(PVOID, DWORD, PVOID) ; 
# 3371
typedef 
# 3364
struct _IMAGE_TLS_DIRECTORY32 { 
DWORD StartAddressOfRawData; 
DWORD EndAddressOfRawData; 
DWORD AddressOfIndex; 
DWORD AddressOfCallBacks; 
DWORD SizeOfZeroFill; 
DWORD Characteristics; 
} IMAGE_TLS_DIRECTORY32, *PIMAGE_TLS_DIRECTORY32; 
# 3380
typedef 
# 3373
struct _IMAGE_TLS_DIRECTORY64 { 
ULONGLONG StartAddressOfRawData; 
ULONGLONG EndAddressOfRawData; 
ULONGLONG AddressOfIndex; 
ULONGLONG AddressOfCallBacks; 
DWORD SizeOfZeroFill; 
DWORD Characteristics; 
} IMAGE_TLS_DIRECTORY64, *PIMAGE_TLS_DIRECTORY64; 




typedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY; 
typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY; 
# 3396
typedef 
# 3389
struct _IMAGE_RESOURCE_DIRECTORY { 
DWORD Characteristics; 
DWORD TimeDateStamp; 
WORD MajorVersion; 
WORD MinorVersion; 
WORD NumberOfNamedEntries; 
WORD NumberOfIdEntries; 
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; 
# 3414
__extension__ typedef 
# 3398
struct _IMAGE_RESOURCE_DIRECTORY_ENTRY { 

union { 
struct { DWORD NameOffset:31; 
DWORD NameIsString:1; 
}; 
DWORD Name; 
WORD Id; 
}; 

union { DWORD OffsetToData; 

struct { DWORD OffsetToDirectory:31; 
DWORD DataIsDirectory:1; 
}; 
}; 
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY; 




typedef 
# 3416
struct _IMAGE_RESOURCE_DIRECTORY_STRING { 
WORD Length; 
CHAR NameString[1]; 
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING; 




typedef 
# 3421
struct _IMAGE_RESOURCE_DIR_STRING_U { 
WORD Length; 
WCHAR NameString[1]; 
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U; 
# 3431
typedef 
# 3426
struct _IMAGE_RESOURCE_DATA_ENTRY { 
DWORD OffsetToData; 
DWORD Size; 
DWORD CodePage; 
DWORD Reserved; 
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY; 
# 3448
typedef 
# 3433
struct _IMAGE_LOAD_CONFIG_DIRECTORY { 
DWORD Characteristics; 
DWORD TimeDateStamp; 
WORD MajorVersion; 
WORD MinorVersion; 
DWORD GlobalFlagsClear; 
DWORD GlobalFlagsSet; 
DWORD CriticalSectionDefaultTimeout; 
DWORD DeCommitFreeBlockThreshold; 
DWORD DeCommitTotalFreeThreshold; 
PVOID LockPrefixTable; 
DWORD MaximumAllocationSize; 
DWORD VirtualMemoryThreshold; 
DWORD ProcessHeapFlags; 
DWORD Reserved[4]; 
} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY; 
# 3469
typedef 
# 3451
struct { DWORD Characteristics; 
DWORD TimeDateStamp; 
WORD MajorVersion; 
WORD MinorVersion; 
DWORD GlobalFlagsClear; 
DWORD GlobalFlagsSet; 
DWORD CriticalSectionDefaultTimeout; 
ULONGLONG DeCommitFreeBlockThreshold; 
ULONGLONG DeCommitTotalFreeThreshold; 
ULONGLONG LockPrefixTable; 
ULONGLONG MaximumAllocationSize; 
ULONGLONG VirtualMemoryThreshold; 
ULONGLONG ProcessAffinityMask; 
DWORD ProcessHeapFlags; 
WORD CSDFlags; 
WORD Reserved1; 
ULONGLONG EditList; 
DWORD Reserved[2]; 
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64; 
# 3477
typedef 
# 3471
struct _IMAGE_RUNTIME_FUNCTION_ENTRY { 
DWORD BeginAddress; 
DWORD EndAddress; 
PVOID ExceptionHandler; 
PVOID HandlerData; 
DWORD PrologEndAddress; 
} IMAGE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_RUNTIME_FUNCTION_ENTRY; 
# 3485
typedef 
# 3479
struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY { 
unsigned FuncStart:32; 
unsigned PrologLen:8; 
unsigned FuncLen:22; 
unsigned ThirtyTwoBit:1; 
unsigned ExceptionFlag:1; 
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_CE_RUNTIME_FUNCTION_ENTRY; 
# 3496
typedef 
# 3487
struct _IMAGE_DEBUG_DIRECTORY { 
DWORD Characteristics; 
DWORD TimeDateStamp; 
WORD MajorVersion; 
WORD MinorVersion; 
DWORD Type; 
DWORD SizeOfData; 
DWORD AddressOfRawData; 
DWORD PointerToRawData; 
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; 
# 3509
typedef 
# 3498
struct _FPO_DATA { 
DWORD ulOffStart; 
DWORD cbProcSize; 
DWORD cdwLocals; 
WORD cdwParams; 
WORD cbProlog:8; 
WORD cbRegs:3; 
WORD fHasSEH:1; 
WORD fUseBP:1; 
WORD reserved:1; 
WORD cbFrame:2; 
} FPO_DATA, *PFPO_DATA; 
# 3517
typedef 
# 3511
struct _IMAGE_DEBUG_MISC { 
DWORD DataType; 
DWORD Length; 
BOOLEAN Unicode; 
BYTE Reserved[3]; 
BYTE Data[1]; 
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC; 
# 3523
typedef 
# 3519
struct _IMAGE_FUNCTION_ENTRY { 
DWORD StartingAddress; 
DWORD EndingAddress; 
DWORD EndOfPrologue; 
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY; 
# 3532
typedef 
# 3525
struct _IMAGE_FUNCTION_ENTRY64 { 
ULONGLONG StartingAddress; 
ULONGLONG EndingAddress; 

union { ULONGLONG EndOfPrologue; 
ULONGLONG UnwindInfoAddress; 
}; 
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64; 
# 3548
typedef 
# 3534
struct _IMAGE_SEPARATE_DEBUG_HEADER { 
WORD Signature; 
WORD Flags; 
WORD Machine; 
WORD Characteristics; 
DWORD TimeDateStamp; 
DWORD CheckSum; 
DWORD ImageBase; 
DWORD SizeOfImage; 
DWORD NumberOfSections; 
DWORD ExportedNamesSize; 
DWORD DebugDirectorySize; 
DWORD SectionAlignment; 
DWORD Reserved[2]; 
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER; 
#pragma pack ( pop )
# 3558
typedef 
# 3551
enum _CM_SERVICE_NODE_TYPE { 
DriverType = 1, 
FileSystemType, 
Win32ServiceOwnProcess = 16, 
Win32ServiceShareProcess = 32, 
AdapterType = 4, 
RecognizerType = 8
} SERVICE_NODE_TYPE; 
# 3566
typedef 
# 3560
enum _CM_SERVICE_LOAD_TYPE { 
BootLoad, 
SystemLoad, 
AutoLoad, 
DemandLoad, 
DisableLoad
} SERVICE_LOAD_TYPE; 
# 3573
typedef 
# 3568
enum _CM_ERROR_CONTROL_TYPE { 
IgnoreError, 
NormalError, 
SevereError, 
CriticalError
} SERVICE_ERROR_TYPE; 
# 3586
typedef 
# 3575
struct _NT_TIB { 
struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; 
PVOID StackBase; 
PVOID StackLimit; 
PVOID SubSystemTib; 

union { PVOID FiberData; 
DWORD Version; 
}; 
PVOID ArbitraryUserPointer; 
_NT_TIB *Self; 
} NT_TIB, *PNT_TIB; 
# 3612
typedef 
# 3588
struct _REPARSE_DATA_BUFFER { 
DWORD ReparseTag; 
WORD ReparseDataLength; 
WORD Reserved; 

union { 
struct { WORD SubstituteNameOffset; 
WORD SubstituteNameLength; 
WORD PrintNameOffset; 
WORD PrintNameLength; 
ULONG Flags; 
WCHAR PathBuffer[1]; 
} SymbolicLinkReparseBuffer; 

struct { WORD SubstituteNameOffset; 
WORD SubstituteNameLength; 
WORD PrintNameOffset; 
WORD PrintNameLength; 
WCHAR PathBuffer[1]; 
} MountPointReparseBuffer; 

struct { BYTE DataBuffer[1]; 
} GenericReparseBuffer; 
}; 
} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER; 
# 3622
typedef 
# 3614
struct _REPARSE_GUID_DATA_BUFFER { 
DWORD ReparseTag; 
WORD ReparseDataLength; 
WORD Reserved; 
GUID ReparseGuid; 

struct { BYTE DataBuffer[1]; 
} GenericReparseBuffer; 
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER; 




typedef 
# 3624
struct _REPARSE_POINT_INFORMATION { 
WORD ReparseDataLength; 
WORD UnparsedNameLength; 
} REPARSE_POINT_INFORMATION, *PREPARSE_POINT_INFORMATION; 
# 3633
typedef 
# 3630
union _FILE_SEGMENT_ELEMENT { 
PVOID64 Buffer; 
ULONGLONG Alignment; 
} FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT; 
# 3700 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 3688
enum _JOBOBJECTINFOCLASS { 
JobObjectBasicAccountingInformation = 1, 
JobObjectBasicLimitInformation, 
JobObjectBasicProcessIdList, 
JobObjectBasicUIRestrictions, 
JobObjectSecurityLimitInformation, 
JobObjectEndOfJobTimeInformation, 
JobObjectAssociateCompletionPortInformation, 
JobObjectBasicAndIoAccountingInformation, 
JobObjectExtendedLimitInformation, 
JobObjectJobSetInformation, 
MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS; 
# 3711
typedef 
# 3702
struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION { 
LARGE_INTEGER TotalUserTime; 
LARGE_INTEGER TotalKernelTime; 
LARGE_INTEGER ThisPeriodTotalUserTime; 
LARGE_INTEGER ThisPeriodTotalKernelTime; 
DWORD TotalPageFaultCount; 
DWORD TotalProcesses; 
DWORD ActiveProcesses; 
DWORD TotalTerminatedProcesses; 
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION; 
# 3723
typedef 
# 3713
struct _JOBOBJECT_BASIC_LIMIT_INFORMATION { 
LARGE_INTEGER PerProcessUserTimeLimit; 
LARGE_INTEGER PerJobUserTimeLimit; 
DWORD LimitFlags; 
SIZE_T MinimumWorkingSetSize; 
SIZE_T MaximumWorkingSetSize; 
DWORD ActiveProcessLimit; 
ULONG_PTR Affinity; 
DWORD PriorityClass; 
DWORD SchedulingClass; 
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION; 
# 3729
typedef 
# 3725
struct _JOBOBJECT_BASIC_PROCESS_ID_LIST { 
DWORD NumberOfAssignedProcesses; 
DWORD NumberOfProcessIdsInList; 
ULONG_PTR ProcessIdList[1]; 
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST; 



typedef 
# 3731
struct _JOBOBJECT_BASIC_UI_RESTRICTIONS { 
DWORD UIRestrictionsClass; 
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS; 
# 3741
typedef 
# 3735
struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION { 
DWORD SecurityLimitFlags; 
HANDLE JobToken; 
PTOKEN_GROUPS SidsToDisable; 
PTOKEN_PRIVILEGES PrivilegesToDelete; 
PTOKEN_GROUPS RestrictedSids; 
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION; 



typedef 
# 3743
struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION { 
DWORD EndOfJobTimeAction; 
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION; 




typedef 
# 3747
struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT { 
PVOID CompletionKey; 
HANDLE CompletionPort; 
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT; 




typedef 
# 3752
struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION { 
JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo; 
IO_COUNTERS IoInfo; 
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION; 
# 3764
typedef 
# 3757
struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION { 
JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation; 
IO_COUNTERS IoInfo; 
SIZE_T ProcessMemoryLimit; 
SIZE_T JobMemoryLimit; 
SIZE_T PeakProcessMemoryUsed; 
SIZE_T PeakJobMemoryUsed; 
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION; 



typedef 
# 3766
struct _JOBOBJECT_JOBSET_INFORMATION { 
DWORD MemberLevel; 
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION; 
# 2 "d:\\mingw\\mingw\\include\\pshpack4.h" 3
#pragma pack ( push, 4 )
# 3783 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 3780
enum _LATENCY_TIME { 
LT_DONT_CARE, 
LT_LOWEST_LATENCY
} LATENCY_TIME, *PLATENCY_TIME; 
# 3795
typedef 
# 3786
enum _SYSTEM_POWER_STATE { 
PowerSystemUnspecified, 
PowerSystemWorking, 
PowerSystemSleeping1, 
PowerSystemSleeping2, 
PowerSystemSleeping3, 
PowerSystemHibernate, 
PowerSystemShutdown, 
PowerSystemMaximum
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE; 
# 3807
typedef 
# 3799
enum { PowerActionNone, 
PowerActionReserved, 
PowerActionSleep, 
PowerActionHibernate, 
PowerActionShutdown, 
PowerActionShutdownReset, 
PowerActionShutdownOff, 
PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION; 
# 3827 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 3820
enum _DEVICE_POWER_STATE { 
PowerDeviceUnspecified, 
PowerDeviceD0, 
PowerDeviceD1, 
PowerDeviceD2, 
PowerDeviceD3, 
PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE; 
# 3833
typedef 
# 3831
struct { DWORD Granularity; 
DWORD Capacity; 
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE; 
# 3840
typedef 
# 3836
struct _POWER_ACTION_POLICY { 
POWER_ACTION Action; 
ULONG Flags; 
ULONG EventCode; 
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY; 
# 3875 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 3869
struct _SYSTEM_POWER_LEVEL { 
BOOLEAN Enable; 
UCHAR Spare[3]; 
ULONG BatteryLevel; 
POWER_ACTION_POLICY PowerPolicy; 
SYSTEM_POWER_STATE MinSystemState; 
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL; 
# 3906
typedef 
# 3877
struct _SYSTEM_POWER_POLICY { 
ULONG Revision; 
POWER_ACTION_POLICY PowerButton; 
POWER_ACTION_POLICY SleepButton; 
POWER_ACTION_POLICY LidClose; 
SYSTEM_POWER_STATE LidOpenWake; 
ULONG Reserved; 
POWER_ACTION_POLICY Idle; 
ULONG IdleTimeout; 
UCHAR IdleSensitivity; 
UCHAR DynamicThrottle; 
UCHAR Spare2[2]; 
SYSTEM_POWER_STATE MinSleep; 
SYSTEM_POWER_STATE MaxSleep; 
SYSTEM_POWER_STATE ReducedLatencySleep; 
ULONG WinLogonFlags; 
ULONG Spare3; 
ULONG DozeS4Timeout; 
ULONG BroadcastCapacityResolution; 
SYSTEM_POWER_LEVEL DischargePolicy[4]; 
ULONG VideoTimeout; 
BOOLEAN VideoDimDisplay; 
ULONG VideoReserved[3]; 
ULONG SpindownTimeout; 
BOOLEAN OptimizeForPower; 
UCHAR FanThrottleTolerance; 
UCHAR ForcedThrottle; 
UCHAR MinThrottle; 
POWER_ACTION_POLICY OverThrottled; 
} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY; 
# 3939
typedef 
# 3909
struct _SYSTEM_POWER_CAPABILITIES { 
BOOLEAN PowerButtonPresent; 
BOOLEAN SleepButtonPresent; 
BOOLEAN LidPresent; 
BOOLEAN SystemS1; 
BOOLEAN SystemS2; 
BOOLEAN SystemS3; 
BOOLEAN SystemS4; 
BOOLEAN SystemS5; 
BOOLEAN HiberFilePresent; 
BOOLEAN FullWake; 
BOOLEAN VideoDimPresent; 
BOOLEAN ApmPresent; 
BOOLEAN UpsPresent; 
BOOLEAN ThermalControl; 
BOOLEAN ProcessorThrottle; 
UCHAR ProcessorMinThrottle; 
UCHAR ProcessorMaxThrottle; 
BOOLEAN FastSystemS4; 
UCHAR spare2[3]; 
BOOLEAN DiskSpinDown; 
UCHAR spare3[8]; 
BOOLEAN SystemBatteriesPresent; 
BOOLEAN BatteriesAreShortTerm; 
BATTERY_REPORTING_SCALE BatteryScale[3]; 
SYSTEM_POWER_STATE AcOnLineWake; 
SYSTEM_POWER_STATE SoftLidWake; 
SYSTEM_POWER_STATE RtcWake; 
SYSTEM_POWER_STATE MinDeviceWakeState; 
SYSTEM_POWER_STATE DefaultLowLatencyWake; 
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES; 
# 3954
typedef 
# 3942
struct _SYSTEM_BATTERY_STATE { 
BOOLEAN AcOnLine; 
BOOLEAN BatteryPresent; 
BOOLEAN Charging; 
BOOLEAN Discharging; 
BOOLEAN Spare1[4]; 
ULONG MaxCapacity; 
ULONG RemainingCapacity; 
ULONG Rate; 
ULONG EstimatedTime; 
ULONG DefaultAlert1; 
ULONG DefaultAlert2; 
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE; 
# 3981
typedef 
# 3957
enum _POWER_INFORMATION_LEVEL { 
SystemPowerPolicyAc, 
SystemPowerPolicyDc, 
VerifySystemPolicyAc, 
VerifySystemPolicyDc, 
SystemPowerCapabilities, 
SystemBatteryState, 
SystemPowerStateHandler, 
ProcessorStateHandler, 
SystemPowerPolicyCurrent, 
AdministratorPowerPolicy, 
SystemReserveHiberFile, 
ProcessorInformation, 
SystemPowerInformation, 
ProcessorStateHandler2, 
LastWakeTime, 
LastSleepTime, 
SystemExecutionState, 
SystemPowerStateNotifyHandler, 
ProcessorPowerPolicyAc, 
ProcessorPowerPolicyDc, 
VerifyProcessorPowerPolicyAc, 
VerifyProcessorPowerPolicyDc, 
ProcessorPowerPolicyCurrent
} POWER_INFORMATION_LEVEL; 


typedef LONG ( __attribute((__stdcall__))*PVECTORED_EXCEPTION_HANDLER)(PEXCEPTION_POINTERS) ; 
# 3993
typedef 
# 3988
struct _SYSTEM_POWER_INFORMATION { 
ULONG MaxIdlenessAllowed; 
ULONG Idleness; 
ULONG TimeRemaining; 
UCHAR CoolingMode; 
} SYSTEM_POWER_INFORMATION, *PSYSTEM_POWER_INFORMATION; 
# 4073 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef 
# 4063
struct _PROCESSOR_POWER_POLICY_INFO { 
ULONG TimeCheck; 
ULONG DemoteLimit; 
ULONG PromoteLimit; 
UCHAR DemotePercent; 
UCHAR PromotePercent; 
UCHAR Spare[2]; 
ULONG AllowDemotion:1; 
ULONG AllowPromotion:1; 
ULONG Reserved:30; 
} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO; 
# 4082
typedef 
# 4075
struct _PROCESSOR_POWER_POLICY { 
ULONG Revision; 
UCHAR DynamicThrottle; 
UCHAR Spare[3]; 
ULONG Reserved; 
ULONG PolicyCount; 
PROCESSOR_POWER_POLICY_INFO Policy[3]; 
} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY; 
# 4091
typedef 
# 4084
struct _ADMINISTRATOR_POWER_POLICY { 
SYSTEM_POWER_STATE MinSleep; 
SYSTEM_POWER_STATE MaxSleep; 
ULONG MinVideoTimeout; 
ULONG MaxVideoTimeout; 
ULONG MinSpindownTimeout; 
ULONG MaxSpindownTimeout; 
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY; 
# 2 "d:\\mingw\\mingw\\include\\poppack.h" 3
#pragma pack ( pop )
# 4096 "d:\\mingw\\mingw\\include\\winnt.h" 3
typedef void ( __attribute((__stdcall__))*WAITORTIMERCALLBACKFUNC)(PVOID, BOOLEAN) ; 
# 4103
typedef OSVERSIONINFOA OSVERSIONINFO, *POSVERSIONINFO, *LPOSVERSIONINFO; 
typedef OSVERSIONINFOEXA OSVERSIONINFOEX, *POSVERSIONINFOEX, *LPOSVERSIONINFOEX; 



__attribute((__stdcall__)) ULONGLONG VerSetConditionMask(ULONGLONG, DWORD, BYTE); 
# 4144 "d:\\mingw\\mingw\\include\\winnt.h" 3
static inline PVOID GetCurrentFiber() 
{ 
void *ret; 
__asm__ volatile (
      "mov{%z0}\t{%%" "fs:0x10" ", %0|%0," "fs:0x10" "}"
      : "=a" (ret)
    ); 
return ret; 
} 

static inline PVOID GetFiberData() 
{ 
void *ret; 
__asm__ volatile (
      "mov{%z0}\t{%%" "fs:0x10" ", %0|%0, " "fs:0x10" "}\n\t"
      "mov{%z0}\t{(%0), %0|%0, [%0]}"
      : "=r" (ret)
    ); 
return ret; 
} 

static inline struct _TEB *NtCurrentTeb() 
{ 
_TEB *ret; 
__asm__ volatile (
      "mov{%z0}\t{%%" "fs:0x18" ", %0|%0, " "fs:0x18" "}"
      : "=a" (ret)
      :
    ); 
return ret; 
} 
# 4326 "d:\\mingw\\mingw\\include\\winnt.h" 3
__attribute((__always_inline__)) static inline void MemoryBarrier() 
{ __atomic_thread_fence(5); } 
# 4336 "d:\\mingw\\mingw\\include\\winnt.h" 3
}
# 271 "d:\\mingw\\mingw\\include\\windef.h" 3
typedef UINT_PTR WPARAM; 
typedef LONG_PTR LPARAM; 
typedef LONG_PTR LRESULT; 

typedef LONG HRESULT; 



typedef WORD ATOM; 

typedef HANDLE HHOOK; 
typedef HANDLE HGLOBAL; 
typedef HANDLE HLOCAL; 
typedef HANDLE GLOBALHANDLE; 
typedef HANDLE LOCALHANDLE; 
typedef void *HGDIOBJ; 
typedef struct HACCEL__ { int i; } *HACCEL; 
typedef struct HBITMAP__ { int i; } *HBITMAP; 
typedef struct HBRUSH__ { int i; } *HBRUSH; 
typedef struct HCOLORSPACE__ { int i; } *HCOLORSPACE; 
typedef struct HDC__ { int i; } *HDC; 
typedef struct HGLRC__ { int i; } *HGLRC; 
typedef struct HDESK__ { int i; } *HDESK; 
typedef struct HENHMETAFILE__ { int i; } *HENHMETAFILE; 
typedef struct HFONT__ { int i; } *HFONT; 
typedef struct HICON__ { int i; } *HICON; 
typedef struct HKEY__ { int i; } *HKEY; 

typedef struct HMONITOR__ { int i; } *HMONITOR; 

typedef struct HTERMINAL__ { int i; } *HTERMINAL; 
typedef struct HWINEVENTHOOK__ { int i; } *HWINEVENTHOOK; 

typedef HKEY *PHKEY; 
typedef struct HMENU__ { int i; } *HMENU; 
typedef struct HMETAFILE__ { int i; } *HMETAFILE; 
typedef struct HINSTANCE__ { int i; } *HINSTANCE; 
typedef HINSTANCE HMODULE; 
typedef struct HPALETTE__ { int i; } *HPALETTE; 
typedef struct HPEN__ { int i; } *HPEN; 
typedef struct HRGN__ { int i; } *HRGN; 
typedef struct HRSRC__ { int i; } *HRSRC; 
typedef struct HSTR__ { int i; } *HSTR; 
typedef struct HTASK__ { int i; } *HTASK; 
typedef struct HWND__ { int i; } *HWND; 
typedef struct HWINSTA__ { int i; } *HWINSTA; 
typedef struct HKL__ { int i; } *HKL; 
typedef int HFILE; 
typedef HICON HCURSOR; 
typedef DWORD COLORREF; 
typedef int ( __attribute((__stdcall__))*FARPROC)(void) ; 
typedef int ( __attribute((__stdcall__))*NEARPROC)(void) ; 
typedef int ( __attribute((__stdcall__))*PROC)(void) ; 
# 329
typedef 
# 324
struct tagRECT { 
LONG left; 
LONG top; 
LONG right; 
LONG bottom; 
} RECT, *PRECT, *LPRECT; 
typedef const RECT *LPCRECT; 
# 336
typedef 
# 331
struct tagRECTL { 
LONG left; 
LONG top; 
LONG right; 
LONG bottom; 
} RECTL, *PRECTL, *LPRECTL; 
typedef const RECTL *LPCRECTL; 



typedef 
# 338
struct tagPOINT { 
LONG x; 
LONG y; 
} POINT, POINTL, *PPOINT, *LPPOINT, *PPOINTL, *LPPOINTL; 



typedef 
# 342
struct tagSIZE { 
LONG cx; 
LONG cy; 
} SIZE, SIZEL, *PSIZE, *LPSIZE, *PSIZEL, *LPSIZEL; 



typedef 
# 346
struct tagPOINTS { 
SHORT x; 
SHORT y; 
} POINTS, *PPOINTS, *LPPOINTS; 

}
# 49 "d:\\mingw\\mingw\\include\\wincon.h" 3
extern "C" {
# 123 "d:\\mingw\\mingw\\include\\wincon.h" 3
typedef 
# 117
struct _CHAR_INFO { 

union { WCHAR UnicodeChar; 
CHAR AsciiChar; 
} Char; 
WORD Attributes; 
} CHAR_INFO, *PCHAR_INFO; 
# 131
typedef 
# 126
struct _SMALL_RECT { 
SHORT Left; 
SHORT Top; 
SHORT Right; 
SHORT Bottom; 
} SMALL_RECT, *PSMALL_RECT; 
# 137
typedef 
# 134
struct _CONSOLE_CURSOR_INFO { 
DWORD dwSize; 
BOOL bVisible; 
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO; 
# 143
typedef 
# 140
struct _COORD { 
SHORT X; 
SHORT Y; 
} COORD, *PCOORD; 
# 152
typedef 
# 146
struct _CONSOLE_SCREEN_BUFFER_INFO { 
COORD dwSize; 
COORD dwCursorPosition; 
WORD wAttributes; 
SMALL_RECT srWindow; 
COORD dwMaximumWindowSize; 
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO; 

typedef BOOL ( __attribute((__stdcall__))*PHANDLER_ROUTINE)(DWORD) ; 
# 172
typedef 
# 157
struct _KEY_EVENT_RECORD { 
# 163
BOOL bKeyDown; 
WORD wRepeatCount; 
WORD wVirtualKeyCode; 
WORD wVirtualScanCode; 

union { WCHAR UnicodeChar; 
CHAR AsciiChar; 
} uChar; 
DWORD dwControlKeyState; 
} __attribute((packed)) KEY_EVENT_RECORD; 
# 180
typedef 
# 175
struct _MOUSE_EVENT_RECORD { 
COORD dwMousePosition; 
DWORD dwButtonState; 
DWORD dwControlKeyState; 
DWORD dwEventFlags; 
} MOUSE_EVENT_RECORD; 




typedef 
# 183
struct _WINDOW_BUFFER_SIZE_RECORD { 
COORD dwSize; 
} WINDOW_BUFFER_SIZE_RECORD; 




typedef 
# 188
struct _MENU_EVENT_RECORD { 
UINT dwCommandId; 
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD; 




typedef 
# 193
struct _FOCUS_EVENT_RECORD { 
BOOL bSetFocus; 
} FOCUS_EVENT_RECORD; 
# 207
typedef 
# 198
struct _INPUT_RECORD { 
WORD EventType; 

union { KEY_EVENT_RECORD KeyEvent; 
MOUSE_EVENT_RECORD MouseEvent; 
WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent; 
MENU_EVENT_RECORD MenuEvent; 
FOCUS_EVENT_RECORD FocusEvent; 
} Event; 
} INPUT_RECORD, *PINPUT_RECORD; 

__attribute((__stdcall__)) BOOL AllocConsole(); 
__attribute((__stdcall__)) HANDLE CreateConsoleScreenBuffer(DWORD, DWORD, const SECURITY_ATTRIBUTES *, DWORD, LPVOID); 
__attribute((__stdcall__)) BOOL FillConsoleOutputAttribute(HANDLE, WORD, DWORD, COORD, PDWORD); 


__attribute((__stdcall__)) BOOL FillConsoleOutputCharacterA(HANDLE, CHAR, DWORD, COORD, PDWORD); 
__attribute((__stdcall__)) BOOL FillConsoleOutputCharacterW(HANDLE, WCHAR, DWORD, COORD, PDWORD); 

__attribute((__stdcall__)) BOOL FlushConsoleInputBuffer(HANDLE); 
__attribute((__stdcall__)) BOOL FreeConsole(); 
__attribute((__stdcall__)) BOOL GenerateConsoleCtrlEvent(DWORD, DWORD); 


__attribute((__stdcall__)) DWORD GetConsoleAliasA(LPSTR, LPSTR, DWORD, LPSTR); 
__attribute((__stdcall__)) DWORD GetConsoleAliasW(LPWSTR, LPWSTR, DWORD, LPWSTR); 

__attribute((__stdcall__)) UINT GetConsoleCP(); 
__attribute((__stdcall__)) BOOL GetConsoleCursorInfo(HANDLE, PCONSOLE_CURSOR_INFO); 
__attribute((__stdcall__)) BOOL GetConsoleMode(HANDLE, PDWORD); 
__attribute((__stdcall__)) UINT GetConsoleOutputCP(); 
__attribute((__stdcall__)) BOOL GetConsoleScreenBufferInfo(HANDLE, PCONSOLE_SCREEN_BUFFER_INFO); 


__attribute((__stdcall__)) DWORD GetConsoleTitleA(LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetConsoleTitleW(LPWSTR, DWORD); 

__attribute((__stdcall__)) COORD GetLargestConsoleWindowSize(HANDLE); 
__attribute((__stdcall__)) BOOL GetNumberOfConsoleInputEvents(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetNumberOfConsoleMouseButtons(PDWORD); 
__attribute((__stdcall__)) BOOL HandlerRoutine(DWORD); 


__attribute((__stdcall__)) BOOL PeekConsoleInputA(HANDLE, PINPUT_RECORD, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL PeekConsoleInputW(HANDLE, PINPUT_RECORD, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL ReadConsoleA(HANDLE, PVOID, DWORD, PDWORD, PVOID); 
__attribute((__stdcall__)) BOOL ReadConsoleW(HANDLE, PVOID, DWORD, PDWORD, PVOID); 


__attribute((__stdcall__)) BOOL ReadConsoleInputA(HANDLE, PINPUT_RECORD, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL ReadConsoleInputW(HANDLE, PINPUT_RECORD, DWORD, PDWORD); 

__attribute((__stdcall__)) BOOL ReadConsoleOutputAttribute(HANDLE, LPWORD, DWORD, COORD, LPDWORD); 


__attribute((__stdcall__)) BOOL ReadConsoleOutputCharacterA(HANDLE, LPSTR, DWORD, COORD, PDWORD); 
__attribute((__stdcall__)) BOOL ReadConsoleOutputCharacterW(HANDLE, LPWSTR, DWORD, COORD, PDWORD); 


__attribute((__stdcall__)) BOOL ReadConsoleOutputA(HANDLE, PCHAR_INFO, COORD, COORD, PSMALL_RECT); 
__attribute((__stdcall__)) BOOL ReadConsoleOutputW(HANDLE, PCHAR_INFO, COORD, COORD, PSMALL_RECT); 


__attribute((__stdcall__)) BOOL ScrollConsoleScreenBufferA(HANDLE, const SMALL_RECT *, const SMALL_RECT *, COORD, const CHAR_INFO *); 

__attribute((__stdcall__)) BOOL ScrollConsoleScreenBufferW(HANDLE, const SMALL_RECT *, const SMALL_RECT *, COORD, const CHAR_INFO *); 


__attribute((__stdcall__)) BOOL SetConsoleActiveScreenBuffer(HANDLE); 
__attribute((__stdcall__)) BOOL SetConsoleCP(UINT); 
__attribute((__stdcall__)) BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE, BOOL); 
__attribute((__stdcall__)) BOOL SetConsoleCursorInfo(HANDLE, const CONSOLE_CURSOR_INFO *); 
__attribute((__stdcall__)) BOOL SetConsoleCursorPosition(HANDLE, COORD); 
__attribute((__stdcall__)) BOOL SetConsoleMode(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetConsoleOutputCP(UINT); 
__attribute((__stdcall__)) BOOL SetConsoleScreenBufferSize(HANDLE, COORD); 
__attribute((__stdcall__)) BOOL SetConsoleTextAttribute(HANDLE, WORD); 


__attribute((__stdcall__)) BOOL SetConsoleTitleA(LPCSTR); 
__attribute((__stdcall__)) BOOL SetConsoleTitleW(LPCWSTR); 

__attribute((__stdcall__)) BOOL SetConsoleWindowInfo(HANDLE, BOOL, const SMALL_RECT *); 


__attribute((__stdcall__)) BOOL WriteConsoleA(HANDLE, PCVOID, DWORD, PDWORD, PVOID); 
__attribute((__stdcall__)) BOOL WriteConsoleW(HANDLE, PCVOID, DWORD, PDWORD, PVOID); 


__attribute((__stdcall__)) BOOL WriteConsoleInputA(HANDLE, const INPUT_RECORD *, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL WriteConsoleInputW(HANDLE, const INPUT_RECORD *, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL WriteConsoleOutputA(HANDLE, const CHAR_INFO *, COORD, COORD, PSMALL_RECT); 
__attribute((__stdcall__)) BOOL WriteConsoleOutputW(HANDLE, const CHAR_INFO *, COORD, COORD, PSMALL_RECT); 

__attribute((__stdcall__)) BOOL WriteConsoleOutputAttribute(HANDLE, const WORD *, DWORD, COORD, PDWORD); 


__attribute((__stdcall__)) BOOL WriteConsoleOutputCharacterA(HANDLE, LPCSTR, DWORD, COORD, PDWORD); 
__attribute((__stdcall__)) BOOL WriteConsoleOutputCharacterW(HANDLE, LPCWSTR, DWORD, COORD, PDWORD); 
# 307
__attribute((__stdcall__)) BOOL GetConsoleDisplayMode(LPDWORD); 
__attribute((__stdcall__)) COORD GetConsoleFontSize(HANDLE, DWORD); 
__attribute((__stdcall__)) HWND GetConsoleWindow(); 
# 422 "d:\\mingw\\mingw\\include\\wincon.h" 3
}
# 64 "d:\\mingw\\mingw\\include\\winbase.h" 3
extern "C" {
# 762 "d:\\mingw\\mingw\\include\\winbase.h" 3
typedef 
# 759
struct _FILETIME { 
DWORD dwLowDateTime; 
DWORD dwHighDateTime; 
} FILETIME, *PFILETIME, *LPFILETIME; 
# 775
typedef 
# 764
struct _BY_HANDLE_FILE_INFORMATION { 
DWORD dwFileAttributes; 
FILETIME ftCreationTime; 
FILETIME ftLastAccessTime; 
FILETIME ftLastWriteTime; 
DWORD dwVolumeSerialNumber; 
DWORD nFileSizeHigh; 
DWORD nFileSizeLow; 
DWORD nNumberOfLinks; 
DWORD nFileIndexHigh; 
DWORD nFileIndexLow; 
} BY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION; 
# 806
typedef 
# 777
struct _DCB { 
DWORD DCBlength; 
DWORD BaudRate; 
DWORD fBinary:1; 
DWORD fParity:1; 
DWORD fOutxCtsFlow:1; 
DWORD fOutxDsrFlow:1; 
DWORD fDtrControl:2; 
DWORD fDsrSensitivity:1; 
DWORD fTXContinueOnXoff:1; 
DWORD fOutX:1; 
DWORD fInX:1; 
DWORD fErrorChar:1; 
DWORD fNull:1; 
DWORD fRtsControl:2; 
DWORD fAbortOnError:1; 
DWORD fDummy2:17; 
WORD wReserved; 
WORD XonLim; 
WORD XoffLim; 
BYTE ByteSize; 
BYTE Parity; 
BYTE StopBits; 
char XonChar; 
char XoffChar; 
char ErrorChar; 
char EofChar; 
char EvtChar; 
WORD wReserved1; 
} DCB, *LPDCB; 
# 817
typedef 
# 808
struct _COMM_CONFIG { 
DWORD dwSize; 
WORD wVersion; 
WORD wReserved; 
DCB dcb; 
DWORD dwProviderSubType; 
DWORD dwProviderOffset; 
DWORD dwProviderSize; 
WCHAR wcProviderData[1]; 
} COMMCONFIG, *LPCOMMCONFIG; 
# 838
typedef 
# 819
struct _COMMPROP { 
WORD wPacketLength; 
WORD wPacketVersion; 
DWORD dwServiceMask; 
DWORD dwReserved1; 
DWORD dwMaxTxQueue; 
DWORD dwMaxRxQueue; 
DWORD dwMaxBaud; 
DWORD dwProvSubType; 
DWORD dwProvCapabilities; 
DWORD dwSettableParams; 
DWORD dwSettableBaud; 
WORD wSettableData; 
WORD wSettableStopParity; 
DWORD dwCurrentTxQueue; 
DWORD dwCurrentRxQueue; 
DWORD dwProvSpec1; 
DWORD dwProvSpec2; 
WCHAR wcProvChar[1]; 
} COMMPROP, *LPCOMMPROP; 
# 846
typedef 
# 840
struct _COMMTIMEOUTS { 
DWORD ReadIntervalTimeout; 
DWORD ReadTotalTimeoutMultiplier; 
DWORD ReadTotalTimeoutConstant; 
DWORD WriteTotalTimeoutMultiplier; 
DWORD WriteTotalTimeoutConstant; 
} COMMTIMEOUTS, *LPCOMMTIMEOUTS; 
# 859
typedef 
# 848
struct _COMSTAT { 
DWORD fCtsHold:1; 
DWORD fDsrHold:1; 
DWORD fRlsdHold:1; 
DWORD fXoffHold:1; 
DWORD fXoffSent:1; 
DWORD fEof:1; 
DWORD fTxim:1; 
DWORD fReserved:25; 
DWORD cbInQue; 
DWORD cbOutQue; 
} COMSTAT, *LPCOMSTAT; 

typedef DWORD ( __attribute((__stdcall__))*LPTHREAD_START_ROUTINE)(LPVOID) ; 
# 874
typedef 
# 863
struct _CREATE_PROCESS_DEBUG_INFO { 
HANDLE hFile; 
HANDLE hProcess; 
HANDLE hThread; 
LPVOID lpBaseOfImage; 
DWORD dwDebugInfoFileOffset; 
DWORD nDebugInfoSize; 
LPVOID lpThreadLocalBase; 
LPTHREAD_START_ROUTINE lpStartAddress; 
LPVOID lpImageName; 
WORD fUnicode; 
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO; 
# 880
typedef 
# 876
struct _CREATE_THREAD_DEBUG_INFO { 
HANDLE hThread; 
LPVOID lpThreadLocalBase; 
LPTHREAD_START_ROUTINE lpStartAddress; 
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO; 




typedef 
# 882
struct _EXCEPTION_DEBUG_INFO { 
EXCEPTION_RECORD ExceptionRecord; 
DWORD dwFirstChance; 
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO; 



typedef 
# 887
struct _EXIT_THREAD_DEBUG_INFO { 
DWORD dwExitCode; 
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO; 



typedef 
# 891
struct _EXIT_PROCESS_DEBUG_INFO { 
DWORD dwExitCode; 
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO; 
# 902
typedef 
# 895
struct _LOAD_DLL_DEBUG_INFO { 
HANDLE hFile; 
LPVOID lpBaseOfDll; 
DWORD dwDebugInfoFileOffset; 
DWORD nDebugInfoSize; 
LPVOID lpImageName; 
WORD fUnicode; 
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO; 



typedef 
# 904
struct _UNLOAD_DLL_DEBUG_INFO { 
LPVOID lpBaseOfDll; 
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO; 
# 912
typedef 
# 908
struct _OUTPUT_DEBUG_STRING_INFO { 
LPSTR lpDebugStringData; 
WORD fUnicode; 
WORD nDebugStringLength; 
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO; 




typedef 
# 914
struct _RIP_INFO { 
DWORD dwError; 
DWORD dwType; 
} RIP_INFO, *LPRIP_INFO; 
# 934
typedef 
# 919
struct _DEBUG_EVENT { 
DWORD dwDebugEventCode; 
DWORD dwProcessId; 
DWORD dwThreadId; 

union { EXCEPTION_DEBUG_INFO Exception; 
CREATE_THREAD_DEBUG_INFO CreateThread; 
CREATE_PROCESS_DEBUG_INFO CreateProcessInfo; 
EXIT_THREAD_DEBUG_INFO ExitThread; 
EXIT_PROCESS_DEBUG_INFO ExitProcess; 
LOAD_DLL_DEBUG_INFO LoadDll; 
UNLOAD_DLL_DEBUG_INFO UnloadDll; 
OUTPUT_DEBUG_STRING_INFO DebugString; 
RIP_INFO RipInfo; 
} u; 
} DEBUG_EVENT, *LPDEBUG_EVENT; 
# 947
typedef 
# 936
struct _OVERLAPPED { 
ULONG_PTR Internal; 
ULONG_PTR InternalHigh; 

union { 
struct { DWORD Offset; 
DWORD OffsetHigh; 
}; 
PVOID Pointer; 
}; 
HANDLE hEvent; 
} OVERLAPPED, *POVERLAPPED, *LPOVERLAPPED; 
# 968
typedef 
# 949
struct _STARTUPINFOA { 
DWORD cb; 
LPSTR lpReserved; 
LPSTR lpDesktop; 
LPSTR lpTitle; 
DWORD dwX; 
DWORD dwY; 
DWORD dwXSize; 
DWORD dwYSize; 
DWORD dwXCountChars; 
DWORD dwYCountChars; 
DWORD dwFillAttribute; 
DWORD dwFlags; 
WORD wShowWindow; 
WORD cbReserved2; 
PBYTE lpReserved2; 
HANDLE hStdInput; 
HANDLE hStdOutput; 
HANDLE hStdError; 
} STARTUPINFOA, *LPSTARTUPINFOA; 
# 989
typedef 
# 970
struct _STARTUPINFOW { 
DWORD cb; 
LPWSTR lpReserved; 
LPWSTR lpDesktop; 
LPWSTR lpTitle; 
DWORD dwX; 
DWORD dwY; 
DWORD dwXSize; 
DWORD dwYSize; 
DWORD dwXCountChars; 
DWORD dwYCountChars; 
DWORD dwFillAttribute; 
DWORD dwFlags; 
WORD wShowWindow; 
WORD cbReserved2; 
PBYTE lpReserved2; 
HANDLE hStdInput; 
HANDLE hStdOutput; 
HANDLE hStdError; 
} STARTUPINFOW, *LPSTARTUPINFOW; 

typedef STARTUPINFOA STARTUPINFO, *LPSTARTUPINFO; 
# 998
typedef 
# 993
struct _PROCESS_INFORMATION { 
HANDLE hProcess; 
HANDLE hThread; 
DWORD dwProcessId; 
DWORD dwThreadId; 
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; 
# 1008
typedef 
# 1000
struct _CRITICAL_SECTION_DEBUG { 
WORD Type; 
WORD CreatorBackTraceIndex; 
_CRITICAL_SECTION *CriticalSection; 
LIST_ENTRY ProcessLocksList; 
DWORD EntryCount; 
DWORD ContentionCount; 
DWORD Spare[2]; 
} CRITICAL_SECTION_DEBUG, *PCRITICAL_SECTION_DEBUG; 
# 1017
typedef 
# 1010
struct _CRITICAL_SECTION { 
PCRITICAL_SECTION_DEBUG DebugInfo; 
LONG LockCount; 
LONG RecursionCount; 
HANDLE OwningThread; 
HANDLE LockSemaphore; 
DWORD SpinCount; 
} CRITICAL_SECTION, *PCRITICAL_SECTION, *LPCRITICAL_SECTION; 
# 1028
typedef 
# 1019
struct _SYSTEMTIME { 
WORD wYear; 
WORD wMonth; 
WORD wDayOfWeek; 
WORD wDay; 
WORD wHour; 
WORD wMinute; 
WORD wSecond; 
WORD wMilliseconds; 
} SYSTEMTIME, *LPSYSTEMTIME; 
# 1037
typedef 
# 1030
struct _WIN32_FILE_ATTRIBUTE_DATA { 
DWORD dwFileAttributes; 
FILETIME ftCreationTime; 
FILETIME ftLastAccessTime; 
FILETIME ftLastWriteTime; 
DWORD nFileSizeHigh; 
DWORD nFileSizeLow; 
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA; 
# 1056
typedef 
# 1039
struct _WIN32_FIND_DATAA { 
DWORD dwFileAttributes; 
FILETIME ftCreationTime; 
FILETIME ftLastAccessTime; 
FILETIME ftLastWriteTime; 
DWORD nFileSizeHigh; 
DWORD nFileSizeLow; 



DWORD dwReserved0; 
DWORD dwReserved1; 

CHAR cFileName[260]; 

CHAR cAlternateFileName[14]; 

} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; 
# 1075
typedef 
# 1058
struct _WIN32_FIND_DATAW { 
DWORD dwFileAttributes; 
FILETIME ftCreationTime; 
FILETIME ftLastAccessTime; 
FILETIME ftLastWriteTime; 
DWORD nFileSizeHigh; 
DWORD nFileSizeLow; 



DWORD dwReserved0; 
DWORD dwReserved1; 

WCHAR cFileName[260]; 

WCHAR cAlternateFileName[14]; 

} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW; 

typedef WIN32_FIND_DATAA WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA; 
# 1085
typedef 
# 1079
struct _WIN32_STREAM_ID { 
DWORD dwStreamId; 
DWORD dwStreamAttributes; 
LARGE_INTEGER Size; 
DWORD dwStreamNameSize; 
WCHAR cStreamName[1]; 
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID; 




typedef 
# 1087
enum _FINDEX_INFO_LEVELS { 
FindExInfoStandard, 
FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS; 
# 1097
typedef 
# 1092
enum _FINDEX_SEARCH_OPS { 
FindExSearchNameMatch, 
FindExSearchLimitToDirectories, 
FindExSearchLimitToDevices, 
FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS; 




typedef 
# 1099
enum _ACL_INFORMATION_CLASS { 
AclRevisionInformation = 1, 
AclSizeInformation
} ACL_INFORMATION_CLASS; 
# 1108
typedef 
# 1104
struct tagHW_PROFILE_INFOA { 
DWORD dwDockInfo; 
CHAR szHwProfileGuid[39]; 
CHAR szHwProfileName[80]; 
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA; 
# 1114
typedef 
# 1110
struct tagHW_PROFILE_INFOW { 
DWORD dwDockInfo; 
WCHAR szHwProfileGuid[39]; 
WCHAR szHwProfileName[80]; 
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW; 

typedef HW_PROFILE_INFOA HW_PROFILE_INFO, *LPHW_PROFILE_INFO; 




typedef 
# 1118
enum _GET_FILEEX_INFO_LEVELS { 
GetFileExInfoStandard, 
GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS; 
# 1140
typedef 
# 1123
struct _SYSTEM_INFO { 

union { DWORD dwOemId; 

struct { WORD wProcessorArchitecture; 
WORD wReserved; 
}; 
}; 
DWORD dwPageSize; 
PVOID lpMinimumApplicationAddress; 
PVOID lpMaximumApplicationAddress; 
DWORD dwActiveProcessorMask; 
DWORD dwNumberOfProcessors; 
DWORD dwProcessorType; 
DWORD dwAllocationGranularity; 
WORD wProcessorLevel; 
WORD wProcessorRevision; 
} SYSTEM_INFO, *LPSYSTEM_INFO; 
# 1149
typedef 
# 1142
struct _SYSTEM_POWER_STATUS { 
BYTE ACLineStatus; 
BYTE BatteryFlag; 
BYTE BatteryLifePercent; 
BYTE Reserved1; 
DWORD BatteryLifeTime; 
DWORD BatteryFullLifeTime; 
} SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS; 
# 1159
typedef 
# 1151
struct _TIME_ZONE_INFORMATION { 
LONG Bias; 
WCHAR StandardName[32]; 
SYSTEMTIME StandardDate; 
LONG StandardBias; 
WCHAR DaylightName[32]; 
SYSTEMTIME DaylightDate; 
LONG DaylightBias; 
} TIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION; 
# 1170
typedef 
# 1161
struct _MEMORYSTATUS { 
DWORD dwLength; 
DWORD dwMemoryLoad; 
DWORD dwTotalPhys; 
DWORD dwAvailPhys; 
DWORD dwTotalPageFile; 
DWORD dwAvailPageFile; 
DWORD dwTotalVirtual; 
DWORD dwAvailVirtual; 
} MEMORYSTATUS, *LPMEMORYSTATUS; 
# 1195
typedef 
# 1172
struct _LDT_ENTRY { 
WORD LimitLow; 
WORD BaseLow; 

union { 
struct { BYTE BaseMid; 
BYTE Flags1; 
BYTE Flags2; 
BYTE BaseHi; 
} Bytes; 

struct { DWORD BaseMid:8; 
DWORD Type:5; 
DWORD Dpl:2; 
DWORD Pres:1; 
DWORD LimitHi:4; 
DWORD Sys:1; 
DWORD Reserved_0:1; 
DWORD Default_Big:1; 
DWORD Granularity:1; 
DWORD BaseHi:8; 
} Bits; 
} HighWord; 
} LDT_ENTRY, *PLDT_ENTRY, *LPLDT_ENTRY; 
# 1215
typedef 
# 1197
struct _PROCESS_HEAP_ENTRY { 
PVOID lpData; 
DWORD cbData; 
BYTE cbOverhead; 
BYTE iRegionIndex; 
WORD wFlags; 

union { 
struct { HANDLE hMem; 
DWORD dwReserved[3]; 
} Block; 

struct { DWORD dwCommittedSize; 
DWORD dwUnCommittedSize; 
LPVOID lpFirstBlock; 
LPVOID lpLastBlock; 
} Region; 
}; 
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY; 
# 1224
typedef 
# 1217
struct _OFSTRUCT { 
BYTE cBytes; 
BYTE fFixedDisk; 
WORD nErrCode; 
WORD Reserved1; 
WORD Reserved2; 
CHAR szPathName[128]; 
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT; 
# 1231
typedef 
# 1226
struct _WIN_CERTIFICATE { 
DWORD dwLength; 
WORD wRevision; 
WORD wCertificateType; 
BYTE bCertificate[1]; 
} WIN_CERTIFICATE, *LPWIN_CERTIFICATE; 

typedef DWORD ( __attribute((__stdcall__))*LPPROGRESS_ROUTINE)(LARGE_INTEGER, LARGE_INTEGER, LARGE_INTEGER, LARGE_INTEGER, DWORD, DWORD, HANDLE, HANDLE, LPVOID) ; 



typedef void ( __attribute((__stdcall__))*LPFIBER_START_ROUTINE)(PVOID) ; 


typedef BOOL ( __attribute((__stdcall__))*ENUMRESLANGPROCA)(HMODULE, LPCSTR, LPCSTR, WORD, LONG) ; 
typedef BOOL ( __attribute((__stdcall__))*ENUMRESLANGPROCW)(HMODULE, LPCWSTR, LPCWSTR, WORD, LONG) ; 



typedef BOOL ( __attribute((__stdcall__))*ENUMRESNAMEPROCA)(HMODULE, LPCSTR, LPSTR, LONG) ; 
typedef BOOL ( __attribute((__stdcall__))*ENUMRESNAMEPROCW)(HMODULE, LPCWSTR, LPWSTR, LONG) ; 


typedef BOOL ( __attribute((__stdcall__))*ENUMRESTYPEPROCA)(HMODULE, LPSTR, LONG) ; 
typedef BOOL ( __attribute((__stdcall__))*ENUMRESTYPEPROCW)(HMODULE, LPWSTR, LONG) ; 

typedef void ( __attribute((__stdcall__))*LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD, DWORD, LPOVERLAPPED) ; 

typedef LONG ( __attribute((__stdcall__))*PTOP_LEVEL_EXCEPTION_FILTER)(LPEXCEPTION_POINTERS) ; 
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER; 
typedef void ( __attribute((__stdcall__))*PAPCFUNC)(ULONG_PTR) ; 
typedef void ( __attribute((__stdcall__))*PTIMERAPCROUTINE)(PVOID, DWORD, DWORD) ; 
# 1263
__attribute((__stdcall__)) int WinMain(HINSTANCE, HINSTANCE, LPSTR, int); 




__attribute((__stdcall__)) int wWinMain(HINSTANCE, HINSTANCE, LPWSTR, int); 

__attribute((__stdcall__)) long _hread(HFILE, LPVOID, long); 
__attribute((__stdcall__)) long _hwrite(HFILE, LPCSTR, long); 
__attribute((__stdcall__)) HFILE _lclose(HFILE); 
__attribute((__stdcall__)) HFILE _lcreat(LPCSTR, int); 
__attribute((__stdcall__)) LONG _llseek(HFILE, LONG, int); 
__attribute((__stdcall__)) HFILE _lopen(LPCSTR, int); 
__attribute((__stdcall__)) UINT _lread(HFILE, LPVOID, UINT); 
__attribute((__stdcall__)) UINT _lwrite(HFILE, LPCSTR, UINT); 



__attribute((__stdcall__)) BOOL AccessCheck(PSECURITY_DESCRIPTOR, HANDLE, DWORD, PGENERIC_MAPPING, PPRIVILEGE_SET, PDWORD, PDWORD, PBOOL); 
# 1287
__attribute((__stdcall__)) BOOL AccessCheckAndAuditAlarmA(LPCSTR, LPVOID, LPSTR, LPSTR, PSECURITY_DESCRIPTOR, DWORD, PGENERIC_MAPPING, BOOL, PDWORD, PBOOL, PBOOL); 



__attribute((__stdcall__)) BOOL AccessCheckAndAuditAlarmW(LPCWSTR, LPVOID, LPWSTR, LPWSTR, PSECURITY_DESCRIPTOR, DWORD, PGENERIC_MAPPING, BOOL, PDWORD, PBOOL, PBOOL); 




__attribute((__stdcall__)) BOOL AddAccessAllowedAce(PACL, DWORD, DWORD, PSID); 
__attribute((__stdcall__)) BOOL AddAccessDeniedAce(PACL, DWORD, DWORD, PSID); 
__attribute((__stdcall__)) BOOL AddAce(PACL, DWORD, DWORD, PVOID, DWORD); 


__attribute((__stdcall__)) ATOM AddAtomA(LPCSTR); 
__attribute((__stdcall__)) ATOM AddAtomW(LPCWSTR); 

__attribute((__stdcall__)) BOOL AddAuditAccessAce(PACL, DWORD, DWORD, PSID, BOOL, BOOL); 
__attribute((__stdcall__)) BOOL AdjustTokenGroups(HANDLE, BOOL, PTOKEN_GROUPS, DWORD, PTOKEN_GROUPS, PDWORD); 

__attribute((__stdcall__)) BOOL AdjustTokenPrivileges(HANDLE, BOOL, PTOKEN_PRIVILEGES, DWORD, PTOKEN_PRIVILEGES, PDWORD); 

__attribute((__stdcall__)) BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, PSID *); 



__attribute((__stdcall__)) BOOL AllocateLocallyUniqueId(PLUID); 
__attribute((__stdcall__)) BOOL AreAllAccessesGranted(DWORD, DWORD); 
__attribute((__stdcall__)) BOOL AreAnyAccessesGranted(DWORD, DWORD); 
__attribute((__stdcall__)) BOOL AreFileApisANSI(); 


__attribute((__stdcall__)) BOOL BackupEventLogA(HANDLE, LPCSTR); 
__attribute((__stdcall__)) BOOL BackupEventLogW(HANDLE, LPCWSTR); 

__attribute((__stdcall__)) BOOL BackupRead(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL, BOOL, LPVOID *); 

__attribute((__stdcall__)) BOOL BackupSeek(HANDLE, DWORD, DWORD, LPDWORD, LPDWORD, LPVOID *); 

__attribute((__stdcall__)) BOOL BackupWrite(HANDLE, LPBYTE, DWORD, LPDWORD, BOOL, BOOL, LPVOID *); 

__attribute((__stdcall__)) BOOL Beep(DWORD, DWORD); 


__attribute((__stdcall__)) HANDLE BeginUpdateResourceA(LPCSTR, BOOL); 
__attribute((__stdcall__)) HANDLE BeginUpdateResourceW(LPCWSTR, BOOL); 


__attribute((__stdcall__)) BOOL BuildCommDCBA(LPCSTR, LPDCB); 
__attribute((__stdcall__)) BOOL BuildCommDCBW(LPCWSTR, LPDCB); 


__attribute((__stdcall__)) BOOL BuildCommDCBAndTimeoutsA(LPCSTR, LPDCB, LPCOMMTIMEOUTS); 
__attribute((__stdcall__)) BOOL BuildCommDCBAndTimeoutsW(LPCWSTR, LPDCB, LPCOMMTIMEOUTS); 



__attribute((__stdcall__)) BOOL CallNamedPipeA(LPCSTR, PVOID, DWORD, PVOID, DWORD, PDWORD, DWORD); 

__attribute((__stdcall__)) BOOL CallNamedPipeW(LPCWSTR, PVOID, DWORD, PVOID, DWORD, PDWORD, DWORD); 


__attribute((__stdcall__)) BOOL CancelDeviceWakeupRequest(HANDLE); 
__attribute((__stdcall__)) BOOL CancelIo(HANDLE); 
__attribute((__stdcall__)) BOOL CancelWaitableTimer(HANDLE); 
__attribute((__stdcall__)) BOOL ClearCommBreak(HANDLE); 
__attribute((__stdcall__)) BOOL ClearCommError(HANDLE, PDWORD, LPCOMSTAT); 


__attribute((__stdcall__)) BOOL ClearEventLogA(HANDLE, LPCSTR); 
__attribute((__stdcall__)) BOOL ClearEventLogW(HANDLE, LPCWSTR); 

__attribute((__stdcall__)) BOOL CloseEventLog(HANDLE); 
__attribute((__stdcall__)) BOOL CloseHandle(HANDLE); 


__attribute((__stdcall__)) BOOL CommConfigDialogA(LPCSTR, HWND, LPCOMMCONFIG); 
__attribute((__stdcall__)) BOOL CommConfigDialogW(LPCWSTR, HWND, LPCOMMCONFIG); 

__attribute((__stdcall__)) LONG CompareFileTime(const FILETIME *, const FILETIME *); 
__attribute((__stdcall__)) BOOL ConnectNamedPipe(HANDLE, LPOVERLAPPED); 
__attribute((__stdcall__)) BOOL ContinueDebugEvent(DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) PVOID ConvertThreadToFiber(PVOID); 


__attribute((__stdcall__)) BOOL CopyFileA(LPCSTR, LPCSTR, BOOL); 
__attribute((__stdcall__)) BOOL CopyFileW(LPCWSTR, LPCWSTR, BOOL); 


__attribute((__stdcall__)) BOOL CopyFileExA(LPCSTR, LPCSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD); 

__attribute((__stdcall__)) BOOL CopyFileExW(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, LPBOOL, DWORD); 
# 1390 "d:\\mingw\\mingw\\include\\winbase.h" 3
__attribute((__stdcall__)) BOOL CopySid(DWORD, PSID, PSID); 


__attribute((__stdcall__)) BOOL CreateDirectoryA(LPCSTR, LPSECURITY_ATTRIBUTES); 
__attribute((__stdcall__)) BOOL CreateDirectoryW(LPCWSTR, LPSECURITY_ATTRIBUTES); 


__attribute((__stdcall__)) BOOL CreateDirectoryExA(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) BOOL CreateDirectoryExW(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES); 



__attribute((__stdcall__)) HANDLE CreateEventA(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCSTR); 

__attribute((__stdcall__)) HANDLE CreateEventW(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCWSTR); 


__attribute((__stdcall__)) LPVOID CreateFiber(SIZE_T, LPFIBER_START_ROUTINE, LPVOID); 


__attribute((__stdcall__)) HANDLE CreateFileA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE); 

__attribute((__stdcall__)) HANDLE CreateFileW(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE); 



__attribute((__stdcall__)) HANDLE CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCSTR); 

__attribute((__stdcall__)) HANDLE CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR); 


__attribute((__stdcall__)) HANDLE CreateIoCompletionPort(HANDLE, HANDLE, ULONG_PTR, DWORD); 



__attribute((__stdcall__)) HANDLE CreateMailslotA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) HANDLE CreateMailslotW(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 



__attribute((__stdcall__)) HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR); 


__attribute((__stdcall__)) HANDLE CreateNamedPipeA(LPCSTR, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) HANDLE CreateNamedPipeW(LPCWSTR, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 


__attribute((__stdcall__)) BOOL CreatePipe(PHANDLE, PHANDLE, LPSECURITY_ATTRIBUTES, DWORD); 

__attribute((__stdcall__)) BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR *, BOOL, HANDLE, PGENERIC_MAPPING); 
# 1449
__attribute((__stdcall__)) BOOL CreateProcessA(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, PVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION); 



__attribute((__stdcall__)) BOOL CreateProcessW(LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, PVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION); 
# 1459
__attribute((__stdcall__)) BOOL CreateProcessAsUserA(HANDLE, LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, PVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION); 



__attribute((__stdcall__)) BOOL CreateProcessAsUserW(HANDLE, LPCWSTR, LPWSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, PVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION); 




__attribute((__stdcall__)) HANDLE CreateRemoteThread(HANDLE, LPSECURITY_ATTRIBUTES, DWORD, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); 
# 1474
__attribute((__stdcall__)) HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCSTR); 

__attribute((__stdcall__)) HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR); 


__attribute((__stdcall__)) DWORD CreateTapePartition(HANDLE, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) HANDLE CreateThread(LPSECURITY_ATTRIBUTES, DWORD, LPTHREAD_START_ROUTINE, PVOID, DWORD, PDWORD); 



__attribute((__stdcall__)) HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); 

__attribute((__stdcall__)) HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR); 


__attribute((__stdcall__)) BOOL DebugActiveProcess(DWORD); 
__attribute((__stdcall__)) void DebugBreak(); 


__attribute((__stdcall__)) BOOL DefineDosDeviceA(DWORD, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL DefineDosDeviceW(DWORD, LPCWSTR, LPCWSTR); 



__attribute((__stdcall__)) BOOL DeleteAce(PACL, DWORD); 
__attribute((__stdcall__)) ATOM DeleteAtom(ATOM); 
__attribute((__stdcall__)) void DeleteCriticalSection(PCRITICAL_SECTION); 
__attribute((__stdcall__)) void DeleteFiber(PVOID); 


__attribute((__stdcall__)) BOOL DeleteFileA(LPCSTR); 
__attribute((__stdcall__)) BOOL DeleteFileW(LPCWSTR); 

__attribute((__stdcall__)) BOOL DeregisterEventSource(HANDLE); 
__attribute((__stdcall__)) BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *); 
__attribute((__stdcall__)) BOOL DeviceIoControl(HANDLE, DWORD, PVOID, DWORD, PVOID, DWORD, PDWORD, POVERLAPPED); 

__attribute((__stdcall__)) BOOL DisableThreadLibraryCalls(HMODULE); 
__attribute((__stdcall__)) BOOL DisconnectNamedPipe(HANDLE); 
__attribute((__stdcall__)) BOOL DosDateTimeToFileTime(WORD, WORD, LPFILETIME); 
__attribute((__stdcall__)) BOOL DuplicateHandle(HANDLE, HANDLE, HANDLE, PHANDLE, DWORD, BOOL, DWORD); 

__attribute((__stdcall__)) BOOL DuplicateToken(HANDLE, SECURITY_IMPERSONATION_LEVEL, PHANDLE); 

__attribute((__stdcall__)) BOOL DuplicateTokenEx(HANDLE, DWORD, LPSECURITY_ATTRIBUTES, SECURITY_IMPERSONATION_LEVEL, TOKEN_TYPE, PHANDLE); 
# 1524
__attribute((__stdcall__)) BOOL EncryptFileA(LPCSTR); 
__attribute((__stdcall__)) BOOL EncryptFileW(LPCWSTR); 


__attribute((__stdcall__)) BOOL EndUpdateResourceA(HANDLE, BOOL); 
__attribute((__stdcall__)) BOOL EndUpdateResourceW(HANDLE, BOOL); 

__attribute((__stdcall__)) void EnterCriticalSection(LPCRITICAL_SECTION); 


__attribute((__stdcall__)) BOOL EnumResourceLanguagesA(HMODULE, LPCSTR, LPCSTR, ENUMRESLANGPROCA, LONG_PTR); 

__attribute((__stdcall__)) BOOL EnumResourceLanguagesW(HMODULE, LPCWSTR, LPCWSTR, ENUMRESLANGPROCW, LONG_PTR); 



__attribute((__stdcall__)) BOOL EnumResourceNamesA(HMODULE, LPCSTR, ENUMRESNAMEPROCA, LONG_PTR); 

__attribute((__stdcall__)) BOOL EnumResourceNamesW(HMODULE, LPCWSTR, ENUMRESNAMEPROCW, LONG_PTR); 



__attribute((__stdcall__)) BOOL EnumResourceTypesA(HMODULE, ENUMRESTYPEPROCA, LONG_PTR); 
__attribute((__stdcall__)) BOOL EnumResourceTypesW(HMODULE, ENUMRESTYPEPROCW, LONG_PTR); 

__attribute((__stdcall__)) BOOL EqualPrefixSid(PSID, PSID); 
__attribute((__stdcall__)) BOOL EqualSid(PSID, PSID); 
__attribute((__stdcall__)) DWORD EraseTape(HANDLE, DWORD, BOOL); 
__attribute((__stdcall__)) BOOL EscapeCommFunction(HANDLE, DWORD); 
__attribute((noreturn)) __attribute((__stdcall__)) void ExitProcess(UINT); 
__attribute((noreturn)) __attribute((__stdcall__)) void ExitThread(DWORD); 


__attribute((__stdcall__)) DWORD ExpandEnvironmentStringsA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD ExpandEnvironmentStringsW(LPCWSTR, LPWSTR, DWORD); 


__attribute((__stdcall__)) void FatalAppExitA(UINT, LPCSTR); 
__attribute((__stdcall__)) void FatalAppExitW(UINT, LPCWSTR); 

__attribute((__stdcall__)) void FatalExit(int); 


__attribute((__stdcall__)) BOOL FileEncryptionStatusA(LPCSTR, LPDWORD); 
__attribute((__stdcall__)) BOOL FileEncryptionStatusW(LPCWSTR, LPDWORD); 

__attribute((__stdcall__)) BOOL FileTimeToDosDateTime(const FILETIME *, LPWORD, LPWORD); 
__attribute((__stdcall__)) BOOL FileTimeToLocalFileTime(const FILETIME *, LPFILETIME); 
__attribute((__stdcall__)) BOOL FileTimeToSystemTime(const FILETIME *, LPSYSTEMTIME); 


__attribute((__stdcall__)) ATOM FindAtomA(LPCSTR); 
__attribute((__stdcall__)) ATOM FindAtomW(LPCWSTR); 

__attribute((__stdcall__)) BOOL FindClose(HANDLE); 
__attribute((__stdcall__)) BOOL FindCloseChangeNotification(HANDLE); 


__attribute((__stdcall__)) HANDLE FindFirstChangeNotificationA(LPCSTR, BOOL, DWORD); 
__attribute((__stdcall__)) HANDLE FindFirstChangeNotificationW(LPCWSTR, BOOL, DWORD); 


__attribute((__stdcall__)) HANDLE FindFirstFileA(LPCSTR, LPWIN32_FIND_DATAA); 
__attribute((__stdcall__)) HANDLE FindFirstFileW(LPCWSTR, LPWIN32_FIND_DATAW); 


__attribute((__stdcall__)) HANDLE FindFirstFileExA(LPCSTR, FINDEX_INFO_LEVELS, PVOID, FINDEX_SEARCH_OPS, PVOID, DWORD); 

__attribute((__stdcall__)) HANDLE FindFirstFileExW(LPCWSTR, FINDEX_INFO_LEVELS, PVOID, FINDEX_SEARCH_OPS, PVOID, DWORD); 


__attribute((__stdcall__)) BOOL FindFirstFreeAce(PACL, PVOID *); 
__attribute((__stdcall__)) BOOL FindNextChangeNotification(HANDLE); 


__attribute((__stdcall__)) BOOL FindNextFileA(HANDLE, LPWIN32_FIND_DATAA); 
__attribute((__stdcall__)) BOOL FindNextFileW(HANDLE, LPWIN32_FIND_DATAW); 


__attribute((__stdcall__)) HRSRC FindResourceA(HMODULE, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HRSRC FindResourceW(HINSTANCE, LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) HRSRC FindResourceExA(HINSTANCE, LPCSTR, LPCSTR, WORD); 
__attribute((__stdcall__)) HRSRC FindResourceExW(HINSTANCE, LPCWSTR, LPCWSTR, WORD); 

__attribute((__stdcall__)) BOOL FlushFileBuffers(HANDLE); 
__attribute((__stdcall__)) BOOL FlushInstructionCache(HANDLE, PCVOID, DWORD); 
__attribute((__stdcall__)) BOOL FlushViewOfFile(PCVOID, DWORD); 


__attribute((__stdcall__)) DWORD FormatMessageA(DWORD, PCVOID, DWORD, DWORD, LPSTR, DWORD, va_list *); 

__attribute((__stdcall__)) DWORD FormatMessageW(DWORD, PCVOID, DWORD, DWORD, LPWSTR, DWORD, va_list *); 



__attribute((__stdcall__)) BOOL FreeEnvironmentStringsA(LPSTR); 
__attribute((__stdcall__)) BOOL FreeEnvironmentStringsW(LPWSTR); 

__attribute((__stdcall__)) BOOL FreeLibrary(HMODULE); 
__attribute((noreturn)) __attribute((__stdcall__)) void FreeLibraryAndExitThread(HMODULE, DWORD); 
# 1632
__attribute((__stdcall__)) BOOL FreeResource(HGLOBAL); 


__attribute((__stdcall__)) PVOID FreeSid(PSID); 
__attribute((__stdcall__)) BOOL GetAce(PACL, DWORD, LPVOID *); 
__attribute((__stdcall__)) BOOL GetAclInformation(PACL, PVOID, DWORD, ACL_INFORMATION_CLASS); 



__attribute((__stdcall__)) UINT GetAtomNameA(ATOM, LPSTR, int); 
__attribute((__stdcall__)) UINT GetAtomNameW(ATOM, LPWSTR, int); 


__attribute((__stdcall__)) BOOL GetBinaryTypeA(LPCSTR, PDWORD); 
__attribute((__stdcall__)) BOOL GetBinaryTypeW(LPCWSTR, PDWORD); 


__attribute((__stdcall__)) LPSTR GetCommandLineA(); 
__attribute((__stdcall__)) LPWSTR GetCommandLineW(); 

__attribute((__stdcall__)) BOOL GetCommConfig(HANDLE, LPCOMMCONFIG, PDWORD); 
__attribute((__stdcall__)) BOOL GetCommMask(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetCommModemStatus(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetCommProperties(HANDLE, LPCOMMPROP); 
__attribute((__stdcall__)) BOOL GetCommState(HANDLE, LPDCB); 
__attribute((__stdcall__)) BOOL GetCommTimeouts(HANDLE, LPCOMMTIMEOUTS); 


__attribute((__stdcall__)) DWORD GetCompressedFileSizeA(LPCSTR, PDWORD); 
__attribute((__stdcall__)) DWORD GetCompressedFileSizeW(LPCWSTR, PDWORD); 


__attribute((__stdcall__)) BOOL GetComputerNameA(LPSTR, PDWORD); 
__attribute((__stdcall__)) BOOL GetComputerNameW(LPWSTR, PDWORD); 


__attribute((__stdcall__)) DWORD GetCurrentDirectoryA(DWORD, LPSTR); 
__attribute((__stdcall__)) DWORD GetCurrentDirectoryW(DWORD, LPWSTR); 



__attribute((__stdcall__)) BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA); 
__attribute((__stdcall__)) BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW); 

__attribute((__stdcall__)) HANDLE GetCurrentProcess(); 
__attribute((__stdcall__)) DWORD GetCurrentProcessId(); 
__attribute((__stdcall__)) HANDLE GetCurrentThread(); 




__attribute((__stdcall__)) DWORD GetCurrentThreadId(); 
# 1689
__attribute((__stdcall__)) BOOL GetDefaultCommConfigA(LPCSTR, LPCOMMCONFIG, PDWORD); 
__attribute((__stdcall__)) BOOL GetDefaultCommConfigW(LPCWSTR, LPCOMMCONFIG, PDWORD); 

__attribute((__stdcall__)) BOOL GetDevicePowerState(HANDLE, BOOL *); 


__attribute((__stdcall__)) BOOL GetDiskFreeSpaceA(LPCSTR, PDWORD, PDWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL GetDiskFreeSpaceW(LPCWSTR, PDWORD, PDWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL GetDiskFreeSpaceExA(LPCSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER); 

__attribute((__stdcall__)) BOOL GetDiskFreeSpaceExW(LPCWSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER); 



__attribute((__stdcall__)) UINT GetDriveTypeA(LPCSTR); 
__attribute((__stdcall__)) UINT GetDriveTypeW(LPCWSTR); 

__attribute((__stdcall__)) LPCH GetEnvironmentStrings(); 


__attribute((__stdcall__)) LPCH GetEnvironmentStringsA(); 
__attribute((__stdcall__)) LPWCH GetEnvironmentStringsW(); 


__attribute((__stdcall__)) DWORD GetEnvironmentVariableA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetEnvironmentVariableW(LPCWSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL GetExitCodeProcess(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetExitCodeThread(HANDLE, PDWORD); 


__attribute((__stdcall__)) DWORD GetFileAttributesA(LPCSTR); 
__attribute((__stdcall__)) DWORD GetFileAttributesW(LPCWSTR); 


__attribute((__stdcall__)) BOOL GetFileAttributesExA(LPCSTR, GET_FILEEX_INFO_LEVELS, PVOID); 

__attribute((__stdcall__)) BOOL GetFileAttributesExW(LPCWSTR, GET_FILEEX_INFO_LEVELS, PVOID); 


__attribute((__stdcall__)) BOOL GetFileInformationByHandle(HANDLE, LPBY_HANDLE_FILE_INFORMATION); 



__attribute((__stdcall__)) BOOL GetFileSecurityA(LPCSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD); 

__attribute((__stdcall__)) BOOL GetFileSecurityW(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD); 


__attribute((__stdcall__)) DWORD GetFileSize(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetFileTime(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME); 
__attribute((__stdcall__)) DWORD GetFileType(HANDLE); 




__attribute((__stdcall__)) DWORD GetFullPathNameA(LPCSTR, DWORD, LPSTR, LPSTR *); 
__attribute((__stdcall__)) DWORD GetFullPathNameW(LPCWSTR, DWORD, LPWSTR, LPWSTR *); 

__attribute((__stdcall__)) BOOL GetHandleInformation(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetKernelObjectSecurity(HANDLE, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD); 

__attribute((__stdcall__)) DWORD GetLastError(); 
__attribute((__stdcall__)) DWORD GetLengthSid(PSID); 
__attribute((__stdcall__)) void GetLocalTime(LPSYSTEMTIME); 
__attribute((__stdcall__)) DWORD GetLogicalDrives(); 


__attribute((__stdcall__)) DWORD GetLogicalDriveStringsA(DWORD, LPSTR); 
__attribute((__stdcall__)) DWORD GetLogicalDriveStringsW(DWORD, LPWSTR); 

__attribute((__stdcall__)) BOOL GetMailslotInfo(HANDLE, PDWORD, PDWORD, PDWORD, PDWORD); 


__attribute((__stdcall__)) DWORD GetModuleFileNameA(HINSTANCE, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetModuleFileNameW(HINSTANCE, LPWSTR, DWORD); 


__attribute((__stdcall__)) HMODULE GetModuleHandleA(LPCSTR); 
__attribute((__stdcall__)) HMODULE GetModuleHandleW(LPCWSTR); 


__attribute((__stdcall__)) BOOL GetNamedPipeHandleStateA(HANDLE, PDWORD, PDWORD, PDWORD, PDWORD, LPSTR, DWORD); 

__attribute((__stdcall__)) BOOL GetNamedPipeHandleStateW(HANDLE, PDWORD, PDWORD, PDWORD, PDWORD, LPWSTR, DWORD); 


__attribute((__stdcall__)) BOOL GetNamedPipeInfo(HANDLE, PDWORD, PDWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL GetNumberOfEventLogRecords(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetOldestEventLogRecord(HANDLE, PDWORD); 
__attribute((__stdcall__)) BOOL GetOverlappedResult(HANDLE, LPOVERLAPPED, PDWORD, BOOL); 
__attribute((__stdcall__)) DWORD GetPriorityClass(HANDLE); 
__attribute((__stdcall__)) BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD); 
# 1792
__attribute((__stdcall__)) UINT GetPrivateProfileIntA(LPCSTR, LPCSTR, INT, LPCSTR); 
__attribute((__stdcall__)) UINT GetPrivateProfileIntW(LPCWSTR, LPCWSTR, INT, LPCWSTR); 


__attribute((__stdcall__)) DWORD GetPrivateProfileSectionA(LPCSTR, LPSTR, DWORD, LPCSTR); 

__attribute((__stdcall__)) DWORD GetPrivateProfileSectionW(LPCWSTR, LPWSTR, DWORD, LPCWSTR); 




__attribute((__stdcall__)) DWORD GetPrivateProfileSectionNamesA(LPSTR, DWORD, LPCSTR); 
__attribute((__stdcall__)) DWORD GetPrivateProfileSectionNamesW(LPWSTR, DWORD, LPCWSTR); 


__attribute((__stdcall__)) DWORD GetPrivateProfileStringA(LPCSTR, LPCSTR, LPCSTR, LPSTR, DWORD, LPCSTR); 

__attribute((__stdcall__)) DWORD GetPrivateProfileStringW(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, DWORD, LPCWSTR); 



__attribute((__stdcall__)) BOOL GetPrivateProfileStructA(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR); 

__attribute((__stdcall__)) BOOL GetPrivateProfileStructW(LPCWSTR, LPCWSTR, LPVOID, UINT, LPCWSTR); 


__attribute((__stdcall__)) FARPROC GetProcAddress(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) BOOL GetProcessAffinityMask(HANDLE, PDWORD, PDWORD); 

__attribute((__stdcall__)) HANDLE GetProcessHeap(); 
__attribute((__stdcall__)) DWORD GetProcessHeaps(DWORD, PHANDLE); 
__attribute((__stdcall__)) BOOL GetProcessPriorityBoost(HANDLE, PBOOL); 
__attribute((__stdcall__)) BOOL GetProcessShutdownParameters(PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL GetProcessTimes(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME); 

__attribute((__stdcall__)) DWORD GetProcessVersion(DWORD); 
__attribute((__stdcall__)) HWINSTA GetProcessWindowStation(); 
__attribute((__stdcall__)) BOOL GetProcessWorkingSetSize(HANDLE, PSIZE_T, PSIZE_T); 


__attribute((__stdcall__)) UINT GetProfileIntA(LPCSTR, LPCSTR, INT); 
__attribute((__stdcall__)) UINT GetProfileIntW(LPCWSTR, LPCWSTR, INT); 


__attribute((__stdcall__)) DWORD GetProfileSectionA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetProfileSectionW(LPCWSTR, LPWSTR, DWORD); 


__attribute((__stdcall__)) DWORD GetProfileStringA(LPCSTR, LPCSTR, LPCSTR, LPSTR, DWORD); 

__attribute((__stdcall__)) DWORD GetProfileStringW(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, DWORD); 


__attribute((__stdcall__)) BOOL GetQueuedCompletionStatus(HANDLE, PDWORD, PULONG_PTR, LPOVERLAPPED *, DWORD); 

__attribute((__stdcall__)) BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR_CONTROL, PDWORD); 

__attribute((__stdcall__)) BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL); 

__attribute((__stdcall__)) BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR, PSID *, LPBOOL); 

__attribute((__stdcall__)) DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR); 
__attribute((__stdcall__)) BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR, PSID *, LPBOOL); 

__attribute((__stdcall__)) BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR, LPBOOL, PACL *, LPBOOL); 



__attribute((__stdcall__)) DWORD GetShortPathNameA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetShortPathNameW(LPCWSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID); 
__attribute((__stdcall__)) DWORD GetSidLengthRequired(UCHAR); 
__attribute((__stdcall__)) PDWORD GetSidSubAuthority(PSID, DWORD); 
__attribute((__stdcall__)) PUCHAR GetSidSubAuthorityCount(PSID); 


__attribute((__stdcall__)) void GetStartupInfoA(LPSTARTUPINFOA); 
__attribute((__stdcall__)) void GetStartupInfoW(LPSTARTUPINFOW); 

__attribute((__stdcall__)) HANDLE GetStdHandle(DWORD); 


__attribute((__stdcall__)) UINT GetSystemDirectoryA(LPSTR, UINT); 
__attribute((__stdcall__)) UINT GetSystemDirectoryW(LPWSTR, UINT); 

__attribute((__stdcall__)) void GetSystemInfo(LPSYSTEM_INFO); 
__attribute((__stdcall__)) BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS); 
__attribute((__stdcall__)) void GetSystemTime(LPSYSTEMTIME); 
__attribute((__stdcall__)) BOOL GetSystemTimeAdjustment(PDWORD, PDWORD, PBOOL); 
__attribute((__stdcall__)) void GetSystemTimeAsFileTime(LPFILETIME); 
__attribute((__stdcall__)) DWORD GetTapeParameters(HANDLE, DWORD, PDWORD, PVOID); 
__attribute((__stdcall__)) DWORD GetTapePosition(HANDLE, DWORD, PDWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) DWORD GetTapeStatus(HANDLE); 


__attribute((__stdcall__)) UINT GetTempFileNameA(LPCSTR, LPCSTR, UINT, LPSTR); 
__attribute((__stdcall__)) UINT GetTempFileNameW(LPCWSTR, LPCWSTR, UINT, LPWSTR); 


__attribute((__stdcall__)) DWORD GetTempPathA(DWORD, LPSTR); 
__attribute((__stdcall__)) DWORD GetTempPathW(DWORD, LPWSTR); 

__attribute((__stdcall__)) BOOL GetThreadContext(HANDLE, LPCONTEXT); 
__attribute((__stdcall__)) int GetThreadPriority(HANDLE); 
__attribute((__stdcall__)) BOOL GetThreadPriorityBoost(HANDLE, PBOOL); 
__attribute((__stdcall__)) BOOL GetThreadSelectorEntry(HANDLE, DWORD, LPLDT_ENTRY); 
__attribute((__stdcall__)) BOOL GetThreadTimes(HANDLE, LPFILETIME, LPFILETIME, LPFILETIME, LPFILETIME); 

__attribute((__stdcall__)) DWORD GetTickCount(); 
__attribute((__stdcall__)) DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION); 
__attribute((__stdcall__)) BOOL GetTokenInformation(HANDLE, TOKEN_INFORMATION_CLASS, PVOID, DWORD, PDWORD); 



__attribute((__stdcall__)) BOOL GetUserNameA(LPSTR, PDWORD); 
__attribute((__stdcall__)) BOOL GetUserNameW(LPWSTR, PDWORD); 

__attribute((__stdcall__)) DWORD GetVersion(); 


__attribute((__stdcall__)) BOOL GetVersionExA(LPOSVERSIONINFOA); 
__attribute((__stdcall__)) BOOL GetVersionExW(LPOSVERSIONINFOW); 


__attribute((__stdcall__)) BOOL GetVolumeInformationA(LPCSTR, LPSTR, DWORD, PDWORD, PDWORD, PDWORD, LPSTR, DWORD); 

__attribute((__stdcall__)) BOOL GetVolumeInformationW(LPCWSTR, LPWSTR, DWORD, PDWORD, PDWORD, PDWORD, LPWSTR, DWORD); 



__attribute((__stdcall__)) UINT GetWindowsDirectoryA(LPSTR, UINT); 
__attribute((__stdcall__)) UINT GetWindowsDirectoryW(LPWSTR, UINT); 

__attribute((__stdcall__)) DWORD GetWindowThreadProcessId(HWND, PDWORD); 
__attribute((__stdcall__)) UINT GetWriteWatch(DWORD, PVOID, SIZE_T, PVOID *, PULONG_PTR, PULONG); 



__attribute((__stdcall__)) ATOM GlobalAddAtomA(LPCSTR); 
__attribute((__stdcall__)) ATOM GlobalAddAtomW(LPCWSTR); 

__attribute((__stdcall__)) HGLOBAL GlobalAlloc(UINT, DWORD); 
__attribute((__stdcall__)) SIZE_T GlobalCompact(DWORD); 
__attribute((__stdcall__)) ATOM GlobalDeleteAtom(ATOM); 




__attribute((__stdcall__)) ATOM GlobalFindAtomA(LPCSTR); 
__attribute((__stdcall__)) ATOM GlobalFindAtomW(LPCWSTR); 

__attribute((__stdcall__)) void GlobalFix(HGLOBAL); 
__attribute((__stdcall__)) UINT GlobalFlags(HGLOBAL); 
__attribute((__stdcall__)) HGLOBAL GlobalFree(HGLOBAL); 


__attribute((__stdcall__)) UINT GlobalGetAtomNameA(ATOM, LPSTR, int); 
__attribute((__stdcall__)) UINT GlobalGetAtomNameW(ATOM, LPWSTR, int); 

__attribute((__stdcall__)) HGLOBAL GlobalHandle(PCVOID); 
__attribute((__stdcall__)) LPVOID GlobalLock(HGLOBAL); 
__attribute((__stdcall__)) void GlobalMemoryStatus(LPMEMORYSTATUS); 
__attribute((__stdcall__)) HGLOBAL GlobalReAlloc(HGLOBAL, DWORD, UINT); 
__attribute((__stdcall__)) DWORD GlobalSize(HGLOBAL); 
__attribute((__stdcall__)) void GlobalUnfix(HGLOBAL); 
__attribute((__stdcall__)) BOOL GlobalUnlock(HGLOBAL); 
__attribute((__stdcall__)) BOOL GlobalUnWire(HGLOBAL); 
__attribute((__stdcall__)) PVOID GlobalWire(HGLOBAL); 




__attribute((__stdcall__)) PVOID HeapAlloc(HANDLE, DWORD, DWORD); 
__attribute((__stdcall__)) SIZE_T HeapCompact(HANDLE, DWORD); 
__attribute((__stdcall__)) HANDLE HeapCreate(DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL HeapDestroy(HANDLE); 
__attribute((__stdcall__)) BOOL HeapFree(HANDLE, DWORD, PVOID); 
__attribute((__stdcall__)) BOOL HeapLock(HANDLE); 
__attribute((__stdcall__)) PVOID HeapReAlloc(HANDLE, DWORD, PVOID, DWORD); 
__attribute((__stdcall__)) DWORD HeapSize(HANDLE, DWORD, PCVOID); 
__attribute((__stdcall__)) BOOL HeapUnlock(HANDLE); 
__attribute((__stdcall__)) BOOL HeapValidate(HANDLE, DWORD, PCVOID); 
__attribute((__stdcall__)) BOOL HeapWalk(HANDLE, LPPROCESS_HEAP_ENTRY); 
__attribute((__stdcall__)) BOOL ImpersonateLoggedOnUser(HANDLE); 
__attribute((__stdcall__)) BOOL ImpersonateNamedPipeClient(HANDLE); 
__attribute((__stdcall__)) BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL); 
__attribute((__stdcall__)) BOOL InitAtomTable(DWORD); 
__attribute((__stdcall__)) BOOL InitializeAcl(PACL, DWORD, DWORD); 
__attribute((__stdcall__)) void InitializeCriticalSection(LPCRITICAL_SECTION); 
__attribute((__stdcall__)) BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION, DWORD); 

__attribute((__stdcall__)) DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION, DWORD); 
__attribute((__stdcall__)) BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR, DWORD); 

__attribute((__stdcall__)) BOOL InitializeSid(PSID, PSID_IDENTIFIER_AUTHORITY, BYTE); 
# 2001 "d:\\mingw\\mingw\\include\\winbase.h" 3
__attribute((__stdcall__)) LONG InterlockedCompareExchange(volatile LONG *, LONG, LONG); 



__attribute((__stdcall__)) LONG InterlockedDecrement(volatile LONG *); 
__attribute((__stdcall__)) LONG InterlockedExchange(volatile LONG *, LONG); 



__attribute((__stdcall__)) LONG InterlockedExchangeAdd(volatile LONG *, LONG); 
# 2016
__attribute((__stdcall__)) LONG InterlockedIncrement(volatile LONG *); 
# 2025 "d:\\mingw\\mingw\\include\\winbase.h" 3
__attribute((__stdcall__)) BOOL IsBadCodePtr(FARPROC); 
__attribute((__stdcall__)) BOOL IsBadHugeReadPtr(PCVOID, UINT); 
__attribute((__stdcall__)) BOOL IsBadHugeWritePtr(PVOID, UINT); 
__attribute((__stdcall__)) BOOL IsBadReadPtr(PCVOID, UINT); 


__attribute((__stdcall__)) BOOL IsBadStringPtrA(LPCSTR, UINT); 
__attribute((__stdcall__)) BOOL IsBadStringPtrW(LPCWSTR, UINT); 

__attribute((__stdcall__)) BOOL IsBadWritePtr(PVOID, UINT); 
__attribute((__stdcall__)) BOOL IsDebuggerPresent(); 
__attribute((__stdcall__)) BOOL IsProcessorFeaturePresent(DWORD); 
__attribute((__stdcall__)) BOOL IsSystemResumeAutomatic(); 
__attribute((__stdcall__)) BOOL IsTextUnicode(PCVOID, int, LPINT); 
__attribute((__stdcall__)) BOOL IsValidAcl(PACL); 
__attribute((__stdcall__)) BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR); 
__attribute((__stdcall__)) BOOL IsValidSid(PSID); 

__attribute((__stdcall__)) void LeaveCriticalSection(LPCRITICAL_SECTION); 




__attribute((__stdcall__)) HINSTANCE LoadLibraryA(LPCSTR); 
__attribute((__stdcall__)) HINSTANCE LoadLibraryW(LPCWSTR); 


__attribute((__stdcall__)) HINSTANCE LoadLibraryExA(LPCSTR, HANDLE, DWORD); 
__attribute((__stdcall__)) HINSTANCE LoadLibraryExW(LPCWSTR, HANDLE, DWORD); 

__attribute((__stdcall__)) DWORD LoadModule(LPCSTR, PVOID); 
__attribute((__stdcall__)) HGLOBAL LoadResource(HINSTANCE, HRSRC); 
__attribute((__stdcall__)) HLOCAL LocalAlloc(UINT, SIZE_T); 
__attribute((__stdcall__)) SIZE_T LocalCompact(UINT); 
HLOCAL LocalDiscard(HLOCAL); 
__attribute((__stdcall__)) BOOL LocalFileTimeToFileTime(const FILETIME *, LPFILETIME); 
__attribute((__stdcall__)) UINT LocalFlags(HLOCAL); 
__attribute((__stdcall__)) HLOCAL LocalFree(HLOCAL); 
__attribute((__stdcall__)) HLOCAL LocalHandle(LPCVOID); 
__attribute((__stdcall__)) PVOID LocalLock(HLOCAL); 
__attribute((__stdcall__)) HLOCAL LocalReAlloc(HLOCAL, SIZE_T, UINT); 
__attribute((__stdcall__)) SIZE_T LocalShrink(HLOCAL, UINT); 
__attribute((__stdcall__)) UINT LocalSize(HLOCAL); 
__attribute((__stdcall__)) BOOL LocalUnlock(HLOCAL); 
__attribute((__stdcall__)) BOOL LockFile(HANDLE, DWORD, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL LockFileEx(HANDLE, DWORD, DWORD, DWORD, DWORD, LPOVERLAPPED); 

__attribute((__stdcall__)) PVOID LockResource(HGLOBAL); 




__attribute((__stdcall__)) BOOL LogonUserA(LPSTR, LPSTR, LPSTR, DWORD, DWORD, PHANDLE); 
__attribute((__stdcall__)) BOOL LogonUserW(LPWSTR, LPWSTR, LPWSTR, DWORD, DWORD, PHANDLE); 



__attribute((__stdcall__)) BOOL LookupAccountNameA(LPCSTR, LPCSTR, PSID, PDWORD, LPSTR, PDWORD, PSID_NAME_USE); 

__attribute((__stdcall__)) BOOL LookupAccountNameW(LPCWSTR, LPCWSTR, PSID, PDWORD, LPWSTR, PDWORD, PSID_NAME_USE); 



__attribute((__stdcall__)) BOOL LookupAccountSidA(LPCSTR, PSID, LPSTR, PDWORD, LPSTR, PDWORD, PSID_NAME_USE); 

__attribute((__stdcall__)) BOOL LookupAccountSidW(LPCWSTR, PSID, LPWSTR, PDWORD, LPWSTR, PDWORD, PSID_NAME_USE); 



__attribute((__stdcall__)) BOOL LookupPrivilegeDisplayNameA(LPCSTR, LPCSTR, LPSTR, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL LookupPrivilegeDisplayNameW(LPCWSTR, LPCWSTR, LPWSTR, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL LookupPrivilegeNameA(LPCSTR, PLUID, LPSTR, PDWORD); 
__attribute((__stdcall__)) BOOL LookupPrivilegeNameW(LPCWSTR, PLUID, LPWSTR, PDWORD); 


__attribute((__stdcall__)) BOOL LookupPrivilegeValueA(LPCSTR, LPCSTR, PLUID); 
__attribute((__stdcall__)) BOOL LookupPrivilegeValueW(LPCWSTR, LPCWSTR, PLUID); 


__attribute((__stdcall__)) LPSTR lstrcatA(LPSTR, LPCSTR); 
__attribute((__stdcall__)) LPWSTR lstrcatW(LPWSTR, LPCWSTR); 


__attribute((__stdcall__)) int lstrcmpA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) int lstrcmpW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) int lstrcmpiA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) int lstrcmpiW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) LPSTR lstrcpyA(LPSTR, LPCSTR); 
__attribute((__stdcall__)) LPWSTR lstrcpyW(LPWSTR, LPCWSTR); 


__attribute((__stdcall__)) LPSTR lstrcpynA(LPSTR, LPCSTR, int); 
__attribute((__stdcall__)) LPWSTR lstrcpynW(LPWSTR, LPCWSTR, int); 


__attribute((__stdcall__)) int lstrlenA(LPCSTR); 
__attribute((__stdcall__)) int lstrlenW(LPCWSTR); 

__attribute((__stdcall__)) BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR, PDWORD, PACL, PDWORD, PACL, PDWORD, PSID, PDWORD, PSID, PDWORD); 
# 2138
__attribute((__stdcall__)) BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR, PDWORD); 

__attribute((__stdcall__)) void MapGenericMask(PDWORD, PGENERIC_MAPPING); 
__attribute((__stdcall__)) PVOID MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) PVOID MapViewOfFileEx(HANDLE, DWORD, DWORD, DWORD, DWORD, PVOID); 



__attribute((__stdcall__)) BOOL MoveFileA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL MoveFileW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) BOOL MoveFileExA(LPCSTR, LPCSTR, DWORD); 
__attribute((__stdcall__)) BOOL MoveFileExW(LPCWSTR, LPCWSTR, DWORD); 

__attribute((__stdcall__)) int MulDiv(int, int, int); 
__attribute((__stdcall__)) BOOL NotifyChangeEventLog(HANDLE, HANDLE); 


__attribute((__stdcall__)) BOOL ObjectCloseAuditAlarmA(LPCSTR, PVOID, BOOL); 
__attribute((__stdcall__)) BOOL ObjectCloseAuditAlarmW(LPCWSTR, PVOID, BOOL); 


__attribute((__stdcall__)) BOOL ObjectDeleteAuditAlarmA(LPCSTR, PVOID, BOOL); 
__attribute((__stdcall__)) BOOL ObjectDeleteAuditAlarmW(LPCWSTR, PVOID, BOOL); 


__attribute((__stdcall__)) BOOL ObjectOpenAuditAlarmA(LPCSTR, PVOID, LPSTR, LPSTR, PSECURITY_DESCRIPTOR, HANDLE, DWORD, DWORD, PPRIVILEGE_SET, BOOL, BOOL, PBOOL); 



__attribute((__stdcall__)) BOOL ObjectOpenAuditAlarmW(LPCWSTR, PVOID, LPWSTR, LPWSTR, PSECURITY_DESCRIPTOR, HANDLE, DWORD, DWORD, PPRIVILEGE_SET, BOOL, BOOL, PBOOL); 
# 2175
__attribute((__stdcall__)) BOOL ObjectPrivilegeAuditAlarmA(LPCSTR, PVOID, HANDLE, DWORD, PPRIVILEGE_SET, BOOL); 

__attribute((__stdcall__)) BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR, PVOID, HANDLE, DWORD, PPRIVILEGE_SET, BOOL); 



__attribute((__stdcall__)) HANDLE OpenBackupEventLogA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenBackupEventLogW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) HANDLE OpenEventA(DWORD, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenEventW(DWORD, BOOL, LPCWSTR); 


__attribute((__stdcall__)) HANDLE OpenEventLogA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenEventLogW(LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) HFILE OpenFile(LPCSTR, LPOFSTRUCT, UINT); 


__attribute((__stdcall__)) HANDLE OpenFileMappingA(DWORD, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenFileMappingW(DWORD, BOOL, LPCWSTR); 


__attribute((__stdcall__)) HANDLE OpenMutexA(DWORD, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenMutexW(DWORD, BOOL, LPCWSTR); 

__attribute((__stdcall__)) HANDLE OpenProcess(DWORD, BOOL, DWORD); 
__attribute((__stdcall__)) BOOL OpenProcessToken(HANDLE, DWORD, PHANDLE); 


__attribute((__stdcall__)) HANDLE OpenSemaphoreA(DWORD, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenSemaphoreW(DWORD, BOOL, LPCWSTR); 

__attribute((__stdcall__)) BOOL OpenThreadToken(HANDLE, DWORD, BOOL, PHANDLE); 



__attribute((__stdcall__)) HANDLE OpenWaitableTimerA(DWORD, BOOL, LPCSTR); 
__attribute((__stdcall__)) HANDLE OpenWaitableTimerW(DWORD, BOOL, LPCWSTR); 


__attribute((__stdcall__)) void OutputDebugStringA(LPCSTR); 
__attribute((__stdcall__)) void OutputDebugStringW(LPCWSTR); 

__attribute((__stdcall__)) BOOL PeekNamedPipe(HANDLE, PVOID, DWORD, PDWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL PostQueuedCompletionStatus(HANDLE, DWORD, ULONG_PTR, LPOVERLAPPED); 

__attribute((__stdcall__)) DWORD PrepareTape(HANDLE, DWORD, BOOL); 
__attribute((__stdcall__)) BOOL PrivilegeCheck(HANDLE, PPRIVILEGE_SET, PBOOL); 


__attribute((__stdcall__)) BOOL PrivilegedServiceAuditAlarmA(LPCSTR, LPCSTR, HANDLE, PPRIVILEGE_SET, BOOL); 

__attribute((__stdcall__)) BOOL PrivilegedServiceAuditAlarmW(LPCWSTR, LPCWSTR, HANDLE, PPRIVILEGE_SET, BOOL); 


__attribute((__stdcall__)) BOOL PulseEvent(HANDLE); 
__attribute((__stdcall__)) BOOL PurgeComm(HANDLE, DWORD); 


__attribute((__stdcall__)) DWORD QueryDosDeviceA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD QueryDosDeviceW(LPCWSTR, LPWSTR, DWORD); 
__attribute((__stdcall__)) BOOL QueryPerformanceCounter(PLARGE_INTEGER); 
__attribute((__stdcall__)) BOOL QueryPerformanceFrequency(PLARGE_INTEGER); 
__attribute((__stdcall__)) DWORD QueueUserAPC(PAPCFUNC, HANDLE, ULONG_PTR); 

__attribute((__stdcall__)) void RaiseException(DWORD, DWORD, DWORD, const DWORD *); 
__attribute((__stdcall__)) BOOL ReadDirectoryChangesW(HANDLE, PVOID, DWORD, BOOL, DWORD, PDWORD, LPOVERLAPPED, LPOVERLAPPED_COMPLETION_ROUTINE); 
# 2250
__attribute((__stdcall__)) BOOL ReadEventLogA(HANDLE, DWORD, DWORD, PVOID, DWORD, DWORD *, DWORD *); 

__attribute((__stdcall__)) BOOL ReadEventLogW(HANDLE, DWORD, DWORD, PVOID, DWORD, DWORD *, DWORD *); 


__attribute((__stdcall__)) BOOL ReadFile(HANDLE, PVOID, DWORD, PDWORD, LPOVERLAPPED); 
__attribute((__stdcall__)) BOOL ReadFileEx(HANDLE, PVOID, DWORD, LPOVERLAPPED, LPOVERLAPPED_COMPLETION_ROUTINE); 

__attribute((__stdcall__)) BOOL ReadFileScatter(HANDLE, FILE_SEGMENT_ELEMENT *, DWORD, LPDWORD, LPOVERLAPPED); 

__attribute((__stdcall__)) BOOL ReadProcessMemory(HANDLE, PCVOID, PVOID, DWORD, PDWORD); 


__attribute((__stdcall__)) HANDLE RegisterEventSourceA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HANDLE RegisterEventSourceW(LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) BOOL ReleaseMutex(HANDLE); 
__attribute((__stdcall__)) BOOL ReleaseSemaphore(HANDLE, LONG, LPLONG); 


__attribute((__stdcall__)) BOOL RemoveDirectoryA(LPCSTR); 
__attribute((__stdcall__)) BOOL RemoveDirectoryW(LPCWSTR); 


__attribute((__stdcall__)) BOOL ReportEventA(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCSTR *, PVOID); 

__attribute((__stdcall__)) BOOL ReportEventW(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCWSTR *, PVOID); 
# 2282
__attribute((__stdcall__)) BOOL ResetEvent(HANDLE); 


__attribute((__stdcall__)) UINT ResetWriteWatch(LPVOID, SIZE_T); 
__attribute((__stdcall__)) DWORD ResumeThread(HANDLE); 
__attribute((__stdcall__)) BOOL RevertToSelf(); 


__attribute((__stdcall__)) DWORD SearchPathA(LPCSTR, LPCSTR, LPCSTR, DWORD, LPSTR, LPSTR *); 

__attribute((__stdcall__)) DWORD SearchPathW(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, LPWSTR, LPWSTR *); 


__attribute((__stdcall__)) BOOL SetAclInformation(PACL, PVOID, DWORD, ACL_INFORMATION_CLASS); 

__attribute((__stdcall__)) BOOL SetCommBreak(HANDLE); 
__attribute((__stdcall__)) BOOL SetCommConfig(HANDLE, LPCOMMCONFIG, DWORD); 
__attribute((__stdcall__)) BOOL SetCommMask(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetCommState(HANDLE, LPDCB); 
__attribute((__stdcall__)) BOOL SetCommTimeouts(HANDLE, LPCOMMTIMEOUTS); 


__attribute((__stdcall__)) BOOL SetComputerNameA(LPCSTR); 
__attribute((__stdcall__)) BOOL SetComputerNameW(LPCWSTR); 


__attribute((__stdcall__)) BOOL SetCurrentDirectoryA(LPCSTR); 
__attribute((__stdcall__)) BOOL SetCurrentDirectoryW(LPCWSTR); 


__attribute((__stdcall__)) BOOL SetDefaultCommConfigA(LPCSTR, LPCOMMCONFIG, DWORD); 
__attribute((__stdcall__)) BOOL SetDefaultCommConfigW(LPCWSTR, LPCOMMCONFIG, DWORD); 

__attribute((__stdcall__)) BOOL SetEndOfFile(HANDLE); 


__attribute((__stdcall__)) BOOL SetEnvironmentVariableA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL SetEnvironmentVariableW(LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) UINT SetErrorMode(UINT); 




__attribute((__stdcall__)) BOOL SetEvent(HANDLE); 


__attribute((__stdcall__)) void SetFileApisToANSI(); 
__attribute((__stdcall__)) void SetFileApisToOEM(); 


__attribute((__stdcall__)) BOOL SetFileAttributesA(LPCSTR, DWORD); 
__attribute((__stdcall__)) BOOL SetFileAttributesW(LPCWSTR, DWORD); 

__attribute((__stdcall__)) DWORD SetFilePointer(HANDLE, LONG, PLONG, DWORD); 
__attribute((__stdcall__)) BOOL SetFilePointerEx(HANDLE, LARGE_INTEGER, PLARGE_INTEGER, DWORD); 



__attribute((__stdcall__)) BOOL SetFileSecurityA(LPCSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 

__attribute((__stdcall__)) BOOL SetFileSecurityW(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 


__attribute((__stdcall__)) BOOL SetFileTime(HANDLE, const FILETIME *, const FILETIME *, const FILETIME *); 


__attribute((__stdcall__)) UINT SetHandleCount(UINT); 
__attribute((__stdcall__)) BOOL SetHandleInformation(HANDLE, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL SetKernelObjectSecurity(HANDLE, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 

__attribute((__stdcall__)) void SetLastError(DWORD); 
__attribute((__stdcall__)) void SetLastErrorEx(DWORD, DWORD); 
__attribute((__stdcall__)) BOOL SetLocalTime(const SYSTEMTIME *); 
__attribute((__stdcall__)) BOOL SetMailslotInfo(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetNamedPipeHandleState(HANDLE, PDWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL SetPriorityClass(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, PSECURITY_DESCRIPTOR *, PGENERIC_MAPPING, HANDLE); 



__attribute((__stdcall__)) BOOL SetProcessAffinityMask(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetProcessPriorityBoost(HANDLE, BOOL); 
__attribute((__stdcall__)) BOOL SetProcessShutdownParameters(DWORD, DWORD); 
__attribute((__stdcall__)) BOOL SetProcessWorkingSetSize(HANDLE, SIZE_T, SIZE_T); 
__attribute((__stdcall__)) BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR, SECURITY_DESCRIPTOR_CONTROL, SECURITY_DESCRIPTOR_CONTROL); 


__attribute((__stdcall__)) BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR, BOOL, PACL, BOOL); 

__attribute((__stdcall__)) BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR, PSID, BOOL); 

__attribute((__stdcall__)) BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR, PSID, BOOL); 

__attribute((__stdcall__)) BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR, BOOL, PACL, BOOL); 

__attribute((__stdcall__)) BOOL SetStdHandle(DWORD, HANDLE); 



__attribute((__stdcall__)) BOOL SetSystemPowerState(BOOL, BOOL); 
__attribute((__stdcall__)) BOOL SetSystemTime(const SYSTEMTIME *); 
__attribute((__stdcall__)) BOOL SetSystemTimeAdjustment(DWORD, BOOL); 
__attribute((__stdcall__)) DWORD SetTapeParameters(HANDLE, DWORD, PVOID); 
__attribute((__stdcall__)) DWORD SetTapePosition(HANDLE, DWORD, DWORD, DWORD, DWORD, BOOL); 

__attribute((__stdcall__)) DWORD SetThreadAffinityMask(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetThreadContext(HANDLE, const CONTEXT *); 

__attribute((__stdcall__)) DWORD SetThreadIdealProcessor(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL SetThreadPriority(HANDLE, int); 
__attribute((__stdcall__)) BOOL SetThreadPriorityBoost(HANDLE, BOOL); 
__attribute((__stdcall__)) BOOL SetThreadToken(PHANDLE, HANDLE); 
__attribute((__stdcall__)) BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *); 
__attribute((__stdcall__)) BOOL SetTokenInformation(HANDLE, TOKEN_INFORMATION_CLASS, PVOID, DWORD); 

__attribute((__stdcall__)) LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER); 

__attribute((__stdcall__)) BOOL SetupComm(HANDLE, DWORD, DWORD); 


__attribute((__stdcall__)) BOOL SetVolumeLabelA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL SetVolumeLabelW(LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) BOOL SetWaitableTimer(HANDLE, const LARGE_INTEGER *, LONG, PTIMERAPCROUTINE, PVOID, BOOL); 

__attribute((__stdcall__)) DWORD SignalObjectAndWait(HANDLE, HANDLE, DWORD, BOOL); 
__attribute((__stdcall__)) DWORD SizeofResource(HINSTANCE, HRSRC); 
__attribute((__stdcall__)) void Sleep(DWORD); 
__attribute((__stdcall__)) DWORD SleepEx(DWORD, BOOL); 
__attribute((__stdcall__)) DWORD SuspendThread(HANDLE); 
__attribute((__stdcall__)) void SwitchToFiber(PVOID); 
__attribute((__stdcall__)) BOOL SwitchToThread(); 
__attribute((__stdcall__)) BOOL SystemTimeToFileTime(const SYSTEMTIME *, LPFILETIME); 
__attribute((__stdcall__)) BOOL SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION, LPSYSTEMTIME, LPSYSTEMTIME); 


__attribute((__stdcall__)) BOOL TerminateProcess(HANDLE, UINT); 
__attribute((__stdcall__)) BOOL TerminateThread(HANDLE, DWORD); 
__attribute((__stdcall__)) DWORD TlsAlloc(); 
__attribute((__stdcall__)) BOOL TlsFree(DWORD); 
__attribute((__stdcall__)) PVOID TlsGetValue(DWORD); 
__attribute((__stdcall__)) BOOL TlsSetValue(DWORD, PVOID); 
__attribute((__stdcall__)) BOOL TransactNamedPipe(HANDLE, PVOID, DWORD, PVOID, DWORD, PDWORD, LPOVERLAPPED); 

__attribute((__stdcall__)) BOOL TransmitCommChar(HANDLE, char); 
__attribute((__stdcall__)) BOOL TryEnterCriticalSection(LPCRITICAL_SECTION); 
__attribute((__stdcall__)) LONG UnhandledExceptionFilter(LPEXCEPTION_POINTERS); 
__attribute((__stdcall__)) BOOL UnlockFile(HANDLE, DWORD, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL UnlockFileEx(HANDLE, DWORD, DWORD, DWORD, LPOVERLAPPED); 




__attribute((__stdcall__)) BOOL UnmapViewOfFile(LPCVOID); 


__attribute((__stdcall__)) BOOL UpdateResourceA(HANDLE, LPCSTR, LPCSTR, WORD, PVOID, DWORD); 

__attribute((__stdcall__)) BOOL UpdateResourceW(HANDLE, LPCWSTR, LPCWSTR, WORD, PVOID, DWORD); 



__attribute((__stdcall__)) BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA, DWORD, DWORDLONG); 

__attribute((__stdcall__)) BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW, DWORD, DWORDLONG); 


__attribute((__stdcall__)) PVOID VirtualAlloc(PVOID, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) PVOID VirtualAllocEx(HANDLE, PVOID, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL VirtualFree(PVOID, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL VirtualFreeEx(HANDLE, PVOID, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL VirtualLock(PVOID, DWORD); 
__attribute((__stdcall__)) BOOL VirtualProtect(PVOID, DWORD, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL VirtualProtectEx(HANDLE, PVOID, DWORD, DWORD, PDWORD); 
__attribute((__stdcall__)) DWORD VirtualQuery(LPCVOID, PMEMORY_BASIC_INFORMATION, DWORD); 
__attribute((__stdcall__)) DWORD VirtualQueryEx(HANDLE, LPCVOID, PMEMORY_BASIC_INFORMATION, DWORD); 

__attribute((__stdcall__)) BOOL VirtualUnlock(PVOID, DWORD); 
__attribute((__stdcall__)) BOOL WaitCommEvent(HANDLE, PDWORD, LPOVERLAPPED); 
__attribute((__stdcall__)) BOOL WaitForDebugEvent(LPDEBUG_EVENT, DWORD); 
__attribute((__stdcall__)) DWORD WaitForMultipleObjects(DWORD, const HANDLE *, BOOL, DWORD); 

__attribute((__stdcall__)) DWORD WaitForMultipleObjectsEx(DWORD, const HANDLE *, BOOL, DWORD, BOOL); 

__attribute((__stdcall__)) DWORD WaitForSingleObject(HANDLE, DWORD); 
__attribute((__stdcall__)) DWORD WaitForSingleObjectEx(HANDLE, DWORD, BOOL); 


__attribute((__stdcall__)) BOOL WaitNamedPipeA(LPCSTR, DWORD); 
__attribute((__stdcall__)) BOOL WaitNamedPipeW(LPCWSTR, DWORD); 

__attribute((__stdcall__)) BOOL WinLoadTrustProvider(GUID *); 
__attribute((__stdcall__)) BOOL WriteFile(HANDLE, PCVOID, DWORD, PDWORD, LPOVERLAPPED); 
__attribute((__stdcall__)) BOOL WriteFileEx(HANDLE, PCVOID, DWORD, LPOVERLAPPED, LPOVERLAPPED_COMPLETION_ROUTINE); 

__attribute((__stdcall__)) BOOL WriteFileGather(HANDLE, FILE_SEGMENT_ELEMENT *, DWORD, LPDWORD, LPOVERLAPPED); 



__attribute((__stdcall__)) BOOL WritePrivateProfileSectionA(LPCSTR, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL WritePrivateProfileSectionW(LPCWSTR, LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) BOOL WritePrivateProfileStringA(LPCSTR, LPCSTR, LPCSTR, LPCSTR); 

__attribute((__stdcall__)) BOOL WritePrivateProfileStringW(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR); 



__attribute((__stdcall__)) BOOL WritePrivateProfileStructA(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR); 

__attribute((__stdcall__)) BOOL WritePrivateProfileStructW(LPCWSTR, LPCWSTR, LPVOID, UINT, LPCWSTR); 


__attribute((__stdcall__)) BOOL WriteProcessMemory(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T *); 



__attribute((__stdcall__)) BOOL WriteProfileSectionA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL WriteProfileSectionW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) BOOL WriteProfileStringA(LPCSTR, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL WriteProfileStringW(LPCWSTR, LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) DWORD WriteTapemark(HANDLE, DWORD, DWORD, BOOL); 
# 2516
__attribute((__stdcall__)) BOOL ConvertFiberToThread(); 
__attribute((__stdcall__)) LPVOID CreateFiberEx(SIZE_T, SIZE_T, DWORD, LPFIBER_START_ROUTINE, LPVOID); 
# 2525
typedef DWORD EXECUTION_STATE; 


__attribute((__stdcall__)) DWORD GetLongPathNameA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD GetLongPathNameW(LPCWSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE); 
# 2537
__attribute((__stdcall__)) HANDLE OpenThread(DWORD, BOOL, DWORD); 
# 2553
typedef 
# 2543
struct _MEMORYSTATUSEX { 
DWORD dwLength; 
DWORD dwMemoryLoad; 
DWORDLONG ullTotalPhys; 
DWORDLONG ullAvailPhys; 
DWORDLONG ullTotalPageFile; 
DWORDLONG ullAvailPageFile; 
DWORDLONG ullTotalVirtual; 
DWORDLONG ullAvailVirtual; 
DWORDLONG ullAvailExtendedVirtual; 
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX; 
# 2565
typedef 
# 2555
enum _COMPUTER_NAME_FORMAT { 
ComputerNameNetBIOS, 
ComputerNameDnsHostname, 
ComputerNameDnsDomain, 
ComputerNameDnsFullyQualified, 
ComputerNamePhysicalNetBIOS, 
ComputerNamePhysicalDnsHostname, 
ComputerNamePhysicalDnsDomain, 
ComputerNamePhysicalDnsFullyQualified, 
ComputerNameMax
} COMPUTER_NAME_FORMAT; 

typedef void ( __attribute((__stdcall__))*WAITORTIMERCALLBACK)(PVOID, BOOLEAN) ; 

__attribute((__stdcall__)) BOOL AddAccessAllowedAceEx(PACL, DWORD, DWORD, DWORD, PSID); 
__attribute((__stdcall__)) BOOL AddAccessDeniedAceEx(PACL, DWORD, DWORD, DWORD, PSID); 
__attribute((__stdcall__)) PVOID AddVectoredExceptionHandler(ULONG, PVECTORED_EXCEPTION_HANDLER); 


__attribute((__stdcall__)) BOOL ChangeTimerQueueTimer(HANDLE, HANDLE, ULONG, ULONG); 
__attribute((__stdcall__)) BOOL CheckTokenMembership(HANDLE, PSID, PBOOL); 


__attribute((__stdcall__)) BOOL CreateHardLinkA(LPCSTR, LPCSTR, LPSECURITY_ATTRIBUTES); 
__attribute((__stdcall__)) BOOL CreateHardLinkW(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES); 



__attribute((__stdcall__)) HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES, LPCSTR); 
__attribute((__stdcall__)) HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES, LPCWSTR); 

__attribute((__stdcall__)) BOOL TerminateJobObject(HANDLE, UINT); 
__attribute((__stdcall__)) BOOL AssignProcessToJobObject(HANDLE, HANDLE); 

__attribute((__stdcall__)) BOOL SetInformationJobObject(HANDLE, JOBOBJECTINFOCLASS, LPVOID, DWORD); 

__attribute((__stdcall__)) BOOL QueryInformationJobObject(HANDLE, JOBOBJECTINFOCLASS, LPVOID, DWORD, LPDWORD); 


__attribute((__stdcall__)) BOOL CreateProcessWithLogonW(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, LPCWSTR, LPWSTR, DWORD, LPVOID, LPCWSTR, LPSTARTUPINFOW, LPPROCESS_INFORMATION); 
# 2601
__attribute((__stdcall__)) BOOL CreateRestrictedToken(HANDLE, DWORD, DWORD, PSID_AND_ATTRIBUTES, DWORD, PLUID_AND_ATTRIBUTES, DWORD, PSID_AND_ATTRIBUTES, PHANDLE); 
# 2610
__attribute((__stdcall__)) HANDLE CreateTimerQueue(); 
__attribute((__stdcall__)) BOOL CreateTimerQueueTimer(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, DWORD, DWORD, ULONG); 


__attribute((__stdcall__)) BOOL DeleteTimerQueue(HANDLE); 
__attribute((__stdcall__)) BOOL DeleteTimerQueueEx(HANDLE, HANDLE); 
__attribute((__stdcall__)) BOOL DeleteTimerQueueTimer(HANDLE, HANDLE, HANDLE); 


__attribute((__stdcall__)) BOOL DeleteVolumeMountPointA(LPCSTR); 
__attribute((__stdcall__)) BOOL DeleteVolumeMountPointW(LPCWSTR); 


__attribute((__stdcall__)) BOOL DnsHostnameToComputerNameA(LPCSTR, LPSTR, LPDWORD); 
__attribute((__stdcall__)) BOOL DnsHostnameToComputerNameW(LPCWSTR, LPWSTR, LPDWORD); 


__attribute((__stdcall__)) HANDLE FindFirstVolumeA(LPCSTR, DWORD); 
__attribute((__stdcall__)) HANDLE FindFirstVolumeW(LPCWSTR, DWORD); 


__attribute((__stdcall__)) HANDLE FindFirstVolumeMountPointA(LPSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) HANDLE FindFirstVolumeMountPointW(LPWSTR, LPWSTR, DWORD); 


__attribute((__stdcall__)) BOOL FindNextVolumeA(HANDLE, LPCSTR, DWORD); 
__attribute((__stdcall__)) BOOL FindNextVolumeW(HANDLE, LPWSTR, DWORD); 


__attribute((__stdcall__)) BOOL FindNextVolumeMountPointA(HANDLE, LPSTR, DWORD); 
__attribute((__stdcall__)) BOOL FindNextVolumeMountPointW(HANDLE, LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL FindVolumeClose(HANDLE); 
__attribute((__stdcall__)) BOOL FindVolumeMountPointClose(HANDLE); 


__attribute((__stdcall__)) BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT, LPSTR, LPDWORD); 

__attribute((__stdcall__)) BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT, LPWSTR, LPDWORD); 


__attribute((__stdcall__)) BOOL GetFileSizeEx(HANDLE, PLARGE_INTEGER); 
__attribute((__stdcall__)) BOOL GetProcessIoCounters(HANDLE, PIO_COUNTERS); 


__attribute((__stdcall__)) UINT GetSystemWindowsDirectoryA(LPSTR, UINT); 
__attribute((__stdcall__)) UINT GetSystemWindowsDirectoryW(LPWSTR, UINT); 


__attribute((__stdcall__)) BOOL GetVolumeNameForVolumeMountPointA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR, LPWSTR, DWORD); 



__attribute((__stdcall__)) BOOL GetVolumePathNameA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) BOOL GetVolumePathNameW(LPCWSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX); 

__attribute((__stdcall__)) BOOL IsTokenRestricted(HANDLE); 


__attribute((__stdcall__)) BOOL MoveFileWithProgressA(LPCSTR, LPCSTR, LPPROGRESS_ROUTINE, LPVOID, DWORD); 

__attribute((__stdcall__)) BOOL MoveFileWithProgressW(LPCWSTR, LPCWSTR, LPPROGRESS_ROUTINE, LPVOID, DWORD); 


__attribute((__stdcall__)) BOOL ProcessIdToSessionId(DWORD, DWORD *); 

__attribute((__stdcall__)) BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE, PVOID, ULONG); 

__attribute((__stdcall__)) BOOL RegisterWaitForSingleObject(PHANDLE, HANDLE, WAITORTIMERCALLBACK, PVOID, ULONG, ULONG); 

__attribute((__stdcall__)) HANDLE RegisterWaitForSingleObjectEx(HANDLE, WAITORTIMERCALLBACK, PVOID, ULONG, ULONG); 

__attribute((__stdcall__)) ULONG RemoveVectoredExceptionHandler(PVOID); 


__attribute((__stdcall__)) BOOL ReplaceFileA(LPCSTR, LPCSTR, LPCSTR, DWORD, LPVOID, LPVOID); 

__attribute((__stdcall__)) BOOL ReplaceFileW(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, LPVOID, LPVOID); 




__attribute((__stdcall__)) BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT, LPCSTR); 
__attribute((__stdcall__)) BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT, LPCWSTR); 


__attribute((__stdcall__)) BOOL SetVolumeMountPointA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) BOOL SetVolumeMountPointW(LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) BOOL UnregisterWait(HANDLE); 
__attribute((__stdcall__)) BOOL UnregisterWaitEx(HANDLE, HANDLE); 

__attribute((__stdcall__)) BOOL AllocateUserPhysicalPages(HANDLE, PULONG_PTR, PULONG_PTR); 


__attribute((__stdcall__)) BOOL FreeUserPhysicalPages(HANDLE, PULONG_PTR, PULONG_PTR); 

__attribute((__stdcall__)) BOOL MapUserPhysicalPages(PVOID, ULONG_PTR, PULONG_PTR); 
__attribute((__stdcall__)) BOOL MapUserPhysicalPagesScatter(PVOID *, ULONG_PTR, PULONG_PTR); 
# 3054 "d:\\mingw\\mingw\\include\\winbase.h" 3
}
# 42 "d:\\mingw\\mingw\\include\\wingdi.h" 3
extern "C" {
# 55 "d:\\mingw\\mingw\\include\\wingdi.h" 3
typedef BYTE BCHAR; 
# 1401 "d:\\mingw\\mingw\\include\\wingdi.h" 3
typedef 
# 1397
struct _ABC { 
int abcA; 
UINT abcB; 
int abcC; 
} ABC, *LPABC; 
# 1407
typedef 
# 1403
struct _ABCFLOAT { 
FLOAT abcfA; 
FLOAT abcfB; 
FLOAT abcfC; 
} ABCFLOAT, *LPABCFLOAT; 
# 1417
typedef 
# 1409
struct tagBITMAP { 
LONG bmType; 
LONG bmWidth; 
LONG bmHeight; 
LONG bmWidthBytes; 
WORD bmPlanes; 
WORD bmBitsPixel; 
LPVOID bmBits; 
} BITMAP, *PBITMAP, *LPBITMAP; 
# 1425
typedef 
# 1419
struct tagBITMAPCOREHEADER { 
DWORD bcSize; 
WORD bcWidth; 
WORD bcHeight; 
WORD bcPlanes; 
WORD bcBitCount; 
} BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER; 

#pragma pack ( push, 1 )





typedef 
# 1429
struct tagRGBTRIPLE { 
BYTE rgbtBlue; 
BYTE rgbtGreen; 
BYTE rgbtRed; 
} RGBTRIPLE, *LPRGBTRIPLE; 

#pragma pack ( 2 )
# 1443
typedef 
# 1437
struct tagBITMAPFILEHEADER { 
WORD bfType; 
DWORD bfSize; 
WORD bfReserved1; 
WORD bfReserved2; 
DWORD bfOffBits; 
} BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER; 

#pragma pack ( pop )




typedef 
# 1447
struct _BITMAPCOREINFO { 
BITMAPCOREHEADER bmciHeader; 
RGBTRIPLE bmciColors[1]; 
} BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO; 
# 1464
typedef 
# 1452
struct tagBITMAPINFOHEADE { 
DWORD biSize; 
LONG biWidth; 
LONG biHeight; 
WORD biPlanes; 
WORD biBitCount; 
DWORD biCompression; 
DWORD biSizeImage; 
LONG biXPelsPerMeter; 
LONG biYPelsPerMeter; 
DWORD biClrUsed; 
DWORD biClrImportant; 
} BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER; 
# 1471
typedef 
# 1466
struct tagRGBQUAD { 
BYTE rgbBlue; 
BYTE rgbGreen; 
BYTE rgbRed; 
BYTE rgbReserved; 
} RGBQUAD, *LPRGBQUAD; 




typedef 
# 1473
struct tagBITMAPINFO { 
BITMAPINFOHEADER bmiHeader; 
RGBQUAD bmiColors[1]; 
} BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO; 
typedef long FXPT16DOT16, *LPFXPT16DOT16; 
typedef long FXPT2DOT30, *LPFXPT2DOT30; 
# 1484
typedef 
# 1480
struct tagCIEXYZ { 
FXPT2DOT30 ciexyzX; 
FXPT2DOT30 ciexyzY; 
FXPT2DOT30 ciexyzZ; 
} CIEXYZ, *LPCIEXYZ; 
# 1490
typedef 
# 1486
struct tagCIEXYZTRIPLE { 
CIEXYZ ciexyzRed; 
CIEXYZ ciexyzGreen; 
CIEXYZ ciexyzBlue; 
} CIEXYZTRIPLE, *LPCIEXYZTRIPLE; 
# 1513
typedef 
# 1493
struct { DWORD bV4Size; 
LONG bV4Width; 
LONG bV4Height; 
WORD bV4Planes; 
WORD bV4BitCount; 
DWORD bV4V4Compression; 
DWORD bV4SizeImage; 
LONG bV4XPelsPerMeter; 
LONG bV4YPelsPerMeter; 
DWORD bV4ClrUsed; 
DWORD bV4ClrImportant; 
DWORD bV4RedMask; 
DWORD bV4GreenMask; 
DWORD bV4BlueMask; 
DWORD bV4AlphaMask; 
DWORD bV4CSType; 
CIEXYZTRIPLE bV4Endpoints; 
DWORD bV4GammaRed; 
DWORD bV4GammaGreen; 
DWORD bV4GammaBlue; 
} BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER; 
# 1540
typedef 
# 1516
struct { DWORD bV5Size; 
LONG bV5Width; 
LONG bV5Height; 
WORD bV5Planes; 
WORD bV5BitCount; 
DWORD bV5Compression; 
DWORD bV5SizeImage; 
LONG bV5XPelsPerMeter; 
LONG bV5YPelsPerMeter; 
DWORD bV5ClrUsed; 
DWORD bV5ClrImportant; 
DWORD bV5RedMask; 
DWORD bV5GreenMask; 
DWORD bV5BlueMask; 
DWORD bV5AlphaMask; 
DWORD bV5CSType; 
CIEXYZTRIPLE bV5Endpoints; 
DWORD bV5GammaRed; 
DWORD bV5GammaGreen; 
DWORD bV5GammaBlue; 
DWORD bV5Intent; 
DWORD bV5ProfileData; 
DWORD bV5ProfileSize; 
DWORD bV5Reserved; 
} BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER; 




typedef 
# 1542
struct tagFONTSIGNATURE { 
DWORD fsUsb[4]; 
DWORD fsCsb[2]; 
} FONTSIGNATURE, *LPFONTSIGNATURE; 
# 1551
typedef 
# 1548
struct { UINT ciCharset; 
UINT ciACP; 
FONTSIGNATURE fs; 
} CHARSETINFO, *LPCHARSETINFO; 
# 1566
typedef 
# 1553
struct tagCOLORADJUSTMENT { 
WORD caSize; 
WORD caFlags; 
WORD caIlluminantIndex; 
WORD caRedGamma; 
WORD caGreenGamma; 
WORD caBlueGamma; 
WORD caReferenceBlack; 
WORD caReferenceWhite; 
SHORT caContrast; 
SHORT caBrightness; 
SHORT caColorfulness; 
SHORT caRedGreenTint; 
} COLORADJUSTMENT, *LPCOLORADJUSTMENT; 
# 1627
typedef 
# 1568
struct _devicemodeA { 
BYTE dmDeviceName[32]; 
WORD dmSpecVersion; 
WORD dmDriverVersion; 
WORD dmSize; 
WORD dmDriverExtra; 
DWORD dmFields; 

union { 
struct { short dmOrientation; 
short dmPaperSize; 
short dmPaperLength; 
short dmPaperWidth; 
short dmScale; 
short dmCopies; 
short dmDefaultSource; 
short dmPrintQuality; 
}; 

struct { POINTL dmPosition; 
DWORD dmDisplayOrientation; 
DWORD dmDisplayFixedOutput; 
}; 
}; 

short dmColor; 
short dmDuplex; 
short dmYResolution; 
short dmTTOption; 
short dmCollate; 
BYTE dmFormName[32]; 
WORD dmLogPixels; 
DWORD dmBitsPerPel; 
DWORD dmPelsWidth; 
DWORD dmPelsHeight; 

union { DWORD dmDisplayFlags; 
DWORD dmNup; 
}; 

DWORD dmDisplayFrequency; 



DWORD dmICMMethod; 
DWORD dmICMIntent; 
DWORD dmMediaType; 
DWORD dmDitherType; 
DWORD dmReserved1; 
DWORD dmReserved2; 



DWORD dmPanningWidth; 
DWORD dmPanningHeight; 




} DEVMODEA, *LPDEVMODEA, *PDEVMODEA; 
# 1688
typedef 
# 1629
struct _devicemodeW { 
WCHAR dmDeviceName[32]; 
WORD dmSpecVersion; 
WORD dmDriverVersion; 
WORD dmSize; 
WORD dmDriverExtra; 
DWORD dmFields; 

union { 
struct { short dmOrientation; 
short dmPaperSize; 
short dmPaperLength; 
short dmPaperWidth; 
short dmScale; 
short dmCopies; 
short dmDefaultSource; 
short dmPrintQuality; 
}; 

struct { POINTL dmPosition; 
DWORD dmDisplayOrientation; 
DWORD dmDisplayFixedOutput; 
}; 
}; 

short dmColor; 
short dmDuplex; 
short dmYResolution; 
short dmTTOption; 
short dmCollate; 
WCHAR dmFormName[32]; 
WORD dmLogPixels; 
DWORD dmBitsPerPel; 
DWORD dmPelsWidth; 
DWORD dmPelsHeight; 

union { DWORD dmDisplayFlags; 
DWORD dmNup; 
}; 

DWORD dmDisplayFrequency; 



DWORD dmICMMethod; 
DWORD dmICMIntent; 
DWORD dmMediaType; 
DWORD dmDitherType; 
DWORD dmReserved1; 
DWORD dmReserved2; 



DWORD dmPanningWidth; 
DWORD dmPanningHeight; 




} DEVMODEW, *LPDEVMODEW, *PDEVMODEW; 

typedef DEVMODEA DEVMODE, *PDEVMODE, *LPDEVMODE; 
# 1698
typedef 
# 1692
struct tagDIBSECTION { 
BITMAP dsBm; 
BITMAPINFOHEADER dsBmih; 
DWORD dsBitfields[3]; 
HANDLE dshSection; 
DWORD dsOffset; 
} DIBSECTION; 
# 1706
typedef 
# 1700
struct _DOCINFOA { 
int cbSize; 
LPCSTR lpszDocName; 
LPCSTR lpszOutput; 
LPCSTR lpszDatatype; 
DWORD fwType; 
} DOCINFOA, *LPDOCINFOA; 
# 1714
typedef 
# 1708
struct _DOCINFOW { 
int cbSize; 
LPCWSTR lpszDocName; 
LPCWSTR lpszOutput; 
LPCWSTR lpszDatatype; 
DWORD fwType; 
} DOCINFOW, *LPDOCINFOW; 

typedef DOCINFOA DOCINFO, *LPDOCINFO; 




typedef 
# 1718
struct tagEMR { 
DWORD iType; 
DWORD nSize; 
} EMR, *PEMR; 
# 1729
typedef 
# 1723
struct tagEMRANGLEARC { 
EMR emr; 
POINTL ptlCenter; 
DWORD nRadius; 
FLOAT eStartAngle; 
FLOAT eSweepAngle; 
} EMRANGLEARC, *PEMRANGLEARC; 
# 1736
typedef 
# 1731
struct tagEMRARC { 
EMR emr; 
RECTL rclBox; 
POINTL ptlStart; 
POINTL ptlEnd; 
} EMRARC, *PEMRARC, EMRARCTO, *PEMRARCTO; 

typedef tagEMRARC EMRCHORD, *PEMRCHORD, EMRPIE, *PEMRPIE; 
# 1747
typedef 
# 1740
struct _XFORM { 
FLOAT eM11; 
FLOAT eM12; 
FLOAT eM21; 
FLOAT eM22; 
FLOAT eDx; 
FLOAT eDy; 
} XFORM, *PXFORM, *LPXFORM; 
# 1765
typedef 
# 1749
struct tagEMRBITBLT { 
EMR emr; 
RECTL rclBounds; 
LONG xDest; 
LONG yDest; 
LONG cxDest; 
LONG cyDest; 
DWORD dwRop; 
LONG xSrc; 
LONG ySrc; 
XFORM xformSrc; 
COLORREF crBkColorSrc; 
DWORD iUsageSrc; 
DWORD offBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
} EMRBITBLT, *PEMRBITBLT; 
# 1771
typedef 
# 1767
struct tagLOGBRUSH { 
UINT lbStyle; 
COLORREF lbColor; 
LONG lbHatch; 
} LOGBRUSH, *PLOGBRUSH, *LPLOGBRUSH; 
typedef LOGBRUSH PATTERN, *PPATTERN, *LPPATTERN; 
# 1778
typedef 
# 1774
struct tagEMRCREATEBRUSHINDIRECT { 
EMR emr; 
DWORD ihBrush; 
LOGBRUSH lb; 
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT; 
typedef LONG LCSCSTYPE; 
typedef LONG LCSGAMUTMATCH; 
# 1793
typedef 
# 1782
struct tagLOGCOLORSPACEA { 
DWORD lcsSignature; 
DWORD lcsVersion; 
DWORD lcsSize; 
LCSCSTYPE lcsCSType; 
LCSGAMUTMATCH lcsIntent; 
CIEXYZTRIPLE lcsEndpoints; 
DWORD lcsGammaRed; 
DWORD lcsGammaGreen; 
DWORD lcsGammaBlue; 
CHAR lcsFilename[260]; 
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA; 
# 1806
typedef 
# 1795
struct tagLOGCOLORSPACEW { 
DWORD lcsSignature; 
DWORD lcsVersion; 
DWORD lcsSize; 
LCSCSTYPE lcsCSType; 
LCSGAMUTMATCH lcsIntent; 
CIEXYZTRIPLE lcsEndpoints; 
DWORD lcsGammaRed; 
DWORD lcsGammaGreen; 
DWORD lcsGammaBlue; 
WCHAR lcsFilename[260]; 
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW; 

typedef LOGCOLORSPACEA LOGCOLORSPACE, *LPLOGCOLORSPACE; 
# 1814
typedef 
# 1810
struct tagEMRCREATECOLORSPACE { 
EMR emr; 
DWORD ihCS; 
LOGCOLORSPACEW lcs; 
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE; 
# 1824
typedef 
# 1816
struct tagEMRCREATEDIBPATTERNBRUSHPT { 
EMR emr; 
DWORD ihBrush; 
DWORD iUsage; 
DWORD offBmi; 
DWORD cbBmi; 
DWORD offBits; 
DWORD cbBits; 
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT; 
# 1834
typedef 
# 1826
struct tagEMRCREATEMONOBRUSH { 
EMR emr; 
DWORD ihBrush; 
DWORD iUsage; 
DWORD offBmi; 
DWORD cbBmi; 
DWORD offBits; 
DWORD cbBits; 
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH; 
# 1841
typedef 
# 1836
struct tagPALETTEENTRY { 
BYTE peRed; 
BYTE peGreen; 
BYTE peBlue; 
BYTE peFlags; 
} PALETTEENTRY, *LPPALETTEENTRY, *PPALETTEENTRY; 
# 1847
typedef 
# 1843
struct tagLOGPALETTE { 
WORD palVersion; 
WORD palNumEntries; 
PALETTEENTRY palPalEntry[1]; 
} LOGPALETTE, *NPLOGPALETTE, *PLOGPALETTE, *LPLOGPALETTE; 
# 1853
typedef 
# 1849
struct tagEMRCREATEPALETTE { 
EMR emr; 
DWORD ihPal; 
LOGPALETTE lgpl; 
} EMRCREATEPALETTE, *PEMRCREATEPALETTE; 
# 1859
typedef 
# 1855
struct tagLOGPEN { 
UINT lopnStyle; 
POINT lopnWidth; 
COLORREF lopnColor; 
} LOGPEN, *PLOGPEN, *LPLOGPEN; 
# 1865
typedef 
# 1861
struct tagEMRCREATEPEN { 
EMR emr; 
DWORD ihPen; 
LOGPEN lopn; 
} EMRCREATEPEN, *PEMRCREATEPEN; 




typedef 
# 1867
struct tagEMRELLIPSE { 
EMR emr; 
RECTL rclBox; 
} EMRELLIPSE, *PEMRELLIPSE, EMRRECTANGLE, *PEMRRECTANGLE; 
# 1877
typedef 
# 1872
struct tagEMREOF { 
EMR emr; 
DWORD nPalEntries; 
DWORD offPalEntries; 
DWORD nSizeLast; 
} EMREOF, *PEMREOF; 




typedef 
# 1879
struct tagEMREXCLUDECLIPRECT { 
EMR emr; 
RECTL rclClip; 
} EMREXCLUDECLIPRECT, *PEMREXCLUDECLIPRECT; 

typedef tagEMREXCLUDECLIPRECT EMRINTERSECTCLIPRECT; 
typedef tagEMREXCLUDECLIPRECT *PEMRINTERSECTCLIPRECT; 
# 1898
typedef 
# 1887
struct tagPANOSE { 
BYTE bFamilyType; 
BYTE bSerifStyle; 
BYTE bWeight; 
BYTE bProportion; 
BYTE bContrast; 
BYTE bStrokeVariation; 
BYTE bArmStyle; 
BYTE bLetterform; 
BYTE bMidline; 
BYTE bXHeight; 
} PANOSE; 
# 1915
typedef 
# 1900
struct tagLOGFONTA { 
LONG lfHeight; 
LONG lfWidth; 
LONG lfEscapement; 
LONG lfOrientation; 
LONG lfWeight; 
BYTE lfItalic; 
BYTE lfUnderline; 
BYTE lfStrikeOut; 
BYTE lfCharSet; 
BYTE lfOutPrecision; 
BYTE lfClipPrecision; 
BYTE lfQuality; 
BYTE lfPitchAndFamily; 
CHAR lfFaceName[32]; 
} LOGFONTA, *PLOGFONTA, *LPLOGFONTA; 
# 1932
typedef 
# 1917
struct tagLOGFONTW { 
LONG lfHeight; 
LONG lfWidth; 
LONG lfEscapement; 
LONG lfOrientation; 
LONG lfWeight; 
BYTE lfItalic; 
BYTE lfUnderline; 
BYTE lfStrikeOut; 
BYTE lfCharSet; 
BYTE lfOutPrecision; 
BYTE lfClipPrecision; 
BYTE lfQuality; 
BYTE lfPitchAndFamily; 
WCHAR lfFaceName[32]; 
} LOGFONTW, *PLOGFONTW, *LPLOGFONTW; 

typedef LOGFONTA LOGFONT, *PLOGFONT, *LPLOGFONT; 
# 1947
typedef 
# 1936
struct tagEXTLOGFONTA { 
LOGFONTA elfLogFont; 
BYTE elfFullName[64]; 
BYTE elfStyle[32]; 
DWORD elfVersion; 
DWORD elfStyleSize; 
DWORD elfMatch; 
DWORD elfReserved; 
BYTE elfVendorId[4]; 
DWORD elfCulture; 
PANOSE elfPanose; 
} EXTLOGFONTA, *PEXTLOGFONTA, *LPEXTLOGFONTA; 
# 1960
typedef 
# 1949
struct tagEXTLOGFONTW { 
LOGFONTW elfLogFont; 
WCHAR elfFullName[64]; 
WCHAR elfStyle[32]; 
DWORD elfVersion; 
DWORD elfStyleSize; 
DWORD elfMatch; 
DWORD elfReserved; 
BYTE elfVendorId[4]; 
DWORD elfCulture; 
PANOSE elfPanose; 
} EXTLOGFONTW, *PEXTLOGFONTW, *LPEXTLOGFONTW; 

typedef EXTLOGFONTA EXTLOGFONT, *PEXTLOGFONT, *LPEXTLOGFONT; 
# 1968
typedef 
# 1964
struct tagEMREXTCREATEFONTINDIRECTW { 
EMR emr; 
DWORD ihFont; 
EXTLOGFONTW elfw; 
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW; 
# 1978
typedef 
# 1970
struct tagEXTLOGPEN { 
UINT elpPenStyle; 
UINT elpWidth; 
UINT elpBrushStyle; 
COLORREF elpColor; 
LONG elpHatch; 
DWORD elpNumEntries; 
DWORD elpStyleEntry[1]; 
} EXTLOGPEN, *PEXTLOGPEN, *LPEXTLOGPEN; 
# 1988
typedef 
# 1980
struct tagEMREXTCREATEPEN { 
EMR emr; 
DWORD ihPen; 
DWORD offBmi; 
DWORD cbBmi; 
DWORD offBits; 
DWORD cbBits; 
EXTLOGPEN elp; 
} EMREXTCREATEPEN, *PEMREXTCREATEPEN; 
# 1995
typedef 
# 1990
struct tagEMREXTFLOODFILL { 
EMR emr; 
POINTL ptlStart; 
COLORREF crColor; 
DWORD iMode; 
} EMREXTFLOODFILL, *PEMREXTFLOODFILL; 
# 2002
typedef 
# 1997
struct tagEMREXTSELECTCLIPRGN { 
EMR emr; 
DWORD cbRgnData; 
DWORD iMode; 
BYTE RgnData[1]; 
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN; 
# 2011
typedef 
# 2004
struct tagEMRTEXT { 
POINTL ptlReference; 
DWORD nChars; 
DWORD offString; 
DWORD fOptions; 
RECTL rcl; 
DWORD offDx; 
} EMRTEXT, *PEMRTEXT; 
# 2020
typedef 
# 2013
struct tagEMREXTTEXTOUTA { 
EMR emr; 
RECTL rclBounds; 
DWORD iGraphicsMode; 
FLOAT exScale; 
FLOAT eyScale; 
EMRTEXT emrtext; 
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA, EMREXTTEXTOUTW, *PEMREXTTEXTOUTW; 




typedef 
# 2022
struct tagEMRFILLPATH { 
EMR emr; 
RECTL rclBounds; 
} EMRFILLPATH, *PEMRFILLPATH, EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH; 

typedef tagEMRFILLPATH EMRSTROKEPATH, *PEMRSTROKEPATH; 
# 2035
typedef 
# 2029
struct tagEMRFILLRGN { 
EMR emr; 
RECTL rclBounds; 
DWORD cbRgnData; 
DWORD ihBrush; 
BYTE RgnData[1]; 
} EMRFILLRGN, *PEMRFILLRGN; 
# 2042
typedef 
# 2037
struct tagEMRFORMAT { 
DWORD dSignature; 
DWORD nVersion; 
DWORD cbData; 
DWORD offData; 
} EMRFORMAT; 
# 2051
typedef 
# 2044
struct tagEMRFRAMERGN { 
EMR emr; 
RECTL rclBounds; 
DWORD cbRgnData; 
DWORD ihBrush; 
SIZEL szlStroke; 
BYTE RgnData[1]; 
} EMRFRAMERGN, *PEMRFRAMERGN; 
# 2057
typedef 
# 2053
struct tagEMRGDICOMMENT { 
EMR emr; 
DWORD cbData; 
BYTE Data[1]; 
} EMRGDICOMMENT, *PEMRGDICOMMENT; 
# 2064
typedef 
# 2059
struct tagEMRINVERTRGN { 
EMR emr; 
RECTL rclBounds; 
DWORD cbRgnData; 
BYTE RgnData[1]; 
} EMRINVERTRGN, *PEMRINVERTRGN, EMRPAINTRGN, *PEMRPAINTRGN; 




typedef 
# 2066
struct tagEMRLINETO { 
EMR emr; 
POINTL ptl; 
} EMRLINETO, *PEMRLINETO, EMRMOVETOEX, *PEMRMOVETOEX; 
# 2095
typedef 
# 2071
struct tagEMRMASKBLT { 
EMR emr; 
RECTL rclBounds; 
LONG xDest; 
LONG yDest; 
LONG cxDest; 
LONG cyDest; 
DWORD dwRop; 
LONG xSrc; 
LONG ySrc; 
XFORM xformSrc; 
COLORREF crBkColorSrc; 
DWORD iUsageSrc; 
DWORD offBmiSrc; 
DWORD cbBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
LONG xMask; 
LONG yMask; 
DWORD iUsageMask; 
DWORD offBmiMask; 
DWORD cbBmiMask; 
DWORD offBitsMask; 
DWORD cbBitsMask; 
} EMRMASKBLT, *PEMRMASKBLT; 
# 2101
typedef 
# 2097
struct tagEMRMODIFYWORLDTRANSFORM { 
EMR emr; 
XFORM xform; 
DWORD iMode; 
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM; 




typedef 
# 2103
struct tagEMROFFSETCLIPRGN { 
EMR emr; 
POINTL ptlOffset; 
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN; 
# 2130
typedef 
# 2108
struct tagEMRPLGBLT { 
EMR emr; 
RECTL rclBounds; 
POINTL aptlDest[3]; 
LONG xSrc; 
LONG ySrc; 
LONG cxSrc; 
LONG cySrc; 
XFORM xformSrc; 
COLORREF crBkColorSrc; 
DWORD iUsageSrc; 
DWORD offBmiSrc; 
DWORD cbBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
LONG xMask; 
LONG yMask; 
DWORD iUsageMask; 
DWORD offBmiMask; 
DWORD cbBmiMask; 
DWORD offBitsMask; 
DWORD cbBitsMask; 
} EMRPLGBLT, *PEMRPLGBLT; 
# 2138
typedef 
# 2132
struct tagEMRPOLYDRAW { 
EMR emr; 
RECTL rclBounds; 
DWORD cptl; 
POINTL aptl[1]; 
BYTE abTypes[1]; 
} EMRPOLYDRAW, *PEMRPOLYDRAW; 
# 2146
typedef 
# 2140
struct tagEMRPOLYDRAW16 { 
EMR emr; 
RECTL rclBounds; 
DWORD cpts; 
POINTS apts[1]; 
BYTE abTypes[1]; 
} EMRPOLYDRAW16, *PEMRPOLYDRAW16; 
# 2153
typedef 
# 2148
struct tagEMRPOLYLINE { 
EMR emr; 
RECTL rclBounds; 
DWORD cptl; 
POINTL aptl[1]; 
} EMRPOLYLINE, *PEMRPOLYLINE, EMRPOLYBEZIER, *PEMRPOLYBEZIER; 

typedef tagEMRPOLYLINE EMRPOLYGON, *PEMRPOLYGON; 
typedef tagEMRPOLYLINE EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO; 
typedef tagEMRPOLYLINE EMRPOLYLINETO, *PEMRPOLYLINETO; 
# 2164
typedef 
# 2159
struct tagEMRPOLYLINE16 { 
EMR emr; 
RECTL rclBounds; 
DWORD cpts; 
POINTL apts[1]; 
} EMRPOLYLINE16, *PEMRPOLYLINE16, EMRPOLYBEZIER16, *PEMRPOLYBEZIER16; 

typedef tagEMRPOLYLINE16 EMRPOLYGON16, *PEMRPOLYGON16; 
typedef tagEMRPOLYLINE16 EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16; 
typedef tagEMRPOLYLINE16 EMRPOLYLINETO16, *PEMRPOLYLINETO16; 
# 2177
typedef 
# 2170
struct tagEMRPOLYPOLYLINE { 
EMR emr; 
RECTL rclBounds; 
DWORD nPolys; 
DWORD cptl; 
DWORD aPolyCounts[1]; 
POINTL aptl[1]; 
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE, EMRPOLYPOLYGON, *PEMRPOLYPOLYGON; 
# 2186
typedef 
# 2179
struct tagEMRPOLYPOLYLINE16 { 
EMR emr; 
RECTL rclBounds; 
DWORD nPolys; 
DWORD cpts; 
DWORD aPolyCounts[1]; 
POINTS apts[1]; 
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16, EMRPOLYPOLYGON16, *PEMRPOLYPOLYGON16; 
# 2196
typedef 
# 2188
struct tagEMRPOLYTEXTOUTA { 
EMR emr; 
RECTL rclBounds; 
DWORD iGraphicsMode; 
FLOAT exScale; 
FLOAT eyScale; 
LONG cStrings; 
EMRTEXT aemrtext[1]; 
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA, EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW; 
# 2202
typedef 
# 2198
struct tagEMRRESIZEPALETTE { 
EMR emr; 
DWORD ihPal; 
DWORD cEntries; 
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE; 




typedef 
# 2204
struct tagEMRRESTOREDC { 
EMR emr; 
LONG iRelative; 
} EMRRESTOREDC, *PEMRRESTOREDC; 
# 2213
typedef 
# 2209
struct tagEMRROUNDRECT { 
EMR emr; 
RECTL rclBox; 
SIZEL szlCorner; 
} EMRROUNDRECT, *PEMRROUNDRECT; 
# 2221
typedef 
# 2215
struct tagEMRSCALEVIEWPORTEXTEX { 
EMR emr; 
LONG xNum; 
LONG xDenom; 
LONG yNum; 
LONG yDenom; 
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX; 

typedef tagEMRSCALEVIEWPORTEXTEX EMRSCALEWINDOWEXTEX; 
typedef tagEMRSCALEVIEWPORTEXTEX *PEMRSCALEWINDOWEXTEX; 




typedef 
# 2226
struct tagEMRSELECTCOLORSPACE { 
EMR emr; 
DWORD ihCS; 
} EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE, EMRDELETECOLORSPACE; 

typedef tagEMRSELECTCOLORSPACE *PEMRDELETECOLORSPACE; 




typedef 
# 2233
struct tagEMRSELECTOBJECT { 
EMR emr; 
DWORD ihObject; 
} EMRSELECTOBJECT, *PEMRSELECTOBJECT, EMRDELETEOBJECT, *PEMRDELETEOBJECT; 




typedef 
# 2238
struct tagEMRSELECTPALETTE { 
EMR emr; 
DWORD ihPal; 
} EMRSELECTPALETTE, *PEMRSELECTPALETTE; 




typedef 
# 2243
struct tagEMRSETARCDIRECTION { 
EMR emr; 
DWORD iArcDirection; 
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION; 




typedef 
# 2248
struct tagEMRSETTEXTCOLOR { 
EMR emr; 
COLORREF crColor; 
} EMRSETBKCOLOR, *PEMRSETBKCOLOR, EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR; 




typedef 
# 2253
struct tagEMRSETCOLORADJUSTMENT { 
EMR emr; 
COLORADJUSTMENT ColorAdjustment; 
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT; 
# 2274
typedef 
# 2258
struct tagEMRSETDIBITSTODEVICE { 
EMR emr; 
RECTL rclBounds; 
LONG xDest; 
LONG yDest; 
LONG xSrc; 
LONG ySrc; 
LONG cxSrc; 
LONG cySrc; 
DWORD offBmiSrc; 
DWORD cbBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
DWORD iUsageSrc; 
DWORD iStartScan; 
DWORD cScans; 
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE; 




typedef 
# 2276
struct tagEMRSETMAPPERFLAGS { 
EMR emr; 
DWORD dwFlags; 
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS; 




typedef 
# 2281
struct tagEMRSETMITERLIMIT { 
EMR emr; 
FLOAT eMiterLimit; 
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT; 
# 2292
typedef 
# 2286
struct tagEMRSETPALETTEENTRIES { 
EMR emr; 
DWORD ihPal; 
DWORD iStart; 
DWORD cEntries; 
PALETTEENTRY aPalEntries[1]; 
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES; 
# 2298
typedef 
# 2294
struct tagEMRSETPIXELV { 
EMR emr; 
POINTL ptlPixel; 
COLORREF crColor; 
} EMRSETPIXELV, *PEMRSETPIXELV; 




typedef 
# 2300
struct tagEMRSETVIEWPORTEXTEX { 
EMR emr; 
SIZEL szlExtent; 
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX, EMRSETWINDOWEXTEX; 

typedef tagEMRSETVIEWPORTEXTEX *PEMRSETWINDOWEXTEX; 




typedef 
# 2307
struct tagEMRSETVIEWPORTORGEX { 
EMR emr; 
POINTL ptlOrigin; 
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX, EMRSETWINDOWORGEX; 

typedef tagEMRSETVIEWPORTORGEX *PEMRSETWINDOWORGEX; 
typedef tagEMRSETVIEWPORTORGEX EMRSETBRUSHORGEX; 
typedef tagEMRSETVIEWPORTORGEX *PEMRSETBRUSHORGEX; 




typedef 
# 2316
struct tagEMRSETWORLDTRANSFORM { 
EMR emr; 
XFORM xform; 
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM; 
# 2340
typedef 
# 2321
struct tagEMRSTRETCHBLT { 
EMR emr; 
RECTL rclBounds; 
LONG xDest; 
LONG yDest; 
LONG cxDest; 
LONG cyDest; 
DWORD dwRop; 
LONG xSrc; 
LONG ySrc; 
XFORM xformSrc; 
COLORREF crBkColorSrc; 
DWORD iUsageSrc; 
DWORD offBmiSrc; 
DWORD cbBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
LONG cxSrc; 
LONG cySrc; 
} EMRSTRETCHBLT, *PEMRSTRETCHBLT; 
# 2359
typedef 
# 2342
struct tagEMRSTRETCHDIBITS { 
EMR emr; 
RECTL rclBounds; 
LONG xDest; 
LONG yDest; 
LONG xSrc; 
LONG ySrc; 
LONG cxSrc; 
LONG cySrc; 
DWORD offBmiSrc; 
DWORD cbBmiSrc; 
DWORD offBitsSrc; 
DWORD cbBitsSrc; 
DWORD iUsageSrc; 
DWORD dwRop; 
LONG cxDest; 
LONG cyDest; 
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS; 



typedef 
# 2361
struct tagABORTPATH { 
EMR emr; 
} EMRABORTPATH, *PEMRABORTPATH, EMRBEGINPATH, *PEMRBEGINPATH; 

typedef tagABORTPATH EMRENDPATH, *PEMRENDPATH; 
typedef tagABORTPATH EMRCLOSEFIGURE, *PEMRCLOSEFIGURE; 
typedef tagABORTPATH EMRFLATTENPATH, *PEMRFLATTENPATH; 
typedef tagABORTPATH EMRWIDENPATH, *PEMRWIDENPATH; 
typedef tagABORTPATH EMRSETMETARGN, *PEMRSETMETARGN; 
typedef tagABORTPATH EMRSAVEDC, *PEMRSAVEDC; 
typedef tagABORTPATH EMRREALIZEPALETTE, *PEMRREALIZEPALETTE; 




typedef 
# 2373
struct tagEMRSELECTCLIPPATH { 
EMR emr; 
DWORD iMode; 
} EMRSELECTCLIPPATH, *PEMRSELECTCLIPPATH, EMRSETBKMODE, *PEMRSETBKMODE; 

typedef tagEMRSELECTCLIPPATH EMRSETMAPMODE, *PEMRSETMAPMODE; 
typedef tagEMRSELECTCLIPPATH EMRSETPOLYFILLMODE, *PEMRSETPOLYFILLMODE; 
typedef tagEMRSELECTCLIPPATH EMRSETROP2, *PEMRSETROP2; 
typedef tagEMRSELECTCLIPPATH EMRSETSTRETCHBLTMODE; 
typedef tagEMRSELECTCLIPPATH *PEMRSETSTRETCHBLTMODE; 
typedef tagEMRSELECTCLIPPATH EMRSETTEXTALIGN, *PEMRSETTEXTALIGN; 
typedef tagEMRSELECTCLIPPATH EMRENABLEICM, *PEMRENABLEICM; 

#pragma pack ( push, 2 )
# 2396
typedef 
# 2388
struct tagMETAHEADER { 
WORD mtType; 
WORD mtHeaderSize; 
WORD mtVersion; 
DWORD mtSize; 
WORD mtNoObjects; 
DWORD mtMaxRecord; 
WORD mtNoParameters; 
} METAHEADER, *PMETAHEADER, *LPMETAHEADER; 

#pragma pack ( pop )
# 2430
typedef 
# 2400
struct tagENHMETAHEADER { 
DWORD iType; 
DWORD nSize; 
RECTL rclBounds; 
RECTL rclFrame; 
DWORD dSignature; 
DWORD nVersion; 
DWORD nBytes; 
DWORD nRecords; 
WORD nHandles; 
WORD sReserved; 
DWORD nDescription; 
DWORD offDescription; 
DWORD nPalEntries; 
SIZEL szlDevice; 
SIZEL szlMillimeters; 



DWORD cbPixelFormat; 
DWORD offPixelFormat; 
DWORD bOpenGL; 



SIZEL szlMicrometers; 




} ENHMETAHEADER, *LPENHMETAHEADER; 
# 2436
typedef 
# 2432
struct tagMETARECORD { 
DWORD rdSize; 
WORD rdFunction; 
WORD rdParm[1]; 
} METARECORD, *PMETARECORD, *LPMETARECORD; 
# 2442
typedef 
# 2438
struct tagENHMETARECORD { 
DWORD iType; 
DWORD nSize; 
DWORD dParm[1]; 
} ENHMETARECORD, *LPENHMETARECORD; 



typedef 
# 2444
struct tagHANDLETABLE { 
HGDIOBJ objectHandle[1]; 
} HANDLETABLE, *LPHANDLETABLE; 
# 2469
typedef 
# 2448
struct tagTEXTMETRICA { 
LONG tmHeight; 
LONG tmAscent; 
LONG tmDescent; 
LONG tmInternalLeading; 
LONG tmExternalLeading; 
LONG tmAveCharWidth; 
LONG tmMaxCharWidth; 
LONG tmWeight; 
LONG tmOverhang; 
LONG tmDigitizedAspectX; 
LONG tmDigitizedAspectY; 
BYTE tmFirstChar; 
BYTE tmLastChar; 
BYTE tmDefaultChar; 
BYTE tmBreakChar; 
BYTE tmItalic; 
BYTE tmUnderlined; 
BYTE tmStruckOut; 
BYTE tmPitchAndFamily; 
BYTE tmCharSet; 
} TEXTMETRICA, *PTEXTMETRICA, *LPTEXTMETRICA; 
# 2492
typedef 
# 2471
struct tagTEXTMETRICW { 
LONG tmHeight; 
LONG tmAscent; 
LONG tmDescent; 
LONG tmInternalLeading; 
LONG tmExternalLeading; 
LONG tmAveCharWidth; 
LONG tmMaxCharWidth; 
LONG tmWeight; 
LONG tmOverhang; 
LONG tmDigitizedAspectX; 
LONG tmDigitizedAspectY; 
WCHAR tmFirstChar; 
WCHAR tmLastChar; 
WCHAR tmDefaultChar; 
WCHAR tmBreakChar; 
BYTE tmItalic; 
BYTE tmUnderlined; 
BYTE tmStruckOut; 
BYTE tmPitchAndFamily; 
BYTE tmCharSet; 
} TEXTMETRICW, *PTEXTMETRICW, *LPTEXTMETRICW; 

typedef TEXTMETRICA TEXTMETRIC, *PTEXTMETRIC, *LPTEXTMETRIC; 
# 2502
typedef 
# 2496
struct _RGNDATAHEADER { 
DWORD dwSize; 
DWORD iType; 
DWORD nCount; 
DWORD nRgnSize; 
RECT rcBound; 
} RGNDATAHEADER; 




typedef 
# 2504
struct _RGNDATA { 
RGNDATAHEADER rdh; 
char Buffer[1]; 
} RGNDATA, *PRGNDATA, *LPRGNDATA; 
# 2520
typedef 
# 2510
struct tagGCP_RESULTSA { 
DWORD lStructSize; 
LPSTR lpOutString; 
UINT *lpOrder; 
INT *lpDx; 
INT *lpCaretPos; 
LPSTR lpClass; 
LPWSTR lpGlyphs; 
UINT nGlyphs; 
UINT nMaxFit; 
} GCP_RESULTSA, *LPGCP_RESULTSA; 
# 2532
typedef 
# 2522
struct tagGCP_RESULTSW { 
DWORD lStructSize; 
LPWSTR lpOutString; 
UINT *lpOrder; 
INT *lpDx; 
INT *lpCaretPos; 
LPSTR lpClass; 
LPWSTR lpGlyphs; 
UINT nGlyphs; 
UINT nMaxFit; 
} GCP_RESULTSW, *LPGCP_RESULTSW; 

typedef GCP_RESULTSA GCP_RESULTS, *LPGCP_RESULTS; 
# 2542
typedef 
# 2536
struct _GLYPHMETRICS { 
UINT gmBlackBoxX; 
UINT gmBlackBoxY; 
POINT gmptGlyphOrigin; 
short gmCellIncX; 
short gmCellIncY; 
} GLYPHMETRICS, *LPGLYPHMETRICS; 
# 2548
typedef 
# 2544
struct tagKERNINGPAIR { 
WORD wFirst; 
WORD wSecond; 
int iKernAmount; 
} KERNINGPAIR, *LPKERNINGPAIR; 




typedef 
# 2550
struct _FIXED { 
WORD fract; 
short value; 
} FIXED; 
# 2560
typedef 
# 2555
struct _MAT2 { 
FIXED eM11; 
FIXED eM12; 
FIXED eM21; 
FIXED eM22; 
} MAT2, *LPMAT2; 
# 2595
typedef 
# 2562
struct _OUTLINETEXTMETRICA { 
UINT otmSize; 
TEXTMETRICA otmTextMetrics; 
BYTE otmFiller; 
PANOSE otmPanoseNumber; 
UINT otmfsSelection; 
UINT otmfsType; 
int otmsCharSlopeRise; 
int otmsCharSlopeRun; 
int otmItalicAngle; 
UINT otmEMSquare; 
int otmAscent; 
int otmDescent; 
UINT otmLineGap; 
UINT otmsCapEmHeight; 
UINT otmsXHeight; 
RECT otmrcFontBox; 
int otmMacAscent; 
int otmMacDescent; 
UINT otmMacLineGap; 
UINT otmusMinimumPPEM; 
POINT otmptSubscriptSize; 
POINT otmptSubscriptOffset; 
POINT otmptSuperscriptSize; 
POINT otmptSuperscriptOffset; 
UINT otmsStrikeoutSize; 
int otmsStrikeoutPosition; 
int otmsUnderscoreSize; 
int otmsUnderscorePosition; 
PSTR otmpFamilyName; 
PSTR otmpFaceName; 
PSTR otmpStyleName; 
PSTR otmpFullName; 
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA; 
# 2630
typedef 
# 2597
struct _OUTLINETEXTMETRICW { 
UINT otmSize; 
TEXTMETRICW otmTextMetrics; 
BYTE otmFiller; 
PANOSE otmPanoseNumber; 
UINT otmfsSelection; 
UINT otmfsType; 
int otmsCharSlopeRise; 
int otmsCharSlopeRun; 
int otmItalicAngle; 
UINT otmEMSquare; 
int otmAscent; 
int otmDescent; 
UINT otmLineGap; 
UINT otmsCapEmHeight; 
UINT otmsXHeight; 
RECT otmrcFontBox; 
int otmMacAscent; 
int otmMacDescent; 
UINT otmMacLineGap; 
UINT otmusMinimumPPEM; 
POINT otmptSubscriptSize; 
POINT otmptSubscriptOffset; 
POINT otmptSuperscriptSize; 
POINT otmptSuperscriptOffset; 
UINT otmsStrikeoutSize; 
int otmsStrikeoutPosition; 
int otmsUnderscoreSize; 
int otmsUnderscorePosition; 
PSTR otmpFamilyName; 
PSTR otmpFaceName; 
PSTR otmpStyleName; 
PSTR otmpFullName; 
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW; 

typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC; 
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC; 
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC; 
# 2640
typedef 
# 2636
struct _RASTERIZER_STATUS { 
short nSize; 
short wFlags; 
short nLanguageID; 
} RASTERIZER_STATUS, *LPRASTERIZER_STATUS; 
# 2650
typedef 
# 2642
struct _POLYTEXTA { 
int x; 
int y; 
UINT n; 
LPCSTR lpstr; 
UINT uiFlags; 
RECT rcl; 
int *pdx; 
} POLYTEXTA, *PPOLYTEXTA, *LPPOLYTEXTA; 
# 2660
typedef 
# 2652
struct _POLYTEXTW { 
int x; 
int y; 
UINT n; 
LPCWSTR lpstr; 
UINT uiFlags; 
RECT rcl; 
int *pdx; 
} POLYTEXTW, *PPOLYTEXTW, *LPPOLYTEXTW; 

typedef POLYTEXTA POLYTEXT, *PPOLYTEXT, *LPPOLYTEXT; 
# 2691
typedef 
# 2664
struct tagPIXELFORMATDESCRIPTOR { 
WORD nSize; 
WORD nVersion; 
DWORD dwFlags; 
BYTE iPixelType; 
BYTE cColorBits; 
BYTE cRedBits; 
BYTE cRedShift; 
BYTE cGreenBits; 
BYTE cGreenShift; 
BYTE cBlueBits; 
BYTE cBlueShift; 
BYTE cAlphaBits; 
BYTE cAlphaShift; 
BYTE cAccumBits; 
BYTE cAccumRedBits; 
BYTE cAccumGreenBits; 
BYTE cAccumBlueBits; 
BYTE cAccumAlphaBits; 
BYTE cDepthBits; 
BYTE cStencilBits; 
BYTE cAuxBuffers; 
BYTE iLayerType; 
BYTE bReserved; 
DWORD dwLayerMask; 
DWORD dwVisibleMask; 
DWORD dwDamageMask; 
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR; 
# 2698
typedef 
# 2693
struct tagMETAFILEPICT { 
LONG mm; 
LONG xExt; 
LONG yExt; 
HMETAFILE hMF; 
} METAFILEPICT, *LPMETAFILEPICT; 
# 2704
typedef 
# 2700
struct tagLOCALESIGNATURE { 
DWORD lsUsb[4]; 
DWORD lsCsbDefault[2]; 
DWORD lsCsbSupported[2]; 
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE; 
typedef LONG LCSTYPE; 

#pragma pack ( push, 4 )
# 2734
typedef 
# 2709
struct tagNEWTEXTMETRICA { 
LONG tmHeight; 
LONG tmAscent; 
LONG tmDescent; 
LONG tmInternalLeading; 
LONG tmExternalLeading; 
LONG tmAveCharWidth; 
LONG tmMaxCharWidth; 
LONG tmWeight; 
LONG tmOverhang; 
LONG tmDigitizedAspectX; 
LONG tmDigitizedAspectY; 
BYTE tmFirstChar; 
BYTE tmLastChar; 
BYTE tmDefaultChar; 
BYTE tmBreakChar; 
BYTE tmItalic; 
BYTE tmUnderlined; 
BYTE tmStruckOut; 
BYTE tmPitchAndFamily; 
BYTE tmCharSet; 
DWORD ntmFlags; 
UINT ntmSizeEM; 
UINT ntmCellHeight; 
UINT ntmAvgWidth; 
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, *LPNEWTEXTMETRICA; 
# 2761
typedef 
# 2736
struct tagNEWTEXTMETRICW { 
LONG tmHeight; 
LONG tmAscent; 
LONG tmDescent; 
LONG tmInternalLeading; 
LONG tmExternalLeading; 
LONG tmAveCharWidth; 
LONG tmMaxCharWidth; 
LONG tmWeight; 
LONG tmOverhang; 
LONG tmDigitizedAspectX; 
LONG tmDigitizedAspectY; 
WCHAR tmFirstChar; 
WCHAR tmLastChar; 
WCHAR tmDefaultChar; 
WCHAR tmBreakChar; 
BYTE tmItalic; 
BYTE tmUnderlined; 
BYTE tmStruckOut; 
BYTE tmPitchAndFamily; 
BYTE tmCharSet; 
DWORD ntmFlags; 
UINT ntmSizeEM; 
UINT ntmCellHeight; 
UINT ntmAvgWidth; 
} NEWTEXTMETRICW, *PNEWTEXTMETRICW, *LPNEWTEXTMETRICW; 

#pragma pack ( pop )

typedef NEWTEXTMETRICA NEWTEXTMETRIC, *PNEWTEXTMETRIC, *LPNEWTEXTMETRIC; 




typedef 
# 2767
struct tagNEWTEXTMETRICEXA { 
NEWTEXTMETRICA ntmTm; 
FONTSIGNATURE ntmFontSig; 
} NEWTEXTMETRICEXA; 




typedef 
# 2772
struct tagNEWTEXTMETRICEXW { 
NEWTEXTMETRICW ntmTm; 
FONTSIGNATURE ntmFontSig; 
} NEWTEXTMETRICEXW; 

typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX; 
# 2785
typedef 
# 2779
struct tagPELARRAY { 
LONG paXCount; 
LONG paYCount; 
LONG paXExt; 
LONG paYExt; 
BYTE paRGBs; 
} PELARRAY, *PPELARRAY, *LPPELARRAY; 
# 2791
typedef 
# 2787
struct tagENUMLOGFONTA { 
LOGFONTA elfLogFont; 
BYTE elfFullName[64]; 
BYTE elfStyle[32]; 
} ENUMLOGFONTA, *LPENUMLOGFONTA; 
# 2797
typedef 
# 2793
struct tagENUMLOGFONTW { 
LOGFONTW elfLogFont; 
WCHAR elfFullName[64]; 
WCHAR elfStyle[32]; 
} ENUMLOGFONTW, *LPENUMLOGFONTW; 

typedef ENUMLOGFONTA ENUMLOGFONT, *LPENUMLOGFONT; 
# 2806
typedef 
# 2801
struct tagENUMLOGFONTEXA { 
LOGFONTA elfLogFont; 
BYTE elfFullName[64]; 
BYTE elfStyle[32]; 
BYTE elfScript[32]; 
} ENUMLOGFONTEXA, *LPENUMLOGFONTEXA; 
# 2813
typedef 
# 2808
struct tagENUMLOGFONTEXW { 
LOGFONTW elfLogFont; 
WCHAR elfFullName[64]; 
WCHAR elfStyle[32]; 
WCHAR elfScript[32]; 
} ENUMLOGFONTEXW, *LPENUMLOGFONTEXW; 

typedef ENUMLOGFONTEXA ENUMLOGFONTEX, *LPENUMLOGFONTEX; 




typedef 
# 2817
struct tagPOINTFX { 
FIXED x; 
FIXED y; 
} POINTFX, *LPPOINTFX; 
# 2826
typedef 
# 2822
struct tagTTPOLYCURVE { 
WORD wType; 
WORD cpfx; 
POINTFX apfx[1]; 
} TTPOLYCURVE, *LPTTPOLYCURVE; 
# 2832
typedef 
# 2828
struct tagTTPOLYGONHEADER { 
DWORD cb; 
DWORD dwType; 
POINTFX pfxStart; 
} TTPOLYGONHEADER, *LPTTPOLYGONHEADER; 




typedef 
# 2834
struct _POINTFLOAT { 
FLOAT x; 
FLOAT y; 
} POINTFLOAT, *PPOINTFLOAT; 
# 2845
typedef 
# 2839
struct _GLYPHMETRICSFLOAT { 
FLOAT gmfBlackBoxX; 
FLOAT gmfBlackBoxY; 
POINTFLOAT gmfptGlyphOrigin; 
FLOAT gmfCellIncX; 
FLOAT gmfCellIncY; 
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT; 
# 2872
typedef 
# 2847
struct tagLAYERPLANEDESCRIPTOR { 
WORD nSize; 
WORD nVersion; 
DWORD dwFlags; 
BYTE iPixelType; 
BYTE cColorBits; 
BYTE cRedBits; 
BYTE cRedShift; 
BYTE cGreenBits; 
BYTE cGreenShift; 
BYTE cBlueBits; 
BYTE cBlueShift; 
BYTE cAlphaBits; 
BYTE cAlphaShift; 
BYTE cAccumBits; 
BYTE cAccumRedBits; 
BYTE cAccumGreenBits; 
BYTE cAccumBlueBits; 
BYTE cAccumAlphaBits; 
BYTE cDepthBits; 
BYTE cStencilBits; 
BYTE cAuxBuffers; 
BYTE iLayerPlane; 
BYTE bReserved; 
COLORREF crTransparent; 
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR; 
# 2879
typedef 
# 2874
struct _BLENDFUNCTION { 
BYTE BlendOp; 
BYTE BlendFlags; 
BYTE SourceConstantAlpha; 
BYTE AlphaFormat; 
} BLENDFUNCTION, *PBLENDFUNCTION, *LPBLENDFUNCTION; 
# 2886
typedef 
# 2882
struct _DESIGNVECTOR { 
DWORD dvReserved; 
DWORD dvNumAxes; 
LONG dvValues[16]; 
} DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR; 

typedef USHORT COLOR16; 
# 2897
typedef 
# 2890
struct _TRIVERTEX { 
LONG x; 
LONG y; 
COLOR16 Red; 
COLOR16 Green; 
COLOR16 Blue; 
COLOR16 Alpha; 
} TRIVERTEX, *PTRIVERTEX, *LPTRIVERTEX; 
# 2903
typedef 
# 2899
struct _GRADIENT_TRIANGLE { 
ULONG Vertex1; 
ULONG Vertex2; 
ULONG Vertex3; 
} GRADIENT_TRIANGLE, *PGRADIENT_TRIANGLE, *LPGRADIENT_TRIANGLE; 




typedef 
# 2905
struct _GRADIENT_RECT { 
ULONG UpperLeft; 
ULONG LowerRight; 
} GRADIENT_RECT, *PGRADIENT_RECT, *LPGRADIENT_RECT; 
# 2917
typedef 
# 2910
struct _DISPLAY_DEVICEA { 
DWORD cb; 
CHAR DeviceName[32]; 
CHAR DeviceString[128]; 
DWORD StateFlags; 
CHAR DeviceID[128]; 
CHAR DeviceKey[128]; 
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA; 
# 2926
typedef 
# 2919
struct _DISPLAY_DEVICEW { 
DWORD cb; 
WCHAR DeviceName[32]; 
WCHAR DeviceString[128]; 
DWORD StateFlags; 
WCHAR DeviceID[128]; 
WCHAR DeviceKey[128]; 
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW; 

typedef DISPLAY_DEVICEA DISPLAY_DEVICE, *PDISPLAY_DEVICE, *LPDISPLAY_DEVICE; 

typedef BOOL ( __attribute((__stdcall__))*ABORTPROC)(HDC, int) ; 

typedef int ( __attribute((__stdcall__))*MFENUMPROC)(HDC, HANDLETABLE *, METARECORD *, int, LPARAM) ; 


typedef int ( __attribute((__stdcall__))*ENHMFENUMPROC)(HDC, HANDLETABLE *, const ENHMETARECORD *, int, LPARAM) ; 


typedef int ( __attribute((__stdcall__))*OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM) ; 


typedef int ( __attribute((__stdcall__))*OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM) ; 



typedef OLDFONTENUMPROCA FONTENUMPROCA; 
typedef OLDFONTENUMPROCW FONTENUMPROCW; 


typedef int ( __attribute((__stdcall__))*ICMENUMPROCA)(LPSTR, LPARAM) ; 
typedef int ( __attribute((__stdcall__))*ICMENUMPROCW)(LPWSTR, LPARAM) ; 

typedef void ( __attribute((__stdcall__))*GOBJENUMPROC)(LPVOID, LPARAM) ; 
typedef void ( __attribute((__stdcall__))*LINEDDAPROC)(int, int, LPARAM) ; 
typedef UINT ( __attribute((__stdcall__))*LPFNDEVMODE)(HWND, HMODULE, LPDEVMODEA, LPSTR, LPSTR, LPDEVMODEA, LPSTR, UINT) ; 


typedef DWORD ( __attribute((__stdcall__))*LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODEA) ; 
# 2981 "d:\\mingw\\mingw\\include\\wingdi.h" 3
__attribute((__stdcall__)) int AbortDoc(HDC); 
__attribute((__stdcall__)) BOOL AbortPath(HDC); 


__attribute((__stdcall__)) int AddFontResourceA(LPCSTR); 
__attribute((__stdcall__)) int AddFontResourceW(LPCWSTR); 

__attribute((__stdcall__)) BOOL AngleArc(HDC, int, int, DWORD, FLOAT, FLOAT); 

__attribute((__stdcall__)) BOOL AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY *); 


__attribute((__stdcall__)) BOOL Arc(HDC, int, int, int, int, int, int, int, int); 
__attribute((__stdcall__)) BOOL ArcTo(HDC, int, int, int, int, int, int, int, int); 
__attribute((__stdcall__)) BOOL BeginPath(HDC); 
__attribute((__stdcall__)) BOOL BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD); 
__attribute((__stdcall__)) BOOL CancelDC(HDC); 
__attribute((__stdcall__)) BOOL CheckColorsInGamut(HDC, PVOID, PVOID, DWORD); 
__attribute((__stdcall__)) BOOL Chord(HDC, int, int, int, int, int, int, int, int); 
__attribute((__stdcall__)) int ChoosePixelFormat(HDC, const PIXELFORMATDESCRIPTOR *); 
__attribute((__stdcall__)) HENHMETAFILE CloseEnhMetaFile(HDC); 
__attribute((__stdcall__)) BOOL CloseFigure(HDC); 
__attribute((__stdcall__)) HMETAFILE CloseMetaFile(HDC); 


__attribute((__stdcall__)) BOOL ColorCorrectPalette(HDC, HPALETTE, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL ColorMatchToTarget(HDC, HDC, DWORD); 


__attribute((__stdcall__)) int CombineRgn(HRGN, HRGN, HRGN, int); 
__attribute((__stdcall__)) BOOL CombineTransform(LPXFORM, const XFORM *, const XFORM *); 


__attribute((__stdcall__)) HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE, LPCSTR); 
__attribute((__stdcall__)) HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE, LPCWSTR); 


__attribute((__stdcall__)) HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR); 
__attribute((__stdcall__)) HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR); 

__attribute((__stdcall__)) HBITMAP CreateBitmap(int, int, UINT, UINT, PCVOID); 
__attribute((__stdcall__)) HBITMAP CreateBitmapIndirect(const BITMAP *); 
__attribute((__stdcall__)) HBRUSH CreateBrushIndirect(const LOGBRUSH *); 


__attribute((__stdcall__)) HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA); 
__attribute((__stdcall__)) HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW); 

__attribute((__stdcall__)) HBITMAP CreateCompatibleBitmap(HDC, int, int); 
__attribute((__stdcall__)) HDC CreateCompatibleDC(HDC); 


__attribute((__stdcall__)) HDC CreateDCA(LPCSTR, LPCSTR, LPCSTR, const DEVMODEA *); 
__attribute((__stdcall__)) HDC CreateDCW(LPCWSTR, LPCWSTR, LPCWSTR, const DEVMODEW *); 

__attribute((__stdcall__)) HBITMAP CreateDIBitmap(HDC, const BITMAPINFOHEADER *, DWORD, PCVOID, const BITMAPINFO *, UINT); 


__attribute((__stdcall__)) HBRUSH CreateDIBPatternBrush(HGLOBAL, UINT); 
__attribute((__stdcall__)) HBRUSH CreateDIBPatternBrushPt(PCVOID, UINT); 

__attribute((__stdcall__)) HBITMAP CreateDIBSection(HDC, const BITMAPINFO *, UINT, void **, HANDLE, DWORD); 


__attribute((__stdcall__)) HBITMAP CreateDiscardableBitmap(HDC, int, int); 
__attribute((__stdcall__)) HRGN CreateEllipticRgn(int, int, int, int); 
__attribute((__stdcall__)) HRGN CreateEllipticRgnIndirect(LPCRECT); 


__attribute((__stdcall__)) HDC CreateEnhMetaFileA(HDC, LPCSTR, LPCRECT, LPCSTR); 
__attribute((__stdcall__)) HDC CreateEnhMetaFileW(HDC, LPCWSTR, LPCRECT, LPCWSTR); 


__attribute((__stdcall__)) HFONT CreateFontA(int, int, int, int, int, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCSTR); 




__attribute((__stdcall__)) HFONT CreateFontW(int, int, int, int, int, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCWSTR); 
# 3066
__attribute((__stdcall__)) HFONT CreateFontIndirectA(const LOGFONTA *); 
__attribute((__stdcall__)) HFONT CreateFontIndirectW(const LOGFONTW *); 

__attribute((__stdcall__)) HPALETTE CreateHalftonePalette(HDC); 
__attribute((__stdcall__)) HBRUSH CreateHatchBrush(int, COLORREF); 


__attribute((__stdcall__)) HDC CreateICA(LPCSTR, LPCSTR, LPCSTR, const DEVMODEA *); 
__attribute((__stdcall__)) HDC CreateICW(LPCWSTR, LPCWSTR, LPCWSTR, const DEVMODEW *); 


__attribute((__stdcall__)) HDC CreateMetaFileA(LPCSTR); 
__attribute((__stdcall__)) HDC CreateMetaFileW(LPCWSTR); 

__attribute((__stdcall__)) HPALETTE CreatePalette(const LOGPALETTE *); 
__attribute((__stdcall__)) HBRUSH CreatePatternBrush(HBITMAP); 
__attribute((__stdcall__)) HPEN CreatePen(int, int, COLORREF); 
__attribute((__stdcall__)) HPEN CreatePenIndirect(const LOGPEN *); 
__attribute((__stdcall__)) HRGN CreatePolygonRgn(const POINT *, int, int); 

__attribute((__stdcall__)) HRGN CreatePolyPolygonRgn(const POINT *, const INT *, int, int); 


__attribute((__stdcall__)) HRGN CreateRectRgn(int, int, int, int); 
__attribute((__stdcall__)) HRGN CreateRectRgnIndirect(LPCRECT); 
__attribute((__stdcall__)) HRGN CreateRoundRectRgn(int, int, int, int, int, int); 


__attribute((__stdcall__)) BOOL CreateScalableFontResourceA(DWORD, LPCSTR, LPCSTR, LPCSTR); 


__attribute((__stdcall__)) BOOL CreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) HBRUSH CreateSolidBrush(COLORREF); 
__attribute((__stdcall__)) BOOL DeleteColorSpace(HCOLORSPACE); 
__attribute((__stdcall__)) BOOL DeleteDC(HDC); 
__attribute((__stdcall__)) BOOL DeleteEnhMetaFile(HENHMETAFILE); 
__attribute((__stdcall__)) BOOL DeleteMetaFile(HMETAFILE); 
__attribute((__stdcall__)) BOOL DeleteObject(HGDIOBJ); 

__attribute((__stdcall__)) int DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR); 




__attribute((__stdcall__)) DWORD DeviceCapabilitiesA(LPCSTR, LPCSTR, WORD, LPSTR, const DEVMODEA *); 


__attribute((__stdcall__)) DWORD DeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD, LPWSTR, const DEVMODEW *); 


__attribute((__stdcall__)) BOOL DPtoLP(HDC, LPPOINT, int); 
__attribute((__stdcall__)) int DrawEscape(HDC, int, int, LPCSTR); 
__attribute((__stdcall__)) BOOL Ellipse(HDC, int, int, int, int); 
__attribute((__stdcall__)) int EndDoc(HDC); 
__attribute((__stdcall__)) int EndPage(HDC); 
__attribute((__stdcall__)) BOOL EndPath(HDC); 

__attribute((__stdcall__)) BOOL EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC, PVOID, LPCRECT); 



__attribute((__stdcall__)) int EnumFontFamiliesA(HDC, LPCSTR, FONTENUMPROCA, LPARAM); 
__attribute((__stdcall__)) int EnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM); 


__attribute((__stdcall__)) int EnumFontFamiliesExA(HDC, PLOGFONTA, FONTENUMPROCA, LPARAM, DWORD); 


__attribute((__stdcall__)) int EnumFontFamiliesExW(HDC, PLOGFONTW, FONTENUMPROCW, LPARAM, DWORD); 



__attribute((__stdcall__)) int EnumFontsA(HDC, LPCSTR, FONTENUMPROCA, LPARAM); 
__attribute((__stdcall__)) int EnumFontsW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM); 


__attribute((__stdcall__)) int EnumICMProfilesA(HDC, ICMENUMPROCA, LPARAM); 
__attribute((__stdcall__)) int EnumICMProfilesW(HDC, ICMENUMPROCW, LPARAM); 

__attribute((__stdcall__)) BOOL EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM); 
__attribute((__stdcall__)) int EnumObjects(HDC, int, GOBJENUMPROC, LPARAM); 
__attribute((__stdcall__)) BOOL EqualRgn(HRGN, HRGN); 
__attribute((__stdcall__)) int Escape(HDC, int, int, LPCSTR, PVOID); 
__attribute((__stdcall__)) int ExcludeClipRect(HDC, int, int, int, int); 
__attribute((__stdcall__)) int ExcludeUpdateRgn(HDC, HWND); 

__attribute((__stdcall__)) HPEN ExtCreatePen(DWORD, DWORD, const LOGBRUSH *, DWORD, const DWORD *); 


__attribute((__stdcall__)) HRGN ExtCreateRegion(const XFORM *, DWORD, const RGNDATA *); 
__attribute((__stdcall__)) int ExtEscape(HDC, int, int, LPCSTR, int, LPSTR); 
__attribute((__stdcall__)) BOOL ExtFloodFill(HDC, int, int, COLORREF, UINT); 
__attribute((__stdcall__)) int ExtSelectClipRgn(HDC, HRGN, int); 


__attribute((__stdcall__)) BOOL ExtTextOutA(HDC, int, int, UINT, LPCRECT, LPCSTR, UINT, const INT *); 


__attribute((__stdcall__)) BOOL ExtTextOutW(HDC, int, int, UINT, LPCRECT, LPCWSTR, UINT, const INT *); 


__attribute((__stdcall__)) BOOL FillPath(HDC); 
__attribute((__stdcall__)) int FillRect(HDC, LPCRECT, HBRUSH); 
__attribute((__stdcall__)) int FillRgn(HDC, HRGN, HBRUSH); 
__attribute((__stdcall__)) BOOL FixBrushOrgEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) BOOL FlattenPath(HDC); 
__attribute((__stdcall__)) BOOL FloodFill(HDC, int, int, COLORREF); 
__attribute((__stdcall__)) BOOL GdiComment(HDC, UINT, const BYTE *); 
__attribute((__stdcall__)) BOOL GdiFlush(); 
__attribute((__stdcall__)) DWORD GdiGetBatchLimit(); 
__attribute((__stdcall__)) DWORD GdiSetBatchLimit(DWORD); 
__attribute((__stdcall__)) int GetArcDirection(HDC); 
__attribute((__stdcall__)) BOOL GetAspectRatioFilterEx(HDC, LPSIZE); 
__attribute((__stdcall__)) LONG GetBitmapBits(HBITMAP, LONG, PVOID); 
__attribute((__stdcall__)) BOOL GetBitmapDimensionEx(HBITMAP, LPSIZE); 
__attribute((__stdcall__)) COLORREF GetBkColor(HDC); 
__attribute((__stdcall__)) int GetBkMode(HDC); 
__attribute((__stdcall__)) UINT GetBoundsRect(HDC, LPRECT, UINT); 
__attribute((__stdcall__)) BOOL GetBrushOrgEx(HDC, LPPOINT); 


__attribute((__stdcall__)) BOOL GetCharABCWidthsA(HDC, UINT, UINT, LPABC); 
__attribute((__stdcall__)) BOOL GetCharABCWidthsW(HDC, UINT, UINT, LPABC); 


__attribute((__stdcall__)) BOOL GetCharABCWidthsFloatA(HDC, UINT, UINT, LPABCFLOAT); 
__attribute((__stdcall__)) BOOL GetCharABCWidthsFloatW(HDC, UINT, UINT, LPABCFLOAT); 


__attribute((__stdcall__)) DWORD GetCharacterPlacementA(HDC, LPCSTR, int, int, LPGCP_RESULTSA, DWORD); 


__attribute((__stdcall__)) DWORD GetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD); 



__attribute((__stdcall__)) BOOL GetCharWidth32A(HDC, UINT, UINT, LPINT); 
__attribute((__stdcall__)) BOOL GetCharWidth32W(HDC, UINT, UINT, LPINT); 


__attribute((__stdcall__)) BOOL GetCharWidthA(HDC, UINT, UINT, LPINT); 
__attribute((__stdcall__)) BOOL GetCharWidthW(HDC, UINT, UINT, LPINT); 


__attribute((__stdcall__)) BOOL GetCharWidthFloatA(HDC, UINT, UINT, PFLOAT); 
__attribute((__stdcall__)) BOOL GetCharWidthFloatW(HDC, UINT, UINT, PFLOAT); 

__attribute((__stdcall__)) int GetClipBox(HDC, LPRECT); 
__attribute((__stdcall__)) int GetClipRgn(HDC, HRGN); 
__attribute((__stdcall__)) BOOL GetColorAdjustment(HDC, LPCOLORADJUSTMENT); 
__attribute((__stdcall__)) HANDLE GetColorSpace(HDC); 
__attribute((__stdcall__)) HGDIOBJ GetCurrentObject(HDC, UINT); 
__attribute((__stdcall__)) BOOL GetCurrentPositionEx(HDC, LPPOINT); 
__attribute((__stdcall__)) HCURSOR GetCursor(); 

__attribute((__stdcall__)) BOOL GetDCOrgEx(HDC, LPPOINT); 
__attribute((__stdcall__)) int GetDeviceCaps(HDC, int); 
__attribute((__stdcall__)) BOOL GetDeviceGammaRamp(HDC, PVOID); 
__attribute((__stdcall__)) UINT GetDIBColorTable(HDC, UINT, UINT, RGBQUAD *); 

__attribute((__stdcall__)) int GetDIBits(HDC, HBITMAP, UINT, UINT, PVOID, LPBITMAPINFO, UINT); 



__attribute((__stdcall__)) HENHMETAFILE GetEnhMetaFileA(LPCSTR); 
__attribute((__stdcall__)) HENHMETAFILE GetEnhMetaFileW(LPCWSTR); 

__attribute((__stdcall__)) UINT GetEnhMetaFileBits(HENHMETAFILE, UINT, LPBYTE); 


__attribute((__stdcall__)) UINT GetEnhMetaFileDescriptionA(HENHMETAFILE, UINT, LPSTR); 
__attribute((__stdcall__)) UINT GetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR); 

__attribute((__stdcall__)) UINT GetEnhMetaFileHeader(HENHMETAFILE, UINT, LPENHMETAHEADER); 


__attribute((__stdcall__)) UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT, LPPALETTEENTRY); 


__attribute((__stdcall__)) UINT GetEnhMetaFilePixelFormat(HENHMETAFILE, DWORD, const PIXELFORMATDESCRIPTOR *); 


__attribute((__stdcall__)) DWORD GetFontData(HDC, DWORD, DWORD, PVOID, DWORD); 
__attribute((__stdcall__)) DWORD GetFontLanguageInfo(HDC); 


__attribute((__stdcall__)) DWORD GetGlyphOutlineA(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, PVOID, const MAT2 *); 


__attribute((__stdcall__)) DWORD GetGlyphOutlineW(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, PVOID, const MAT2 *); 


__attribute((__stdcall__)) int GetGraphicsMode(HDC); 


__attribute((__stdcall__)) BOOL GetICMProfileA(HDC, LPDWORD, LPSTR); 
__attribute((__stdcall__)) BOOL GetICMProfileW(HDC, LPDWORD, LPWSTR); 


__attribute((__stdcall__)) DWORD GetKerningPairsA(HDC, DWORD, LPKERNINGPAIR); 
__attribute((__stdcall__)) DWORD GetKerningPairsW(HDC, DWORD, LPKERNINGPAIR); 


__attribute((__stdcall__)) BOOL GetLogColorSpaceA(HCOLORSPACE, LPLOGCOLORSPACEA, DWORD); 
__attribute((__stdcall__)) BOOL GetLogColorSpaceW(HCOLORSPACE, LPLOGCOLORSPACEW, DWORD); 

__attribute((__stdcall__)) int GetMapMode(HDC); 


__attribute((__stdcall__)) HMETAFILE GetMetaFileA(LPCSTR); 
__attribute((__stdcall__)) HMETAFILE GetMetaFileW(LPCWSTR); 

__attribute((__stdcall__)) UINT GetMetaFileBitsEx(HMETAFILE, UINT, PVOID); 
__attribute((__stdcall__)) int GetMetaRgn(HDC, HRGN); 
__attribute((__stdcall__)) BOOL GetMiterLimit(HDC, PFLOAT); 
__attribute((__stdcall__)) COLORREF GetNearestColor(HDC, COLORREF); 
__attribute((__stdcall__)) UINT GetNearestPaletteIndex(HPALETTE, COLORREF); 


__attribute((__stdcall__)) int GetObjectA(HGDIOBJ, int, PVOID); 
__attribute((__stdcall__)) int GetObjectW(HGDIOBJ, int, PVOID); 

__attribute((__stdcall__)) DWORD GetObjectType(HGDIOBJ); 


__attribute((__stdcall__)) UINT GetOutlineTextMetricsA(HDC, UINT, LPOUTLINETEXTMETRICA); 
__attribute((__stdcall__)) UINT GetOutlineTextMetricsW(HDC, UINT, LPOUTLINETEXTMETRICW); 

__attribute((__stdcall__)) UINT GetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY); 
__attribute((__stdcall__)) int GetPath(HDC, LPPOINT, PBYTE, int); 
__attribute((__stdcall__)) COLORREF GetPixel(HDC, int, int); 
__attribute((__stdcall__)) int GetPixelFormat(HDC); 
__attribute((__stdcall__)) int GetPolyFillMode(HDC); 
__attribute((__stdcall__)) BOOL GetRasterizerCaps(LPRASTERIZER_STATUS, UINT); 
__attribute((__stdcall__)) int GetRandomRgn(HDC, HRGN, INT); 
__attribute((__stdcall__)) DWORD GetRegionData(HRGN, DWORD, LPRGNDATA); 
__attribute((__stdcall__)) int GetRgnBox(HRGN, LPRECT); 
__attribute((__stdcall__)) int GetROP2(HDC); 
__attribute((__stdcall__)) HGDIOBJ GetStockObject(int); 
__attribute((__stdcall__)) int GetStretchBltMode(HDC); 

__attribute((__stdcall__)) UINT GetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY); 


__attribute((__stdcall__)) UINT GetSystemPaletteUse(HDC); 
__attribute((__stdcall__)) UINT GetTextAlign(HDC); 
__attribute((__stdcall__)) int GetTextCharacterExtra(HDC); 
__attribute((__stdcall__)) int GetTextCharset(HDC); 
__attribute((__stdcall__)) int GetTextCharsetInfo(HDC, LPFONTSIGNATURE, DWORD); 
__attribute((__stdcall__)) COLORREF GetTextColor(HDC); 


__attribute((__stdcall__)) BOOL GetTextExtentExPointA(HDC, LPCSTR, int, int, LPINT, LPINT, LPSIZE); 


__attribute((__stdcall__)) BOOL GetTextExtentExPointW(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE); 



__attribute((__stdcall__)) BOOL GetTextExtentPointA(HDC, LPCSTR, int, LPSIZE); 
__attribute((__stdcall__)) BOOL GetTextExtentPointW(HDC, LPCWSTR, int, LPSIZE); 


__attribute((__stdcall__)) BOOL GetTextExtentPoint32A(HDC, LPCSTR, int, LPSIZE); 
__attribute((__stdcall__)) BOOL GetTextExtentPoint32W(HDC, LPCWSTR, int, LPSIZE); 


__attribute((__stdcall__)) int GetTextFaceA(HDC, int, LPSTR); 
__attribute((__stdcall__)) int GetTextFaceW(HDC, int, LPWSTR); 


__attribute((__stdcall__)) BOOL GetTextMetricsA(HDC, LPTEXTMETRICA); 
__attribute((__stdcall__)) BOOL GetTextMetricsW(HDC, LPTEXTMETRICW); 

__attribute((__stdcall__)) BOOL GetViewportExtEx(HDC, LPSIZE); 
__attribute((__stdcall__)) BOOL GetViewportOrgEx(HDC, LPPOINT); 
__attribute((__stdcall__)) BOOL GetWindowExtEx(HDC, LPSIZE); 
__attribute((__stdcall__)) BOOL GetWindowOrgEx(HDC, LPPOINT); 

__attribute((__stdcall__)) UINT GetWinMetaFileBits(HENHMETAFILE, UINT, LPBYTE, INT, HDC); 


__attribute((__stdcall__)) BOOL GetWorldTransform(HDC, LPXFORM); 
__attribute((__stdcall__)) int IntersectClipRect(HDC, int, int, int, int); 
__attribute((__stdcall__)) BOOL InvertRgn(HDC, HRGN); 
__attribute((__stdcall__)) BOOL LineDDA(int, int, int, int, LINEDDAPROC, LPARAM); 
__attribute((__stdcall__)) BOOL LineTo(HDC, int, int); 
__attribute((__stdcall__)) BOOL LPtoDP(HDC, LPPOINT, int); 

__attribute((__stdcall__)) BOOL MaskBlt(HDC, int, int, int, int, HDC, int, int, HBITMAP, int, int, DWORD); 


__attribute((__stdcall__)) BOOL ModifyWorldTransform(HDC, const XFORM *, DWORD); 
__attribute((__stdcall__)) BOOL MoveToEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) int OffsetClipRgn(HDC, int, int); 
__attribute((__stdcall__)) int OffsetRgn(HRGN, int, int); 
__attribute((__stdcall__)) BOOL OffsetViewportOrgEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) BOOL OffsetWindowOrgEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) BOOL PaintRgn(HDC, HRGN); 
__attribute((__stdcall__)) BOOL PatBlt(HDC, int, int, int, int, DWORD); 
__attribute((__stdcall__)) HRGN PathToRegion(HDC); 
__attribute((__stdcall__)) BOOL Pie(HDC, int, int, int, int, int, int, int, int); 
__attribute((__stdcall__)) BOOL PlayEnhMetaFile(HDC, HENHMETAFILE, LPCRECT); 

__attribute((__stdcall__)) BOOL PlayEnhMetaFileRecord(HDC, LPHANDLETABLE, const ENHMETARECORD *, UINT); 


__attribute((__stdcall__)) BOOL PlayMetaFile(HDC, HMETAFILE); 

__attribute((__stdcall__)) BOOL PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, UINT); 


__attribute((__stdcall__)) BOOL PlgBlt(HDC, const POINT *, HDC, int, int, int, int, HBITMAP, int, int); 


__attribute((__stdcall__)) BOOL PolyBezier(HDC, const POINT *, DWORD); 
__attribute((__stdcall__)) BOOL PolyBezierTo(HDC, const POINT *, DWORD); 
__attribute((__stdcall__)) BOOL PolyDraw(HDC, const POINT *, const BYTE *, int); 
__attribute((__stdcall__)) BOOL Polygon(HDC, const POINT *, int); 
__attribute((__stdcall__)) BOOL Polyline(HDC, const POINT *, int); 
__attribute((__stdcall__)) BOOL PolylineTo(HDC, const POINT *, DWORD); 
__attribute((__stdcall__)) BOOL PolyPolygon(HDC, const POINT *, const INT *, int); 
__attribute((__stdcall__)) BOOL PolyPolyline(HDC, const POINT *, const DWORD *, DWORD); 


__attribute((__stdcall__)) BOOL PolyTextOutA(HDC, const POLYTEXTA *, int); 
__attribute((__stdcall__)) BOOL PolyTextOutW(HDC, const POLYTEXTW *, int); 

__attribute((__stdcall__)) BOOL PtInRegion(HRGN, int, int); 
__attribute((__stdcall__)) BOOL PtVisible(HDC, int, int); 
__attribute((__stdcall__)) UINT RealizePalette(HDC); 
__attribute((__stdcall__)) BOOL Rectangle(HDC, int, int, int, int); 
__attribute((__stdcall__)) BOOL RectInRegion(HRGN, LPCRECT); 
__attribute((__stdcall__)) BOOL RectVisible(HDC, LPCRECT); 


__attribute((__stdcall__)) BOOL RemoveFontResourceA(LPCSTR); 
__attribute((__stdcall__)) BOOL RemoveFontResourceW(LPCWSTR); 


__attribute((__stdcall__)) HDC ResetDCA(HDC, const DEVMODEA *); 
__attribute((__stdcall__)) HDC ResetDCW(HDC, const DEVMODEW *); 

__attribute((__stdcall__)) BOOL ResizePalette(HPALETTE, UINT); 
__attribute((__stdcall__)) BOOL RestoreDC(HDC, int); 
__attribute((__stdcall__)) BOOL RoundRect(HDC, int, int, int, int, int, int); 
__attribute((__stdcall__)) int SaveDC(HDC); 
__attribute((__stdcall__)) BOOL ScaleViewportExtEx(HDC, int, int, int, int, LPSIZE); 
__attribute((__stdcall__)) BOOL ScaleWindowExtEx(HDC, int, int, int, int, LPSIZE); 
__attribute((__stdcall__)) BOOL SelectClipPath(HDC, int); 
__attribute((__stdcall__)) int SelectClipRgn(HDC, HRGN); 
__attribute((__stdcall__)) HGDIOBJ SelectObject(HDC, HGDIOBJ); 
__attribute((__stdcall__)) HPALETTE SelectPalette(HDC, HPALETTE, BOOL); 
__attribute((__stdcall__)) int SetAbortProc(HDC, ABORTPROC); 
__attribute((__stdcall__)) int SetArcDirection(HDC, int); 
__attribute((__stdcall__)) LONG SetBitmapBits(HBITMAP, DWORD, PCVOID); 
__attribute((__stdcall__)) BOOL SetBitmapDimensionEx(HBITMAP, int, int, LPSIZE); 
__attribute((__stdcall__)) COLORREF SetBkColor(HDC, COLORREF); 
__attribute((__stdcall__)) int SetBkMode(HDC, int); 
__attribute((__stdcall__)) UINT SetBoundsRect(HDC, LPCRECT, UINT); 
__attribute((__stdcall__)) BOOL SetBrushOrgEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) BOOL SetColorAdjustment(HDC, const COLORADJUSTMENT *); 
__attribute((__stdcall__)) BOOL SetColorSpace(HDC, HCOLORSPACE); 

__attribute((__stdcall__)) BOOL SetDeviceGammaRamp(HDC, PVOID); 
__attribute((__stdcall__)) UINT SetDIBColorTable(HDC, UINT, UINT, const RGBQUAD *); 

__attribute((__stdcall__)) int SetDIBits(HDC, HBITMAP, UINT, UINT, PCVOID, const BITMAPINFO *, UINT); 


__attribute((__stdcall__)) int SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int, int, UINT, UINT, PCVOID, const BITMAPINFO *, UINT); 




__attribute((__stdcall__)) HENHMETAFILE SetEnhMetaFileBits(UINT, const BYTE *); 
__attribute((__stdcall__)) int SetGraphicsMode(HDC, int); 
__attribute((__stdcall__)) int SetICMMode(HDC, int); 


__attribute((__stdcall__)) BOOL SetICMProfileA(HDC, LPSTR); 
__attribute((__stdcall__)) BOOL SetICMProfileW(HDC, LPWSTR); 

__attribute((__stdcall__)) int SetMapMode(HDC, int); 
__attribute((__stdcall__)) DWORD SetMapperFlags(HDC, DWORD); 
__attribute((__stdcall__)) HMETAFILE SetMetaFileBitsEx(UINT, const BYTE *); 
__attribute((__stdcall__)) int SetMetaRgn(HDC); 
__attribute((__stdcall__)) BOOL SetMiterLimit(HDC, FLOAT, PFLOAT); 

__attribute((__stdcall__)) UINT SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY *); 


__attribute((__stdcall__)) COLORREF SetPixel(HDC, int, int, COLORREF); 
__attribute((__stdcall__)) BOOL SetPixelFormat(HDC, int, const PIXELFORMATDESCRIPTOR *); 
__attribute((__stdcall__)) BOOL SetPixelV(HDC, int, int, COLORREF); 
__attribute((__stdcall__)) int SetPolyFillMode(HDC, int); 
__attribute((__stdcall__)) BOOL SetRectRgn(HRGN, int, int, int, int); 
__attribute((__stdcall__)) int SetROP2(HDC, int); 
__attribute((__stdcall__)) int SetStretchBltMode(HDC, int); 
__attribute((__stdcall__)) UINT SetSystemPaletteUse(HDC, UINT); 
__attribute((__stdcall__)) UINT SetTextAlign(HDC, UINT); 
__attribute((__stdcall__)) int SetTextCharacterExtra(HDC, int); 
__attribute((__stdcall__)) COLORREF SetTextColor(HDC, COLORREF); 
__attribute((__stdcall__)) BOOL SetTextJustification(HDC, int, int); 
__attribute((__stdcall__)) BOOL SetViewportExtEx(HDC, int, int, LPSIZE); 
__attribute((__stdcall__)) BOOL SetViewportOrgEx(HDC, int, int, LPPOINT); 
__attribute((__stdcall__)) BOOL SetWindowExtEx(HDC, int, int, LPSIZE); 
__attribute((__stdcall__)) BOOL SetWindowOrgEx(HDC, int, int, LPPOINT); 

__attribute((__stdcall__)) HENHMETAFILE SetWinMetaFileBits(UINT, const BYTE *, HDC, const METAFILEPICT *); 


__attribute((__stdcall__)) BOOL SetWorldTransform(HDC, const XFORM *); 


__attribute((__stdcall__)) int StartDocA(HDC, const DOCINFOA *); 
__attribute((__stdcall__)) int StartDocW(HDC, const DOCINFOW *); 

__attribute((__stdcall__)) int StartPage(HDC); 

__attribute((__stdcall__)) BOOL StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD); 


__attribute((__stdcall__)) int StretchDIBits(HDC, int, int, int, int, int, int, int, int, const void *, const BITMAPINFO *, UINT, DWORD); 




__attribute((__stdcall__)) BOOL StrokeAndFillPath(HDC); 
__attribute((__stdcall__)) BOOL StrokePath(HDC); 
__attribute((__stdcall__)) BOOL SwapBuffers(HDC); 


__attribute((__stdcall__)) BOOL TextOutA(HDC, int, int, LPCSTR, int); 
__attribute((__stdcall__)) BOOL TextOutW(HDC, int, int, LPCWSTR, int); 

__attribute((__stdcall__)) BOOL TranslateCharsetInfo(PDWORD, LPCHARSETINFO, DWORD); 
__attribute((__stdcall__)) BOOL UnrealizeObject(HGDIOBJ); 
__attribute((__stdcall__)) BOOL UpdateColors(HDC); 


__attribute((__stdcall__)) BOOL UpdateICMRegKeyA(DWORD, DWORD, LPSTR, UINT); 
__attribute((__stdcall__)) BOOL UpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT); 

__attribute((__stdcall__)) BOOL WidenPath(HDC); 
__attribute((__stdcall__)) BOOL wglCopyContext(HGLRC, HGLRC, UINT); 
__attribute((__stdcall__)) HGLRC wglCreateContext(HDC); 
__attribute((__stdcall__)) HGLRC wglCreateLayerContext(HDC, int); 
__attribute((__stdcall__)) BOOL wglDeleteContext(HGLRC); 

__attribute((__stdcall__)) BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR); 


__attribute((__stdcall__)) HGLRC wglGetCurrentContext(); 
__attribute((__stdcall__)) HDC wglGetCurrentDC(); 

__attribute((__stdcall__)) int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *); 


__attribute((__stdcall__)) PROC wglGetProcAddress(LPCSTR); 
__attribute((__stdcall__)) BOOL wglMakeCurrent(HDC, HGLRC); 
__attribute((__stdcall__)) BOOL wglRealizeLayerPalette(HDC, int, BOOL); 

__attribute((__stdcall__)) int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *); 


__attribute((__stdcall__)) BOOL wglShareLists(HGLRC, HGLRC); 
__attribute((__stdcall__)) BOOL wglSwapLayerBuffers(HDC, UINT); 


__attribute((__stdcall__)) BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD); 


__attribute((__stdcall__)) BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT); 


__attribute((__stdcall__)) BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT); 



__attribute((__stdcall__)) BOOL AlphaBlend(HDC, int, int, int, int, HDC, int, int, int, int, BLENDFUNCTION); 


__attribute((__stdcall__)) BOOL GradientFill(HDC, PTRIVERTEX, ULONG, PVOID, ULONG, ULONG); 


__attribute((__stdcall__)) BOOL TransparentBlt(HDC, int, int, int, int, HDC, int, int, int, int, UINT); 



__attribute((__stdcall__)) DWORD GetLayout(HDC); 
__attribute((__stdcall__)) DWORD SetLayout(HDC, DWORD); 

__attribute((__stdcall__)) COLORREF GetDCBrushColor(HDC); 
__attribute((__stdcall__)) COLORREF GetDCPenColor(HDC); 
# 3571
typedef 
# 3568
struct tagWCRANGE { 
WCHAR wcLow; 
USHORT cGlyphs; 
} WCRANGE, *PWCRANGE, *LPWCRANGE; 
# 3579
typedef 
# 3573
struct tagGLYPHSET { 
DWORD cbThis; 
DWORD flAccel; 
DWORD cGlyphsSupported; 
DWORD cRanges; 
WCRANGE ranges[1]; 
} GLYPHSET, *PGLYPHSET, *LPGLYPHSET; 




typedef 
# 3581
struct tagENUMLOGFONTEXDVA { 
ENUMLOGFONTEXA elfEnumLogfontEx; 
DESIGNVECTOR elfDesignVector; 
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA; 




typedef 
# 3586
struct tagENUMLOGFONTEXDVW { 
ENUMLOGFONTEXW elfEnumLogfontEx; 
DESIGNVECTOR elfDesignVector; 
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW; 

typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV, *PENUMLOGFONTEXDV, *LPENUMLOGFONTEXDV; 

__attribute((__stdcall__)) HANDLE AddFontMemResourceEx(PVOID, DWORD, PVOID, DWORD *); 


__attribute((__stdcall__)) int AddFontResourceExA(LPCSTR, DWORD, PVOID); 
__attribute((__stdcall__)) int AddFontResourceExW(LPCWSTR, DWORD, PVOID); 

__attribute((__stdcall__)) BOOL GetTextExtentExPointI(HDC, LPWORD, int, int, LPINT, LPINT, LPSIZE); 


__attribute((__stdcall__)) BOOL RemoveFontMemResourceEx(HANDLE); 


__attribute((__stdcall__)) BOOL RemoveFontResourceExA(LPCSTR, DWORD, PVOID); 
__attribute((__stdcall__)) BOOL RemoveFontResourceExW(LPCWSTR, DWORD, PVOID); 

__attribute((__stdcall__)) COLORREF SetDCBrushColor(HDC, COLORREF); 
__attribute((__stdcall__)) COLORREF SetDCPenColor(HDC, COLORREF); 

__attribute((__stdcall__)) DWORD GetFontUnicodeRanges(HDC, LPGLYPHSET); 


__attribute((__stdcall__)) DWORD GetGlyphIndicesA(HDC, LPCSTR, int, LPWORD, DWORD); 
__attribute((__stdcall__)) DWORD GetGlyphIndicesW(HDC, LPCWSTR, int, LPWORD, DWORD); 



}
# 53 "d:\\mingw\\mingw\\include\\winuser.h" 3
extern "C" {
# 2606 "d:\\mingw\\mingw\\include\\winuser.h" 3
typedef BOOL ( __attribute((__stdcall__))*DLGPROC)(HWND, UINT, WPARAM, LPARAM) ; 
typedef void ( __attribute((__stdcall__))*TIMERPROC)(HWND, UINT, UINT_PTR, DWORD) ; 
typedef BOOL ( __attribute((__stdcall__))*GRAYSTRINGPROC)(HDC, LPARAM, int) ; 
typedef LRESULT ( __attribute((__stdcall__))*HOOKPROC)(int, WPARAM, LPARAM) ; 


typedef BOOL ( __attribute((__stdcall__))*PROPENUMPROCA)(HWND, LPCSTR, HANDLE) ; 
typedef BOOL ( __attribute((__stdcall__))*PROPENUMPROCW)(HWND, LPCWSTR, HANDLE) ; 


typedef BOOL ( __attribute((__stdcall__))*PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, DWORD) ; 
typedef BOOL ( __attribute((__stdcall__))*PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, DWORD) ; 


typedef int ( __attribute((__stdcall__))*EDITWORDBREAKPROCA)(LPSTR, int, int, int) ; 
typedef int ( __attribute((__stdcall__))*EDITWORDBREAKPROCW)(LPWSTR, int, int, int) ; 
typedef LRESULT ( __attribute((__stdcall__))*WNDPROC)(HWND, UINT, WPARAM, LPARAM) ; 
typedef BOOL ( __attribute((__stdcall__))*DRAWSTATEPROC)(HDC, LPARAM, WPARAM, int, int) ; 
typedef BOOL ( __attribute((__stdcall__))*WNDENUMPROC)(HWND, LPARAM) ; 
typedef BOOL ( __attribute((__stdcall__))*ENUMWINDOWSPROC)(HWND, LPARAM) ; 
typedef BOOL ( __attribute((__stdcall__))*MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM) ; 
typedef BOOL ( __attribute((__stdcall__))*NAMEENUMPROCA)(LPSTR, LPARAM) ; 
typedef BOOL ( __attribute((__stdcall__))*NAMEENUMPROCW)(LPWSTR, LPARAM) ; 

typedef NAMEENUMPROCA DESKTOPENUMPROCA; 
typedef NAMEENUMPROCW DESKTOPENUMPROCW; 
typedef NAMEENUMPROCA WINSTAENUMPROCA; 
typedef NAMEENUMPROCW WINSTAENUMPROCW; 

typedef void ( __attribute((__stdcall__))*SENDASYNCPROC)(HWND, UINT, DWORD, LRESULT) ; 

typedef struct HDWP__ { int i; } *HDWP; 
typedef struct HDEVNOTIFY__ { int i; } *HDEVNOTIFY; 
# 2646
typedef 
# 2640
struct tagMENUGETOBJECTINFO { 
DWORD dwFlags; 
UINT uPos; 
HMENU hmenu; 
PVOID riid; 
PVOID pvObj; 
} MENUGETOBJECTINFO, *PMENUGETOBJECTINFO; 
# 2652
typedef 
# 2648
struct tagACCEL { 
BYTE fVirt; 
WORD key; 
WORD cmd; 
} ACCEL, *LPACCEL; 
# 2658
typedef 
# 2654
struct tagACCESSTIMEOUT { 
UINT cbSize; 
DWORD dwFlags; 
DWORD iTimeOutMSec; 
} ACCESSTIMEOUT, *LPACCESSTIMEOUT; 




typedef 
# 2660
struct tagANIMATIONINFO { 
UINT cbSize; 
int iMinAnimate; 
} ANIMATIONINFO, *LPANIMATIONINFO; 
# 2678
typedef 
# 2665
struct tagCREATESTRUCTA { 
LPVOID lpCreateParams; 
HINSTANCE hInstance; 
HMENU hMenu; 
HWND hwndParent; 
int cy; 
int cx; 
int y; 
int x; 
LONG style; 
LPCSTR lpszName; 
LPCSTR lpszClass; 
DWORD dwExStyle; 
} CREATESTRUCTA, *LPCREATESTRUCTA; 
# 2693
typedef 
# 2680
struct tagCREATESTRUCTW { 
LPVOID lpCreateParams; 
HINSTANCE hInstance; 
HMENU hMenu; 
HWND hwndParent; 
int cy; 
int cx; 
int y; 
int x; 
LONG style; 
LPCWSTR lpszName; 
LPCWSTR lpszClass; 
DWORD dwExStyle; 
} CREATESTRUCTW, *LPCREATESTRUCTW; 

typedef CREATESTRUCTA CREATESTRUCT, *LPCREATESTRUCT; 




typedef 
# 2697
struct tagCBT_CREATEWNDA { 
LPCREATESTRUCTA lpcs; 
HWND hwndInsertAfter; 
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA; 




typedef 
# 2702
struct tagCBT_CREATEWNDW { 
LPCREATESTRUCTW lpcs; 
HWND hwndInsertAfter; 
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW; 

typedef CBT_CREATEWNDA CBT_CREATEWND, *LPCBT_CREATEWND; 




typedef 
# 2709
struct tagCBTACTIVATESTRUCT { 
BOOL fMouse; 
HWND hWndActive; 
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT; 




typedef 
# 2714
struct tagCLIENTCREATESTRUCT { 
HANDLE hWindowMenu; 
UINT idFirstChild; 
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT; 
# 2728
typedef 
# 2719
struct tagCOMPAREITEMSTRUCT { 
UINT CtlType; 
UINT CtlID; 
HWND hwndItem; 
UINT itemID1; 
DWORD itemData1; 
UINT itemID2; 
DWORD itemData2; 
DWORD dwLocaleId; 
} COMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT; 
# 2734
typedef 
# 2730
struct tagCOPYDATASTRUCT { 
DWORD dwData; 
DWORD cbData; 
PVOID lpData; 
} COPYDATASTRUCT, *PCOPYDATASTRUCT; 
# 2744
typedef 
# 2736
struct tagCURSORSHAPE { 
int xHotSpot; 
int yHotSpot; 
int cx; 
int cy; 
int cbWidth; 
BYTE Planes; 
BYTE BitsPixel; 
} CURSORSHAPE, *LPCURSORSHAPE; 
# 2752
typedef 
# 2746
struct tagCWPRETSTRUCT { 
LRESULT lResult; 
LPARAM lParam; 
WPARAM wParam; 
DWORD message; 
HWND hwnd; 
} CWPRETSTRUCT; 
# 2759
typedef 
# 2754
struct tagCWPSTRUCT { 
LPARAM lParam; 
WPARAM wParam; 
UINT message; 
HWND hwnd; 
} CWPSTRUCT, *PCWPSTRUCT; 
# 2767
typedef 
# 2761
struct tagDEBUGHOOKINFO { 
DWORD idThread; 
DWORD idThreadInstaller; 
LPARAM lParam; 
WPARAM wParam; 
int code; 
} DEBUGHOOKINFO, *PDEBUGHOOKINFO, *LPDEBUGHOOKINFO; 
# 2775
typedef 
# 2769
struct tagDELETEITEMSTRUCT { 
UINT CtlType; 
UINT CtlID; 
UINT itemID; 
HWND hwndItem; 
UINT itemData; 
} DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT; 

#pragma pack ( push, 2 )
# 2787
typedef 
# 2780
struct { DWORD style; 
DWORD dwExtendedStyle; 
short x; 
short y; 
short cx; 
short cy; 
WORD id; 
} DLGITEMTEMPLATE, *LPDLGITEMTEMPLATE; 
# 2797
typedef 
# 2790
struct { DWORD style; 
DWORD dwExtendedStyle; 
WORD cdit; 
short x; 
short y; 
short cx; 
short cy; 
} DLGTEMPLATE, *LPDLGTEMPLATE, *LPDLGTEMPLATEA, *LPDLGTEMPLATEW; 

typedef const DLGTEMPLATE *LPCDLGTEMPLATE; 

#pragma pack ( pop )
# 2813
typedef 
# 2803
struct tagDRAWITEMSTRUCT { 
UINT CtlType; 
UINT CtlID; 
UINT itemID; 
UINT itemAction; 
UINT itemState; 
HWND hwndItem; 
HDC hDC; 
RECT rcItem; 
DWORD itemData; 
} DRAWITEMSTRUCT, *LPDRAWITEMSTRUCT, *PDRAWITEMSTRUCT; 
# 2821
typedef 
# 2816
struct { UINT cbSize; 
int iTabLength; 
int iLeftMargin; 
int iRightMargin; 
UINT uiLengthDrawn; 
} DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS; 
# 2830
typedef 
# 2823
struct tagPAINTSTRUCT { 
HDC hdc; 
BOOL fErase; 
RECT rcPaint; 
BOOL fRestore; 
BOOL fIncUpdate; 
BYTE rgbReserved[32]; 
} PAINTSTRUCT, *LPPAINTSTRUCT; 
# 2839
typedef 
# 2832
struct tagMSG { 
HWND hwnd; 
UINT message; 
WPARAM wParam; 
LPARAM lParam; 
DWORD time; 
POINT pt; 
} MSG, *LPMSG, *PMSG; 
# 2847
typedef 
# 2841
struct _ICONINFO { 
BOOL fIcon; 
DWORD xHotspot; 
DWORD yHotspot; 
HBITMAP hbmMask; 
HBITMAP hbmColor; 
} ICONINFO, *PICONINFO; 
# 2853
typedef 
# 2849
struct tagNMHDR { 
HWND hwndFrom; 
UINT idFrom; 
UINT code; 
} NMHDR, *LPNMHDR; 
# 2866
typedef 
# 2855
struct _WNDCLASSA { 
UINT style; 
WNDPROC lpfnWndProc; 
int cbClsExtra; 
int cbWndExtra; 
HINSTANCE hInstance; 
HICON hIcon; 
HCURSOR hCursor; 
HBRUSH hbrBackground; 
LPCSTR lpszMenuName; 
LPCSTR lpszClassName; 
} WNDCLASSA, *LPWNDCLASSA, *PWNDCLASSA; 
# 2879
typedef 
# 2868
struct _WNDCLASSW { 
UINT style; 
WNDPROC lpfnWndProc; 
int cbClsExtra; 
int cbWndExtra; 
HINSTANCE hInstance; 
HICON hIcon; 
HCURSOR hCursor; 
HBRUSH hbrBackground; 
LPCWSTR lpszMenuName; 
LPCWSTR lpszClassName; 
} WNDCLASSW, *LPWNDCLASSW, *PWNDCLASSW; 

typedef WNDCLASSA WNDCLASS, *LPWNDCLASS, *PWNDCLASS; 
# 2896
typedef 
# 2883
struct _WNDCLASSEXA { 
UINT cbSize; 
UINT style; 
WNDPROC lpfnWndProc; 
int cbClsExtra; 
int cbWndExtra; 
HINSTANCE hInstance; 
HICON hIcon; 
HCURSOR hCursor; 
HBRUSH hbrBackground; 
LPCSTR lpszMenuName; 
LPCSTR lpszClassName; 
HICON hIconSm; 
} WNDCLASSEXA, *LPWNDCLASSEXA, *PWNDCLASSEXA; 
# 2911
typedef 
# 2898
struct _WNDCLASSEXW { 
UINT cbSize; 
UINT style; 
WNDPROC lpfnWndProc; 
int cbClsExtra; 
int cbWndExtra; 
HINSTANCE hInstance; 
HICON hIcon; 
HCURSOR hCursor; 
HBRUSH hbrBackground; 
LPCWSTR lpszMenuName; 
LPCWSTR lpszClassName; 
HICON hIconSm; 
} WNDCLASSEXW, *LPWNDCLASSEXW, *PWNDCLASSEXW; 

typedef WNDCLASSEXA WNDCLASSEX, *LPWNDCLASSEX, *PWNDCLASSEX; 
# 2930
typedef 
# 2915
struct tagMENUITEMINFOA { 
UINT cbSize; 
UINT fMask; 
UINT fType; 
UINT fState; 
UINT wID; 
HMENU hSubMenu; 
HBITMAP hbmpChecked; 
HBITMAP hbmpUnchecked; 
ULONG_PTR dwItemData; 
LPSTR dwTypeData; 
UINT cch; 

HBITMAP hbmpItem; 

} MENUITEMINFOA, *LPMENUITEMINFOA; 

typedef const MENUITEMINFOA *LPCMENUITEMINFOA; 
# 2949
typedef 
# 2934
struct tagMENUITEMINFOW { 
UINT cbSize; 
UINT fMask; 
UINT fType; 
UINT fState; 
UINT wID; 
HMENU hSubMenu; 
HBITMAP hbmpChecked; 
HBITMAP hbmpUnchecked; 
ULONG_PTR dwItemData; 
LPWSTR dwTypeData; 
UINT cch; 

HBITMAP hbmpItem; 

} MENUITEMINFOW, *LPMENUITEMINFOW; 

typedef const MENUITEMINFOW *LPCMENUITEMINFOW; 
typedef MENUITEMINFOA MENUITEMINFO, *LPMENUITEMINFO; 
typedef LPCMENUITEMINFOA LPCMENUITEMINFO; 
# 2963
typedef 
# 2955
struct tagSCROLLINFO { 
UINT cbSize; 
UINT fMask; 
int nMin; 
int nMax; 
UINT nPage; 
int nPos; 
int nTrackPos; 
} SCROLLINFO, *LPSCROLLINFO; 

typedef const SCROLLINFO *LPCSCROLLINFO; 
# 2974
typedef 
# 2967
struct _WINDOWPLACEMENT { 
UINT length; 
UINT flags; 
UINT showCmd; 
POINT ptMinPosition; 
POINT ptMaxPosition; 
RECT rcNormalPosition; 
} WINDOWPLACEMENT, *LPWINDOWPLACEMENT, *PWINDOWPLACEMENT; 




typedef 
# 2977
struct { WORD versionNumber; 
WORD offset; 
} MENUITEMTEMPLATEHEADER; 
# 2985
typedef 
# 2982
struct { WORD mtOption; 
WORD mtID; 
WCHAR mtString[1]; 
} MENUITEMTEMPLATE; 

typedef void MENUTEMPLATE, MENUTEMPLATEA, MENUTEMPLATEW; 
typedef void *LPMENUTEMPLATE, *LPMENUTEMPLATEA, *LPMENUTEMPLATEW; 
# 2997
typedef 
# 2990
struct tagHELPINFO { 
UINT cbSize; 
int iContextType; 
int iCtrlId; 
HANDLE hItemHandle; 
DWORD dwContextId; 
POINT MousePos; 
} HELPINFO, *LPHELPINFO; 

typedef void ( __attribute((__stdcall__))*MSGBOXCALLBACK)(LPHELPINFO) ; 
# 3012
typedef 
# 3002
struct { UINT cbSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
LPCSTR lpszText; 
LPCSTR lpszCaption; 
DWORD dwStyle; 
LPCSTR lpszIcon; 
DWORD dwContextHelpId; 
MSGBOXCALLBACK lpfnMsgBoxCallback; 
DWORD dwLanguageId; 
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA; 
# 3025
typedef 
# 3015
struct { UINT cbSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
LPCWSTR lpszText; 
LPCWSTR lpszCaption; 
DWORD dwStyle; 
LPCWSTR lpszIcon; 
DWORD dwContextHelpId; 
MSGBOXCALLBACK lpfnMsgBoxCallback; 
DWORD dwLanguageId; 
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW; 

typedef MSGBOXPARAMSA MSGBOXPARAMS, *PMSGBOXPARAMS, *LPMSGBOXPARAMS; 
# 3033
typedef 
# 3029
struct tagUSEROBJECTFLAGS { 
BOOL fInherit; 
BOOL fReserved; 
DWORD dwFlags; 
} USEROBJECTFLAGS; 
# 3042
typedef 
# 3035
struct tagFILTERKEYS { 
UINT cbSize; 
DWORD dwFlags; 
DWORD iWaitMSec; 
DWORD iDelayMSec; 
DWORD iRepeatMSec; 
DWORD iBounceMSec; 
} FILTERKEYS; 
# 3048
typedef 
# 3044
struct tagHIGHCONTRASTA { 
UINT cbSize; 
DWORD dwFlags; 
LPSTR lpszDefaultScheme; 
} HIGHCONTRASTA, *LPHIGHCONTRASTA; 
# 3054
typedef 
# 3050
struct tagHIGHCONTRASTW { 
UINT cbSize; 
DWORD dwFlags; 
LPWSTR lpszDefaultScheme; 
} HIGHCONTRASTW, *LPHIGHCONTRASTW; 

typedef HIGHCONTRASTA HIGHCONTRAST, *LPHIGHCONTRAST; 
# 3064
typedef 
# 3058
struct tagMINIMIZEDMETRICS { 
UINT cbSize; 
int iWidth; 
int iHorzGap; 
int iVertGap; 
int iArrange; 
} MINIMIZEDMETRICS, *LPMINIMIZEDMETRICS; 
# 3074
typedef 
# 3066
struct tagMOUSEKEYS { 
UINT cbSize; 
DWORD dwFlags; 
DWORD iMaxSpeed; 
DWORD iTimeToMaxSpeed; 
DWORD iCtrlSpeed; 
DWORD dwReserved1; 
DWORD dwReserved2; 
} MOUSEKEYS, *LPMOUSEKEYS; 
# 3084
typedef 
# 3076
struct tagSERIALKEYSA { 
UINT cbSize; 
DWORD dwFlags; 
LPSTR lpszActivePort; 
LPSTR lpszPort; 
UINT iBaudRate; 
UINT iPortState; 
UINT iActive; 
} SERIALKEYSA, *LPSERIALKEYSA; 
# 3094
typedef 
# 3086
struct tagSERIALKEYSW { 
UINT cbSize; 
DWORD dwFlags; 
LPWSTR lpszActivePort; 
LPWSTR lpszPort; 
UINT iBaudRate; 
UINT iPortState; 
UINT iActive; 
} SERIALKEYSW, *LPSERIALKEYSW; 

typedef SERIALKEYSA SERIALKEYS, *LPSERIALKEYS; 
# 3111
typedef 
# 3098
struct tagSOUNDSENTRYA { 
UINT cbSize; 
DWORD dwFlags; 
DWORD iFSTextEffect; 
DWORD iFSTextEffectMSec; 
DWORD iFSTextEffectColorBits; 
DWORD iFSGrafEffect; 
DWORD iFSGrafEffectMSec; 
DWORD iFSGrafEffectColor; 
DWORD iWindowsEffect; 
DWORD iWindowsEffectMSec; 
LPSTR lpszWindowsEffectDLL; 
DWORD iWindowsEffectOrdinal; 
} SOUNDSENTRYA, *LPSOUNDSENTRYA; 
# 3126
typedef 
# 3113
struct tagSOUNDSENTRYW { 
UINT cbSize; 
DWORD dwFlags; 
DWORD iFSTextEffect; 
DWORD iFSTextEffectMSec; 
DWORD iFSTextEffectColorBits; 
DWORD iFSGrafEffect; 
DWORD iFSGrafEffectMSec; 
DWORD iFSGrafEffectColor; 
DWORD iWindowsEffect; 
DWORD iWindowsEffectMSec; 
LPWSTR lpszWindowsEffectDLL; 
DWORD iWindowsEffectOrdinal; 
} SOUNDSENTRYW, *LPSOUNDSENTRYW; 

typedef SOUNDSENTRYA SOUNDSENTRY, *LPSOUNDSENTRY; 




typedef 
# 3130
struct tagSTICKYKEYS { 
DWORD cbSize; 
DWORD dwFlags; 
} STICKYKEYS, *LPSTICKYKEYS; 




typedef 
# 3135
struct tagTOGGLEKEYS { 
DWORD cbSize; 
DWORD dwFlags; 
} TOGGLEKEYS; 
# 3145
typedef 
# 3140
struct tagMOUSEHOOKSTRUCT { 
POINT pt; 
HWND hwnd; 
UINT wHitTestCode; 
DWORD dwExtraInfo; 
} MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT; 
# 3152
typedef 
# 3147
struct tagTRACKMOUSEEVENT { 
DWORD cbSize; 
DWORD dwFlags; 
HWND hwndTrack; 
DWORD dwHoverTime; 
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT; 




typedef 
# 3154
struct tagTPMPARAMS { 
UINT cbSize; 
RECT rcExclude; 
} TPMPARAMS, *LPTPMPARAMS; 
# 3165
typedef 
# 3159
struct tagEVENTMSG { 
UINT message; 
UINT paramL; 
UINT paramH; 
DWORD time; 
HWND hwnd; 
} EVENTMSG, *PEVENTMSGMSG, *LPEVENTMSGMSG, *PEVENTMSG, *LPEVENTMSG; 
# 3175
typedef 
# 3167
struct _WINDOWPOS { 
HWND hwnd; 
HWND hwndInsertAfter; 
int x; 
int y; 
int cx; 
int cy; 
UINT flags; 
} WINDOWPOS, *PWINDOWPOS, *LPWINDOWPOS; 




typedef 
# 3177
struct tagNCCALCSIZE_PARAMS { 
RECT rgrc[3]; 
PWINDOWPOS lppos; 
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS; 
# 3192
typedef 
# 3182
struct tagMDICREATESTRUCTA { 
LPCSTR szClass; 
LPCSTR szTitle; 
HANDLE hOwner; 
int x; 
int y; 
int cx; 
int cy; 
DWORD style; 
LPARAM lParam; 
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA; 
# 3204
typedef 
# 3194
struct tagMDICREATESTRUCTW { 
LPCWSTR szClass; 
LPCWSTR szTitle; 
HANDLE hOwner; 
int x; 
int y; 
int cx; 
int cy; 
DWORD style; 
LPARAM lParam; 
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW; 

typedef MDICREATESTRUCTA MDICREATESTRUCT, *LPMDICREATESTRUCT; 
# 3214
typedef 
# 3208
struct tagMINMAXINFO { 
POINT ptReserved; 
POINT ptMaxSize; 
POINT ptMaxPosition; 
POINT ptMinTrackSize; 
POINT ptMaxTrackSize; 
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO; 
# 3220
typedef 
# 3216
struct tagMDINEXTMENU { 
HMENU hmenuIn; 
HMENU hmenuNext; 
HWND hwndNext; 
} MDINEXTMENU, *PMDINEXTMENU, *LPMDINEXTMENU; 
# 3229
typedef 
# 3222
struct tagMEASUREITEMSTRUCT { 
UINT CtlType; 
UINT CtlID; 
UINT itemID; 
UINT itemWidth; 
UINT itemHeight; 
DWORD itemData; 
} MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT; 
# 3238
typedef 
# 3231
struct tagDROPSTRUCT { 
HWND hwndSource; 
HWND hwndSink; 
DWORD wFmt; 
DWORD dwData; 
POINT ptDrop; 
DWORD dwControlData; 
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT; 

typedef DWORD HELPPOLY; 
# 3246
typedef 
# 3242
struct tagMULTIKEYHELPA { 
DWORD mkSize; 
CHAR mkKeylist; 
CHAR szKeyphrase[1]; 
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA; 
# 3252
typedef 
# 3248
struct tagMULTIKEYHELPW { 
DWORD mkSize; 
WCHAR mkKeylist; 
WCHAR szKeyphrase[1]; 
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW; 

typedef MULTIKEYHELPA MULTIKEYHELP, *PMULTIKEYHELP, *LPMULTIKEYHELP; 
# 3264
typedef 
# 3256
struct tagHELPWININFOA { 
int wStructSize; 
int x; 
int y; 
int dx; 
int dy; 
int wMax; 
CHAR rgchMember[2]; 
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA; 
# 3274
typedef 
# 3266
struct tagHELPWININFOW { 
int wStructSize; 
int x; 
int y; 
int dx; 
int dy; 
int wMax; 
WCHAR rgchMember[2]; 
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW; 




typedef 
# 3276
struct tagSTYLESTRUCT { 
DWORD styleOld; 
DWORD styleNew; 
} STYLESTRUCT, *LPSTYLESTRUCT; 
# 3291
typedef 
# 3281
struct tagALTTABINFO { 
DWORD cbSize; 
int cItems; 
int cColumns; 
int cRows; 
int iColFocus; 
int iRowFocus; 
int cxItem; 
int cyItem; 
POINT ptStart; 
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO; 
# 3301
typedef 
# 3293
struct tagCOMBOBOXINFO { 
DWORD cbSize; 
RECT rcItem; 
RECT rcButton; 
DWORD stateButton; 
HWND hwndCombo; 
HWND hwndItem; 
HWND hwndList; 
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO; 
# 3308
typedef 
# 3303
struct tagCURSORINFO { 
DWORD cbSize; 
DWORD flags; 
HCURSOR hCursor; 
POINT ptScreenPos; 
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO; 
# 3317
typedef 
# 3310
struct tagMENUBARINFO { 
DWORD cbSize; 
RECT rcBar; 
HMENU hMenu; 
HWND hwndMenu; 
BOOL fBarFocused:1; 
BOOL fFocused:1; 
} MENUBARINFO, *PMENUBARINFO; 
# 3327
typedef 
# 3319
struct tagMENUINFO { 
DWORD cbSize; 
DWORD fMask; 
DWORD dwStyle; 
UINT cyMax; 
HBRUSH hbrBack; 
DWORD dwContextHelpID; 
ULONG_PTR dwMenuData; 
} MENUINFO, *LPMENUINFO; 

typedef const MENUINFO *LPCMENUINFO; 
# 3341
typedef 
# 3333
struct tagSCROLLBARINFO { 
DWORD cbSize; 
RECT rcScrollBar; 
int dxyLineButton; 
int xyThumbTop; 
int xyThumbBottom; 
int reserved; 
DWORD rgstate[5 + 1]; 
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO; 
# 3354
typedef 
# 3343
struct tagWINDOWINFO { 
DWORD cbSize; 
RECT rcWindow; 
RECT rcClient; 
DWORD dwStyle; 
DWORD dwExStyle; 
DWORD dwWindowStatus; 
UINT cxWindowBorders; 
UINT cyWindowBorders; 
ATOM atomWindowType; 
WORD wCreatorVersion; 
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO; 




typedef 
# 3356
struct tagLASTINPUTINFO { 
UINT cbSize; 
DWORD dwTime; 
} LASTINPUTINFO, *PLASTINPUTINFO; 
# 3366
typedef 
# 3361
struct tagMONITORINFO { 
DWORD cbSize; 
RECT rcMonitor; 
RECT rcWork; 
DWORD dwFlags; 
} MONITORINFO, *LPMONITORINFO; 
# 3373
typedef 
# 3371
struct tagMONITORINFOEXA : public tagMONITORINFO { 
CHAR szDevice[32]; 
} MONITORINFOEXA, *LPMONITORINFOEXA; 



typedef 
# 3375
struct tagMONITORINFOEXW : public tagMONITORINFO { 
WCHAR szDevice[32]; 
} MONITORINFOEXW, *LPMONITORINFOEXW; 
# 3397 "d:\\mingw\\mingw\\include\\winuser.h" 3
typedef MONITORINFOEXA MONITORINFOEX, *LPMONITORINFOEX; 
# 3405
typedef 
# 3399
struct tagKBDLLHOOKSTRUCT { 
DWORD vkCode; 
DWORD scanCode; 
DWORD flags; 
DWORD time; 
DWORD dwExtraInfo; 
} KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT; 
# 3413
typedef 
# 3408
struct { POINT pt; 
DWORD mouseData; 
DWORD flags; 
DWORD time; 
ULONG_PTR dwExtraInfo; 
} MSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT; 
# 3437 "d:\\mingw\\mingw\\include\\winuser.h" 3
typedef const GUID *LPCGUID; 


__attribute((__stdcall__)) HKL ActivateKeyboardLayout(HKL, UINT); 
__attribute((__stdcall__)) BOOL AdjustWindowRect(LPRECT, DWORD, BOOL); 
__attribute((__stdcall__)) BOOL AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD); 

__attribute((__stdcall__)) BOOL AnyPopup(); 


__attribute((__stdcall__)) BOOL AppendMenuA(HMENU, UINT, UINT_PTR, LPCSTR); 
__attribute((__stdcall__)) BOOL AppendMenuW(HMENU, UINT, UINT_PTR, LPCWSTR); 

__attribute((__stdcall__)) UINT ArrangeIconicWindows(HWND); 
__attribute((__stdcall__)) BOOL AttachThreadInput(DWORD, DWORD, BOOL); 
__attribute((__stdcall__)) HDWP BeginDeferWindowPos(int); 
__attribute((__stdcall__)) HDC BeginPaint(HWND, LPPAINTSTRUCT); 
__attribute((__stdcall__)) BOOL BringWindowToTop(HWND); 
__attribute((__stdcall__)) long BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) BOOL CallMsgFilterA(LPMSG, INT); 
__attribute((__stdcall__)) BOOL CallMsgFilterW(LPMSG, INT); 


__attribute((__stdcall__)) LRESULT CallWindowProcA(WNDPROC, HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT CallWindowProcW(WNDPROC, HWND, UINT, WPARAM, LPARAM); 

__attribute((__stdcall__)) WORD CascadeWindows(HWND, UINT, LPCRECT, UINT, const HWND *); 
__attribute((__stdcall__)) BOOL ChangeClipboardChain(HWND, HWND); 


__attribute((__stdcall__)) LRESULT CallNextHookEx(HHOOK, int, WPARAM, LPARAM); 


__attribute((__stdcall__)) BOOL ChangeMenuA(HMENU, UINT, LPCSTR, UINT, UINT); 
__attribute((__stdcall__)) BOOL ChangeMenuW(HMENU, UINT, LPCWSTR, UINT, UINT); 


__attribute((__stdcall__)) LPSTR CharLowerA(LPSTR); 
__attribute((__stdcall__)) LPWSTR CharLowerW(LPWSTR); 


__attribute((__stdcall__)) DWORD CharLowerBuffA(LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD CharLowerBuffW(LPWSTR, DWORD); 


__attribute((__stdcall__)) LPSTR CharNextA(LPCSTR); 
__attribute((__stdcall__)) LPWSTR CharNextW(LPCWSTR); 
__attribute((__stdcall__)) LPSTR CharNextExA(WORD, LPCSTR, DWORD); 


__attribute((__stdcall__)) LPSTR CharPrevA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) LPWSTR CharPrevW(LPCWSTR, LPCWSTR); 
__attribute((__stdcall__)) LPSTR CharPrevExA(WORD, LPCSTR, LPCSTR, DWORD); 


__attribute((__stdcall__)) BOOL CharToOemA(LPCSTR, LPSTR); 
__attribute((__stdcall__)) BOOL CharToOemW(LPCWSTR, LPSTR); 


__attribute((__stdcall__)) BOOL CharToOemBuffA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) BOOL CharToOemBuffW(LPCWSTR, LPSTR, DWORD); 


__attribute((__stdcall__)) LPSTR CharUpperA(LPSTR); 
__attribute((__stdcall__)) LPWSTR CharUpperW(LPWSTR); 


__attribute((__stdcall__)) DWORD CharUpperBuffA(LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD CharUpperBuffW(LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL CheckDlgButton(HWND, int, UINT); 
__attribute((__stdcall__)) DWORD CheckMenuItem(HMENU, UINT, UINT); 
__attribute((__stdcall__)) BOOL CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT); 
__attribute((__stdcall__)) BOOL CheckRadioButton(HWND, int, int, int); 
__attribute((__stdcall__)) HWND ChildWindowFromPoint(HWND, POINT); 
__attribute((__stdcall__)) HWND ChildWindowFromPointEx(HWND, POINT, UINT); 
__attribute((__stdcall__)) BOOL ClientToScreen(HWND, LPPOINT); 
__attribute((__stdcall__)) BOOL ClipCursor(LPCRECT); 
__attribute((__stdcall__)) BOOL CloseClipboard(); 
__attribute((__stdcall__)) BOOL CloseDesktop(HDESK); 
__attribute((__stdcall__)) BOOL CloseWindow(HWND); 
__attribute((__stdcall__)) BOOL CloseWindowStation(HWINSTA); 


__attribute((__stdcall__)) int CopyAcceleratorTableA(HACCEL, LPACCEL, int); 
__attribute((__stdcall__)) int CopyAcceleratorTableW(HACCEL, LPACCEL, int); 


__attribute((__stdcall__)) HICON CopyIcon(HICON); 
__attribute((__stdcall__)) HANDLE CopyImage(HANDLE, UINT, int, int, UINT); 
__attribute((__stdcall__)) BOOL CopyRect(LPRECT, LPCRECT); 
__attribute((__stdcall__)) int CountClipboardFormats(); 


__attribute((__stdcall__)) HACCEL CreateAcceleratorTableA(LPACCEL, int); 
__attribute((__stdcall__)) HACCEL CreateAcceleratorTableW(LPACCEL, int); 

__attribute((__stdcall__)) BOOL CreateCaret(HWND, HBITMAP, int, int); 
__attribute((__stdcall__)) HCURSOR CreateCursor(HINSTANCE, int, int, int, int, PCVOID, PCVOID); 
# 3549 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) HWND CreateDialogIndirectParamA(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM); 

__attribute((__stdcall__)) HWND CreateDialogIndirectParamW(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM); 


__attribute((__stdcall__)) HWND CreateDialogParamA(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM); 
__attribute((__stdcall__)) HWND CreateDialogParamW(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM); 

__attribute((__stdcall__)) HICON CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const BYTE *, const BYTE *); 
__attribute((__stdcall__)) HICON CreateIconFromResource(PBYTE, DWORD, BOOL, DWORD); 
__attribute((__stdcall__)) HICON CreateIconFromResourceEx(PBYTE, DWORD, BOOL, DWORD, int, int, UINT); 
__attribute((__stdcall__)) HICON CreateIconIndirect(PICONINFO); 


__attribute((__stdcall__)) HWND CreateMDIWindowA(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HINSTANCE, LPARAM); 
__attribute((__stdcall__)) HWND CreateMDIWindowW(LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HINSTANCE, LPARAM); 
__attribute((__stdcall__)) HMENU CreateMenu(); 
__attribute((__stdcall__)) HMENU CreatePopupMenu(); 
# 3575 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) HWND CreateWindowExA(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID); 

__attribute((__stdcall__)) HWND CreateWindowExW(DWORD, LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID); 



__attribute((__stdcall__)) HWINSTA CreateWindowStationA(LPCSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 
__attribute((__stdcall__)) HWINSTA CreateWindowStationW(LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) HDWP DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT); 


__attribute((__stdcall__)) LRESULT DefDlgProcA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT DefDlgProcW(HWND, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) LRESULT DefFrameProcA(HWND, HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT DefFrameProcW(HWND, HWND, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) LRESULT DefMDIChildProcA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT DefMDIChildProcW(HWND, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) LRESULT DefWindowProcA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT DefWindowProcW(HWND, UINT, WPARAM, LPARAM); 

__attribute((__stdcall__)) BOOL DeleteMenu(HMENU, UINT, UINT); 
__attribute((__stdcall__)) BOOL DeregisterShellHookWindow(HWND); 
__attribute((__stdcall__)) BOOL DestroyAcceleratorTable(HACCEL); 
__attribute((__stdcall__)) BOOL DestroyCaret(); 
__attribute((__stdcall__)) BOOL DestroyCursor(HCURSOR); 
__attribute((__stdcall__)) BOOL DestroyIcon(HICON); 
__attribute((__stdcall__)) BOOL DestroyMenu(HMENU); 
__attribute((__stdcall__)) BOOL DestroyWindow(HWND); 
# 3620 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) int DialogBoxIndirectParamA(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM); 
__attribute((__stdcall__)) int DialogBoxIndirectParamW(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM); 
# 3629
__attribute((__stdcall__)) int DialogBoxParamA(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM); 
__attribute((__stdcall__)) int DialogBoxParamW(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM); 



__attribute((__stdcall__)) LONG DispatchMessageA(const MSG *); 
__attribute((__stdcall__)) LONG DispatchMessageW(const MSG *); 


__attribute((__stdcall__)) int DlgDirListA(HWND, LPSTR, int, int, UINT); 
__attribute((__stdcall__)) int DlgDirListW(HWND, LPWSTR, int, int, UINT); 


__attribute((__stdcall__)) int DlgDirListComboBoxA(HWND, LPSTR, int, int, UINT); 
__attribute((__stdcall__)) int DlgDirListComboBoxW(HWND, LPWSTR, int, int, UINT); 


__attribute((__stdcall__)) BOOL DlgDirSelectComboBoxExA(HWND, LPSTR, int, int); 
__attribute((__stdcall__)) BOOL DlgDirSelectComboBoxExW(HWND, LPWSTR, int, int); 


__attribute((__stdcall__)) BOOL DlgDirSelectExA(HWND, LPSTR, int, int); 
__attribute((__stdcall__)) BOOL DlgDirSelectExW(HWND, LPWSTR, int, int); 

__attribute((__stdcall__)) BOOL DragDetect(HWND, POINT); 
__attribute((__stdcall__)) DWORD DragObject(HWND, HWND, UINT, DWORD, HCURSOR); 
__attribute((__stdcall__)) BOOL DrawAnimatedRects(HWND, int, LPCRECT, LPCRECT); 
__attribute((__stdcall__)) BOOL DrawCaption(HWND, HDC, LPCRECT, UINT); 
__attribute((__stdcall__)) BOOL DrawEdge(HDC, LPRECT, UINT, UINT); 
__attribute((__stdcall__)) BOOL DrawFocusRect(HDC, LPCRECT); 
__attribute((__stdcall__)) BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT); 
__attribute((__stdcall__)) BOOL DrawIcon(HDC, int, int, HICON); 
__attribute((__stdcall__)) BOOL DrawIconEx(HDC, int, int, HICON, int, int, UINT, HBRUSH, UINT); 
__attribute((__stdcall__)) BOOL DrawMenuBar(HWND); 


__attribute((__stdcall__)) BOOL DrawStateA(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT); 

__attribute((__stdcall__)) BOOL DrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT); 



__attribute((__stdcall__)) int DrawTextA(HDC, LPCSTR, int, LPRECT, UINT); 
__attribute((__stdcall__)) int DrawTextW(HDC, LPCWSTR, int, LPRECT, UINT); 


__attribute((__stdcall__)) int DrawTextExA(HDC, LPSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS); 
__attribute((__stdcall__)) int DrawTextExW(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS); 

__attribute((__stdcall__)) BOOL EmptyClipboard(); 
__attribute((__stdcall__)) BOOL EnableMenuItem(HMENU, UINT, UINT); 
__attribute((__stdcall__)) BOOL EnableScrollBar(HWND, UINT, UINT); 
__attribute((__stdcall__)) BOOL EnableWindow(HWND, BOOL); 
__attribute((__stdcall__)) BOOL EndDeferWindowPos(HDWP); 
__attribute((__stdcall__)) BOOL EndDialog(HWND, int); 
__attribute((__stdcall__)) BOOL EndMenu(); 
__attribute((__stdcall__)) BOOL EndPaint(HWND, const PAINTSTRUCT *); 

__attribute((__stdcall__)) BOOL EnumChildWindows(HWND, ENUMWINDOWSPROC, LPARAM); 
__attribute((__stdcall__)) UINT EnumClipboardFormats(UINT); 


__attribute((__stdcall__)) BOOL EnumDesktopsA(HWINSTA, DESKTOPENUMPROCA, LPARAM); 
__attribute((__stdcall__)) BOOL EnumDesktopsW(HWINSTA, DESKTOPENUMPROCW, LPARAM); 

__attribute((__stdcall__)) BOOL EnumDesktopWindows(HDESK, ENUMWINDOWSPROC, LPARAM); 
__attribute((__stdcall__)) BOOL EnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM); 


__attribute((__stdcall__)) int EnumPropsA(HWND, PROPENUMPROCA); 
__attribute((__stdcall__)) int EnumPropsW(HWND, PROPENUMPROCW); 


__attribute((__stdcall__)) int EnumPropsExA(HWND, PROPENUMPROCEXA, LPARAM); 
__attribute((__stdcall__)) int EnumPropsExW(HWND, PROPENUMPROCEXW, LPARAM); 


__attribute((__stdcall__)) BOOL EnumThreadWindows(DWORD, WNDENUMPROC, LPARAM); 
__attribute((__stdcall__)) BOOL EnumWindows(WNDENUMPROC, LPARAM); 


__attribute((__stdcall__)) BOOL EnumWindowStationsA(WINSTAENUMPROCA, LPARAM); 
__attribute((__stdcall__)) BOOL EnumWindowStationsW(WINSTAENUMPROCW, LPARAM); 

__attribute((__stdcall__)) BOOL EqualRect(LPCRECT, LPCRECT); 


__attribute((__stdcall__)) BOOL ExitWindowsEx(UINT, DWORD); 


__attribute((__stdcall__)) HWND FindWindowA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HWND FindWindowW(LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) HWND FindWindowExA(HWND, HWND, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HWND FindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) BOOL FlashWindow(HWND, BOOL); 

__attribute((__stdcall__)) int FrameRect(HDC, LPCRECT, HBRUSH); 
__attribute((__stdcall__)) BOOL FrameRgn(HDC, HRGN, HBRUSH, int, int); 
__attribute((__stdcall__)) HWND GetActiveWindow(); 
__attribute((__stdcall__)) HWND GetAncestor(HWND, UINT); 
__attribute((__stdcall__)) SHORT GetAsyncKeyState(int); 
__attribute((__stdcall__)) HWND GetCapture(); 
__attribute((__stdcall__)) UINT GetCaretBlinkTime(); 
__attribute((__stdcall__)) BOOL GetCaretPos(LPPOINT); 


__attribute((__stdcall__)) BOOL GetClassInfoA(HINSTANCE, LPCSTR, LPWNDCLASSA); 
__attribute((__stdcall__)) BOOL GetClassInfoW(HINSTANCE, LPCWSTR, LPWNDCLASSW); 


__attribute((__stdcall__)) BOOL GetClassInfoExA(HINSTANCE, LPCSTR, LPWNDCLASSEXA); 
__attribute((__stdcall__)) BOOL GetClassInfoExW(HINSTANCE, LPCWSTR, LPWNDCLASSEXW); 


__attribute((__stdcall__)) DWORD GetClassLongA(HWND, int); 
__attribute((__stdcall__)) DWORD GetClassLongW(HWND, int); 
# 3760 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) int GetClassNameA(HWND, LPSTR, int); 
__attribute((__stdcall__)) int GetClassNameW(HWND, LPWSTR, int); 

__attribute((__stdcall__)) WORD GetClassWord(HWND, int); 
__attribute((__stdcall__)) BOOL GetClientRect(HWND, LPRECT); 


__attribute((__stdcall__)) int GetClipboardFormatNameA(UINT, LPSTR, int); 
__attribute((__stdcall__)) int GetClipboardFormatNameW(UINT, LPWSTR, int); 

__attribute((__stdcall__)) HANDLE GetClipboardData(UINT); 
__attribute((__stdcall__)) HWND GetClipboardOwner(); 

__attribute((__stdcall__)) HWND GetClipboardViewer(); 
__attribute((__stdcall__)) BOOL GetClipCursor(LPRECT); 
__attribute((__stdcall__)) BOOL GetCursorPos(LPPOINT); 
__attribute((__stdcall__)) HDC GetDC(HWND); 
__attribute((__stdcall__)) HDC GetDCEx(HWND, HRGN, DWORD); 
__attribute((__stdcall__)) HWND GetDesktopWindow(); 
__attribute((__stdcall__)) long GetDialogBaseUnits(); 
__attribute((__stdcall__)) int GetDlgCtrlID(HWND); 
__attribute((__stdcall__)) HWND GetDlgItem(HWND, int); 
__attribute((__stdcall__)) UINT GetDlgItemInt(HWND, int, PBOOL, BOOL); 


__attribute((__stdcall__)) UINT GetDlgItemTextA(HWND, int, LPSTR, int); 
__attribute((__stdcall__)) UINT GetDlgItemTextW(HWND, int, LPWSTR, int); 

__attribute((__stdcall__)) UINT GetDoubleClickTime(); 
__attribute((__stdcall__)) HWND GetFocus(); 
__attribute((__stdcall__)) HWND GetForegroundWindow(); 
__attribute((__stdcall__)) BOOL GetIconInfo(HICON, PICONINFO); 
__attribute((__stdcall__)) BOOL GetInputState(); 
__attribute((__stdcall__)) UINT GetKBCodePage(); 
__attribute((__stdcall__)) HKL GetKeyboardLayout(DWORD); 
__attribute((__stdcall__)) UINT GetKeyboardLayoutList(int, HKL *); 


__attribute((__stdcall__)) BOOL GetKeyboardLayoutNameA(LPSTR); 
__attribute((__stdcall__)) BOOL GetKeyboardLayoutNameW(LPWSTR); 

__attribute((__stdcall__)) BOOL GetKeyboardState(PBYTE); 
__attribute((__stdcall__)) int GetKeyboardType(int); 


__attribute((__stdcall__)) int GetKeyNameTextA(LONG, LPSTR, int); 
__attribute((__stdcall__)) int GetKeyNameTextW(LONG, LPWSTR, int); 

__attribute((__stdcall__)) SHORT GetKeyState(int); 
__attribute((__stdcall__)) HWND GetLastActivePopup(HWND); 
__attribute((__stdcall__)) HMENU GetMenu(HWND); 
__attribute((__stdcall__)) LONG GetMenuCheckMarkDimensions(); 
__attribute((__stdcall__)) DWORD GetMenuContextHelpId(HMENU); 
__attribute((__stdcall__)) UINT GetMenuDefaultItem(HMENU, UINT, UINT); 
__attribute((__stdcall__)) int GetMenuItemCount(HMENU); 
__attribute((__stdcall__)) UINT GetMenuItemID(HMENU, int); 


__attribute((__stdcall__)) BOOL GetMenuItemInfoA(HMENU, UINT, BOOL, LPMENUITEMINFOA); 
__attribute((__stdcall__)) BOOL GetMenuItemInfoW(HMENU, UINT, BOOL, LPMENUITEMINFOW); 

__attribute((__stdcall__)) BOOL GetMenuItemRect(HWND, HMENU, UINT, LPRECT); 
__attribute((__stdcall__)) UINT GetMenuState(HMENU, UINT, UINT); 


__attribute((__stdcall__)) int GetMenuStringA(HMENU, UINT, LPSTR, int, UINT); 
__attribute((__stdcall__)) int GetMenuStringW(HMENU, UINT, LPWSTR, int, UINT); 


__attribute((__stdcall__)) BOOL GetMessageA(LPMSG, HWND, UINT, UINT); 
__attribute((__stdcall__)) BOOL GetMessageW(LPMSG, HWND, UINT, UINT); 

__attribute((__stdcall__)) LONG GetMessageExtraInfo(); 
__attribute((__stdcall__)) DWORD GetMessagePos(); 
__attribute((__stdcall__)) LONG GetMessageTime(); 

__attribute((__stdcall__)) HWND GetNextDlgGroupItem(HWND, HWND, BOOL); 
__attribute((__stdcall__)) HWND GetNextDlgTabItem(HWND, HWND, BOOL); 
__attribute((__stdcall__)) HWND GetOpenClipboardWindow(); 
__attribute((__stdcall__)) HWND GetParent(HWND); 
__attribute((__stdcall__)) int GetPriorityClipboardFormat(UINT *, int); 


__attribute((__stdcall__)) HANDLE GetPropA(HWND, LPCSTR); 
__attribute((__stdcall__)) HANDLE GetPropW(HWND, LPCWSTR); 

__attribute((__stdcall__)) DWORD GetQueueStatus(UINT); 
__attribute((__stdcall__)) BOOL GetScrollInfo(HWND, int, LPSCROLLINFO); 
__attribute((__stdcall__)) int GetScrollPos(HWND, int); 
__attribute((__stdcall__)) BOOL GetScrollRange(HWND, int, LPINT, LPINT); 
__attribute((__stdcall__)) HMENU GetSubMenu(HMENU, int); 
__attribute((__stdcall__)) DWORD GetSysColor(int); 
__attribute((__stdcall__)) HBRUSH GetSysColorBrush(int); 
__attribute((__stdcall__)) HMENU GetSystemMenu(HWND, BOOL); 
__attribute((__stdcall__)) int GetSystemMetrics(int); 



__attribute((__stdcall__)) DWORD GetTabbedTextExtentA(HDC, LPCSTR, int, int, LPINT); 
__attribute((__stdcall__)) DWORD GetTabbedTextExtentW(HDC, LPCWSTR, int, int, LPINT); 


__attribute((__stdcall__)) LONG GetWindowLongA(HWND, int); 
__attribute((__stdcall__)) LONG GetWindowLongW(HWND, int); 
# 3875 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) HDESK GetThreadDesktop(DWORD); 
__attribute((__stdcall__)) HWND GetTopWindow(HWND); 
__attribute((__stdcall__)) BOOL GetUpdateRect(HWND, LPRECT, BOOL); 
__attribute((__stdcall__)) int GetUpdateRgn(HWND, HRGN, BOOL); 


__attribute((__stdcall__)) BOOL GetUserObjectInformationA(HANDLE, int, PVOID, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL GetUserObjectInformationW(HANDLE, int, PVOID, DWORD, PDWORD); 

__attribute((__stdcall__)) BOOL GetUserObjectSecurity(HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD); 


__attribute((__stdcall__)) HWND GetWindow(HWND, UINT); 


__attribute((__stdcall__)) DWORD GetWindowContextHelpId(HWND); 
__attribute((__stdcall__)) HDC GetWindowDC(HWND); 
__attribute((__stdcall__)) BOOL GetWindowPlacement(HWND, WINDOWPLACEMENT *); 
__attribute((__stdcall__)) BOOL GetWindowRect(HWND, LPRECT); 
__attribute((__stdcall__)) int GetWindowRgn(HWND, HRGN); 
__attribute((__stdcall__)) WORD GetWindowWord(HWND, int); 




__attribute((__stdcall__)) int GetWindowTextA(HWND, LPSTR, int); 
__attribute((__stdcall__)) int GetWindowTextW(HWND, LPWSTR, int); 


__attribute((__stdcall__)) int GetWindowTextLengthA(HWND); 
__attribute((__stdcall__)) int GetWindowTextLengthW(HWND); 


__attribute((__stdcall__)) BOOL GetAltTabInfoA(HWND, int, PALTTABINFO, LPSTR, UINT); 
__attribute((__stdcall__)) BOOL GetAltTabInfoW(HWND, int, PALTTABINFO, LPWSTR, UINT); 

__attribute((__stdcall__)) BOOL GetComboBoxInfo(HWND, PCOMBOBOXINFO); 
__attribute((__stdcall__)) BOOL GetCursorInfo(PCURSORINFO); 

__attribute((__stdcall__)) BOOL GetLastInputInfo(PLASTINPUTINFO); 
__attribute((__stdcall__)) DWORD GetListBoxInfo(HWND); 
__attribute((__stdcall__)) BOOL GetMenuBarInfo(HWND, LONG, LONG, PMENUBARINFO); 
__attribute((__stdcall__)) BOOL GetMenuInfo(HMENU, LPMENUINFO); 

__attribute((__stdcall__)) BOOL GetWindowInfo(HWND, PWINDOWINFO); 
__attribute((__stdcall__)) BOOL GetScrollBarInfo(HWND, LONG, PSCROLLBARINFO); 


__attribute((__stdcall__)) BOOL GetMonitorInfoA(HMONITOR, LPMONITORINFO); 
__attribute((__stdcall__)) BOOL GetMonitorInfoW(HMONITOR, LPMONITORINFO); 


__attribute((__stdcall__)) UINT GetWindowModuleFileNameA(HWND, LPSTR, UINT); 
__attribute((__stdcall__)) UINT GetWindowModuleFileNameW(HWND, LPWSTR, UINT); 


__attribute((__stdcall__)) BOOL GrayStringA(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int); 
__attribute((__stdcall__)) BOOL GrayStringW(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int); 

__attribute((__stdcall__)) BOOL HideCaret(HWND); 
__attribute((__stdcall__)) BOOL HiliteMenuItem(HWND, HMENU, UINT, UINT); 
__attribute((__stdcall__)) BOOL InflateRect(LPRECT, int, int); 
__attribute((__stdcall__)) BOOL InSendMessage(); 


__attribute((__stdcall__)) BOOL InsertMenuA(HMENU, UINT, UINT, UINT, LPCSTR); 
__attribute((__stdcall__)) BOOL InsertMenuW(HMENU, UINT, UINT, UINT, LPCWSTR); 


__attribute((__stdcall__)) BOOL InsertMenuItemA(HMENU, UINT, BOOL, LPCMENUITEMINFOA); 
__attribute((__stdcall__)) BOOL InsertMenuItemW(HMENU, UINT, BOOL, LPCMENUITEMINFOW); 

__attribute((__stdcall__)) INT InternalGetWindowText(HWND, LPWSTR, INT); 
__attribute((__stdcall__)) BOOL IntersectRect(LPRECT, LPCRECT, LPCRECT); 
__attribute((__stdcall__)) BOOL InvalidateRect(HWND, LPCRECT, BOOL); 
__attribute((__stdcall__)) BOOL InvalidateRgn(HWND, HRGN, BOOL); 
__attribute((__stdcall__)) BOOL InvertRect(HDC, LPCRECT); 


__attribute((__stdcall__)) BOOL IsCharAlphaA(CHAR ch); 
__attribute((__stdcall__)) BOOL IsCharAlphaW(WCHAR); 


__attribute((__stdcall__)) BOOL IsCharAlphaNumericA(CHAR); 
__attribute((__stdcall__)) BOOL IsCharAlphaNumericW(WCHAR); 


__attribute((__stdcall__)) BOOL IsCharLowerA(CHAR); 
__attribute((__stdcall__)) BOOL IsCharLowerW(WCHAR); 


__attribute((__stdcall__)) BOOL IsCharUpperA(CHAR); 
__attribute((__stdcall__)) BOOL IsCharUpperW(WCHAR); 

__attribute((__stdcall__)) BOOL IsChild(HWND, HWND); 
__attribute((__stdcall__)) BOOL IsClipboardFormatAvailable(UINT); 
__attribute((__stdcall__)) UINT IsDlgButtonChecked(HWND, int); 


__attribute((__stdcall__)) BOOL IsDialogMessageA(HWND, LPMSG); 
__attribute((__stdcall__)) BOOL IsDialogMessageW(HWND, LPMSG); 

__attribute((__stdcall__)) BOOL IsIconic(HWND); 
__attribute((__stdcall__)) BOOL IsMenu(HMENU); 
__attribute((__stdcall__)) BOOL IsRectEmpty(LPCRECT); 
__attribute((__stdcall__)) BOOL IsWindow(HWND); 
__attribute((__stdcall__)) BOOL IsWindowEnabled(HWND); 
__attribute((__stdcall__)) BOOL IsWindowUnicode(HWND); 
__attribute((__stdcall__)) BOOL IsWindowVisible(HWND); 

__attribute((__stdcall__)) BOOL IsZoomed(HWND); 
__attribute((__stdcall__)) void keybd_event(BYTE, BYTE, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL KillTimer(HWND, UINT_PTR); 


__attribute((__stdcall__)) HACCEL LoadAcceleratorsA(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) HACCEL LoadAcceleratorsW(HINSTANCE, LPCWSTR); 


__attribute((__stdcall__)) HBITMAP LoadBitmapA(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) HBITMAP LoadBitmapW(HINSTANCE, LPCWSTR); 


__attribute((__stdcall__)) HCURSOR LoadCursorA(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) HCURSOR LoadCursorW(HINSTANCE, LPCWSTR); 


__attribute((__stdcall__)) HCURSOR LoadCursorFromFileA(LPCSTR); 
__attribute((__stdcall__)) HCURSOR LoadCursorFromFileW(LPCWSTR); 


__attribute((__stdcall__)) HICON LoadIconA(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) HICON LoadIconW(HINSTANCE, LPCWSTR); 


__attribute((__stdcall__)) HANDLE LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT); 
__attribute((__stdcall__)) HANDLE LoadImageW(HINSTANCE, LPCWSTR, UINT, int, int, UINT); 


__attribute((__stdcall__)) HKL LoadKeyboardLayoutA(LPCSTR, UINT); 
__attribute((__stdcall__)) HKL LoadKeyboardLayoutW(LPCWSTR, UINT); 


__attribute((__stdcall__)) HMENU LoadMenuA(HINSTANCE, LPCSTR); 
__attribute((__stdcall__)) HMENU LoadMenuW(HINSTANCE, LPCWSTR); 


__attribute((__stdcall__)) HMENU LoadMenuIndirectA(const MENUTEMPLATE *); 
__attribute((__stdcall__)) HMENU LoadMenuIndirectW(const MENUTEMPLATE *); 


__attribute((__stdcall__)) int LoadStringA(HINSTANCE, UINT, LPSTR, int); 
__attribute((__stdcall__)) int LoadStringW(HINSTANCE, UINT, LPWSTR, int); 

__attribute((__stdcall__)) BOOL LockWindowUpdate(HWND); 

__attribute((__stdcall__)) int LookupIconIdFromDirectory(PBYTE, BOOL); 
__attribute((__stdcall__)) int LookupIconIdFromDirectoryEx(PBYTE, BOOL, int, int, UINT); 
__attribute((__stdcall__)) BOOL MapDialogRect(HWND, LPRECT); 


__attribute((__stdcall__)) UINT MapVirtualKeyA(UINT, UINT); 
__attribute((__stdcall__)) UINT MapVirtualKeyW(UINT, UINT); 


__attribute((__stdcall__)) UINT MapVirtualKeyExA(UINT, UINT, HKL); 
__attribute((__stdcall__)) UINT MapVirtualKeyExW(UINT, UINT, HKL); 

__attribute((__stdcall__)) int MapWindowPoints(HWND, HWND, LPPOINT, UINT); 
__attribute((__stdcall__)) int MenuItemFromPoint(HWND, HMENU, POINT); 
__attribute((__stdcall__)) BOOL MessageBeep(UINT); 


__attribute((__stdcall__)) int MessageBoxA(HWND, LPCSTR, LPCSTR, UINT); 
__attribute((__stdcall__)) int MessageBoxW(HWND, LPCWSTR, LPCWSTR, UINT); 


__attribute((__stdcall__)) int MessageBoxExA(HWND, LPCSTR, LPCSTR, UINT, WORD); 
__attribute((__stdcall__)) int MessageBoxExW(HWND, LPCWSTR, LPCWSTR, UINT, WORD); 


__attribute((__stdcall__)) int MessageBoxIndirectA(const MSGBOXPARAMSA *); 
__attribute((__stdcall__)) int MessageBoxIndirectW(const MSGBOXPARAMSW *); 


__attribute((__stdcall__)) BOOL ModifyMenuA(HMENU, UINT, UINT, UINT, LPCSTR); 
__attribute((__stdcall__)) BOOL ModifyMenuW(HMENU, UINT, UINT, UINT, LPCWSTR); 

__attribute((__stdcall__)) void mouse_event(DWORD, DWORD, DWORD, DWORD, ULONG_PTR); 
__attribute((__stdcall__)) BOOL MoveWindow(HWND, int, int, int, int, BOOL); 
__attribute((__stdcall__)) DWORD MsgWaitForMultipleObjects(DWORD, const HANDLE *, BOOL, DWORD, DWORD); 
__attribute((__stdcall__)) DWORD MsgWaitForMultipleObjectsEx(DWORD, const HANDLE *, DWORD, DWORD, DWORD); 

__attribute((__stdcall__)) DWORD OemKeyScan(WORD); 


__attribute((__stdcall__)) BOOL OemToCharA(LPCSTR, LPSTR); 
__attribute((__stdcall__)) BOOL OemToCharW(LPCSTR, LPWSTR); 


__attribute((__stdcall__)) BOOL OemToCharBuffA(LPCSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) BOOL OemToCharBuffW(LPCSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL OffsetRect(LPRECT, int, int); 
__attribute((__stdcall__)) BOOL OpenClipboard(HWND); 


__attribute((__stdcall__)) HDESK OpenDesktopA(LPSTR, DWORD, BOOL, DWORD); 
__attribute((__stdcall__)) HDESK OpenDesktopW(LPWSTR, DWORD, BOOL, DWORD); 

__attribute((__stdcall__)) BOOL OpenIcon(HWND); 
__attribute((__stdcall__)) HDESK OpenInputDesktop(DWORD, BOOL, DWORD); 


__attribute((__stdcall__)) HWINSTA OpenWindowStationA(LPSTR, BOOL, DWORD); 
__attribute((__stdcall__)) HWINSTA OpenWindowStationW(LPWSTR, BOOL, DWORD); 

__attribute((__stdcall__)) BOOL PaintDesktop(HDC); 


__attribute((__stdcall__)) BOOL PeekMessageA(LPMSG, HWND, UINT, UINT, UINT); 
__attribute((__stdcall__)) BOOL PeekMessageW(LPMSG, HWND, UINT, UINT, UINT); 
# 4103
__attribute((__stdcall__)) BOOL PostMessageA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) BOOL PostMessageW(HWND, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) BOOL PostThreadMessageA(DWORD, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) BOOL PostThreadMessageW(DWORD, UINT, WPARAM, LPARAM); 

__attribute((__stdcall__)) void PostQuitMessage(int); 

__attribute((__stdcall__)) BOOL PtInRect(LPCRECT, POINT); 
__attribute((__stdcall__)) BOOL RedrawWindow(HWND, LPCRECT, HRGN, UINT); 
__attribute((__stdcall__)) HWND RealChildWindowFromPoint(HWND, POINT); 


__attribute((__stdcall__)) UINT RealGetWindowClassA(HWND, LPSTR, UINT); 
__attribute((__stdcall__)) UINT RealGetWindowClassW(HWND, LPWSTR, UINT); 


__attribute((__stdcall__)) ATOM RegisterClassA(const WNDCLASSA *); 
__attribute((__stdcall__)) ATOM RegisterClassW(const WNDCLASSW *); 


__attribute((__stdcall__)) ATOM RegisterClassExA(const WNDCLASSEXA *); 
__attribute((__stdcall__)) ATOM RegisterClassExW(const WNDCLASSEXW *); 


__attribute((__stdcall__)) UINT RegisterClipboardFormatA(LPCSTR); 
__attribute((__stdcall__)) UINT RegisterClipboardFormatW(LPCWSTR); 

__attribute((__stdcall__)) BOOL RegisterHotKey(HWND, int, UINT, UINT); 


__attribute((__stdcall__)) UINT RegisterWindowMessageA(LPCSTR); 
__attribute((__stdcall__)) UINT RegisterWindowMessageW(LPCWSTR); 

__attribute((__stdcall__)) BOOL ReleaseCapture(); 
__attribute((__stdcall__)) int ReleaseDC(HWND, HDC); 
__attribute((__stdcall__)) BOOL RemoveMenu(HMENU, UINT, UINT); 


__attribute((__stdcall__)) HANDLE RemovePropA(HWND, LPCSTR); 
__attribute((__stdcall__)) HANDLE RemovePropW(HWND, LPCWSTR); 

__attribute((__stdcall__)) BOOL ReplyMessage(LRESULT); 
__attribute((__stdcall__)) BOOL ScreenToClient(HWND, LPPOINT); 
__attribute((__stdcall__)) BOOL ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT); 
__attribute((__stdcall__)) BOOL ScrollWindow(HWND, int, int, LPCRECT, LPCRECT); 
__attribute((__stdcall__)) int ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT); 


__attribute((__stdcall__)) LONG SendDlgItemMessageA(HWND, int, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LONG SendDlgItemMessageW(HWND, int, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) LRESULT SendMessageA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) LRESULT SendMessageW(HWND, UINT, WPARAM, LPARAM); 


__attribute((__stdcall__)) BOOL SendMessageCallbackA(HWND, UINT, WPARAM, LPARAM, SENDASYNCPROC, DWORD); 
__attribute((__stdcall__)) BOOL SendMessageCallbackW(HWND, UINT, WPARAM, LPARAM, SENDASYNCPROC, DWORD); 


__attribute((__stdcall__)) LRESULT SendMessageTimeoutA(HWND, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD_PTR); 
__attribute((__stdcall__)) LRESULT SendMessageTimeoutW(HWND, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD_PTR); 


__attribute((__stdcall__)) BOOL SendNotifyMessageA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) BOOL SendNotifyMessageW(HWND, UINT, WPARAM, LPARAM); 

__attribute((__stdcall__)) HWND SetActiveWindow(HWND); 
__attribute((__stdcall__)) HWND SetCapture(HWND hWnd); 
__attribute((__stdcall__)) BOOL SetCaretBlinkTime(UINT); 
__attribute((__stdcall__)) BOOL SetCaretPos(int, int); 


__attribute((__stdcall__)) DWORD SetClassLongA(HWND, int, LONG); 
__attribute((__stdcall__)) DWORD SetClassLongW(HWND, int, LONG); 
# 4191 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) WORD SetClassWord(HWND, int, WORD); 
__attribute((__stdcall__)) HANDLE SetClipboardData(UINT, HANDLE); 
__attribute((__stdcall__)) HWND SetClipboardViewer(HWND); 
__attribute((__stdcall__)) HCURSOR SetCursor(HCURSOR); 
__attribute((__stdcall__)) BOOL SetCursorPos(int, int); 
__attribute((__stdcall__)) void SetDebugErrorLevel(DWORD); 
__attribute((__stdcall__)) BOOL SetDlgItemInt(HWND, int, UINT, BOOL); 


__attribute((__stdcall__)) BOOL SetDlgItemTextA(HWND, int, LPCSTR); 
__attribute((__stdcall__)) BOOL SetDlgItemTextW(HWND, int, LPCWSTR); 

__attribute((__stdcall__)) BOOL SetDoubleClickTime(UINT); 
__attribute((__stdcall__)) HWND SetFocus(HWND); 
__attribute((__stdcall__)) BOOL SetForegroundWindow(HWND); 
__attribute((__stdcall__)) BOOL SetKeyboardState(PBYTE); 
__attribute((__stdcall__)) BOOL SetMenu(HWND, HMENU); 
__attribute((__stdcall__)) BOOL SetMenuContextHelpId(HMENU, DWORD); 
__attribute((__stdcall__)) BOOL SetMenuDefaultItem(HMENU, UINT, UINT); 
__attribute((__stdcall__)) BOOL SetMenuInfo(HMENU, LPCMENUINFO); 
__attribute((__stdcall__)) BOOL SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP); 


__attribute((__stdcall__)) BOOL SetMenuItemInfoA(HMENU, UINT, BOOL, LPCMENUITEMINFOA); 
__attribute((__stdcall__)) BOOL SetMenuItemInfoW(HMENU, UINT, BOOL, LPCMENUITEMINFOW); 

__attribute((__stdcall__)) LPARAM SetMessageExtraInfo(LPARAM); 
__attribute((__stdcall__)) BOOL SetMessageQueue(int); 
__attribute((__stdcall__)) HWND SetParent(HWND, HWND); 
__attribute((__stdcall__)) BOOL SetProcessWindowStation(HWINSTA); 


__attribute((__stdcall__)) BOOL SetPropA(HWND, LPCSTR, HANDLE); 
__attribute((__stdcall__)) BOOL SetPropW(HWND, LPCWSTR, HANDLE); 

__attribute((__stdcall__)) BOOL SetRect(LPRECT, int, int, int, int); 
__attribute((__stdcall__)) BOOL SetRectEmpty(LPRECT); 
__attribute((__stdcall__)) int SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL); 
__attribute((__stdcall__)) int SetScrollPos(HWND, int, int, BOOL); 
__attribute((__stdcall__)) BOOL SetScrollRange(HWND, int, int, int, BOOL); 
__attribute((__stdcall__)) BOOL SetSysColors(int, const INT *, const COLORREF *); 



__attribute((__stdcall__)) BOOL SetSystemCursor(HCURSOR, DWORD); 
__attribute((__stdcall__)) BOOL SetThreadDesktop(HDESK); 
__attribute((__stdcall__)) UINT SetTimer(HWND, UINT_PTR, UINT, TIMERPROC); 


__attribute((__stdcall__)) BOOL SetUserObjectInformationA(HANDLE, int, PVOID, DWORD); 
__attribute((__stdcall__)) BOOL SetUserObjectInformationW(HANDLE, int, PVOID, DWORD); 

__attribute((__stdcall__)) BOOL SetUserObjectSecurity(HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 


__attribute((__stdcall__)) BOOL SetWindowContextHelpId(HWND, DWORD); 


__attribute((__stdcall__)) LONG SetWindowLongA(HWND, int, LONG); 
__attribute((__stdcall__)) LONG SetWindowLongW(HWND, int, LONG); 
# 4262 "d:\\mingw\\mingw\\include\\winuser.h" 3
__attribute((__stdcall__)) BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *); 
__attribute((__stdcall__)) BOOL SetWindowPos(HWND, HWND, int, int, int, int, UINT); 
__attribute((__stdcall__)) int SetWindowRgn(HWND, HRGN, BOOL); 


__attribute((__stdcall__)) HHOOK SetWindowsHookA(int, HOOKPROC); 
__attribute((__stdcall__)) HHOOK SetWindowsHookW(int, HOOKPROC); 


__attribute((__stdcall__)) HHOOK SetWindowsHookExA(int, HOOKPROC, HINSTANCE, DWORD); 
__attribute((__stdcall__)) HHOOK SetWindowsHookExW(int, HOOKPROC, HINSTANCE, DWORD); 


__attribute((__stdcall__)) BOOL SetWindowTextA(HWND, LPCSTR); 
__attribute((__stdcall__)) BOOL SetWindowTextW(HWND, LPCWSTR); 

__attribute((__stdcall__)) WORD SetWindowWord(HWND, int, WORD); 
__attribute((__stdcall__)) BOOL ShowCaret(HWND); 
__attribute((__stdcall__)) int ShowCursor(BOOL); 
__attribute((__stdcall__)) BOOL ShowOwnedPopups(HWND, BOOL); 
__attribute((__stdcall__)) BOOL ShowScrollBar(HWND, int, BOOL); 
__attribute((__stdcall__)) BOOL ShowWindow(HWND, int); 
__attribute((__stdcall__)) BOOL ShowWindowAsync(HWND, int); 
__attribute((__stdcall__)) BOOL SubtractRect(LPRECT, LPCRECT, LPCRECT); 
__attribute((__stdcall__)) BOOL SwapMouseButton(BOOL); 
__attribute((__stdcall__)) BOOL SwitchDesktop(HDESK); 


__attribute((__stdcall__)) BOOL SystemParametersInfoA(UINT, UINT, PVOID, UINT); 
__attribute((__stdcall__)) BOOL SystemParametersInfoW(UINT, UINT, PVOID, UINT); 


__attribute((__stdcall__)) LONG TabbedTextOutA(HDC, int, int, LPCSTR, int, int, LPINT, int); 
__attribute((__stdcall__)) LONG TabbedTextOutW(HDC, int, int, LPCWSTR, int, int, LPINT, int); 

__attribute((__stdcall__)) WORD TileWindows(HWND, UINT, LPCRECT, UINT, const HWND *); 
__attribute((__stdcall__)) int ToAscii(UINT, UINT, PBYTE, LPWORD, UINT); 
__attribute((__stdcall__)) int ToAsciiEx(UINT, UINT, PBYTE, LPWORD, UINT, HKL); 
__attribute((__stdcall__)) int ToUnicode(UINT, UINT, PBYTE, LPWSTR, int, UINT); 
__attribute((__stdcall__)) int ToUnicodeEx(UINT, UINT, PBYTE, LPWSTR, int, UINT, HKL); 
__attribute((__stdcall__)) BOOL TrackMouseEvent(LPTRACKMOUSEEVENT); 
__attribute((__stdcall__)) BOOL TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT); 
__attribute((__stdcall__)) BOOL TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS); 


__attribute((__stdcall__)) int TranslateAcceleratorA(HWND, HACCEL, LPMSG); 
__attribute((__stdcall__)) int TranslateAcceleratorW(HWND, HACCEL, LPMSG); 

__attribute((__stdcall__)) BOOL TranslateMDISysAccel(HWND, LPMSG); 
__attribute((__stdcall__)) BOOL TranslateMessage(const MSG *); 
__attribute((__stdcall__)) BOOL UnhookWindowsHook(int, HOOKPROC); 
__attribute((__stdcall__)) BOOL UnhookWindowsHookEx(HHOOK); 

__attribute((__stdcall__)) BOOL UnionRect(LPRECT, LPCRECT, LPCRECT); 
__attribute((__stdcall__)) BOOL UnloadKeyboardLayout(HKL); 


__attribute((__stdcall__)) BOOL UnregisterClassA(LPCSTR, HINSTANCE); 
__attribute((__stdcall__)) BOOL UnregisterClassW(LPCWSTR, HINSTANCE); 

__attribute((__stdcall__)) BOOL UnregisterHotKey(HWND, int); 
__attribute((__stdcall__)) BOOL UpdateWindow(HWND); 

__attribute((__stdcall__)) BOOL ValidateRect(HWND, LPCRECT); 
__attribute((__stdcall__)) BOOL ValidateRgn(HWND, HRGN); 


__attribute((__stdcall__)) SHORT VkKeyScanA(CHAR); 
__attribute((__stdcall__)) SHORT VkKeyScanW(WCHAR); 


__attribute((__stdcall__)) SHORT VkKeyScanExA(CHAR, HKL); 
__attribute((__stdcall__)) SHORT VkKeyScanExW(WCHAR, HKL); 

__attribute((__stdcall__)) DWORD WaitForInputIdle(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL WaitMessage(); 
__attribute((__stdcall__)) HWND WindowFromDC(HDC hDC); 
__attribute((__stdcall__)) HWND WindowFromPoint(POINT); 
__attribute((__stdcall__)) UINT WinExec(LPCSTR, UINT); 


__attribute((__stdcall__)) BOOL WinHelpA(HWND, LPCSTR, UINT, DWORD); 
__attribute((__stdcall__)) BOOL WinHelpW(HWND, LPCWSTR, UINT, DWORD); 


__attribute((__cdecl__)) int wsprintfA(LPSTR, LPCSTR, ...); 
__attribute((__cdecl__)) int wsprintfW(LPWSTR, LPCWSTR, ...); 


__attribute((__stdcall__)) int wvsprintfA(LPSTR, LPCSTR, va_list arglist); 
__attribute((__stdcall__)) int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist); 



__attribute((__stdcall__)) long BroadcastSystemMessageA(DWORD, LPDWORD, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) long BroadcastSystemMessageW(DWORD, LPDWORD, UINT, WPARAM, LPARAM); 
# 4367
typedef 
# 4360
struct tagMOUSEINPUT { 
LONG dx; 
LONG dy; 
DWORD mouseData; 
DWORD dwFlags; 
DWORD time; 
ULONG_PTR dwExtraInfo; 
} MOUSEINPUT, *PMOUSEINPUT; 
# 4375
typedef 
# 4369
struct tagKEYBDINPUT { 
WORD wVk; 
WORD wScan; 
DWORD dwFlags; 
DWORD time; 
ULONG_PTR dwExtraInfo; 
} KEYBDINPUT, *PKEYBDINPUT; 
# 4381
typedef 
# 4377
struct tagHARDWAREINPUT { 
DWORD uMsg; 
WORD wParamL; 
WORD wParamH; 
} HARDWAREINPUT, *PHARDWAREINPUT; 
# 4390
typedef 
# 4383
struct tagINPUT { 
DWORD type; 

union { MOUSEINPUT mi; 
KEYBDINPUT ki; 
HARDWAREINPUT hi; 
}; 
} INPUT, *PINPUT, *LPINPUT; 

__attribute((__stdcall__)) UINT SendInput(UINT, LPINPUT, int); 
# 4404
typedef 
# 4399
struct { UINT cbSize; 
HWND hwnd; 
DWORD dwFlags; 
UINT uCount; 
DWORD dwTimeout; 
} FLASHWINFO, *PFLASHWINFO; 
# 4412
typedef 
# 4408
struct tagTITLEBARINFO { 
DWORD cbSize; 
RECT rcTitleBar; 
DWORD rgstate[5 + 1]; 
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO; 

__attribute((__stdcall__)) BOOL GetTitleBarInfo(HWND, PTITLEBARINFO); 

__attribute((__stdcall__)) BOOL BlockInput(BOOL); 
__attribute((__stdcall__)) BOOL FlashWindowEx(PFLASHWINFO); 
__attribute((__stdcall__)) DWORD GetClipboardSequenceNumber(); 
__attribute((__stdcall__)) DWORD InSendMessageEx(LPVOID); 

__attribute((__stdcall__)) HMONITOR MonitorFromPoint(POINT, DWORD); 
__attribute((__stdcall__)) HMONITOR MonitorFromRect(LPCRECT, DWORD); 
__attribute((__stdcall__)) HMONITOR MonitorFromWindow(HWND, DWORD); 

__attribute((__stdcall__)) BOOL UnregisterDeviceNotification(HANDLE); 
# 4433
typedef 
# 4428
struct tagMOUSEMOVEPOINT { 
int x; 
int y; 
DWORD time; 
ULONG_PTR dwExtraInfo; 
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, *LPMOUSEMOVEPOINT; 

__attribute((__stdcall__)) BOOL AllowSetForegroundWindow(DWORD); 
__attribute((__stdcall__)) int GetMouseMovePointsEx(UINT, LPMOUSEMOVEPOINT, LPMOUSEMOVEPOINT, int, DWORD); 
__attribute((__stdcall__)) BOOL LockSetForegroundWindow(UINT); 
# 4450
typedef 
# 4440
struct tagGUITHREADINFO { 
DWORD cbSize; 
DWORD flags; 
HWND hwndActive; 
HWND hwndFocus; 
HWND hwndCapture; 
HWND hwndMenuOwner; 
HWND hwndMoveSize; 
HWND hwndCaret; 
RECT rcCaret; 
} GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO; 

typedef void ( __attribute((__stdcall__))*WINEVENTPROC)(HWINEVENTHOOK, DWORD, HWND, LONG, LONG, DWORD, DWORD) ; 

__attribute((__stdcall__)) BOOL AnimateWindow(HWND, DWORD, DWORD); 

__attribute((__stdcall__)) BOOL EndTask(HWND, BOOL, BOOL); 

__attribute((__stdcall__)) DWORD GetGuiResources(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL GetGUIThreadInfo(DWORD, LPGUITHREADINFO); 
__attribute((__stdcall__)) BOOL GetProcessDefaultLayout(DWORD *); 
__attribute((__stdcall__)) HWND GetShellWindow(); 

__attribute((__stdcall__)) BOOL IsHungAppWindow(HWND); 
__attribute((__stdcall__)) BOOL LockWorkStation(); 
__attribute((__stdcall__)) void NotifyWinEvent(DWORD, HWND, LONG, LONG); 


__attribute((__stdcall__)) HDEVNOTIFY RegisterDeviceNotificationA(HANDLE, LPVOID, DWORD); 
__attribute((__stdcall__)) HDEVNOTIFY RegisterDeviceNotificationW(HANDLE, LPVOID, DWORD); 

__attribute((__stdcall__)) BOOL SetLayeredWindowAttributes(HWND, COLORREF, BYTE, DWORD); 
__attribute((__stdcall__)) BOOL SetProcessDefaultLayout(DWORD); 
__attribute((__stdcall__)) HWINEVENTHOOK SetWinEventHook(UINT, UINT, HMODULE, WINEVENTPROC, DWORD, DWORD, UINT); 

__attribute((__stdcall__)) void SwitchToThisWindow(HWND, BOOL); 

__attribute((__stdcall__)) BOOL UnhookWinEvent(HWINEVENTHOOK); 
__attribute((__stdcall__)) BOOL UserHandleGrantAccess(HANDLE, HANDLE, BOOL); 
# 4666 "d:\\mingw\\mingw\\include\\winuser.h" 3
typedef 
# 4660
struct tagICONMETRICSA { 
UINT cbSize; 
int iHorzSpacing; 
int iVertSpacing; 
int iTitleWrap; 
LOGFONTA lfFont; 
} ICONMETRICSA, *LPICONMETRICSA; 
# 4674
typedef 
# 4668
struct tagICONMETRICSW { 
UINT cbSize; 
int iHorzSpacing; 
int iVertSpacing; 
int iTitleWrap; 
LOGFONTW lfFont; 
} ICONMETRICSW, *LPICONMETRICSW; 

typedef ICONMETRICSA ICONMETRICS, *LPICONMETRICS; 
# 4694
typedef 
# 4678
struct tagNONCLIENTMETRICSA { 
UINT cbSize; 
int iBorderWidth; 
int iScrollWidth; 
int iScrollHeight; 
int iCaptionWidth; 
int iCaptionHeight; 
LOGFONTA lfCaptionFont; 
int iSmCaptionWidth; 
int iSmCaptionHeight; 
LOGFONTA lfSmCaptionFont; 
int iMenuWidth; 
int iMenuHeight; 
LOGFONTA lfMenuFont; 
LOGFONTA lfStatusFont; 
LOGFONTA lfMessageFont; 
} NONCLIENTMETRICSA, *LPNONCLIENTMETRICSA; 
# 4712
typedef 
# 4696
struct tagNONCLIENTMETRICSW { 
UINT cbSize; 
int iBorderWidth; 
int iScrollWidth; 
int iScrollHeight; 
int iCaptionWidth; 
int iCaptionHeight; 
LOGFONTW lfCaptionFont; 
int iSmCaptionWidth; 
int iSmCaptionHeight; 
LOGFONTW lfSmCaptionFont; 
int iMenuWidth; 
int iMenuHeight; 
LOGFONTW lfMenuFont; 
LOGFONTW lfStatusFont; 
LOGFONTW lfMessageFont; 
} NONCLIENTMETRICSW, *LPNONCLIENTMETRICSW; 

typedef NONCLIENTMETRICSA NONCLIENTMETRICS, *LPNONCLIENTMETRICS; 


__attribute((__stdcall__)) LONG ChangeDisplaySettingsA(PDEVMODEA, DWORD); 
__attribute((__stdcall__)) LONG ChangeDisplaySettingsW(PDEVMODEW, DWORD); 


__attribute((__stdcall__)) LONG ChangeDisplaySettingsExA(LPCSTR, LPDEVMODEA, HWND, DWORD, LPVOID); 
__attribute((__stdcall__)) LONG ChangeDisplaySettingsExW(LPCWSTR, LPDEVMODEW, HWND, DWORD, LPVOID); 


__attribute((__stdcall__)) HDESK CreateDesktopA(LPCSTR, LPCSTR, LPDEVMODEA, DWORD, ACCESS_MASK, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) HDESK CreateDesktopW(LPCWSTR, LPCWSTR, LPDEVMODEW, DWORD, ACCESS_MASK, LPSECURITY_ATTRIBUTES); 



__attribute((__stdcall__)) BOOL EnumDisplayDevicesA(LPCSTR, DWORD, PDISPLAY_DEVICEA, DWORD); 
__attribute((__stdcall__)) BOOL EnumDisplayDevicesW(LPCWSTR, DWORD, PDISPLAY_DEVICEW, DWORD); 


__attribute((__stdcall__)) BOOL EnumDisplaySettingsA(LPCSTR, DWORD, PDEVMODEA); 
__attribute((__stdcall__)) BOOL EnumDisplaySettingsW(LPCWSTR, DWORD, PDEVMODEW); 


__attribute((__stdcall__)) BOOL EnumDisplaySettingsExA(LPCSTR, DWORD, LPDEVMODEA, DWORD); 
__attribute((__stdcall__)) BOOL EnumDisplaySettingsExW(LPCWSTR, DWORD, LPDEVMODEW, DWORD); 



__attribute((__stdcall__)) BOOL UpdateLayeredWindow(HWND, HDC, POINT *, SIZE *, HDC, POINT *, COLORREF, BLENDFUNCTION *, DWORD); 
# 4753
}
# 38 "d:\\mingw\\mingw\\include\\winnls.h" 3
extern "C" {
# 720 "d:\\mingw\\mingw\\include\\winnls.h" 3
typedef DWORD LCTYPE; 
typedef DWORD CALTYPE; 
typedef DWORD CALID; 
typedef DWORD LGRPID; 
typedef DWORD GEOID; 
typedef DWORD GEOTYPE; 
typedef DWORD GEOCLASS; 


typedef BOOL ( __attribute((__stdcall__))*CALINFO_ENUMPROCA)(LPSTR) ; 
typedef BOOL ( __attribute((__stdcall__))*CALINFO_ENUMPROCW)(LPWSTR) ; 


typedef BOOL ( __attribute((__stdcall__))*CALINFO_ENUMPROCEXA)(LPSTR, CALID) ; 
typedef BOOL ( __attribute((__stdcall__))*CALINFO_ENUMPROCEXW)(LPWSTR, CALID) ; 


typedef BOOL ( __attribute((__stdcall__))*LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR) ; 
typedef BOOL ( __attribute((__stdcall__))*LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR) ; 


typedef BOOL ( __attribute((__stdcall__))*LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR) ; 
typedef BOOL ( __attribute((__stdcall__))*LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR) ; 


typedef BOOL ( __attribute((__stdcall__))*UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR) ; 
typedef BOOL ( __attribute((__stdcall__))*UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR) ; 


typedef BOOL ( __attribute((__stdcall__))*LOCALE_ENUMPROCA)(LPSTR) ; 
typedef BOOL ( __attribute((__stdcall__))*LOCALE_ENUMPROCW)(LPWSTR) ; 


typedef BOOL ( __attribute((__stdcall__))*CODEPAGE_ENUMPROCA)(LPSTR) ; 
typedef BOOL ( __attribute((__stdcall__))*CODEPAGE_ENUMPROCW)(LPWSTR) ; 


typedef BOOL ( __attribute((__stdcall__))*DATEFMT_ENUMPROCA)(LPSTR) ; 
typedef BOOL ( __attribute((__stdcall__))*DATEFMT_ENUMPROCW)(LPWSTR) ; 


typedef BOOL ( __attribute((__stdcall__))*DATEFMT_ENUMPROCEXA)(LPSTR, CALID) ; 
typedef BOOL ( __attribute((__stdcall__))*DATEFMT_ENUMPROCEXW)(LPWSTR, CALID) ; 


typedef BOOL ( __attribute((__stdcall__))*TIMEFMT_ENUMPROCA)(LPSTR) ; 
typedef BOOL ( __attribute((__stdcall__))*TIMEFMT_ENUMPROCW)(LPWSTR) ; 

typedef BOOL ( __attribute((__stdcall__))*GEO_ENUMPROC)(GEOID) ; 




typedef 
# 771
enum NLS_FUNCTION { 
COMPARE_STRING = 1
} NLS_FUNCTION; 

enum SYSGEOCLASS { 
GEOCLASS_NATION = 16, 
GEOCLASS_REGION = 14
}; 

enum SYSGEOTYPE { 
GEO_NATION = 1, 
GEO_LATITUDE, 
GEO_LONGITUDE, 
GEO_ISO2, 
GEO_ISO3, 
GEO_RFC1766, 
GEO_LCID, 
GEO_FRIENDLYNAME, 
GEO_OFFICIALNAME, 
GEO_TIMEZONES, 
GEO_OFFICIALLANGUAGES
}; 
# 801
typedef 
# 797
struct _cpinfo { 
UINT MaxCharSize; 
BYTE DefaultChar[2]; 
BYTE LeadByte[12]; 
} CPINFO, *LPCPINFO; 
# 810
typedef 
# 803
struct _cpinfoexA { 
UINT MaxCharSize; 
BYTE DefaultChar[2]; 
BYTE LeadByte[12]; 
WCHAR UnicodeDefaultChar; 
UINT CodePage; 
CHAR CodePageName[260]; 
} CPINFOEXA, *LPCPINFOEXA; 
# 819
typedef 
# 812
struct _cpinfoexW { 
UINT MaxCharSize; 
BYTE DefaultChar[2]; 
BYTE LeadByte[12]; 
WCHAR UnicodeDefaultChar; 
UINT CodePage; 
WCHAR CodePageName[260]; 
} CPINFOEXW, *LPCPINFOEXW; 

typedef CPINFOEXA CPINFOEX, *LPCPINFOEX; 
# 832
typedef 
# 823
struct _currencyfmtA { 
UINT NumDigits; 
UINT LeadingZero; 
UINT Grouping; 
LPSTR lpDecimalSep; 
LPSTR lpThousandSep; 
UINT NegativeOrder; 
UINT PositiveOrder; 
LPSTR lpCurrencySymbol; 
} CURRENCYFMTA, *LPCURRENCYFMTA; 
# 843
typedef 
# 834
struct _currencyfmtW { 
UINT NumDigits; 
UINT LeadingZero; 
UINT Grouping; 
LPWSTR lpDecimalSep; 
LPWSTR lpThousandSep; 
UINT NegativeOrder; 
UINT PositiveOrder; 
LPWSTR lpCurrencySymbol; 
} CURRENCYFMTW, *LPCURRENCYFMTW; 

typedef CURRENCYFMTA CURRENCYFMT, *LPCURRENCYFMT; 
# 851
typedef 
# 847
struct nlsversioninfo { 
DWORD dwNLSVersionInfoSize; 
DWORD dwNLSVersion; 
DWORD dwDefinedVersion; 
} NLSVERSIONINFO, *LPNLSVERSIONINFO; 
# 860
typedef 
# 853
struct _numberfmtA { 
UINT NumDigits; 
UINT LeadingZero; 
UINT Grouping; 
LPSTR lpDecimalSep; 
LPSTR lpThousandSep; 
UINT NegativeOrder; 
} NUMBERFMTA, *LPNUMBERFMTA; 
# 869
typedef 
# 862
struct _numberfmtW { 
UINT NumDigits; 
UINT LeadingZero; 
UINT Grouping; 
LPWSTR lpDecimalSep; 
LPWSTR lpThousandSep; 
UINT NegativeOrder; 
} NUMBERFMTW, *LPNUMBERFMTW; 

typedef NUMBERFMTA NUMBERFMT, *LPNUMBERFMT; 


__attribute((__stdcall__)) int CompareStringA(LCID, DWORD, LPCSTR, int, LPCSTR, int); 
__attribute((__stdcall__)) int CompareStringW(LCID, DWORD, LPCWSTR, int, LPCWSTR, int); 

__attribute((__stdcall__)) LCID ConvertDefaultLocale(LCID); 


__attribute((__stdcall__)) BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA, LCID, CALID, CALTYPE); 
__attribute((__stdcall__)) BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW, LCID, CALID, CALTYPE); 


__attribute((__stdcall__)) BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA, LCID, DWORD); 
__attribute((__stdcall__)) BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW, LCID, DWORD); 


__attribute((__stdcall__)) BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA, DWORD); 
__attribute((__stdcall__)) BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW, DWORD); 

__attribute((__stdcall__)) BOOL EnumSystemGeoID(GEOCLASS, GEOID, GEO_ENUMPROC); 


__attribute((__stdcall__)) BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA, DWORD); 
__attribute((__stdcall__)) BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW, DWORD); 


__attribute((__stdcall__)) BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA, LCID, DWORD); 
__attribute((__stdcall__)) BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW, LCID, DWORD); 


__attribute((__stdcall__)) int FoldStringA(DWORD, LPCSTR, int, LPSTR, int); 
__attribute((__stdcall__)) int FoldStringW(DWORD, LPCWSTR, int, LPWSTR, int); 

__attribute((__stdcall__)) UINT GetACP(); 


__attribute((__stdcall__)) int GetCalendarInfoA(LCID, CALID, CALTYPE, LPSTR, int, LPDWORD); 
__attribute((__stdcall__)) int GetCalendarInfoW(LCID, CALID, CALTYPE, LPWSTR, int, LPDWORD); 

__attribute((__stdcall__)) BOOL GetCPInfo(UINT, LPCPINFO); 


__attribute((__stdcall__)) BOOL GetCPInfoExA(UINT, DWORD, LPCPINFOEXA); 
__attribute((__stdcall__)) BOOL GetCPInfoExW(UINT, DWORD, LPCPINFOEXW); 


__attribute((__stdcall__)) int GetCurrencyFormatA(LCID, DWORD, LPCSTR, const CURRENCYFMTA *, LPSTR, int); 
__attribute((__stdcall__)) int GetCurrencyFormatW(LCID, DWORD, LPCWSTR, const CURRENCYFMTW *, LPWSTR, int); 


__attribute((__stdcall__)) int GetDateFormatA(LCID, DWORD, const SYSTEMTIME *, LPCSTR, LPSTR, int); 
__attribute((__stdcall__)) int GetDateFormatW(LCID, DWORD, const SYSTEMTIME *, LPCWSTR, LPWSTR, int); 


__attribute((__stdcall__)) int GetGeoInfoA(GEOID, GEOTYPE, LPSTR, int, LANGID); 
__attribute((__stdcall__)) int GetGeoInfoW(GEOID, GEOTYPE, LPWSTR, int, LANGID); 


__attribute((__stdcall__)) int GetLocaleInfoA(LCID, LCTYPE, LPSTR, int); 
__attribute((__stdcall__)) int GetLocaleInfoW(LCID, LCTYPE, LPWSTR, int); 

__attribute((__stdcall__)) BOOL GetNLSVersion(NLS_FUNCTION, LCID, LPNLSVERSIONINFO); 


__attribute((__stdcall__)) int GetNumberFormatA(LCID, DWORD, LPCSTR, const NUMBERFMTA *, LPSTR, int); 
__attribute((__stdcall__)) int GetNumberFormatW(LCID, DWORD, LPCWSTR, const NUMBERFMTW *, LPWSTR, int); 

__attribute((__stdcall__)) UINT GetOEMCP(); 

__attribute((__stdcall__)) BOOL GetStringTypeA(LCID, DWORD, LPCSTR, int, LPWORD); 
__attribute((__stdcall__)) BOOL GetStringTypeW(DWORD, LPCWSTR, int, LPWORD); 


__attribute((__stdcall__)) BOOL GetStringTypeExA(LCID, DWORD, LPCSTR, int, LPWORD); 
__attribute((__stdcall__)) BOOL GetStringTypeExW(LCID, DWORD, LPCWSTR, int, LPWORD); 

__attribute((__stdcall__)) LANGID GetSystemDefaultLangID(); 
__attribute((__stdcall__)) LCID GetSystemDefaultLCID(); 
__attribute((__stdcall__)) LCID GetThreadLocale(); 


__attribute((__stdcall__)) int GetTimeFormatA(LCID, DWORD, const SYSTEMTIME *, LPCSTR, LPSTR, int); 
__attribute((__stdcall__)) int GetTimeFormatW(LCID, DWORD, const SYSTEMTIME *, LPCWSTR, LPWSTR, int); 

__attribute((__stdcall__)) LANGID GetUserDefaultLangID(); 
__attribute((__stdcall__)) LCID GetUserDefaultLCID(); 
__attribute((__stdcall__)) GEOID GetUserGeoID(GEOCLASS); 
__attribute((__stdcall__)) BOOL IsDBCSLeadByte(BYTE); 
__attribute((__stdcall__)) BOOL IsDBCSLeadByteEx(UINT, BYTE); 
__attribute((__stdcall__)) BOOL IsNLSDefinedString(NLS_FUNCTION, DWORD, LPNLSVERSIONINFO, LPCWSTR, int); 
__attribute((__stdcall__)) BOOL IsValidCodePage(UINT); 
__attribute((__stdcall__)) BOOL IsValidLocale(LCID, DWORD); 


__attribute((__stdcall__)) int LCMapStringA(LCID, DWORD, LPCSTR, int, LPSTR, int); 
__attribute((__stdcall__)) int LCMapStringW(LCID, DWORD, LPCWSTR, int, LPWSTR, int); 

__attribute((__stdcall__)) int MultiByteToWideChar(UINT, DWORD, LPCSTR, int, LPWSTR, int); 


__attribute((__stdcall__)) int SetCalendarInfoA(LCID, CALID, CALTYPE, LPCSTR); 
__attribute((__stdcall__)) int SetCalendarInfoW(LCID, CALID, CALTYPE, LPCWSTR); 


__attribute((__stdcall__)) BOOL SetLocaleInfoA(LCID, LCTYPE, LPCSTR); 
__attribute((__stdcall__)) BOOL SetLocaleInfoW(LCID, LCTYPE, LPCWSTR); 

__attribute((__stdcall__)) BOOL SetThreadLocale(LCID); 
__attribute((__stdcall__)) BOOL SetUserGeoID(GEOID); 
__attribute((__stdcall__)) int WideCharToMultiByte(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL); 




__attribute((__stdcall__)) BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA, LCID, CALID, CALTYPE); 
__attribute((__stdcall__)) BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW, LCID, CALID, CALTYPE); 


__attribute((__stdcall__)) BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA, LCID, DWORD); 
__attribute((__stdcall__)) BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW, LCID, DWORD); 


__attribute((__stdcall__)) BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA, DWORD, LONG_PTR); 
__attribute((__stdcall__)) BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW, DWORD, LONG_PTR); 


__attribute((__stdcall__)) BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA, LGRPID, DWORD, LONG_PTR); 
__attribute((__stdcall__)) BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW, LGRPID, DWORD, LONG_PTR); 


__attribute((__stdcall__)) BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA, DWORD, LONG_PTR); 
__attribute((__stdcall__)) BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW, DWORD, LONG_PTR); 

__attribute((__stdcall__)) LANGID GetSystemDefaultUILanguage(); 
__attribute((__stdcall__)) LANGID GetUserDefaultUILanguage(); 
__attribute((__stdcall__)) BOOL IsValidLanguageGroup(LGRPID, DWORD); 
# 1017 "d:\\mingw\\mingw\\include\\winnls.h" 3
}
# 120 "d:\\mingw\\mingw\\include\\winver.h" 3
extern "C" {
# 137
typedef 
# 123
struct tagVS_FIXEDFILEINFO { 
DWORD dwSignature; 
DWORD dwStrucVersion; 
DWORD dwFileVersionMS; 
DWORD dwFileVersionLS; 
DWORD dwProductVersionMS; 
DWORD dwProductVersionLS; 
DWORD dwFileFlagsMask; 
DWORD dwFileFlags; 
DWORD dwFileOS; 
DWORD dwFileType; 
DWORD dwFileSubtype; 
DWORD dwFileDateMS; 
DWORD dwFileDateLS; 
} VS_FIXEDFILEINFO; 
# 149 "d:\\mingw\\mingw\\include\\winver.h" 3
__attribute((__stdcall__)) DWORD VerFindFileA(DWORD, LPSTR, LPSTR, LPSTR, LPSTR, PUINT, LPSTR, PUINT); 
__attribute((__stdcall__)) DWORD VerFindFileW(DWORD, LPWSTR, LPWSTR, LPWSTR, LPWSTR, PUINT, LPWSTR, PUINT); 


__attribute((__stdcall__)) DWORD VerInstallFileA(DWORD, LPSTR, LPSTR, LPSTR, LPSTR, LPSTR, LPSTR, PUINT); 
__attribute((__stdcall__)) DWORD VerInstallFileW(DWORD, LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR, LPWSTR, PUINT); 


__attribute((__stdcall__)) DWORD GetFileVersionInfoSizeA(LPCSTR, PDWORD); 
__attribute((__stdcall__)) DWORD GetFileVersionInfoSizeW(LPCWSTR, PDWORD); 


__attribute((__stdcall__)) BOOL GetFileVersionInfoA(LPCSTR, DWORD, DWORD, PVOID); 
__attribute((__stdcall__)) BOOL GetFileVersionInfoW(LPCWSTR, DWORD, DWORD, PVOID); 
# 198 "d:\\mingw\\mingw\\include\\winver.h" 3
__attribute((__stdcall__)) DWORD VerLanguageNameA(DWORD, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD VerLanguageNameW(DWORD, LPWSTR, DWORD); 


__attribute((__stdcall__)) BOOL VerQueryValueA(LPCVOID, LPCSTR, LPVOID *, PUINT); 
__attribute((__stdcall__)) BOOL VerQueryValueW(LPCVOID, LPCWSTR, LPVOID *, PUINT); 

}
# 41 "d:\\mingw\\mingw\\include\\winnetwk.h" 3
extern "C" {
# 212 "d:\\mingw\\mingw\\include\\winnetwk.h" 3
typedef 
# 203
struct _NETRESOURCEA { 
DWORD dwScope; 
DWORD dwType; 
DWORD dwDisplayType; 
DWORD dwUsage; 
LPSTR lpLocalName; 
LPSTR lpRemoteName; 
LPSTR lpComment; 
LPSTR lpProvider; 
} NETRESOURCEA, *LPNETRESOURCEA; 
# 224
typedef 
# 215
struct _NETRESOURCEW { 
DWORD dwScope; 
DWORD dwType; 
DWORD dwDisplayType; 
DWORD dwUsage; 
LPWSTR lpLocalName; 
LPWSTR lpRemoteName; 
LPWSTR lpComment; 
LPWSTR lpProvider; 
} NETRESOURCEW, *LPNETRESOURCEW; 

typedef NETRESOURCEA NETRESOURCE, *LPNETRESOURCE; 
# 235
typedef 
# 229
struct _CONNECTDLGSTRUCTA { 
DWORD cbStructure; 
HWND hwndOwner; 
LPNETRESOURCEA lpConnRes; 
DWORD dwFlags; 
DWORD dwDevNum; 
} CONNECTDLGSTRUCTA, *LPCONNECTDLGSTRUCTA; 
# 244
typedef 
# 238
struct _CONNECTDLGSTRUCTW { 
DWORD cbStructure; 
HWND hwndOwner; 
LPNETRESOURCEW lpConnRes; 
DWORD dwFlags; 
DWORD dwDevNum; 
} CONNECTDLGSTRUCTW, *LPCONNECTDLGSTRUCTW; 

typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT, *LPCONNECTDLGSTRUCT; 
# 255
typedef 
# 249
struct _DISCDLGSTRUCTA { 
DWORD cbStructure; 
HWND hwndOwner; 
LPSTR lpLocalName; 
LPSTR lpRemoteName; 
DWORD dwFlags; 
} DISCDLGSTRUCTA, *LPDISCDLGSTRUCTA; 
# 264
typedef 
# 258
struct _DISCDLGSTRUCTW { 
DWORD cbStructure; 
HWND hwndOwner; 
LPWSTR lpLocalName; 
LPWSTR lpRemoteName; 
DWORD dwFlags; 
} DISCDLGSTRUCTW, *LPDISCDLGSTRUCTW; 

typedef DISCDLGSTRUCTA DISCDLGSTRUCT, *LPDISCDLGSTRUCT; 




typedef 
# 269
struct _UNIVERSAL_NAME_INFOA { 
LPSTR lpUniversalName; 
} UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA; 




typedef 
# 274
struct _UNIVERSAL_NAME_INFOW { 
LPWSTR lpUniversalName; 
} UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW; 

typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO, *LPUNIVERSAL_NAME_INFO; 
# 285
typedef 
# 281
struct _REMOTE_NAME_INFOA { 
LPSTR lpUniversalName; 
LPSTR lpConnectionName; 
LPSTR lpRemainingPath; 
} REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA; 
# 292
typedef 
# 288
struct _REMOTE_NAME_INFOW { 
LPWSTR lpUniversalName; 
LPWSTR lpConnectionName; 
LPWSTR lpRemainingPath; 
} REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW; 

typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO, *LPREMOTE_NAME_INFO; 
# 306
typedef 
# 297
struct _NETINFOSTRUCT { 
DWORD cbStructure; 
DWORD dwProviderVersion; 
DWORD dwStatus; 
DWORD dwCharacteristics; 
DWORD dwHandle; 
WORD wNetType; 
DWORD dwPrinters; 
DWORD dwDrives; 
} NETINFOSTRUCT, *LPNETINFOSTRUCT; 


typedef UINT ( __attribute((__stdcall__))*PFNGETPROFILEPATHA)(LPCSTR, LPSTR, UINT) ; 
typedef UINT ( __attribute((__stdcall__))*PFNGETPROFILEPATHW)(LPCWSTR, LPWSTR, UINT) ; 


typedef UINT ( __attribute((__stdcall__))*PFNRECONCILEPROFILEA)(LPCSTR, LPCSTR, DWORD) ; 
typedef UINT ( __attribute((__stdcall__))*PFNRECONCILEPROFILEW)(LPCWSTR, LPCWSTR, DWORD) ; 


typedef BOOL ( __attribute((__stdcall__))*PFNPROCESSPOLICIESA)(HWND, LPCSTR, LPCSTR, LPCSTR, DWORD) ; 
typedef BOOL ( __attribute((__stdcall__))*PFNPROCESSPOLICIESW)(HWND, LPCWSTR, LPCWSTR, LPCWSTR, DWORD) ; 
# 327
typedef 
# 321
struct _NETCONNECTINFOSTRUCT { 
DWORD cbStructure; 
DWORD dwFlags; 
DWORD dwSpeed; 
DWORD dwDelay; 
DWORD dwOptDataSize; 
} NETCONNECTINFOSTRUCT, *LPNETCONNECTINFOSTRUCT; 


__attribute((__stdcall__)) DWORD WNetAddConnectionA(LPCSTR, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) DWORD WNetAddConnectionW(LPCWSTR, LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) DWORD WNetAddConnection2A(LPNETRESOURCEA, LPCSTR, LPCSTR, DWORD); 
__attribute((__stdcall__)) DWORD WNetAddConnection2W(LPNETRESOURCEW, LPCWSTR, LPCWSTR, DWORD); 


__attribute((__stdcall__)) DWORD WNetAddConnection3A(HWND, LPNETRESOURCEA, LPCSTR, LPCSTR, DWORD); 
__attribute((__stdcall__)) DWORD WNetAddConnection3W(HWND, LPNETRESOURCEW, LPCWSTR, LPCWSTR, DWORD); 


__attribute((__stdcall__)) DWORD WNetCancelConnectionA(LPCSTR, BOOL); 
__attribute((__stdcall__)) DWORD WNetCancelConnectionW(LPCWSTR, BOOL); 


__attribute((__stdcall__)) DWORD WNetCancelConnection2A(LPCSTR, DWORD, BOOL); 
__attribute((__stdcall__)) DWORD WNetCancelConnection2W(LPCWSTR, DWORD, BOOL); 


__attribute((__stdcall__)) DWORD WNetGetConnectionA(LPCSTR, LPSTR, PDWORD); 
__attribute((__stdcall__)) DWORD WNetGetConnectionW(LPCWSTR, LPWSTR, PDWORD); 


__attribute((__stdcall__)) DWORD WNetUseConnectionA(HWND, LPNETRESOURCEA, LPCSTR, LPCSTR, DWORD, LPSTR, PDWORD, PDWORD); 
__attribute((__stdcall__)) DWORD WNetUseConnectionW(HWND, LPNETRESOURCEW, LPCWSTR, LPCWSTR, DWORD, LPWSTR, PDWORD, PDWORD); 


__attribute((__stdcall__)) DWORD WNetSetConnectionA(LPCSTR, DWORD, PVOID); 
__attribute((__stdcall__)) DWORD WNetSetConnectionW(LPCWSTR, DWORD, PVOID); 

__attribute((__stdcall__)) DWORD WNetConnectionDialog(HWND, DWORD); 
__attribute((__stdcall__)) DWORD WNetDisconnectDialog(HWND, DWORD); 


__attribute((__stdcall__)) DWORD WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA); 
__attribute((__stdcall__)) DWORD WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW); 


__attribute((__stdcall__)) DWORD WNetDisconnectDialog1A(LPDISCDLGSTRUCTA); 
__attribute((__stdcall__)) DWORD WNetDisconnectDialog1W(LPDISCDLGSTRUCTW); 


__attribute((__stdcall__)) DWORD WNetOpenEnumA(DWORD, DWORD, DWORD, LPNETRESOURCEA, LPHANDLE); 
__attribute((__stdcall__)) DWORD WNetOpenEnumW(DWORD, DWORD, DWORD, LPNETRESOURCEW, LPHANDLE); 


__attribute((__stdcall__)) DWORD WNetEnumResourceA(HANDLE, PDWORD, PVOID, PDWORD); 
__attribute((__stdcall__)) DWORD WNetEnumResourceW(HANDLE, PDWORD, PVOID, PDWORD); 

__attribute((__stdcall__)) DWORD WNetCloseEnum(HANDLE); 


__attribute((__stdcall__)) DWORD WNetGetUniversalNameA(LPCSTR, DWORD, PVOID, PDWORD); 
__attribute((__stdcall__)) DWORD WNetGetUniversalNameW(LPCWSTR, DWORD, PVOID, PDWORD); 


__attribute((__stdcall__)) DWORD WNetGetUserA(LPCSTR, LPSTR, PDWORD); 
__attribute((__stdcall__)) DWORD WNetGetUserW(LPCWSTR, LPWSTR, PDWORD); 


__attribute((__stdcall__)) DWORD WNetGetProviderNameA(DWORD, LPSTR, PDWORD); 
__attribute((__stdcall__)) DWORD WNetGetProviderNameW(DWORD, LPWSTR, PDWORD); 


__attribute((__stdcall__)) DWORD WNetGetNetworkInformationA(LPCSTR, LPNETINFOSTRUCT); 
__attribute((__stdcall__)) DWORD WNetGetNetworkInformationW(LPCWSTR, LPNETINFOSTRUCT); 


__attribute((__stdcall__)) DWORD WNetGetResourceInformationA(LPNETRESOURCEA, LPVOID, LPDWORD, LPSTR *); 
__attribute((__stdcall__)) DWORD WNetGetResourceInformationW(LPNETRESOURCEW, LPVOID, LPDWORD, LPWSTR *); 


__attribute((__stdcall__)) DWORD WNetGetResourceParentA(LPNETRESOURCEA, LPVOID, LPDWORD); 
__attribute((__stdcall__)) DWORD WNetGetResourceParentW(LPNETRESOURCEW, LPVOID, LPDWORD); 


__attribute((__stdcall__)) DWORD WNetGetLastErrorA(PDWORD, LPSTR, DWORD, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD WNetGetLastErrorW(PDWORD, LPWSTR, DWORD, LPWSTR, DWORD); 


__attribute((__stdcall__)) DWORD MultinetGetConnectionPerformanceA(LPNETRESOURCEA, LPNETCONNECTINFOSTRUCT); 
__attribute((__stdcall__)) DWORD MultinetGetConnectionPerformanceW(LPNETRESOURCEW, LPNETCONNECTINFOSTRUCT); 



}
# 44 "d:\\mingw\\mingw\\include\\winreg.h" 3
extern "C" {
# 107 "d:\\mingw\\mingw\\include\\winreg.h" 3
typedef ACCESS_MASK REGSAM; 
# 114
typedef 
# 109
struct value_entA { 
LPSTR ve_valuename; 
DWORD ve_valuelen; 
DWORD ve_valueptr; 
DWORD ve_type; 
} VALENTA, *PVALENTA; 
# 121
typedef 
# 116
struct value_entW { 
LPWSTR ve_valuename; 
DWORD ve_valuelen; 
DWORD ve_valueptr; 
DWORD ve_type; 
} VALENTW, *PVALENTW; 

typedef VALENTA VALENT, *PVALENT; 


__attribute((__stdcall__)) BOOL AbortSystemShutdownA(LPCSTR); 
__attribute((__stdcall__)) BOOL AbortSystemShutdownW(LPCWSTR); 


__attribute((__stdcall__)) BOOL InitiateSystemShutdownA(LPSTR, LPSTR, DWORD, BOOL, BOOL); 
__attribute((__stdcall__)) BOOL InitiateSystemShutdownW(LPWSTR, LPWSTR, DWORD, BOOL, BOOL); 

__attribute((__stdcall__)) LONG RegCloseKey(HKEY); 


__attribute((__stdcall__)) LONG RegConnectRegistryA(LPCSTR, HKEY, PHKEY); 
__attribute((__stdcall__)) LONG RegConnectRegistryW(LPCWSTR, HKEY, PHKEY); 


__attribute((__stdcall__)) LONG RegCreateKeyA(HKEY, LPCSTR, PHKEY); 
__attribute((__stdcall__)) LONG RegCreateKeyW(HKEY, LPCWSTR, PHKEY); 


__attribute((__stdcall__)) LONG RegCreateKeyExA(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD); 



__attribute((__stdcall__)) LONG RegCreateKeyExW(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, PDWORD); 




__attribute((__stdcall__)) LONG RegDeleteKeyA(HKEY, LPCSTR); 
__attribute((__stdcall__)) LONG RegDeleteKeyW(HKEY, LPCWSTR); 


__attribute((__stdcall__)) LONG RegDeleteValueA(HKEY, LPCSTR); 
__attribute((__stdcall__)) LONG RegDeleteValueW(HKEY, LPCWSTR); 


__attribute((__stdcall__)) LONG RegDisablePredefinedCache(); 


__attribute((__stdcall__)) LONG RegEnumKeyA(HKEY, DWORD, LPSTR, DWORD); 
__attribute((__stdcall__)) LONG RegEnumKeyW(HKEY, DWORD, LPWSTR, DWORD); 


__attribute((__stdcall__)) LONG RegEnumKeyExA(HKEY, DWORD, LPSTR, PDWORD, PDWORD, LPSTR, PDWORD, PFILETIME); 


__attribute((__stdcall__)) LONG RegEnumKeyExW(HKEY, DWORD, LPWSTR, PDWORD, PDWORD, LPWSTR, PDWORD, PFILETIME); 



__attribute((__stdcall__)) LONG RegEnumValueA(HKEY, DWORD, LPSTR, PDWORD, PDWORD, PDWORD, LPBYTE, PDWORD); 


__attribute((__stdcall__)) LONG RegEnumValueW(HKEY, DWORD, LPWSTR, PDWORD, PDWORD, PDWORD, LPBYTE, PDWORD); 


__attribute((__stdcall__)) LONG RegFlushKey(HKEY); 
__attribute((__stdcall__)) LONG RegGetKeySecurity(HKEY, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, PDWORD); 



__attribute((__stdcall__)) LONG RegLoadKeyA(HKEY, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) LONG RegLoadKeyW(HKEY, LPCWSTR, LPCWSTR); 

__attribute((__stdcall__)) LONG RegNotifyChangeKeyValue(HKEY, BOOL, DWORD, HANDLE, BOOL); 


__attribute((__stdcall__)) LONG RegOpenCurrentUser(REGSAM, PHKEY); 


__attribute((__stdcall__)) LONG RegOpenKeyA(HKEY, LPCSTR, PHKEY); 
__attribute((__stdcall__)) LONG RegOpenKeyW(HKEY, LPCWSTR, PHKEY); 


__attribute((__stdcall__)) LONG RegOpenKeyExA(HKEY, LPCSTR, DWORD, REGSAM, PHKEY); 
__attribute((__stdcall__)) LONG RegOpenKeyExW(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY); 


__attribute((__stdcall__)) LONG RegOpenUserClassesRoot(HANDLE, DWORD, REGSAM, PHKEY); 


__attribute((__stdcall__)) LONG RegOverridePredefKey(HKEY, HKEY); 


__attribute((__stdcall__)) LONG RegQueryInfoKeyA(HKEY, LPSTR, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PFILETIME); 



__attribute((__stdcall__)) LONG RegQueryInfoKeyW(HKEY, LPWSTR, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PFILETIME); 




__attribute((__stdcall__)) LONG RegQueryMultipleValuesA(HKEY, PVALENTA, DWORD, LPSTR, LPDWORD); 


__attribute((__stdcall__)) LONG RegQueryMultipleValuesW(HKEY, PVALENTW, DWORD, LPWSTR, LPDWORD); 



__attribute((__stdcall__)) LONG RegQueryValueA(HKEY, LPCSTR, LPSTR, PLONG); 
__attribute((__stdcall__)) LONG RegQueryValueW(HKEY, LPCWSTR, LPWSTR, PLONG); 


__attribute((__stdcall__)) LONG RegQueryValueExA(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); 


__attribute((__stdcall__)) LONG RegQueryValueExW(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); 



__attribute((__stdcall__)) LONG RegReplaceKeyA(HKEY, LPCSTR, LPCSTR, LPCSTR); 
__attribute((__stdcall__)) LONG RegReplaceKeyW(HKEY, LPCWSTR, LPCWSTR, LPCWSTR); 


__attribute((__stdcall__)) LONG RegRestoreKeyA(HKEY, LPCSTR, DWORD); 
__attribute((__stdcall__)) LONG RegRestoreKeyW(HKEY, LPCWSTR, DWORD); 


__attribute((__stdcall__)) LONG RegSaveKeyA(HKEY, LPCSTR, LPSECURITY_ATTRIBUTES); 
__attribute((__stdcall__)) LONG RegSaveKeyW(HKEY, LPCWSTR, LPSECURITY_ATTRIBUTES); 

__attribute((__stdcall__)) LONG RegSetKeySecurity(HKEY, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 



__attribute((__stdcall__)) LONG RegSetValueA(HKEY, LPCSTR, DWORD, LPCSTR, DWORD); 
__attribute((__stdcall__)) LONG RegSetValueW(HKEY, LPCWSTR, DWORD, LPCWSTR, DWORD); 


__attribute((__stdcall__)) LONG RegSetValueExA(HKEY, LPCSTR, DWORD, DWORD, const BYTE *, DWORD); 


__attribute((__stdcall__)) LONG RegSetValueExW(HKEY, LPCWSTR, DWORD, DWORD, const BYTE *, DWORD); 



__attribute((__stdcall__)) LONG RegUnLoadKeyA(HKEY, LPCSTR); 
__attribute((__stdcall__)) LONG RegUnLoadKeyW(HKEY, LPCWSTR); 
# 360 "d:\\mingw\\mingw\\include\\winreg.h" 3
}
# 42 "d:\\mingw\\mingw\\include\\winsvc.h" 3
extern "C" {
# 139 "d:\\mingw\\mingw\\include\\winsvc.h" 3
typedef 
# 131
struct _SERVICE_STATUS { 
DWORD dwServiceType; 
DWORD dwCurrentState; 
DWORD dwControlsAccepted; 
DWORD dwWin32ExitCode; 
DWORD dwServiceSpecificExitCode; 
DWORD dwCheckPoint; 
DWORD dwWaitHint; 
} SERVICE_STATUS, *LPSERVICE_STATUS; 
# 152
typedef 
# 142
struct _SERVICE_STATUS_PROCESS { 
DWORD dwServiceType; 
DWORD dwCurrentState; 
DWORD dwControlsAccepted; 
DWORD dwWin32ExitCode; 
DWORD dwServiceSpecificExitCode; 
DWORD dwCheckPoint; 
DWORD dwWaitHint; 
DWORD dwProcessId; 
DWORD dwServiceFlags; 
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS; 




typedef 
# 155
enum _SC_STATUS_TYPE { 
SC_STATUS_PROCESS_INFO
} SC_STATUS_TYPE; 




typedef 
# 160
enum _SC_ENUM_TYPE { 
SC_ENUM_PROCESS_INFO
} SC_ENUM_TYPE; 
# 169
typedef 
# 165
struct _ENUM_SERVICE_STATUSA { 
LPSTR lpServiceName; 
LPSTR lpDisplayName; 
SERVICE_STATUS ServiceStatus; 
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA; 
# 176
typedef 
# 172
struct _ENUM_SERVICE_STATUSW { 
LPWSTR lpServiceName; 
LPWSTR lpDisplayName; 
SERVICE_STATUS ServiceStatus; 
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW; 


typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS, *LPENUM_SERVICE_STATUS; 
# 186
typedef 
# 182
struct _ENUM_SERVICE_STATUS_PROCESSA { 
LPSTR lpServiceName; 
LPSTR lpDisplayName; 
SERVICE_STATUS_PROCESS ServiceStatusProcess; 
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA; 
# 193
typedef 
# 189
struct _ENUM_SERVICE_STATUS_PROCESSW { 
LPWSTR lpServiceName; 
LPWSTR lpDisplayName; 
SERVICE_STATUS_PROCESS ServiceStatusProcess; 
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW; 


typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS, *LPENUM_SERVICE_STATUS_PROCESS; 
# 209
typedef 
# 199
struct _QUERY_SERVICE_CONFIGA { 
DWORD dwServiceType; 
DWORD dwStartType; 
DWORD dwErrorControl; 
LPSTR lpBinaryPathName; 
LPSTR lpLoadOrderGroup; 
DWORD dwTagId; 
LPSTR lpDependencies; 
LPSTR lpServiceStartName; 
LPSTR lpDisplayName; 
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA; 
# 222
typedef 
# 212
struct _QUERY_SERVICE_CONFIGW { 
DWORD dwServiceType; 
DWORD dwStartType; 
DWORD dwErrorControl; 
LPWSTR lpBinaryPathName; 
LPWSTR lpLoadOrderGroup; 
DWORD dwTagId; 
LPWSTR lpDependencies; 
LPWSTR lpServiceStartName; 
LPWSTR lpDisplayName; 
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW; 


typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG, *LPQUERY_SERVICE_CONFIG; 
# 232
typedef 
# 228
struct _QUERY_SERVICE_LOCK_STATUSA { 
DWORD fIsLocked; 
LPSTR lpLockOwner; 
DWORD dwLockDuration; 
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA; 
# 239
typedef 
# 235
struct _QUERY_SERVICE_LOCK_STATUSW { 
DWORD fIsLocked; 
LPWSTR lpLockOwner; 
DWORD dwLockDuration; 
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW; 


typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS, *LPQUERY_SERVICE_LOCK_STATUS; 

typedef void ( __attribute((__stdcall__))*LPSERVICE_MAIN_FUNCTIONA)(DWORD, LPSTR *) ; 
typedef void ( __attribute((__stdcall__))*LPSERVICE_MAIN_FUNCTIONW)(DWORD, LPWSTR *) ; 

typedef LPSERVICE_MAIN_FUNCTIONA LPSERVICE_MAIN_FUNCTION; 
# 253
typedef 
# 250
struct _SERVICE_TABLE_ENTRYA { 
LPSTR lpServiceName; 
LPSERVICE_MAIN_FUNCTIONA lpServiceProc; 
} SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA; 
# 259
typedef 
# 256
struct _SERVICE_TABLE_ENTRYW { 
LPWSTR lpServiceName; 
LPSERVICE_MAIN_FUNCTIONW lpServiceProc; 
} SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW; 


typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY; 

typedef struct SC_HANDLE__ { int i; } *SC_HANDLE; 

typedef PVOID SC_LOCK; 
typedef SC_HANDLE *LPSC_HANDLE; 
typedef DWORD SERVICE_STATUS_HANDLE; 
typedef void ( __attribute((__stdcall__))*LPHANDLER_FUNCTION)(DWORD) ; 
typedef DWORD ( __attribute((__stdcall__))*LPHANDLER_FUNCTION_EX)(DWORD, DWORD, LPVOID, LPVOID) ; 




typedef 
# 273
struct _SERVICE_DESCRIPTIONA { 
LPSTR lpDescription; 
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA; 




typedef 
# 278
struct _SERVICE_DESCRIPTIONW { 
LPWSTR lpDescription; 
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW; 


typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION, *LPSERVICE_DESCRIPTION; 
# 291
typedef 
# 286
enum _SC_ACTION_TYPE { 
SC_ACTION_NONE, 
SC_ACTION_RESTART, 
SC_ACTION_REBOOT, 
SC_ACTION_RUN_COMMAND
} SC_ACTION_TYPE; 
# 297
typedef 
# 294
struct _SC_ACTION { 
SC_ACTION_TYPE Type; 
DWORD Delay; 
} SC_ACTION, *LPSC_ACTION; 
# 306
typedef 
# 300
struct _SERVICE_FAILURE_ACTIONSA { 
DWORD dwResetPeriod; 
LPSTR lpRebootMsg; 
LPSTR lpCommand; 
DWORD cActions; 
SC_ACTION *lpsaActions; 
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA; 
# 315
typedef 
# 309
struct _SERVICE_FAILURE_ACTIONSW { 
DWORD dwResetPeriod; 
LPWSTR lpRebootMsg; 
LPWSTR lpCommand; 
DWORD cActions; 
SC_ACTION *lpsaActions; 
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW; 


typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS, *LPSERVICE_FAILURE_ACTIONS; 



__attribute((__stdcall__)) BOOL ChangeServiceConfigA(SC_HANDLE, DWORD, DWORD, DWORD, LPCSTR, LPCSTR, LPDWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR); 



__attribute((__stdcall__)) BOOL ChangeServiceConfigW(SC_HANDLE, DWORD, DWORD, DWORD, LPCWSTR, LPCWSTR, LPDWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR); 
# 332
__attribute((__stdcall__)) BOOL ChangeServiceConfig2A(SC_HANDLE, DWORD, LPVOID); 
__attribute((__stdcall__)) BOOL ChangeServiceConfig2W(SC_HANDLE, DWORD, LPVOID); 

__attribute((__stdcall__)) BOOL CloseServiceHandle(SC_HANDLE); 
__attribute((__stdcall__)) BOOL ControlService(SC_HANDLE, DWORD, LPSERVICE_STATUS); 



__attribute((__stdcall__)) SC_HANDLE CreateServiceA(SC_HANDLE, LPCSTR, LPCSTR, DWORD, DWORD, DWORD, DWORD, LPCSTR, LPCSTR, PDWORD, LPCSTR, LPCSTR, LPCSTR); 



__attribute((__stdcall__)) SC_HANDLE CreateServiceW(SC_HANDLE, LPCWSTR, LPCWSTR, DWORD, DWORD, DWORD, DWORD, LPCWSTR, LPCWSTR, PDWORD, LPCWSTR, LPCWSTR, LPCWSTR); 




__attribute((__stdcall__)) BOOL DeleteService(SC_HANDLE); 



__attribute((__stdcall__)) BOOL EnumDependentServicesA(SC_HANDLE, DWORD, LPENUM_SERVICE_STATUSA, DWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL EnumDependentServicesW(SC_HANDLE, DWORD, LPENUM_SERVICE_STATUSW, DWORD, PDWORD, PDWORD); 




__attribute((__stdcall__)) BOOL EnumServicesStatusA(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSA, DWORD, PDWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL EnumServicesStatusW(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSW, DWORD, PDWORD, PDWORD, PDWORD); 
# 371
__attribute((__stdcall__)) BOOL EnumServicesStatusExA(SC_HANDLE, SC_ENUM_TYPE, DWORD, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD, LPDWORD, LPCSTR); 



__attribute((__stdcall__)) BOOL EnumServicesStatusExW(SC_HANDLE, SC_ENUM_TYPE, DWORD, DWORD, LPBYTE, DWORD, LPDWORD, LPDWORD, LPDWORD, LPCWSTR); 
# 381
__attribute((__stdcall__)) BOOL GetServiceDisplayNameA(SC_HANDLE, LPCSTR, LPSTR, PDWORD); 
__attribute((__stdcall__)) BOOL GetServiceDisplayNameW(SC_HANDLE, LPCWSTR, LPWSTR, PDWORD); 


__attribute((__stdcall__)) BOOL GetServiceKeyNameA(SC_HANDLE, LPCSTR, LPSTR, PDWORD); 
__attribute((__stdcall__)) BOOL GetServiceKeyNameW(SC_HANDLE, LPCWSTR, LPWSTR, PDWORD); 

__attribute((__stdcall__)) SC_LOCK LockServiceDatabase(SC_HANDLE); 
__attribute((__stdcall__)) BOOL NotifyBootConfigStatus(BOOL); 


__attribute((__stdcall__)) SC_HANDLE OpenSCManagerA(LPCSTR, LPCSTR, DWORD); 
__attribute((__stdcall__)) SC_HANDLE OpenSCManagerW(LPCWSTR, LPCWSTR, DWORD); 


__attribute((__stdcall__)) SC_HANDLE OpenServiceA(SC_HANDLE, LPCSTR, DWORD); 
__attribute((__stdcall__)) SC_HANDLE OpenServiceW(SC_HANDLE, LPCWSTR, DWORD); 



__attribute((__stdcall__)) BOOL QueryServiceConfigA(SC_HANDLE, LPQUERY_SERVICE_CONFIGA, DWORD, PDWORD); 

__attribute((__stdcall__)) BOOL QueryServiceConfigW(SC_HANDLE, LPQUERY_SERVICE_CONFIGW, DWORD, PDWORD); 




__attribute((__stdcall__)) BOOL QueryServiceConfig2A(SC_HANDLE, DWORD, LPBYTE, DWORD, LPDWORD); 

__attribute((__stdcall__)) BOOL QueryServiceConfig2W(SC_HANDLE, DWORD, LPBYTE, DWORD, LPDWORD); 




__attribute((__stdcall__)) BOOL QueryServiceLockStatusA(SC_HANDLE, LPQUERY_SERVICE_LOCK_STATUSA, DWORD, PDWORD); 

__attribute((__stdcall__)) BOOL QueryServiceLockStatusW(SC_HANDLE, LPQUERY_SERVICE_LOCK_STATUSW, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL QueryServiceObjectSecurity(SC_HANDLE, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, LPDWORD); 


__attribute((__stdcall__)) BOOL QueryServiceStatus(SC_HANDLE, LPSERVICE_STATUS); 

__attribute((__stdcall__)) BOOL QueryServiceStatusEx(SC_HANDLE, SC_STATUS_TYPE, LPBYTE, DWORD, LPDWORD); 




__attribute((__stdcall__)) SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR, LPHANDLER_FUNCTION); 

__attribute((__stdcall__)) SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR, LPHANDLER_FUNCTION); 




__attribute((__stdcall__)) SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR, LPHANDLER_FUNCTION_EX, LPVOID); 

__attribute((__stdcall__)) SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR, LPHANDLER_FUNCTION_EX, LPVOID); 


__attribute((__stdcall__)) BOOL SetServiceObjectSecurity(SC_HANDLE, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR); 


__attribute((__stdcall__)) BOOL SetServiceStatus(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS); 


__attribute((__stdcall__)) BOOL StartServiceA(SC_HANDLE, DWORD, LPCSTR *); 
__attribute((__stdcall__)) BOOL StartServiceW(SC_HANDLE, DWORD, LPCWSTR *); 


__attribute((__stdcall__)) BOOL StartServiceCtrlDispatcherA(LPSERVICE_TABLE_ENTRYA); 
__attribute((__stdcall__)) BOOL StartServiceCtrlDispatcherW(LPSERVICE_TABLE_ENTRYW); 

__attribute((__stdcall__)) BOOL UnlockServiceDatabase(SC_LOCK); 

}
# 8 "d:\\mingw\\mingw\\include\\dde.h" 3
extern "C" {
# 25 "d:\\mingw\\mingw\\include\\dde.h" 3
typedef 
# 23
struct { 
unsigned short bAppReturnCode:8, reserved:6, fBusy:1, fAck:1; 
} DDEACK; 



typedef 
# 26
struct { 
unsigned short reserved:14, fDeferUpd:1, fAckReq:1; 
short cfFormat; 
} DDEADVISE; 




typedef 
# 30
struct { 
unsigned short unused:12, fResponse:1, fRelease:1, reserved:1, fAckReq:1; 
short cfFormat; 
BYTE Value[1]; 
} DDEDATA; 




typedef 
# 35
struct { 
unsigned short unused:13, fRelease:1, fReserved:2; 
short cfFormat; 
BYTE Value[1]; 
} DDEPOKE; 
# 46
typedef 
# 40
struct { 
unsigned short unused:13, 
fRelease:1, 
fDeferUpd:1, 
fAckReq:1; 
short cfFormat; 
} DDELN; 
# 52
typedef 
# 48
struct { 
unsigned short unused:12, fAck:1, fRelease:1, fReserved:1, fAckReq:1; 
short cfFormat; 
BYTE rgb[1]; 
} DDEUP; 
__attribute((__stdcall__)) BOOL DdeSetQualityOfService(HWND, const SECURITY_QUALITY_OF_SERVICE *, PSECURITY_QUALITY_OF_SERVICE); 
__attribute((__stdcall__)) BOOL ImpersonateDdeClientWindow(HWND, HWND); 
__attribute((__stdcall__)) LPARAM PackDDElParam(UINT, UINT_PTR, UINT_PTR); 
__attribute((__stdcall__)) BOOL UnpackDDElParam(UINT, LPARAM, PUINT_PTR, PUINT_PTR); 
__attribute((__stdcall__)) BOOL FreeDDElParam(UINT, LPARAM); 
__attribute((__stdcall__)) LPARAM ReuseDDElParam(LPARAM, UINT, UINT, UINT_PTR, UINT_PTR); 



}
# 8 "d:\\mingw\\mingw\\include\\ddeml.h" 3
extern "C" {
# 145 "d:\\mingw\\mingw\\include\\ddeml.h" 3
typedef struct HCONVLIST__ { int i; } *HCONVLIST; 
typedef struct HCONV__ { int i; } *HCONV; 
typedef struct HSZ__ { int i; } *HSZ; 
typedef struct HDDEDATA__ { int i; } *HDDEDATA; 
__attribute((__stdcall__)) typedef HDDEDATA FNCALLBACK(UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD); 
typedef HDDEDATA ( __attribute((__stdcall__))*PFNCALLBACK)(UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, DWORD, DWORD) ; 



typedef 
# 151
struct tagHSZPAIR { 
HSZ hszSvc; 
HSZ hszTopic; 
} HSZPAIR, *PHSZPAIR; 
# 163
typedef 
# 155
struct tagCONVCONTEXT { 
UINT cb; 
UINT wFlags; 
UINT wCountryID; 
int iCodePage; 
DWORD dwLangID; 
DWORD dwSecurity; 
SECURITY_QUALITY_OF_SERVICE qos; 
} CONVCONTEXT, *PCONVCONTEXT; 
# 181
typedef 
# 164
struct tagCONVINFO { 
DWORD cb; 
DWORD hUser; 
HCONV hConvPartner; 
HSZ hszSvcPartner; 
HSZ hszServiceReq; 
HSZ hszTopic; 
HSZ hszItem; 
UINT wFmt; 
UINT wType; 
UINT wStatus; 
UINT wConvst; 
UINT wLastError; 
HCONVLIST hConvList; 
CONVCONTEXT ConvCtxt; 
HWND hwnd; 
HWND hwndPartner; 
} CONVINFO, *PCONVINFO; 
# 187
typedef 
# 182
struct tagDDEML_MSG_HOOK_DATA { 
UINT uiLo; 
UINT uiHi; 
DWORD cbData; 
DWORD Data[8]; 
} DDEML_MSG_HOOK_DATA; 
# 195
typedef 
# 188
struct tagMONHSZSTRUCT { 
UINT cb; 
BOOL fsAction; 
DWORD dwTime; 
HSZ hsz; 
HANDLE hTask; 
TCHAR str[1]; 
} MONHSZSTRUCT, *PMONHSZSTRUCT; 
# 209
typedef 
# 196
struct tagMONLINKSTRUCT { 
UINT cb; 
DWORD dwTime; 
HANDLE hTask; 
BOOL fEstablished; 
BOOL fNoData; 
HSZ hszSvc; 
HSZ hszTopic; 
HSZ hszItem; 
UINT wFmt; 
BOOL fServer; 
HCONV hConvServer; 
HCONV hConvClient; 
} MONLINKSTRUCT, *PMONLINKSTRUCT; 
# 219
typedef 
# 210
struct tagMONCONVSTRUCT { 
UINT cb; 
BOOL fConnect; 
DWORD dwTime; 
HANDLE hTask; 
HSZ hszSvc; 
HSZ hszTopic; 
HCONV hConvClient; 
HCONV hConvServer; 
} MONCONVSTRUCT, *PMONCONVSTRUCT; 
# 236
typedef 
# 220
struct tagMONCBSTRUCT { 
UINT cb; 
DWORD dwTime; 
HANDLE hTask; 
DWORD dwRet; 
UINT wType; 
UINT wFmt; 
HCONV hConv; 
HSZ hsz1; 
HSZ hsz2; 
HDDEDATA hData; 
ULONG_PTR dwData1; 
ULONG_PTR dwData2; 
CONVCONTEXT cc; 
DWORD cbData; 
DWORD Data[8]; 
} MONCBSTRUCT, *PMONCBSTRUCT; 
# 242
typedef 
# 237
struct tagMONERRSTRUCT { 
UINT cb; 
UINT wLastError; 
DWORD dwTime; 
HANDLE hTask; 
} MONERRSTRUCT, *PMONERRSTRUCT; 
# 252
typedef 
# 243
struct tagMONMSGSTRUCT { 
UINT cb; 
HWND hwndTo; 
DWORD dwTime; 
HANDLE hTask; 
UINT wMsg; 
WPARAM wParam; 
LPARAM lParam; 
DDEML_MSG_HOOK_DATA dmhd; 
} MONMSGSTRUCT, *PMONMSGSTRUCT; 

__attribute((__stdcall__)) BOOL DdeAbandonTransaction(DWORD, HCONV, DWORD); 
__attribute((__stdcall__)) PBYTE DdeAccessData(HDDEDATA, PDWORD); 
__attribute((__stdcall__)) HDDEDATA DdeAddData(HDDEDATA, PBYTE, DWORD, DWORD); 
__attribute((__stdcall__)) HDDEDATA DdeClientTransaction(PBYTE, DWORD, HCONV, HSZ, UINT, UINT, DWORD, PDWORD); 
__attribute((__stdcall__)) int DdeCmpStringHandles(HSZ, HSZ); 
__attribute((__stdcall__)) HCONV DdeConnect(DWORD, HSZ, HSZ, PCONVCONTEXT); 
__attribute((__stdcall__)) HCONVLIST DdeConnectList(DWORD, HSZ, HSZ, HCONVLIST, PCONVCONTEXT); 
__attribute((__stdcall__)) HDDEDATA DdeCreateDataHandle(DWORD, PBYTE, DWORD, DWORD, HSZ, UINT, UINT); 
__attribute((__stdcall__)) HSZ DdeCreateStringHandleA(DWORD, LPCSTR, int); 
__attribute((__stdcall__)) HSZ DdeCreateStringHandleW(DWORD, LPCWSTR, int); 
__attribute((__stdcall__)) BOOL DdeDisconnect(HCONV); 
__attribute((__stdcall__)) BOOL DdeDisconnectList(HCONVLIST); 
__attribute((__stdcall__)) BOOL DdeEnableCallback(DWORD, HCONV, UINT); 
__attribute((__stdcall__)) BOOL DdeFreeDataHandle(HDDEDATA); 
__attribute((__stdcall__)) BOOL DdeFreeStringHandle(DWORD, HSZ); 
__attribute((__stdcall__)) DWORD DdeGetData(HDDEDATA, PBYTE, DWORD, DWORD); 
__attribute((__stdcall__)) UINT DdeGetLastError(DWORD); 
__attribute((__stdcall__)) BOOL DdeImpersonateClient(HCONV); 
__attribute((__stdcall__)) UINT DdeInitializeA(PDWORD, PFNCALLBACK, DWORD, DWORD); 
__attribute((__stdcall__)) UINT DdeInitializeW(PDWORD, PFNCALLBACK, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL DdeKeepStringHandle(DWORD, HSZ); 
__attribute((__stdcall__)) HDDEDATA DdeNameService(DWORD, HSZ, HSZ, UINT); 
__attribute((__stdcall__)) BOOL DdePostAdvise(DWORD, HSZ, HSZ); 
__attribute((__stdcall__)) UINT DdeQueryConvInfo(HCONV, DWORD, PCONVINFO); 
__attribute((__stdcall__)) HCONV DdeQueryNextServer(HCONVLIST, HCONV); 
__attribute((__stdcall__)) DWORD DdeQueryStringA(DWORD, HSZ, LPSTR, DWORD, int); 
__attribute((__stdcall__)) DWORD DdeQueryStringW(DWORD, HSZ, LPWSTR, DWORD, int); 
__attribute((__stdcall__)) HCONV DdeReconnect(HCONV); 
__attribute((__stdcall__)) BOOL DdeSetUserHandle(HCONV, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL DdeUnaccessData(HDDEDATA); 
__attribute((__stdcall__)) BOOL DdeUninitialize(DWORD); 
# 312 "d:\\mingw\\mingw\\include\\ddeml.h" 3
}
# 8 "d:\\mingw\\mingw\\include\\dlgs.h" 3
extern "C" {
# 181 "d:\\mingw\\mingw\\include\\dlgs.h" 3
typedef 
# 176
struct tagCRGB { 
BYTE bRed; 
BYTE bGreen; 
BYTE bBlue; 
BYTE bExtra; 
} CRGB; 


}
# 8 "d:\\mingw\\mingw\\include\\imm.h" 3
extern "C" {
# 249 "d:\\mingw\\mingw\\include\\imm.h" 3
typedef DWORD HIMC; 
typedef DWORD HIMCC; 
typedef HKL *LPHKL; 




typedef 
# 252
struct tagCOMPOSITIONFORM { 
DWORD dwStyle; 
POINT ptCurrentPos; 
RECT rcArea; 
} COMPOSITIONFORM, *PCOMPOSITIONFORM, *LPCOMPOSITIONFORM; 
# 262
typedef 
# 257
struct tagCANDIDATEFORM { 
DWORD dwIndex; 
DWORD dwStyle; 
POINT ptCurrentPos; 
RECT rcArea; 
} CANDIDATEFORM, *PCANDIDATEFORM, *LPCANDIDATEFORM; 
# 271
typedef 
# 263
struct tagCANDIDATELIST { 
DWORD dwSize; 
DWORD dwStyle; 
DWORD dwCount; 
DWORD dwSelection; 
DWORD dwPageStart; 
DWORD dwPageSize; 
DWORD dwOffset[1]; 
} CANDIDATELIST, *PCANDIDATELIST, *LPCANDIDATELIST; 
# 278
typedef 
# 272
struct tagIMECHARPOSITION { 
DWORD dwSize; 
DWORD dwCharPos; 
POINT pt; 
UINT cLineHeight; 
RECT rcDocument; 
} IMECHARPOSITION, *PIMECHARPOSITION; 
# 288
typedef 
# 279
struct tagRECONVERTSTRING { 
DWORD dwSize; 
DWORD dwVersion; 
DWORD dwStrLen; 
DWORD dwStrOffset; 
DWORD dwCompStrLen; 
DWORD dwCompStrOffset; 
DWORD dwTargetStrLen; 
DWORD dwTargetStrOffset; 
} RECONVERTSTRING, *PRECONVERTSTRING; 



typedef 
# 289
struct tagREGISTERWORDA { 
LPSTR lpReading; 
LPSTR lpWord; 
} REGISTERWORDA, *PREGISTERWORDA, *LPREGISTERWORDA; 



typedef 
# 293
struct tagREGISTERWORDW { 
LPWSTR lpReading; 
LPWSTR lpWord; 
} REGISTERWORDW, *PREGISTERWORDW, *LPREGISTERWORDW; 



typedef 
# 297
struct tagSTYLEBUFA { 
DWORD dwStyle; 
CHAR szDescription[32]; 
} STYLEBUFA, *PSTYLEBUFA, *LPSTYLEBUFA; 



typedef 
# 301
struct tagSTYLEBUFW { 
DWORD dwStyle; 
WCHAR szDescription[32]; 
} STYLEBUFW, *PSTYLEBUFW, *LPSTYLEBUFW; 
# 315
typedef 
# 305
struct tagIMEMENUITEMINFOA { 
UINT cbSize; 
UINT fType; 
UINT fState; 
UINT wID; 
HBITMAP hbmpChecked; 
HBITMAP hbmpUnchecked; 
DWORD dwItemData; 
CHAR szString[80]; 
HBITMAP hbmpItem; 
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, *LPIMEMENUITEMINFOA; 
# 326
typedef 
# 316
struct tagIMEMENUITEMINFOW { 
UINT cbSize; 
UINT fType; 
UINT fState; 
UINT wID; 
HBITMAP hbmpChecked; 
HBITMAP hbmpUnchecked; 
DWORD dwItemData; 
WCHAR szString[80]; 
HBITMAP hbmpItem; 
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, *LPIMEMENUITEMINFOW; 
typedef int ( __attribute((__stdcall__))*REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID) ; 
typedef int ( __attribute((__stdcall__))*REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID) ; 
# 336
typedef REGISTERWORDA REGISTERWORD, *PREGISTERWORD, *LPREGISTERWORD; 
typedef STYLEBUFA STYLEBUF, *PSTYLEBUF, *LPSTYLEBUF; 
typedef IMEMENUITEMINFOA IMEMENUITEMINFO, *PIMEMENUITEMINFO, *LPIMEMENUITEMINFO; 

__attribute((__stdcall__)) HKL ImmInstallIMEA(LPCSTR, LPCSTR); 
__attribute((__stdcall__)) HKL ImmInstallIMEW(LPCWSTR, LPCWSTR); 
__attribute((__stdcall__)) HWND ImmGetDefaultIMEWnd(HWND); 
__attribute((__stdcall__)) UINT ImmGetDescriptionA(HKL, LPSTR, UINT); 
__attribute((__stdcall__)) UINT ImmGetDescriptionW(HKL, LPWSTR, UINT); 
__attribute((__stdcall__)) UINT ImmGetIMEFileNameA(HKL, LPSTR, UINT); 
__attribute((__stdcall__)) UINT ImmGetIMEFileNameW(HKL, LPWSTR, UINT); 
__attribute((__stdcall__)) DWORD ImmGetProperty(HKL, DWORD); 
__attribute((__stdcall__)) BOOL ImmIsIME(HKL); 
__attribute((__stdcall__)) BOOL ImmSimulateHotKey(HWND, DWORD); 
__attribute((__stdcall__)) HIMC ImmCreateContext(); 
__attribute((__stdcall__)) BOOL ImmDestroyContext(HIMC); 
__attribute((__stdcall__)) HIMC ImmGetContext(HWND); 
__attribute((__stdcall__)) BOOL ImmReleaseContext(HWND, HIMC); 
__attribute((__stdcall__)) HIMC ImmAssociateContext(HWND, HIMC); 
__attribute((__stdcall__)) LONG ImmGetCompositionStringA(HIMC, DWORD, PVOID, DWORD); 
__attribute((__stdcall__)) LONG ImmGetCompositionStringW(HIMC, DWORD, PVOID, DWORD); 
__attribute((__stdcall__)) BOOL ImmSetCompositionStringA(HIMC, DWORD, PCVOID, DWORD, PCVOID, DWORD); 
__attribute((__stdcall__)) BOOL ImmSetCompositionStringW(HIMC, DWORD, PCVOID, DWORD, PCVOID, DWORD); 
__attribute((__stdcall__)) DWORD ImmGetCandidateListCountA(HIMC, PDWORD); 
__attribute((__stdcall__)) DWORD ImmGetCandidateListCountW(HIMC, PDWORD); 
__attribute((__stdcall__)) DWORD ImmGetCandidateListA(HIMC, DWORD, PCANDIDATELIST, DWORD); 
__attribute((__stdcall__)) DWORD ImmGetCandidateListW(HIMC, DWORD, PCANDIDATELIST, DWORD); 
__attribute((__stdcall__)) DWORD ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD); 
__attribute((__stdcall__)) BOOL ImmGetConversionStatus(HIMC, LPDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL ImmGetOpenStatus(HIMC); 
__attribute((__stdcall__)) BOOL ImmSetOpenStatus(HIMC, BOOL); 

__attribute((__stdcall__)) BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA); 
__attribute((__stdcall__)) BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW); 
__attribute((__stdcall__)) BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA); 
__attribute((__stdcall__)) BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW); 

__attribute((__stdcall__)) BOOL ImmConfigureIMEA(HKL, HWND, DWORD, PVOID); 
__attribute((__stdcall__)) BOOL ImmConfigureIMEW(HKL, HWND, DWORD, PVOID); 
__attribute((__stdcall__)) LRESULT ImmEscapeA(HKL, HIMC, UINT, PVOID); 
__attribute((__stdcall__)) LRESULT ImmEscapeW(HKL, HIMC, UINT, PVOID); 
__attribute((__stdcall__)) DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR, PCANDIDATELIST, DWORD, UINT); 
__attribute((__stdcall__)) DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR, PCANDIDATELIST, DWORD, UINT); 
__attribute((__stdcall__)) BOOL ImmNotifyIME(HIMC, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) BOOL ImmGetStatusWindowPos(HIMC, LPPOINT); 
__attribute((__stdcall__)) BOOL ImmSetStatusWindowPos(HIMC, LPPOINT); 
__attribute((__stdcall__)) BOOL ImmGetCompositionWindow(HIMC, PCOMPOSITIONFORM); 
__attribute((__stdcall__)) BOOL ImmSetCompositionWindow(HIMC, PCOMPOSITIONFORM); 
__attribute((__stdcall__)) BOOL ImmGetCandidateWindow(HIMC, DWORD, PCANDIDATEFORM); 
__attribute((__stdcall__)) BOOL ImmSetCandidateWindow(HIMC, PCANDIDATEFORM); 
__attribute((__stdcall__)) BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM); 
__attribute((__stdcall__)) UINT ImmGetVirtualKey(HWND); 
__attribute((__stdcall__)) BOOL ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR); 
__attribute((__stdcall__)) BOOL ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR); 
__attribute((__stdcall__)) BOOL ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR); 
__attribute((__stdcall__)) BOOL ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR); 
__attribute((__stdcall__)) UINT ImmGetRegisterWordStyleA(HKL, UINT, PSTYLEBUFA); 
__attribute((__stdcall__)) UINT ImmGetRegisterWordStyleW(HKL, UINT, PSTYLEBUFW); 
__attribute((__stdcall__)) UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, PVOID); 
__attribute((__stdcall__)) UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, PVOID); 
__attribute((__stdcall__)) BOOL EnableEUDC(BOOL); 
__attribute((__stdcall__)) BOOL ImmDisableIME(DWORD); 
__attribute((__stdcall__)) DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD); 
__attribute((__stdcall__)) DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD); 
# 450 "d:\\mingw\\mingw\\include\\imm.h" 3
}
# 8 "d:\\mingw\\mingw\\include\\lzexpand.h" 3
extern "C" {
# 18 "d:\\mingw\\mingw\\include\\lzexpand.h" 3
__attribute((__stdcall__)) LONG CopyLZFile(INT, INT); 
__attribute((__stdcall__)) INT GetExpandedNameA(LPSTR, LPSTR); 
__attribute((__stdcall__)) INT GetExpandedNameW(LPWSTR, LPWSTR); 
__attribute((__stdcall__)) void LZClose(INT); 
__attribute((__stdcall__)) LONG LZCopy(INT, INT); 
__attribute((__stdcall__)) void LZDone(); 
__attribute((__stdcall__)) INT LZInit(INT); 
__attribute((__stdcall__)) INT LZOpenFileA(LPSTR, LPOFSTRUCT, WORD); 
__attribute((__stdcall__)) INT LZOpenFileW(LPWSTR, LPOFSTRUCT, WORD); 
__attribute((__stdcall__)) INT LZRead(INT, LPSTR, INT); 
__attribute((__stdcall__)) LONG LZSeek(INT, LONG, INT); 
__attribute((__stdcall__)) INT LZStart(); 
# 38 "d:\\mingw\\mingw\\include\\lzexpand.h" 3
}
# 7 "d:\\mingw\\mingw\\include\\mmsystem.h" 3
#pragma pack ( push, 1 )

extern "C" {
# 905 "d:\\mingw\\mingw\\include\\mmsystem.h" 3
typedef DWORD MCIERROR; 
typedef UINT MCIDEVICEID; 
typedef UINT ( __attribute((__stdcall__))*YIELDPROC)(MCIDEVICEID, DWORD) ; 
typedef UINT MMVERSION; 
typedef UINT MMRESULT; 
# 930
typedef 
# 910
struct mmtime_tag { 
UINT wType; 
union { 
DWORD ms; 
DWORD sample; 
DWORD cb; 
DWORD ticks; 
struct { 
BYTE hour; 
BYTE min; 
BYTE sec; 
BYTE frame; 
BYTE fps; 
BYTE dummy; 
BYTE pad[2]; 
} smpte; 
struct { 
DWORD songptrpos; 
} midi; 
} u; 
} MMTIME, *PMMTIME, *LPMMTIME; 
typedef struct HDRVR__ { int i; } *HDRVR; 




typedef 
# 932
struct tagDRVCONFIGINFO { 
DWORD dwDCISize; 
LPCWSTR lpszDCISectionName; 
LPCWSTR lpszDCIAliasName; 
} DRVCONFIGINFO, *PDRVCONFIGINFO, *LPDRVCONFIGINFO; 
# 942
typedef 
# 937
struct DRVCONFIGINFOEX { 
DWORD dwDCISize; 
LPCWSTR lpszDCISectionName; 
LPCWSTR lpszDCIAliasName; 
DWORD dnDevNode; 
} DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, *LPDRVCONFIGINFOEX; 
typedef LRESULT ( __attribute((__stdcall__))*DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM) ; 
typedef void DRVCALLBACK(HDRVR, UINT, DWORD, DWORD, DWORD) ; 
typedef DRVCALLBACK *LPDRVCALLBACK; 
typedef DRVCALLBACK *PDRVCALLBACK; 
typedef struct HWAVE__ { int i; } *HWAVE; 
typedef struct HWAVEIN__ { int i; } *HWAVEIN; 
typedef struct HWAVEOUT__ { int i; } *HWAVEOUT; 
typedef HWAVEIN *LPHWAVEIN; 
typedef HWAVEOUT *LPHWAVEOUT; 
typedef DRVCALLBACK WAVECALLBACK; 
typedef WAVECALLBACK *LPWAVECALLBACK; 
# 963
typedef 
# 954
struct wavehdr_tag { 
LPSTR lpData; 
DWORD dwBufferLength; 
DWORD dwBytesRecorded; 
DWORD dwUser; 
DWORD dwFlags; 
DWORD dwLoops; 
wavehdr_tag *lpNext; 
DWORD reserved; 
} WAVEHDR, *PWAVEHDR, *LPWAVEHDR; 
# 973
typedef 
# 964
struct tagWAVEOUTCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
DWORD dwFormats; 
WORD wChannels; 
WORD wReserved1; 
DWORD dwSupport; 
} WAVEOUTCAPSA, *PWAVEOUTCAPSA, *LPWAVEOUTCAPSA; 
# 983
typedef 
# 974
struct tagWAVEOUTCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
DWORD dwFormats; 
WORD wChannels; 
WORD wReserved1; 
DWORD dwSupport; 
} WAVEOUTCAPSW, *PWAVEOUTCAPSW, *LPWAVEOUTCAPSW; 
# 992
typedef 
# 984
struct tagWAVEINCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
DWORD dwFormats; 
WORD wChannels; 
WORD wReserved1; 
} WAVEINCAPSA, *PWAVEINCAPSA, *LPWAVEINCAPSA; 
# 1001
typedef 
# 993
struct tagWAVEINCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
DWORD dwFormats; 
WORD wChannels; 
WORD wReserved1; 
} WAVEINCAPSW, *PWAVEINCAPSW, *LPWAVEINCAPSW; 
# 1008
typedef 
# 1002
struct waveformat_tag { 
WORD wFormatTag; 
WORD nChannels; 
DWORD nSamplesPerSec; 
DWORD nAvgBytesPerSec; 
WORD nBlockAlign; 
} WAVEFORMAT, *PWAVEFORMAT, *LPWAVEFORMAT; 



typedef 
# 1009
struct pcmwaveformat_tag { 
WAVEFORMAT wf; 
WORD wBitsPerSample; 
} PCMWAVEFORMAT, *PPCMWAVEFORMAT, *LPPCMWAVEFORMAT; 
# 1024
typedef 
# 1016
struct tWAVEFORMATEX { 
WORD wFormatTag; 
WORD nChannels; 
DWORD nSamplesPerSec; 
DWORD nAvgBytesPerSec; 
WORD nBlockAlign; 
WORD wBitsPerSample; 
WORD cbSize; 
} WAVEFORMATEX, *PWAVEFORMATEX, *LPWAVEFORMATEX; 
typedef const WAVEFORMATEX *LPCWAVEFORMATEX; 

typedef struct HMIDI__ { int i; } *HMIDI; 
typedef struct HMIDIIN__ { int i; } *HMIDIIN; 
typedef struct HMIDIOUT__ { int i; } *HMIDIOUT; 
typedef struct HMIDISTRM__ { int i; } *HMIDISTRM; 
typedef HMIDI *LPHMIDI; 
typedef HMIDIIN *LPHMIDIIN; 
typedef HMIDIOUT *LPHMIDIOUT; 
typedef HMIDISTRM *LPHMIDISTRM; 
typedef DRVCALLBACK MIDICALLBACK; 
typedef MIDICALLBACK *LPMIDICALLBACK; 
typedef WORD PATCHARRAY[128]; 
typedef WORD *LPPATCHARRAY; 
typedef WORD KEYARRAY[128]; 
typedef WORD *LPKEYARRAY; 
# 1051
typedef 
# 1041
struct tagMIDIOUTCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
WORD wTechnology; 
WORD wVoices; 
WORD wNotes; 
WORD wChannelMask; 
DWORD dwSupport; 
} MIDIOUTCAPSA, *PMIDIOUTCAPSA, *LPMIDIOUTCAPSA; 
# 1062
typedef 
# 1052
struct tagMIDIOUTCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
WORD wTechnology; 
WORD wVoices; 
WORD wNotes; 
WORD wChannelMask; 
DWORD dwSupport; 
} MIDIOUTCAPSW, *PMIDIOUTCAPSW, *LPMIDIOUTCAPSW; 
# 1069
typedef 
# 1063
struct tagMIDIINCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
DWORD dwSupport; 
} MIDIINCAPSA, *PMIDIINCAPSA, *LPMIDIINCAPSA; 
# 1076
typedef 
# 1070
struct tagMIDIINCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
DWORD dwSupport; 
} MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW; 
# 1087
typedef 
# 1077
struct midihdr_tag { 
LPSTR lpData; 
DWORD dwBufferLength; 
DWORD dwBytesRecorded; 
DWORD dwUser; 
DWORD dwFlags; 
midihdr_tag *lpNext; 
DWORD reserved; 
DWORD dwOffset; 
DWORD dwReserved[8]; 
} MIDIHDR, *PMIDIHDR, *LPMIDIHDR; 
# 1093
typedef 
# 1088
struct midievent_tag { 
DWORD dwDeltaTime; 
DWORD dwStreamID; 
DWORD dwEvent; 
DWORD dwParms[1]; 
} MIDIEVENT; 




typedef 
# 1094
struct midistrmbuffver_tag { 
DWORD dwVersion; 
DWORD dwMid; 
DWORD dwOEMVersion; 
} MIDISTRMBUFFVER; 



typedef 
# 1099
struct midiproptimediv_tag { 
DWORD cbStruct; 
DWORD dwTimeDiv; 
} MIDIPROPTIMEDIV, *LPMIDIPROPTIMEDIV; 



typedef 
# 1103
struct midiproptempo_tag { 
DWORD cbStruct; 
DWORD dwTempo; 
} MIDIPROPTEMPO, *LPMIDIPROPTEMPO; 
# 1115
typedef 
# 1107
struct tagAUXCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
WORD wTechnology; 
WORD wReserved1; 
DWORD dwSupport; 
} AUXCAPSA, *PAUXCAPSA, *LPAUXCAPSA; 
# 1124
typedef 
# 1116
struct tagAUXCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
WORD wTechnology; 
WORD wReserved1; 
DWORD dwSupport; 
} AUXCAPSW, *PAUXCAPSW, *LPAUXCAPSW; 
typedef struct HMIXEROBJ__ { int i; } *HMIXEROBJ; 
typedef HMIXEROBJ *LPHMIXEROBJ; 
typedef struct HMIXER__ { int i; } *HMIXER; 
typedef HMIXER *LPHMIXER; 
# 1136
typedef 
# 1129
struct tagMIXERCAPSA { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
DWORD fdwSupport; 
DWORD cDestinations; 
} MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA; 
# 1144
typedef 
# 1137
struct tagMIXERCAPSW { 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
DWORD fdwSupport; 
DWORD cDestinations; 
} MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW; 
# 1166
typedef 
# 1145
struct tagMIXERLINEA { 
DWORD cbStruct; 
DWORD dwDestination; 
DWORD dwSource; 
DWORD dwLineID; 
DWORD fdwLine; 
DWORD dwUser; 
DWORD dwComponentType; 
DWORD cChannels; 
DWORD cConnections; 
DWORD cControls; 
CHAR szShortName[16]; 
CHAR szName[64]; 
struct { 
DWORD dwType; 
DWORD dwDeviceID; 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
CHAR szPname[32]; 
} Target; 
} MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA; 
# 1188
typedef 
# 1167
struct tagMIXERLINEW { 
DWORD cbStruct; 
DWORD dwDestination; 
DWORD dwSource; 
DWORD dwLineID; 
DWORD fdwLine; 
DWORD dwUser; 
DWORD dwComponentType; 
DWORD cChannels; 
DWORD cConnections; 
DWORD cControls; 
WCHAR szShortName[16]; 
WCHAR szName[64]; 
struct { 
DWORD dwType; 
DWORD dwDeviceID; 
WORD wMid; 
WORD wPid; 
MMVERSION vDriverVersion; 
WCHAR szPname[32]; 
} Target; 
} MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW; 
# 1213
typedef 
# 1189
struct tagMIXERCONTROLA { 
DWORD cbStruct; 
DWORD dwControlID; 
DWORD dwControlType; 
DWORD fdwControl; 
DWORD cMultipleItems; 
CHAR szShortName[16]; 
CHAR szName[64]; 
union { 
struct { 
LONG lMinimum; 
LONG lMaximum; 
}; 
struct { 
DWORD dwMinimum; 
DWORD dwMaximum; 
}; 
DWORD dwReserved[6]; 
} Bounds; 
union { 
DWORD cSteps; 
DWORD cbCustomData; 
DWORD dwReserved[6]; 
} Metrics; 
} MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA; 
# 1238
typedef 
# 1214
struct tagMIXERCONTROLW { 
DWORD cbStruct; 
DWORD dwControlID; 
DWORD dwControlType; 
DWORD fdwControl; 
DWORD cMultipleItems; 
WCHAR szShortName[16]; 
WCHAR szName[64]; 
union { 
struct { 
LONG lMinimum; 
LONG lMaximum; 
}; 
struct { 
DWORD dwMinimum; 
DWORD dwMaximum; 
}; 
DWORD dwReserved[6]; 
} Bounds; 
union { 
DWORD cSteps; 
DWORD cbCustomData; 
DWORD dwReserved[6]; 
} Metrics; 
} MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW; 
# 1249
typedef 
# 1239
struct tagMIXERLINECONTROLSA { 
DWORD cbStruct; 
DWORD dwLineID; 
union { 
DWORD dwControlID; 
DWORD dwControlType; 
}; 
DWORD cControls; 
DWORD cbmxctrl; 
LPMIXERCONTROLA pamxctrl; 
} MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA; 
# 1260
typedef 
# 1250
struct tagMIXERLINECONTROLSW { 
DWORD cbStruct; 
DWORD dwLineID; 
union { 
DWORD dwControlID; 
DWORD dwControlType; 
}; 
DWORD cControls; 
DWORD cbmxctrl; 
LPMIXERCONTROLW pamxctrl; 
} MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW; 
# 1271
typedef 
# 1261
struct tMIXERCONTROLDETAILS { 
DWORD cbStruct; 
DWORD dwControlID; 
DWORD cChannels; 
union { 
HWND hwndOwner; 
DWORD cMultipleItems; 
}; 
DWORD cbDetails; 
PVOID paDetails; 
} MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, *LPMIXERCONTROLDETAILS; 




typedef 
# 1272
struct tagMIXERCONTROLDETAILS_LISTTEXTA { 
DWORD dwParam1; 
DWORD dwParam2; 
CHAR szName[64]; 
} MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA; 




typedef 
# 1277
struct tagMIXERCONTROLDETAILS_LISTTEXTW { 
DWORD dwParam1; 
DWORD dwParam2; 
WCHAR szName[64]; 
} MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW; 


typedef 
# 1282
struct tMIXERCONTROLDETAILS_BOOLEAN { 
LONG fValue; 
} MIXERCONTROLDETAILS_BOOLEAN, *PMIXERCONTROLDETAILS_BOOLEAN, *LPMIXERCONTROLDETAILS_BOOLEAN; 


typedef 
# 1285
struct tMIXERCONTROLDETAILS_SIGNED { 
LONG lValue; 
} MIXERCONTROLDETAILS_SIGNED, *PMIXERCONTROLDETAILS_SIGNED, *LPMIXERCONTROLDETAILS_SIGNED; 


typedef 
# 1288
struct tMIXERCONTROLDETAILS_UNSIGNED { 
DWORD dwValue; 
} MIXERCONTROLDETAILS_UNSIGNED, *PMIXERCONTROLDETAILS_UNSIGNED, *LPMIXERCONTROLDETAILS_UNSIGNED; 
typedef void TIMECALLBACK(UINT, UINT, DWORD, DWORD, DWORD) ; 
typedef TIMECALLBACK *LPTIMECALLBACK; 



typedef 
# 1293
struct timecaps_tag { 
UINT wPeriodMin; 
UINT wPeriodMax; 
} TIMECAPS, *PTIMECAPS, *LPTIMECAPS; 
# 1322
typedef 
# 1297
struct tagJOYCAPSA { 
WORD wMid; 
WORD wPid; 
CHAR szPname[32]; 
UINT wXmin; 
UINT wXmax; 
UINT wYmin; 
UINT wYmax; 
UINT wZmin; 
UINT wZmax; 
UINT wNumButtons; 
UINT wPeriodMin; 
UINT wPeriodMax; 
UINT wRmin; 
UINT wRmax; 
UINT wUmin; 
UINT wUmax; 
UINT wVmin; 
UINT wVmax; 
UINT wCaps; 
UINT wMaxAxes; 
UINT wNumAxes; 
UINT wMaxButtons; 
CHAR szRegKey[32]; 
CHAR szOEMVxD[260]; 
} JOYCAPSA, *PJOYCAPSA, *LPJOYCAPSA; 
# 1348
typedef 
# 1323
struct tagJOYCAPSW { 
WORD wMid; 
WORD wPid; 
WCHAR szPname[32]; 
UINT wXmin; 
UINT wXmax; 
UINT wYmin; 
UINT wYmax; 
UINT wZmin; 
UINT wZmax; 
UINT wNumButtons; 
UINT wPeriodMin; 
UINT wPeriodMax; 
UINT wRmin; 
UINT wRmax; 
UINT wUmin; 
UINT wUmax; 
UINT wVmin; 
UINT wVmax; 
UINT wCaps; 
UINT wMaxAxes; 
UINT wNumAxes; 
UINT wMaxButtons; 
WCHAR szRegKey[32]; 
WCHAR szOEMVxD[260]; 
} JOYCAPSW, *PJOYCAPSW, *LPJOYCAPSW; 
# 1354
typedef 
# 1349
struct joyinfo_tag { 
UINT wXpos; 
UINT wYpos; 
UINT wZpos; 
UINT wButtons; 
} JOYINFO, *PJOYINFO, *LPJOYINFO; 
# 1369
typedef 
# 1355
struct joyinfoex_tag { 
DWORD dwSize; 
DWORD dwFlags; 
DWORD dwXpos; 
DWORD dwYpos; 
DWORD dwZpos; 
DWORD dwRpos; 
DWORD dwUpos; 
DWORD dwVpos; 
DWORD dwButtons; 
DWORD dwButtonNumber; 
DWORD dwPOV; 
DWORD dwReserved1; 
DWORD dwReserved2; 
} JOYINFOEX, *PJOYINFOEX, *LPJOYINFOEX; 
typedef DWORD FOURCC; 
typedef char *HPSTR; 
typedef struct HMMIO__ { int i; } *HMMIO; 
typedef LRESULT MMIOPROC(LPSTR, UINT, LPARAM, LPARAM) ; 
typedef MMIOPROC *LPMMIOPROC; 
# 1392
typedef 
# 1375
struct _MMIOINFO { 
DWORD dwFlags; 
FOURCC fccIOProc; 
LPMMIOPROC pIOProc; 
UINT wErrorRet; 
HTASK htask; 
LONG cchBuffer; 
HPSTR pchBuffer; 
HPSTR pchNext; 
HPSTR pchEndRead; 
HPSTR pchEndWrite; 
LONG lBufOffset; 
LONG lDiskOffset; 
DWORD adwInfo[3]; 
DWORD dwReserved1; 
DWORD dwReserved2; 
HMMIO hmmio; 
} MMIOINFO, *PMMIOINFO, *LPMMIOINFO; 
typedef const MMIOINFO *LPCMMIOINFO; 
# 1400
typedef 
# 1394
struct _MMCKINFO { 
FOURCC ckid; 
DWORD cksize; 
FOURCC fccType; 
DWORD dwDataOffset; 
DWORD dwFlags; 
} MMCKINFO, *PMMCKINFO, *LPMMCKINFO; 
typedef const MMCKINFO *LPCMMCKINFO; 


typedef 
# 1402
struct tagMCI_GENERIC_PARMS { 
DWORD dwCallback; 
} MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, *LPMCI_GENERIC_PARMS; 
# 1411
typedef 
# 1405
struct tagMCI_OPEN_PARMSA { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCSTR lpstrDeviceType; 
LPCSTR lpstrElementName; 
LPCSTR lpstrAlias; 
} MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA; 
# 1418
typedef 
# 1412
struct tagMCI_OPEN_PARMSW { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCWSTR lpstrDeviceType; 
LPCWSTR lpstrElementName; 
LPCWSTR lpstrAlias; 
} MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW; 




typedef 
# 1419
struct tagMCI_PLAY_PARMS { 
DWORD dwCallback; 
DWORD dwFrom; 
DWORD dwTo; 
} MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, *LPMCI_PLAY_PARMS; 



typedef 
# 1424
struct tagMCI_SEEK_PARMS { 
DWORD dwCallback; 
DWORD dwTo; 
} MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, *LPMCI_SEEK_PARMS; 
# 1433
typedef 
# 1428
struct tagMCI_STATUS_PARMS { 
DWORD dwCallback; 
DWORD dwReturn; 
DWORD dwItem; 
DWORD dwTrack; 
} MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, *LPMCI_STATUS_PARMS; 




typedef 
# 1434
struct tagMCI_INFO_PARMSA { 
DWORD dwCallback; 
LPSTR lpstrReturn; 
DWORD dwRetSize; 
} MCI_INFO_PARMSA, *LPMCI_INFO_PARMSA; 




typedef 
# 1439
struct tagMCI_INFO_PARMSW { 
DWORD dwCallback; 
LPWSTR lpstrReturn; 
DWORD dwRetSize; 
} MCI_INFO_PARMSW, *LPMCI_INFO_PARMSW; 




typedef 
# 1444
struct tagMCI_GETDEVCAPS_PARMS { 
DWORD dwCallback; 
DWORD dwReturn; 
DWORD dwItem; 
} MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, *LPMCI_GETDEVCAPS_PARMS; 
# 1455
typedef 
# 1449
struct tagMCI_SYSINFO_PARMSA { 
DWORD dwCallback; 
LPSTR lpstrReturn; 
DWORD dwRetSize; 
DWORD dwNumber; 
UINT wDeviceType; 
} MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, *LPMCI_SYSINFO_PARMSA; 
# 1462
typedef 
# 1456
struct tagMCI_SYSINFO_PARMSW { 
DWORD dwCallback; 
LPWSTR lpstrReturn; 
DWORD dwRetSize; 
DWORD dwNumber; 
UINT wDeviceType; 
} MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, *LPMCI_SYSINFO_PARMSW; 




typedef 
# 1463
struct tagMCI_SET_PARMS { 
DWORD dwCallback; 
DWORD dwTimeFormat; 
DWORD dwAudio; 
} MCI_SET_PARMS, *PMCI_SET_PARMS, *LPMCI_SET_PARMS; 




typedef 
# 1468
struct tagMCI_BREAK_PARMS { 
DWORD dwCallback; 
int nVirtKey; 
HWND hwndBreak; 
} MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, *LPMCI_BREAK_PARMS; 



typedef 
# 1473
struct tagMCI_SAVE_PARMSA { 
DWORD dwCallback; 
LPCSTR lpfilename; 
} MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, *LPMCI_SAVE_PARMSA; 



typedef 
# 1477
struct tagMCI_SAVE_PARMSW { 
DWORD dwCallback; 
LPCWSTR lpfilename; 
} MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, *LPMCI_SAVE_PARMSW; 



typedef 
# 1481
struct tagMCI_LOAD_PARMSA { 
DWORD dwCallback; 
LPCSTR lpfilename; 
} MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, *LPMCI_LOAD_PARMSA; 



typedef 
# 1485
struct tagMCI_LOAD_PARMSW { 
DWORD dwCallback; 
LPCWSTR lpfilename; 
} MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, *LPMCI_LOAD_PARMSW; 




typedef 
# 1489
struct tagMCI_RECORD_PARMS { 
DWORD dwCallback; 
DWORD dwFrom; 
DWORD dwTo; 
} MCI_RECORD_PARMS, *LPMCI_RECORD_PARMS; 
# 1499
typedef 
# 1494
struct tagMCI_VD_PLAY_PARMS { 
DWORD dwCallback; 
DWORD dwFrom; 
DWORD dwTo; 
DWORD dwSpeed; 
} MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, *LPMCI_VD_PLAY_PARMS; 



typedef 
# 1500
struct tagMCI_VD_STEP_PARMS { 
DWORD dwCallback; 
DWORD dwFrames; 
} MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, *LPMCI_VD_STEP_PARMS; 



typedef 
# 1504
struct tagMCI_VD_ESCAPE_PARMSA { 
DWORD dwCallback; 
LPCSTR lpstrCommand; 
} MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA; 



typedef 
# 1508
struct tagMCI_VD_ESCAPE_PARMSW { 
DWORD dwCallback; 
LPCWSTR lpstrCommand; 
} MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW; 
# 1519
typedef 
# 1512
struct tagMCI_WAVE_OPEN_PARMSA { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCSTR lpstrDeviceType; 
LPCSTR lpstrElementName; 
LPCSTR lpstrAlias; 
DWORD dwBufferSeconds; 
} MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA; 
# 1527
typedef 
# 1520
struct tagMCI_WAVE_OPEN_PARMSW { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCWSTR lpstrDeviceType; 
LPCWSTR lpstrElementName; 
LPCWSTR lpstrAlias; 
DWORD dwBufferSeconds; 
} MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW; 




typedef 
# 1528
struct tagMCI_WAVE_DELETE_PARMS { 
DWORD dwCallback; 
DWORD dwFrom; 
DWORD dwTo; 
} MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, *LPMCI_WAVE_DELETE_PARMS; 
# 1549
typedef 
# 1533
struct tagMCI_WAVE_SET_PARMS { 
DWORD dwCallback; 
DWORD dwTimeFormat; 
DWORD dwAudio; 
UINT wInput; 
UINT wOutput; 
WORD wFormatTag; 
WORD wReserved2; 
WORD nChannels; 
WORD wReserved3; 
DWORD nSamplesPerSec; 
DWORD nAvgBytesPerSec; 
WORD nBlockAlign; 
WORD wReserved4; 
WORD wBitsPerSample; 
WORD wReserved5; 
} MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, *LPMCI_WAVE_SET_PARMS; 

__attribute((__stdcall__)) LRESULT CloseDriver(HDRVR, LONG, LONG); 
__attribute((__stdcall__)) HDRVR OpenDriver(LPCWSTR, LPCWSTR, LONG); 
__attribute((__stdcall__)) LRESULT SendDriverMessage(HDRVR, UINT, LONG, LONG); 
__attribute((__stdcall__)) HMODULE DrvGetModuleHandle(HDRVR); 
__attribute((__stdcall__)) HMODULE GetDriverModuleHandle(HDRVR); 
__attribute((__stdcall__)) LRESULT DefDriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM); 
__attribute((__stdcall__)) UINT mmsystemGetVersion(); 

__attribute((__stdcall__)) BOOL sndPlaySoundA(LPCSTR, UINT); 
__attribute((__stdcall__)) BOOL sndPlaySoundW(LPCWSTR, UINT); 
__attribute((__stdcall__)) BOOL PlaySoundA(LPCSTR, HMODULE, DWORD); 
__attribute((__stdcall__)) BOOL PlaySoundW(LPCWSTR, HMODULE, DWORD); 
__attribute((__stdcall__)) UINT waveOutGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT waveOutGetDevCapsA(UINT, LPWAVEOUTCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutGetDevCapsW(UINT, LPWAVEOUTCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutGetVolume(HWAVEOUT, PDWORD); 
__attribute((__stdcall__)) MMRESULT waveOutSetVolume(HWAVEOUT, DWORD); 
__attribute((__stdcall__)) MMRESULT waveOutGetErrorTextA(MMRESULT, LPSTR, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutGetErrorTextW(MMRESULT, LPWSTR, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutOpen(LPHWAVEOUT, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT waveOutClose(HWAVEOUT); 
__attribute((__stdcall__)) MMRESULT waveOutPrepareHeader(HWAVEOUT, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutUnprepareHeader(HWAVEOUT, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutWrite(HWAVEOUT, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutPause(HWAVEOUT); 
__attribute((__stdcall__)) MMRESULT waveOutRestart(HWAVEOUT); 
__attribute((__stdcall__)) MMRESULT waveOutReset(HWAVEOUT); 
__attribute((__stdcall__)) MMRESULT waveOutBreakLoop(HWAVEOUT); 
__attribute((__stdcall__)) MMRESULT waveOutGetPosition(HWAVEOUT, LPMMTIME, UINT); 
__attribute((__stdcall__)) MMRESULT waveOutGetPitch(HWAVEOUT, PDWORD); 
__attribute((__stdcall__)) MMRESULT waveOutSetPitch(HWAVEOUT, DWORD); 
__attribute((__stdcall__)) MMRESULT waveOutGetPlaybackRate(HWAVEOUT, PDWORD); 
__attribute((__stdcall__)) MMRESULT waveOutSetPlaybackRate(HWAVEOUT, DWORD); 
__attribute((__stdcall__)) MMRESULT waveOutGetID(HWAVEOUT, LPUINT); 
__attribute((__stdcall__)) MMRESULT waveOutMessage(HWAVEOUT, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) UINT waveInGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT waveInGetDevCapsA(UINT, LPWAVEINCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT waveInGetDevCapsW(UINT, LPWAVEINCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT waveInGetErrorTextA(MMRESULT, LPSTR, UINT); 
__attribute((__stdcall__)) MMRESULT waveInGetErrorTextW(MMRESULT, LPWSTR, UINT); 
__attribute((__stdcall__)) MMRESULT waveInOpen(LPHWAVEIN, UINT, LPCWAVEFORMATEX, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT waveInClose(HWAVEIN); 
__attribute((__stdcall__)) MMRESULT waveInPrepareHeader(HWAVEIN, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveInUnprepareHeader(HWAVEIN, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveInAddBuffer(HWAVEIN, LPWAVEHDR, UINT); 
__attribute((__stdcall__)) MMRESULT waveInStart(HWAVEIN); 
__attribute((__stdcall__)) MMRESULT waveInStop(HWAVEIN); 
__attribute((__stdcall__)) MMRESULT waveInReset(HWAVEIN); 
__attribute((__stdcall__)) MMRESULT waveInGetPosition(HWAVEIN, LPMMTIME, UINT); 
__attribute((__stdcall__)) MMRESULT waveInGetID(HWAVEIN, LPUINT); 
__attribute((__stdcall__)) MMRESULT waveInMessage(HWAVEIN, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) UINT midiOutGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT midiStreamOpen(LPHMIDISTRM, LPUINT, DWORD, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT midiStreamClose(HMIDISTRM); 
__attribute((__stdcall__)) MMRESULT midiStreamProperty(HMIDISTRM, LPBYTE, DWORD); 
__attribute((__stdcall__)) MMRESULT midiStreamPosition(HMIDISTRM, LPMMTIME, UINT); 
__attribute((__stdcall__)) MMRESULT midiStreamOut(HMIDISTRM, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiStreamPause(HMIDISTRM); 
__attribute((__stdcall__)) MMRESULT midiStreamRestart(HMIDISTRM); 
__attribute((__stdcall__)) MMRESULT midiStreamStop(HMIDISTRM); 
__attribute((__stdcall__)) MMRESULT midiConnect(HMIDI, HMIDIOUT, PVOID); 
__attribute((__stdcall__)) MMRESULT midiDisconnect(HMIDI, HMIDIOUT, PVOID); 
__attribute((__stdcall__)) MMRESULT midiOutGetDevCapsA(UINT, LPMIDIOUTCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutGetDevCapsW(UINT, LPMIDIOUTCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutGetVolume(HMIDIOUT, PDWORD); 
__attribute((__stdcall__)) MMRESULT midiOutSetVolume(HMIDIOUT, DWORD); 
__attribute((__stdcall__)) MMRESULT midiOutGetErrorTextA(MMRESULT, LPSTR, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutGetErrorTextW(MMRESULT, LPWSTR, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutOpen(LPHMIDIOUT, UINT, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT midiOutClose(HMIDIOUT); 
__attribute((__stdcall__)) MMRESULT midiOutPrepareHeader(HMIDIOUT, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutUnprepareHeader(HMIDIOUT, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutShortMsg(HMIDIOUT, DWORD); 
__attribute((__stdcall__)) MMRESULT midiOutLongMsg(HMIDIOUT, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutReset(HMIDIOUT); 
__attribute((__stdcall__)) MMRESULT midiOutCachePatches(HMIDIOUT, UINT, LPWORD, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutCacheDrumPatches(HMIDIOUT, UINT, LPWORD, UINT); 
__attribute((__stdcall__)) MMRESULT midiOutGetID(HMIDIOUT, LPUINT); 
__attribute((__stdcall__)) MMRESULT midiOutMessage(HMIDIOUT, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) UINT midiInGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT midiInGetDevCapsA(UINT, LPMIDIINCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT midiInGetDevCapsW(UINT, LPMIDIINCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT midiInGetErrorTextA(MMRESULT, LPSTR, UINT); 
__attribute((__stdcall__)) MMRESULT midiInGetErrorTextW(MMRESULT, LPWSTR, UINT); 
__attribute((__stdcall__)) MMRESULT midiInOpen(LPHMIDIIN, UINT, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT midiInClose(HMIDIIN); 
__attribute((__stdcall__)) MMRESULT midiInPrepareHeader(HMIDIIN, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiInUnprepareHeader(HMIDIIN, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiInAddBuffer(HMIDIIN, LPMIDIHDR, UINT); 
__attribute((__stdcall__)) MMRESULT midiInStart(HMIDIIN); 
__attribute((__stdcall__)) MMRESULT midiInStop(HMIDIIN); 
__attribute((__stdcall__)) MMRESULT midiInReset(HMIDIIN); 
__attribute((__stdcall__)) MMRESULT midiInGetID(HMIDIIN, LPUINT); 
__attribute((__stdcall__)) MMRESULT midiInMessage(HMIDIIN, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) UINT auxGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT auxGetDevCapsA(UINT, LPAUXCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT auxGetDevCapsW(UINT, LPAUXCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT auxSetVolume(UINT, DWORD); 
__attribute((__stdcall__)) MMRESULT auxGetVolume(UINT, PDWORD); 
__attribute((__stdcall__)) MMRESULT auxOutMessage(UINT, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) UINT mixerGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT mixerGetDevCapsA(UINT, LPMIXERCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT mixerGetDevCapsW(UINT, LPMIXERCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT mixerOpen(LPHMIXER, UINT, DWORD, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerClose(HMIXER); 
__attribute((__stdcall__)) DWORD mixerMessage(HMIXER, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetLineInfoA(HMIXEROBJ, LPMIXERLINEA, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetLineInfoW(HMIXEROBJ, LPMIXERLINEW, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetID(HMIXEROBJ, PUINT, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetLineControlsA(HMIXEROBJ, LPMIXERLINECONTROLSA, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetLineControlsW(HMIXEROBJ, LPMIXERLINECONTROLSW, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetControlDetailsA(HMIXEROBJ, LPMIXERCONTROLDETAILS, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerGetControlDetailsW(HMIXEROBJ, LPMIXERCONTROLDETAILS, DWORD); 
__attribute((__stdcall__)) MMRESULT mixerSetControlDetails(HMIXEROBJ, LPMIXERCONTROLDETAILS, DWORD); 
__attribute((__stdcall__)) MMRESULT timeGetSystemTime(LPMMTIME, UINT); 
__attribute((__stdcall__)) DWORD timeGetTime(); 
__attribute((__stdcall__)) MMRESULT timeSetEvent(UINT, UINT, LPTIMECALLBACK, DWORD, UINT); 
__attribute((__stdcall__)) MMRESULT timeKillEvent(UINT); 
__attribute((__stdcall__)) MMRESULT timeGetDevCaps(LPTIMECAPS, UINT); 
__attribute((__stdcall__)) MMRESULT timeBeginPeriod(UINT); 
__attribute((__stdcall__)) MMRESULT timeEndPeriod(UINT); 
__attribute((__stdcall__)) UINT joyGetNumDevs(); 
__attribute((__stdcall__)) MMRESULT joyGetDevCapsA(UINT, LPJOYCAPSA, UINT); 
__attribute((__stdcall__)) MMRESULT joyGetDevCapsW(UINT, LPJOYCAPSW, UINT); 
__attribute((__stdcall__)) MMRESULT joyGetPos(UINT, LPJOYINFO); 
__attribute((__stdcall__)) MMRESULT joyGetPosEx(UINT, LPJOYINFOEX); 
__attribute((__stdcall__)) MMRESULT joyGetThreshold(UINT, LPUINT); 
__attribute((__stdcall__)) MMRESULT joyReleaseCapture(UINT); 
__attribute((__stdcall__)) MMRESULT joySetCapture(HWND, UINT, UINT, BOOL); 
__attribute((__stdcall__)) MMRESULT joySetThreshold(UINT, UINT); 
__attribute((__stdcall__)) FOURCC mmioStringToFOURCCA(LPCSTR, UINT); 
__attribute((__stdcall__)) FOURCC mmioStringToFOURCCW(LPCWSTR, UINT); 
__attribute((__stdcall__)) LPMMIOPROC mmioInstallIOProcA(FOURCC, LPMMIOPROC, DWORD); 
__attribute((__stdcall__)) LPMMIOPROC mmioInstallIOProcW(FOURCC, LPMMIOPROC, DWORD); 
__attribute((__stdcall__)) HMMIO mmioOpenA(LPSTR, LPMMIOINFO, DWORD); 
__attribute((__stdcall__)) HMMIO mmioOpenW(LPWSTR, LPMMIOINFO, DWORD); 
__attribute((__stdcall__)) MMRESULT mmioRenameA(LPCSTR, LPCSTR, LPCMMIOINFO, DWORD); 
__attribute((__stdcall__)) MMRESULT mmioRenameW(LPCWSTR, LPCWSTR, LPCMMIOINFO, DWORD); 
__attribute((__stdcall__)) MMRESULT mmioClose(HMMIO, UINT); 
__attribute((__stdcall__)) LONG mmioRead(HMMIO, HPSTR, LONG); 
__attribute((__stdcall__)) LONG mmioWrite(HMMIO, LPCSTR, LONG); 
__attribute((__stdcall__)) LONG mmioSeek(HMMIO, LONG, int); 
__attribute((__stdcall__)) MMRESULT mmioGetInfo(HMMIO, LPMMIOINFO, UINT); 
__attribute((__stdcall__)) MMRESULT mmioSetInfo(HMMIO, LPCMMIOINFO, UINT); 
__attribute((__stdcall__)) MMRESULT mmioSetBuffer(HMMIO, LPSTR, LONG, UINT); 
__attribute((__stdcall__)) MMRESULT mmioFlush(HMMIO, UINT); 
__attribute((__stdcall__)) MMRESULT mmioAdvance(HMMIO, LPMMIOINFO, UINT); 
__attribute((__stdcall__)) LRESULT mmioSendMessage(HMMIO, UINT, LPARAM, LPARAM); 
__attribute((__stdcall__)) MMRESULT mmioDescend(HMMIO, LPMMCKINFO, const MMCKINFO *, UINT); 
__attribute((__stdcall__)) MMRESULT mmioAscend(HMMIO, LPMMCKINFO, UINT); 
__attribute((__stdcall__)) MMRESULT mmioCreateChunk(HMMIO, LPMMCKINFO, UINT); 
__attribute((__stdcall__)) MCIERROR mciSendCommandA(MCIDEVICEID, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) MCIERROR mciSendCommandW(MCIDEVICEID, UINT, DWORD, DWORD); 
__attribute((__stdcall__)) MCIERROR mciSendStringA(LPCSTR, LPSTR, UINT, HWND); 
__attribute((__stdcall__)) MCIERROR mciSendStringW(LPCWSTR, LPWSTR, UINT, HWND); 
__attribute((__stdcall__)) MCIDEVICEID mciGetDeviceIDA(LPCSTR); 
__attribute((__stdcall__)) MCIDEVICEID mciGetDeviceIDW(LPCWSTR); 
__attribute((__stdcall__)) MCIDEVICEID mciGetDeviceIDFromElementIDA(DWORD, LPCSTR); 
__attribute((__stdcall__)) MCIDEVICEID mciGetDeviceIDFromElementIDW(DWORD, LPCWSTR); 
__attribute((__stdcall__)) BOOL mciGetErrorStringA(MCIERROR, LPSTR, UINT); 
__attribute((__stdcall__)) BOOL mciGetErrorStringW(MCIERROR, LPWSTR, UINT); 
__attribute((__stdcall__)) BOOL mciSetYieldProc(MCIDEVICEID, YIELDPROC, DWORD); 
__attribute((__stdcall__)) HTASK mciGetCreatorTask(MCIDEVICEID); 
__attribute((__stdcall__)) YIELDPROC mciGetYieldProc(MCIDEVICEID, PDWORD); 
# 1725
typedef 
# 1716
struct tagMCI_SEQ_SET_PARMS { 
DWORD dwCallback; 
DWORD dwTimeFormat; 
DWORD dwAudio; 
DWORD dwTempo; 
DWORD dwPort; 
DWORD dwSlave; 
DWORD dwMaster; 
DWORD dwOffset; 
} MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, *LPMCI_SEQ_SET_PARMS; 
# 1734
typedef 
# 1726
struct tagMCI_ANIM_OPEN_PARMSA { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCSTR lpstrDeviceType; 
LPCSTR lpstrElementName; 
LPCSTR lpstrAlias; 
DWORD dwStyle; 
HWND hWndParent; 
} MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA; 
# 1743
typedef 
# 1735
struct tagMCI_ANIM_OPEN_PARMSW { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCWSTR lpstrDeviceType; 
LPCWSTR lpstrElementName; 
LPCWSTR lpstrAlias; 
DWORD dwStyle; 
HWND hWndParent; 
} MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW; 
# 1749
typedef 
# 1744
struct tagMCI_ANIM_PLAY_PARMS { 
DWORD dwCallback; 
DWORD dwFrom; 
DWORD dwTo; 
DWORD dwSpeed; 
} MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, *LPMCI_ANIM_PLAY_PARMS; 



typedef 
# 1750
struct tagMCI_ANIM_STEP_PARMS { 
DWORD dwCallback; 
DWORD dwFrames; 
} MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, *LPMCI_ANIM_STEP_PARMS; 
# 1759
typedef 
# 1754
struct tagMCI_ANIM_WINDOW_PARMSA { 
DWORD dwCallback; 
HWND hWnd; 
UINT nCmdShow; 
LPCSTR lpstrText; 
} MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, *LPMCI_ANIM_WINDOW_PARMSA; 
# 1765
typedef 
# 1760
struct tagMCI_ANIM_WINDOW_PARMSW { 
DWORD dwCallback; 
HWND hWnd; 
UINT nCmdShow; 
LPCWSTR lpstrText; 
} MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, *LPMCI_ANIM_WINDOW_PARMSW; 
# 1774
typedef 
# 1766
struct tagMCI_ANIM_RECT_PARMS { 
DWORD dwCallback; 




RECT rc; 

} MCI_ANIM_RECT_PARMS, *PMCI_ANIM_RECT_PARMS, *LPMCI_ANIM_RECT_PARMS; 




typedef 
# 1775
struct tagMCI_ANIM_UPDATE_PARMS { 
DWORD dwCallback; 
RECT rc; 
HDC hDC; 
} MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, *LPMCI_ANIM_UPDATE_PARMS; 
# 1788
typedef 
# 1780
struct tagMCI_OVLY_OPEN_PARMSA { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCSTR lpstrDeviceType; 
LPCSTR lpstrElementName; 
LPCSTR lpstrAlias; 
DWORD dwStyle; 
HWND hWndParent; 
} MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA; 
# 1797
typedef 
# 1789
struct tagMCI_OVLY_OPEN_PARMSW { 
DWORD dwCallback; 
MCIDEVICEID wDeviceID; 
LPCWSTR lpstrDeviceType; 
LPCWSTR lpstrElementName; 
LPCWSTR lpstrAlias; 
DWORD dwStyle; 
HWND hWndParent; 
} MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW; 
# 1803
typedef 
# 1798
struct tagMCI_OVLY_WINDOW_PARMSA { 
DWORD dwCallback; 
HWND hWnd; 
UINT nCmdShow; 
LPCSTR lpstrText; 
} MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, *LPMCI_OVLY_WINDOW_PARMSA; 
# 1809
typedef 
# 1804
struct tagMCI_OVLY_WINDOW_PARMSW { 
DWORD dwCallback; 
HWND hWnd; 
UINT nCmdShow; 
LPCWSTR lpstrText; 
} MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, *LPMCI_OVLY_WINDOW_PARMSW; 
# 1818
typedef 
# 1810
struct tagMCI_OVLY_RECT_PARMS { 
DWORD dwCallback; 




RECT rc; 

} MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, *LPMCI_OVLY_RECT_PARMS; 




typedef 
# 1819
struct tagMCI_OVLY_SAVE_PARMSA { 
DWORD dwCallback; 
LPCSTR lpfilename; 
RECT rc; 
} MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, *LPMCI_OVLY_SAVE_PARMSA; 




typedef 
# 1824
struct tagMCI_OVLY_SAVE_PARMSW { 
DWORD dwCallback; 
LPCWSTR lpfilename; 
RECT rc; 
} MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, *LPMCI_OVLY_SAVE_PARMSW; 




typedef 
# 1829
struct tagMCI_OVLY_LOAD_PARMSA { 
DWORD dwCallback; 
LPCSTR lpfilename; 
RECT rc; 
} MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, *LPMCI_OVLY_LOAD_PARMSA; 




typedef 
# 1834
struct tagMCI_OVLY_LOAD_PARMSW { 
DWORD dwCallback; 
LPCWSTR lpfilename; 
RECT rc; 
} MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, *LPMCI_OVLY_LOAD_PARMSW; 
# 1890 "d:\\mingw\\mingw\\include\\mmsystem.h" 3
typedef WAVEOUTCAPSA WAVEOUTCAPS, *PWAVEOUTCAPS, *LPWAVEOUTCAPS; 
typedef WAVEINCAPSA WAVEINCAPS, *PWAVEINCAPS, *LPWAVEINCAPS; 
typedef MIDIOUTCAPSA MIDIOUTCAPS, *PMIDIOUTCAPS, *LPMIDIOUTCAPS; 
typedef MIDIINCAPSA MIDIINCAPS, *PMIDIINCAPS, *LPMIDIINCAPS; 
typedef AUXCAPSA AUXCAPS, *PAUXCAPS, *LPAUXCAPS; 
typedef MIXERCAPSA MIXERCAPS, *PMIXERCAPS, *LPMIXERCAPS; 
typedef MIXERLINEA MIXERLINE, *PMIXERLINE, *LPMIXERLINE; 
typedef MIXERCONTROLA MIXERCONTROL, *PMIXERCONTROL, *LPMIXERCONTROL; 
typedef MIXERLINECONTROLSA MIXERLINECONTROLS, *PMIXERLINECONTROLS, *LPMIXERLINECONTROLS; 
typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT, *PMIXERCONTROLDETAILS_LISTTEXT, *LPMIXERCONTROLDETAILS_LISTTEXT; 
typedef JOYCAPSA JOYCAPS, *PJOYCAPS, *LPJOYCAPS; 
typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS, *PMCI_OPEN_PARMS, *LPMCI_OPEN_PARMS; 
typedef MCI_INFO_PARMSA MCI_INFO_PARMS, *LPMCI_INFO_PARMS; 
typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS, *PMCI_SYSINFO_PARMS, *LPMCI_SYSINFO_PARMS; 
typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS, *PMCI_SAVE_PARMS, *LPMCI_SAVE_PARMS; 
typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS, *PMCI_LOAD_PARMS, *LPMCI_LOAD_PARMS; 
typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS, *PMCI_VD_ESCAPE_PARMS, *LPMCI_VD_ESCAPE_PARMS; 
typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS, *PMCI_WAVE_OPEN_PARMS, *LPMCI_WAVE_OPEN_PARMS; 
typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS, *PMCI_ANIM_OPEN_PARMS, *LPMCI_ANIM_OPEN_PARMS; 
typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS, *PMCI_ANIM_WINDOW_PARMS, *LPMCI_ANIM_WINDOW_PARMS; 
typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS, *PMCI_OVLY_OPEN_PARMS, *LPMCI_OVLY_OPEN_PARMS; 
typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS, *PMCI_OVLY_WINDOW_PARMS, *LPMCI_OVLY_WINDOW_PARMS; 
typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS, *PMCI_OVLY_SAVE_PARMS, *LPMCI_OVLY_SAVE_PARMS; 
# 1940 "d:\\mingw\\mingw\\include\\mmsystem.h" 3
}

#pragma pack ( pop )
# 8 "d:\\mingw\\mingw\\include\\nb30.h" 3
extern "C" {
# 99 "d:\\mingw\\mingw\\include\\nb30.h" 3
typedef 
# 95
struct _ACTION_HEADER { 
ULONG transport_id; 
USHORT action_code; 
USHORT reserved; 
} ACTION_HEADER, *PACTION_HEADER; 
# 128
typedef 
# 100
struct _ADAPTER_STATUS { 
UCHAR adapter_address[6]; 
UCHAR rev_major; 
UCHAR reserved0; 
UCHAR adapter_type; 
UCHAR rev_minor; 
WORD duration; 
WORD frmr_recv; 
WORD frmr_xmit; 
WORD iframe_recv_err; 
WORD xmit_aborts; 
DWORD xmit_success; 
DWORD recv_success; 
WORD iframe_xmit_err; 
WORD recv_buff_unavail; 
WORD t1_timeouts; 
WORD ti_timeouts; 
DWORD reserved1; 
WORD free_ncbs; 
WORD max_cfg_ncbs; 
WORD max_ncbs; 
WORD xmit_buf_unavail; 
WORD max_dgram_size; 
WORD pending_sess; 
WORD max_cfg_sess; 
WORD max_sess; 
WORD max_sess_pkt_size; 
WORD name_count; 
} ADAPTER_STATUS, *PADAPTER_STATUS; 
# 136
typedef 
# 129
struct _FIND_NAME_BUFFER { 
UCHAR length; 
UCHAR access_control; 
UCHAR frame_control; 
UCHAR destination_addr[6]; 
UCHAR source_addr[6]; 
UCHAR routing_info[18]; 
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER; 




typedef 
# 137
struct _FIND_NAME_HEADER { 
WORD node_count; 
UCHAR reserved; 
UCHAR unique_group; 
} FIND_NAME_HEADER, *PFIND_NAME_HEADER; 



typedef 
# 142
struct _LANA_ENUM { 
UCHAR length; 
UCHAR lana[254 + 1]; 
} LANA_ENUM, *PLANA_ENUM; 




typedef 
# 146
struct _NAME_BUFFER { 
UCHAR name[16]; 
UCHAR name_num; 
UCHAR name_flags; 
} NAME_BUFFER, *PNAME_BUFFER; 
# 167
typedef 
# 151
struct _NCB { 
UCHAR ncb_command; 
UCHAR ncb_retcode; 
UCHAR ncb_lsn; 
UCHAR ncb_num; 
PUCHAR ncb_buffer; 
WORD ncb_length; 
UCHAR ncb_callname[16]; 
UCHAR ncb_name[16]; 
UCHAR ncb_rto; 
UCHAR ncb_sto; 
void ( __attribute((__stdcall__))*ncb_post)(_NCB *) ; 
UCHAR ncb_lana_num; 
UCHAR ncb_cmd_cplt; 
UCHAR ncb_reserve[10]; 
HANDLE ncb_event; 
} NCB, *PNCB; 
# 175
typedef 
# 168
struct _SESSION_BUFFER { 
UCHAR lsn; 
UCHAR state; 
UCHAR local_name[16]; 
UCHAR remote_name[16]; 
UCHAR rcvs_outstanding; 
UCHAR sends_outstanding; 
} SESSION_BUFFER, *PSESSION_BUFFER; 
# 181
typedef 
# 176
struct _SESSION_HEADER { 
UCHAR sess_name; 
UCHAR num_sess; 
UCHAR rcv_dg_outstanding; 
UCHAR rcv_any_outstanding; 
} SESSION_HEADER, *PSESSION_HEADER; 
__attribute((__stdcall__)) UCHAR Netbios(PNCB); 

}
# 12 "d:\\mingw\\mingw\\include\\rpc.h" 3
extern "C" {
# 37 "d:\\mingw\\mingw\\include\\rpc.h" 3
typedef void *I_RPC_HANDLE; 
typedef long RPC_STATUS; 
# 8 "d:\\mingw\\mingw\\include\\rpcdce.h" 3
extern "C" {
# 125 "d:\\mingw\\mingw\\include\\basetyps.h" 3
typedef GUID UUID; 



typedef GUID IID; 

typedef GUID CLSID; 
typedef CLSID *LPCLSID; 
typedef IID *LPIID; 
typedef IID *REFIID; 
typedef CLSID *REFCLSID; 
typedef GUID FMTID; 
typedef FMTID *REFFMTID; 
typedef unsigned long error_status_t; 

typedef unsigned long PROPID; 
# 94 "d:\\mingw\\mingw\\include\\rpcdce.h" 3
typedef I_RPC_HANDLE RPC_BINDING_HANDLE; 
typedef RPC_BINDING_HANDLE handle_t; 



typedef 
# 96
struct _RPC_BINDING_VECTOR { 
unsigned long Count; 
RPC_BINDING_HANDLE BindingH[1]; 
} RPC_BINDING_VECTOR; 



typedef 
# 100
struct _UUID_VECTOR { 
unsigned long Count; 
UUID *Uuid[1]; 
} UUID_VECTOR; 
typedef void *RPC_IF_HANDLE; 




typedef 
# 105
struct _RPC_IF_ID { 
UUID Uuid; 
unsigned short VersMajor; 
unsigned short VersMinor; 
} RPC_IF_ID; 




typedef 
# 110
struct _RPC_POLICY { 
unsigned Length; 
unsigned long EndpointFlags; 
unsigned long NICFlags; 
} RPC_POLICY, *PRPC_POLICY; 
__attribute((__stdcall__)) typedef void RPC_OBJECT_INQ_FN(UUID *, UUID *, RPC_STATUS *); 
typedef RPC_STATUS RPC_IF_CALLBACK_FN(RPC_IF_HANDLE, void *); 



typedef 
# 117
struct { 
unsigned Count; 
unsigned long Stats[1]; 
} RPC_STATS_VECTOR; 



typedef 
# 121
struct { 
unsigned long Count; 
RPC_IF_ID *IfId[1]; 
} RPC_IF_ID_VECTOR; 
typedef void *RPC_AUTH_IDENTITY_HANDLE; 
typedef void *RPC_AUTHZ_HANDLE; 
# 132
typedef 
# 127
struct _RPC_SECURITY_QOS { 
unsigned long Version; 
unsigned long Capabilities; 
unsigned long IdentityTracking; 
unsigned long ImpersonationType; 
} RPC_SECURITY_QOS, *PRPC_SECURITY_QOS; 
# 141
typedef 
# 133
struct _SEC_WINNT_AUTH_IDENTITY_W { 
unsigned short *User; 
unsigned long UserLength; 
unsigned short *Domain; 
unsigned long DomainLength; 
unsigned short *Password; 
unsigned long PasswordLength; 
unsigned long Flags; 
} SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W; 
# 150
typedef 
# 142
struct _SEC_WINNT_AUTH_IDENTITY_A { 
unsigned char *User; 
unsigned long UserLength; 
unsigned char *Domain; 
unsigned long DomainLength; 
unsigned char *Password; 
unsigned long PasswordLength; 
unsigned long Flags; 
} SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A; 
# 156
typedef 
# 151
struct { 
unsigned char *UserName; 
unsigned char *ComputerName; 
unsigned short Privilege; 
unsigned long AuthFlags; 
} RPC_CLIENT_INFORMATION1, *PRPC_CLIENT_INFORMATION1; 
typedef I_RPC_HANDLE *RPC_EP_INQ_HANDLE; 
typedef int ( __attribute((__stdcall__))*RPC_MGMT_AUTHORIZATION_FN)(RPC_BINDING_HANDLE, unsigned long, RPC_STATUS *) ; 
# 164
typedef 
# 161
struct _RPC_PROTSEQ_VECTORA { 
unsigned Count; 
unsigned char *Protseq[1]; 
} RPC_PROTSEQ_VECTORA; 



typedef 
# 165
struct _RPC_PROTSEQ_VECTORW { 
unsigned Count; 
unsigned short *Protseq[1]; 
} RPC_PROTSEQ_VECTORW; 
__attribute((__stdcall__)) RPC_STATUS RpcBindingFromStringBindingA(unsigned char *, RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingFromStringBindingW(unsigned short *, RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingToStringBindingA(RPC_BINDING_HANDLE, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingToStringBindingW(RPC_BINDING_HANDLE, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringBindingComposeA(unsigned char *, unsigned char *, unsigned char *, unsigned char *, unsigned char *, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringBindingComposeW(unsigned short *, unsigned short *, unsigned short *, unsigned short *, unsigned short *, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringBindingParseA(unsigned char *, unsigned char **, unsigned char **, unsigned char **, unsigned char **, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringBindingParseW(unsigned short *, unsigned short **, unsigned short **, unsigned short **, unsigned short **, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringFreeA(unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcStringFreeW(unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcNetworkIsProtseqValidA(unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNetworkIsProtseqValidW(unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNetworkInqProtseqsA(RPC_PROTSEQ_VECTORA **); 
__attribute((__stdcall__)) RPC_STATUS RpcNetworkInqProtseqsW(RPC_PROTSEQ_VECTORW **); 
__attribute((__stdcall__)) RPC_STATUS RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA **); 
__attribute((__stdcall__)) RPC_STATUS RpcProtseqVectorFreeW(RPC_PROTSEQ_VECTORW **); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqA(unsigned char *, unsigned, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqW(unsigned short *, unsigned, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqExA(unsigned char *, unsigned MaxCalls, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqExW(unsigned short *, unsigned, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqEpA(unsigned char *, unsigned, unsigned char *, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqEpExA(unsigned char *, unsigned, unsigned char *, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqEpW(unsigned short *, unsigned, unsigned short *, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqEpExW(unsigned short *, unsigned, unsigned short *, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqIfA(unsigned char *, unsigned, RPC_IF_HANDLE, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqIfExA(unsigned char *, unsigned, RPC_IF_HANDLE, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqIfW(unsigned short *, unsigned, RPC_IF_HANDLE, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseProtseqIfExW(unsigned short *, unsigned, RPC_IF_HANDLE, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqServerPrincNameA(RPC_BINDING_HANDLE, unsigned long, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqServerPrincNameW(RPC_BINDING_HANDLE, unsigned long, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcServerInqDefaultPrincNameA(unsigned long, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcServerInqDefaultPrincNameW(unsigned long, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingInqEntryNameA(RPC_BINDING_HANDLE, unsigned long, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingInqEntryNameW(RPC_BINDING_HANDLE, unsigned long, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthClientA(RPC_BINDING_HANDLE, RPC_AUTHZ_HANDLE *, unsigned char **, unsigned long *, unsigned long *, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthClientW(RPC_BINDING_HANDLE, RPC_AUTHZ_HANDLE *, unsigned short **, unsigned long *, unsigned long *, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthInfoA(RPC_BINDING_HANDLE, unsigned char **, unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthInfoW(RPC_BINDING_HANDLE, unsigned short **, unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE, unsigned char *, unsigned long, unsigned long, RPC_AUTH_IDENTITY_HANDLE, unsigned long); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE, unsigned char *, unsigned long, unsigned long, RPC_AUTH_IDENTITY_HANDLE, unsigned long, RPC_SECURITY_QOS *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingSetAuthInfoW(RPC_BINDING_HANDLE, unsigned short *, unsigned long, unsigned long, RPC_AUTH_IDENTITY_HANDLE, unsigned long); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingSetAuthInfoExW(RPC_BINDING_HANDLE, unsigned short *, unsigned long, unsigned long, RPC_AUTH_IDENTITY_HANDLE, unsigned long, RPC_SECURITY_QOS *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthInfoExA(RPC_BINDING_HANDLE, unsigned char **, unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *, unsigned long, RPC_SECURITY_QOS *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqAuthInfoExW(RPC_BINDING_HANDLE, unsigned short **, unsigned long *, unsigned long *, RPC_AUTH_IDENTITY_HANDLE *, unsigned long *, unsigned long, RPC_SECURITY_QOS *); 
typedef void ( __attribute((__stdcall__))*RPC_AUTH_KEY_RETRIEVAL_FN)(void *, unsigned short *, unsigned long, void **, RPC_STATUS *) ; 
__attribute((__stdcall__)) RPC_STATUS RpcServerRegisterAuthInfoA(unsigned char *, unsigned long, RPC_AUTH_KEY_RETRIEVAL_FN, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerRegisterAuthInfoW(unsigned short *, unsigned long, RPC_AUTH_KEY_RETRIEVAL_FN, void *); 
__attribute((__stdcall__)) RPC_STATUS UuidToStringA(UUID *, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS UuidFromStringA(unsigned char *, UUID *); 
__attribute((__stdcall__)) RPC_STATUS UuidToStringW(UUID *, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS UuidFromStringW(unsigned short *, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcEpRegisterNoReplaceA(RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcEpRegisterNoReplaceW(RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcEpRegisterA(RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcEpRegisterW(RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS DceErrorInqTextA(RPC_STATUS, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS DceErrorInqTextW(RPC_STATUS, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEpEltInqNextA(RPC_EP_INQ_HANDLE, RPC_IF_ID *, RPC_BINDING_HANDLE *, UUID *, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEpEltInqNextW(RPC_EP_INQ_HANDLE, RPC_IF_ID *, RPC_BINDING_HANDLE *, UUID *, unsigned short **); 
# 332 "d:\\mingw\\mingw\\include\\rpcdce.h" 3
__attribute((__stdcall__)) RPC_STATUS RpcBindingCopy(RPC_BINDING_HANDLE, RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingFree(RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingInqObject(RPC_BINDING_HANDLE, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingReset(RPC_BINDING_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingSetObject(RPC_BINDING_HANDLE, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqDefaultProtectLevel(unsigned long, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingVectorFree(RPC_BINDING_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcIfInqId(RPC_IF_HANDLE, RPC_IF_ID *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqComTimeout(RPC_BINDING_HANDLE, unsigned *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtSetComTimeout(RPC_BINDING_HANDLE, unsigned); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtSetCancelTimeout(long Timeout); 
__attribute((__stdcall__)) RPC_STATUS RpcObjectInqType(UUID *, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcObjectSetInqFn(RPC_OBJECT_INQ_FN *); 
__attribute((__stdcall__)) RPC_STATUS RpcObjectSetType(UUID *, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA **); 
__attribute((__stdcall__)) RPC_STATUS RpcServerInqIf(RPC_IF_HANDLE, UUID *, void **); 
__attribute((__stdcall__)) RPC_STATUS RpcServerListen(unsigned, unsigned, unsigned); 
__attribute((__stdcall__)) RPC_STATUS RpcServerRegisterIf(RPC_IF_HANDLE, UUID *, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerRegisterIfEx(RPC_IF_HANDLE, UUID *, void *, unsigned, unsigned, RPC_IF_CALLBACK_FN *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerRegisterIf2(RPC_IF_HANDLE, UUID *, void *, unsigned, unsigned, unsigned, RPC_IF_CALLBACK_FN *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUnregisterIf(RPC_IF_HANDLE, UUID *, unsigned); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseAllProtseqs(unsigned, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseAllProtseqsEx(unsigned, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseAllProtseqsIf(unsigned, RPC_IF_HANDLE, void *); 
__attribute((__stdcall__)) RPC_STATUS RpcServerUseAllProtseqsIfEx(unsigned, RPC_IF_HANDLE, void *, PRPC_POLICY); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtStatsVectorFree(RPC_STATS_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqStats(RPC_BINDING_HANDLE, RPC_STATS_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtIsServerListening(RPC_BINDING_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtStopServerListening(RPC_BINDING_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtWaitServerListen(); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtSetServerStackSize(unsigned long); 
__attribute((__stdcall__)) void RpcSsDontSerializeContext(); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEnableIdleCleanup(); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqIfIds(RPC_BINDING_HANDLE, RPC_IF_ID_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcIfIdVectorFree(RPC_IF_ID_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcEpResolveBinding(RPC_BINDING_HANDLE, RPC_IF_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcBindingServerFromClient(RPC_BINDING_HANDLE, RPC_BINDING_HANDLE *); 
__attribute((noreturn)) __attribute((__stdcall__)) void RpcRaiseException(RPC_STATUS); 
__attribute((__stdcall__)) RPC_STATUS RpcTestCancel(); 
__attribute((__stdcall__)) RPC_STATUS RpcCancelThread(void *); 
__attribute((__stdcall__)) RPC_STATUS UuidCreate(UUID *); 
__attribute((__stdcall__)) signed int UuidCompare(UUID *, UUID *, RPC_STATUS *); 
__attribute((__stdcall__)) RPC_STATUS UuidCreateNil(UUID *); 
__attribute((__stdcall__)) int UuidEqual(UUID *, UUID *, RPC_STATUS *); 
__attribute((__stdcall__)) unsigned short UuidHash(UUID *, RPC_STATUS *); 
__attribute((__stdcall__)) int UuidIsNil(UUID *, RPC_STATUS *); 
__attribute((__stdcall__)) RPC_STATUS RpcEpUnregister(RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEpEltInqBegin(RPC_BINDING_HANDLE, unsigned long, RPC_IF_ID *, unsigned long, UUID *, RPC_EP_INQ_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEpEltInqDone(RPC_EP_INQ_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtEpUnregister(RPC_BINDING_HANDLE, RPC_IF_ID *, RPC_BINDING_HANDLE, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtSetAuthorizationFn(RPC_MGMT_AUTHORIZATION_FN); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtInqParameter(unsigned, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtSetParameter(unsigned, unsigned long); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtBindingInqParameter(RPC_BINDING_HANDLE, unsigned, unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcMgmtBindingSetParameter(RPC_BINDING_HANDLE, unsigned, unsigned long); 


__attribute((__stdcall__)) RPC_STATUS UuidCreateSequential(UUID *); 
# 8 "d:\\mingw\\mingw\\include\\rpcdcep.h" 3
extern "C" {
# 25 "d:\\mingw\\mingw\\include\\rpcdcep.h" 3
typedef 
# 22
struct _RPC_VERSION { 
unsigned short MajorVersion; 
unsigned short MinorVersion; 
} RPC_VERSION; 



typedef 
# 26
struct _RPC_SYNTAX_IDENTIFIER { 
GUID SyntaxGUID; 
RPC_VERSION SyntaxVersion; 
} RPC_SYNTAX_IDENTIFIER, *PRPC_SYNTAX_IDENTIFIER; 
# 42
typedef 
# 30
struct _RPC_MESSAGE { 
HANDLE Handle; 
unsigned long DataRepresentation; 
void *Buffer; 
unsigned BufferLength; 
unsigned ProcNum; 
PRPC_SYNTAX_IDENTIFIER TransferSyntax; 
void *RpcInterfaceInformation; 
void *ReservedForRuntime; 
void *ManagerEpv; 
void *ImportContext; 
unsigned long RpcFlags; 
} RPC_MESSAGE, *PRPC_MESSAGE; 
__attribute((__stdcall__)) typedef long RPC_FORWARD_FUNCTION(GUID *, RPC_VERSION *, GUID *, unsigned char *, void **); 
typedef void ( __attribute((__stdcall__))*RPC_DISPATCH_FUNCTION)(PRPC_MESSAGE Message) ; 




typedef 
# 45
struct { 
unsigned DispatchTableCount; 
RPC_DISPATCH_FUNCTION *DispatchTable; 
int Reserved; 
} RPC_DISPATCH_TABLE, *PRPC_DISPATCH_TABLE; 



typedef 
# 50
struct _RPC_PROTSEQ_ENDPOINT { 
unsigned char *RpcProtocolSequence; 
unsigned char *Endpoint; 
} RPC_PROTSEQ_ENDPOINT, *PRPC_PROTSEQ_ENDPOINT; 
# 63
typedef 
# 54
struct _RPC_SERVER_INTERFACE { 
unsigned Length; 
RPC_SYNTAX_IDENTIFIER InterfaceId; 
RPC_SYNTAX_IDENTIFIER TransferSyntax; 
PRPC_DISPATCH_TABLE DispatchTable; 
unsigned RpcProtseqEndpointCount; 
PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint; 
void *DefaultManagerEpv; 
const void *InterpreterInfo; 
} RPC_SERVER_INTERFACE, *PRPC_SERVER_INTERFACE; 
# 73
typedef 
# 64
struct _RPC_CLIENT_INTERFACE { 
unsigned Length; 
RPC_SYNTAX_IDENTIFIER InterfaceId; 
RPC_SYNTAX_IDENTIFIER TransferSyntax; 
PRPC_DISPATCH_TABLE DispatchTable; 
unsigned RpcProtseqEndpointCount; 
PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint; 
unsigned long Reserved; 
const void *InterpreterInfo; 
} RPC_CLIENT_INTERFACE, *PRPC_CLIENT_INTERFACE; 
typedef void *I_RPC_MUTEX; 




typedef 
# 75
struct _RPC_TRANSFER_SYNTAX { 
GUID Uuid; 
unsigned short VersMajor; 
unsigned short VersMinor; 
} RPC_TRANSFER_SYNTAX; 
typedef RPC_STATUS (*RPC_BLOCKING_FN)(void *, void *, void *); 

__attribute((__stdcall__)) long I_RpcGetBuffer(RPC_MESSAGE *); 
__attribute((__stdcall__)) long I_RpcSendReceive(RPC_MESSAGE *); 
__attribute((__stdcall__)) long I_RpcSend(RPC_MESSAGE *); 
__attribute((__stdcall__)) long I_RpcFreeBuffer(RPC_MESSAGE *); 
__attribute((__stdcall__)) void I_RpcRequestMutex(I_RPC_MUTEX *); 
__attribute((__stdcall__)) void I_RpcClearMutex(I_RPC_MUTEX); 
__attribute((__stdcall__)) void I_RpcDeleteMutex(I_RPC_MUTEX); 
__attribute((__stdcall__)) void *I_RpcAllocate(unsigned); 
__attribute((__stdcall__)) void I_RpcFree(void *); 
__attribute((__stdcall__)) void I_RpcPauseExecution(unsigned long); 
typedef void ( __attribute((__stdcall__))*PRPC_RUNDOWN)(void *) ; 
__attribute((__stdcall__)) long I_RpcMonitorAssociation(HANDLE, PRPC_RUNDOWN, void *); 
__attribute((__stdcall__)) long I_RpcStopMonitorAssociation(HANDLE); 
__attribute((__stdcall__)) HANDLE I_RpcGetCurrentCallHandle(); 
__attribute((__stdcall__)) long I_RpcGetAssociationContext(void **); 
__attribute((__stdcall__)) long I_RpcSetAssociationContext(void *); 

__attribute((__stdcall__)) long I_RpcNsBindingSetEntryName(HANDLE, unsigned long, unsigned short *); 
__attribute((__stdcall__)) long I_RpcBindingInqDynamicEndpoint(HANDLE, unsigned short **); 




__attribute((__stdcall__)) long I_RpcBindingInqTransportType(HANDLE, unsigned *); 
__attribute((__stdcall__)) long I_RpcIfInqTransferSyntaxes(HANDLE, RPC_TRANSFER_SYNTAX *, unsigned, unsigned *); 
__attribute((__stdcall__)) long I_UuidCreate(GUID *); 
__attribute((__stdcall__)) long I_RpcBindingCopy(HANDLE, HANDLE *); 
__attribute((__stdcall__)) long I_RpcBindingIsClientLocal(HANDLE, unsigned *); 
__attribute((__stdcall__)) void I_RpcSsDontSerializeContext(); 
__attribute((__stdcall__)) long I_RpcServerRegisterForwardFunction(RPC_FORWARD_FUNCTION *); 
__attribute((__stdcall__)) long I_RpcConnectionInqSockBuffSize(unsigned long *, unsigned long *); 
__attribute((__stdcall__)) long I_RpcConnectionSetSockBuffSize(unsigned long, unsigned long); 
__attribute((__stdcall__)) long I_RpcBindingSetAsync(HANDLE, RPC_BLOCKING_FN); 
__attribute((__stdcall__)) long I_RpcAsyncSendReceive(RPC_MESSAGE *, void *); 
__attribute((__stdcall__)) long I_RpcGetThreadWindowHandle(void **); 
__attribute((__stdcall__)) long I_RpcServerThreadPauseListening(); 
__attribute((__stdcall__)) long I_RpcServerThreadContinueListening(); 
__attribute((__stdcall__)) long I_RpcServerUnregisterEndpointA(unsigned char *, unsigned char *); 
__attribute((__stdcall__)) long I_RpcServerUnregisterEndpointW(unsigned short *, unsigned short *); 
# 127
}
# 394 "d:\\mingw\\mingw\\include\\rpcdce.h" 3
}
# 8 "d:\\mingw\\mingw\\include\\rpcnsi.h" 3
extern "C" {

typedef void *RPC_NS_HANDLE; 
# 20 "d:\\mingw\\mingw\\include\\rpcnsi.h" 3
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingExportA(unsigned long, unsigned char *, RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingUnexportA(unsigned long, unsigned char *, RPC_IF_HANDLE, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingLookupBeginA(unsigned long, unsigned char *, RPC_IF_HANDLE, UUID *, unsigned long, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingLookupNext(RPC_NS_HANDLE, RPC_BINDING_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingLookupDone(RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupDeleteA(unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrAddA(unsigned long, unsigned char *, unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrRemoveA(unsigned long, unsigned char *, unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrInqBeginA(unsigned long, unsigned char *, unsigned long, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrInqNextA(RPC_NS_HANDLE, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrInqDone(RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileDeleteA(unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltAddA(unsigned long, unsigned char *, RPC_IF_ID *, unsigned long, unsigned char *, unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltRemoveA(unsigned long, unsigned char *, RPC_IF_ID *, unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltInqBeginA(unsigned long, unsigned char *, unsigned long, RPC_IF_ID *, unsigned long, unsigned long, unsigned char *, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltInqNextA(RPC_NS_HANDLE, RPC_IF_ID *, unsigned char **, unsigned long *, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltInqDone(RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsEntryObjectInqNext(RPC_NS_HANDLE, UUID *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsEntryObjectInqDone(RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsEntryExpandNameA(unsigned long, unsigned char *, unsigned char **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtBindingUnexportA(unsigned long, unsigned char *, RPC_IF_ID *, unsigned long, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryCreateA(unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryDeleteA(unsigned long, unsigned char *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryInqIfIdsA(unsigned long, unsigned char *, RPC_IF_ID_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE, unsigned long); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtInqExpAge(unsigned long *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtSetExpAge(unsigned long); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingImportNext(RPC_NS_HANDLE, RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingImportDone(RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingSelect(RPC_BINDING_VECTOR *, RPC_BINDING_HANDLE *); 

__attribute((__stdcall__)) RPC_STATUS RpcNsEntryObjectInqBeginA(unsigned long, unsigned char *, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingImportBeginA(unsigned long, unsigned char *, RPC_IF_HANDLE, UUID *, RPC_NS_HANDLE *); 


__attribute((__stdcall__)) RPC_STATUS RpcNsBindingExportW(unsigned long, unsigned short *, RPC_IF_HANDLE, RPC_BINDING_VECTOR *, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingUnexportW(unsigned long, unsigned short *, RPC_IF_HANDLE, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingLookupBeginW(unsigned long, unsigned short *, RPC_IF_HANDLE, UUID *, unsigned long, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupDeleteW(unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrAddW(unsigned long, unsigned short *, unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrRemoveW(unsigned long, unsigned short *, unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrInqBeginW(unsigned long, unsigned short *, unsigned long, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsGroupMbrInqNextW(RPC_NS_HANDLE, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileDeleteW(unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltAddW(unsigned long, unsigned short *, RPC_IF_ID *, unsigned long, unsigned short *, unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltRemoveW(unsigned long, unsigned short *, RPC_IF_ID *, unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltInqBeginW(unsigned long, unsigned short *, unsigned long, RPC_IF_ID *, unsigned long, unsigned long, unsigned short *, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsProfileEltInqNextW(RPC_NS_HANDLE, RPC_IF_ID *, unsigned short **, unsigned long *, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsEntryObjectInqBeginW(unsigned long, unsigned short *, RPC_NS_HANDLE *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsEntryExpandNameW(unsigned long, unsigned short *, unsigned short **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtBindingUnexportW(unsigned long, unsigned short *, RPC_IF_ID *, unsigned long, UUID_VECTOR *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryCreateW(unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryDeleteW(unsigned long, unsigned short *); 
__attribute((__stdcall__)) RPC_STATUS RpcNsMgmtEntryInqIfIdsW(unsigned long, unsigned short, RPC_IF_ID_VECTOR **); 
__attribute((__stdcall__)) RPC_STATUS RpcNsBindingImportBeginW(unsigned long, unsigned short *, RPC_IF_HANDLE, UUID *, RPC_NS_HANDLE *); 
# 120 "d:\\mingw\\mingw\\include\\rpcnsi.h" 3
}
# 59 "d:\\mingw\\mingw\\include\\rpc.h" 3
__attribute((__stdcall__)) RPC_STATUS RpcImpersonateClient(RPC_BINDING_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcRevertToSelf(); 
__attribute((__stdcall__)) long I_RpcMapWin32Status(RPC_STATUS); 

}
# 8 "d:\\mingw\\mingw\\include\\shellapi.h" 3
extern "C" {
# 145 "d:\\mingw\\mingw\\include\\shellapi.h" 3
typedef WORD FILEOP_FLAGS; 
typedef WORD PRINTEROP_FLAGS; 
# 2 "d:\\mingw\\mingw\\include\\pshpack2.h" 3
#pragma pack ( push, 2 )
# 155 "d:\\mingw\\mingw\\include\\shellapi.h" 3
typedef 
# 148
struct _AppBarData { 
DWORD cbSize; 
HWND hWnd; 
UINT uCallbackMessage; 
UINT uEdge; 
RECT rc; 
LPARAM lParam; 
} APPBARDATA, *PAPPBARDATA; 
typedef struct HDROP__ { int i; } *HDROP; 
# 185 "d:\\mingw\\mingw\\include\\shellapi.h" 3
typedef 
# 158 "d:\\mingw\\mingw\\include\\shellapi.h" 3
struct _NOTIFYICONDATAA { 
DWORD cbSize; 
HWND hWnd; 
UINT uID; 
UINT uFlags; 
UINT uCallbackMessage; 
HICON hIcon; 

CHAR szTip[128]; 
DWORD dwState; 
DWORD dwStateMask; 
CHAR szInfo[256]; 
union { 
UINT uTimeout; 
UINT uVersion; 
}; 
CHAR szInfoTitle[64]; 
DWORD dwInfoFlags; 
# 185 "d:\\mingw\\mingw\\include\\shellapi.h" 3
} NOTIFYICONDATAA, *PNOTIFYICONDATAA; 
# 214 "d:\\mingw\\mingw\\include\\shellapi.h" 3
typedef 
# 187 "d:\\mingw\\mingw\\include\\shellapi.h" 3
struct _NOTIFYICONDATAW { 
DWORD cbSize; 
HWND hWnd; 
UINT uID; 
UINT uFlags; 
UINT uCallbackMessage; 
HICON hIcon; 

WCHAR szTip[128]; 
DWORD dwState; 
DWORD dwStateMask; 
WCHAR szInfo[256]; 
union { 
UINT uTimeout; 
UINT uVersion; 
}; 
WCHAR szInfoTitle[64]; 
DWORD dwInfoFlags; 
# 214 "d:\\mingw\\mingw\\include\\shellapi.h" 3
} NOTIFYICONDATAW, *PNOTIFYICONDATAW; 
# 232
typedef 
# 216
struct _SHELLEXECUTEINFOA { 
DWORD cbSize; 
ULONG fMask; 
HWND hwnd; 
LPCSTR lpVerb; 
LPCSTR lpFile; 
LPCSTR lpParameters; 
LPCSTR lpDirectory; 
int nShow; 
HINSTANCE hInstApp; 
PVOID lpIDList; 
LPCSTR lpClass; 
HKEY hkeyClass; 
DWORD dwHotKey; 
HANDLE hIcon; 
HANDLE hProcess; 
} SHELLEXECUTEINFOA, *LPSHELLEXECUTEINFOA; 
# 249
typedef 
# 233
struct _SHELLEXECUTEINFOW { 
DWORD cbSize; 
ULONG fMask; 
HWND hwnd; 
LPCWSTR lpVerb; 
LPCWSTR lpFile; 
LPCWSTR lpParameters; 
LPCWSTR lpDirectory; 
int nShow; 
HINSTANCE hInstApp; 
PVOID lpIDList; 
LPCWSTR lpClass; 
HKEY hkeyClass; 
DWORD dwHotKey; 
HANDLE hIcon; 
HANDLE hProcess; 
} SHELLEXECUTEINFOW, *LPSHELLEXECUTEINFOW; 
# 259
typedef 
# 250
struct _SHFILEOPSTRUCTA { 
HWND hwnd; 
UINT wFunc; 
LPCSTR pFrom; 
LPCSTR pTo; 
FILEOP_FLAGS fFlags; 
BOOL fAnyOperationsAborted; 
PVOID hNameMappings; 
LPCSTR lpszProgressTitle; 
} SHFILEOPSTRUCTA, *LPSHFILEOPSTRUCTA; 
# 269
typedef 
# 260
struct _SHFILEOPSTRUCTW { 
HWND hwnd; 
UINT wFunc; 
LPCWSTR pFrom; 
LPCWSTR pTo; 
FILEOP_FLAGS fFlags; 
BOOL fAnyOperationsAborted; 
PVOID hNameMappings; 
LPCWSTR lpszProgressTitle; 
} SHFILEOPSTRUCTW, *LPSHFILEOPSTRUCTW; 
# 276
typedef 
# 270
struct _SHFILEINFOA { 
HICON hIcon; 
int iIcon; 
DWORD dwAttributes; 
CHAR szDisplayName[260]; 
CHAR szTypeName[80]; 
} SHFILEINFOA; 
# 283
typedef 
# 277
struct _SHFILEINFOW { 
HICON hIcon; 
int iIcon; 
DWORD dwAttributes; 
WCHAR szDisplayName[260]; 
WCHAR szTypeName[80]; 
} SHFILEINFOW; 




typedef 
# 284
struct _SHQUERYRBINFO { 
DWORD cbSize; 
long long i64Size; 
long long i64NumItems; 
} SHQUERYRBINFO, *LPSHQUERYRBINFO; 
# 2 "d:\\mingw\\mingw\\include\\poppack.h" 3
#pragma pack ( pop )
# 291 "d:\\mingw\\mingw\\include\\shellapi.h" 3
LPWSTR *CommandLineToArgvW(LPCWSTR, int *) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void DragAcceptFiles(HWND, BOOL); 
__attribute((__stdcall__)) void DragFinish(HDROP); 
__attribute((__stdcall__)) UINT DragQueryFileA(HDROP, UINT, LPSTR, UINT); 
__attribute((__stdcall__)) UINT DragQueryFileW(HDROP, UINT, LPWSTR, UINT); 
__attribute((__stdcall__)) BOOL DragQueryPoint(HDROP, LPPOINT); 
__attribute((__stdcall__)) HICON DuplicateIcon(HINSTANCE, HICON); 
__attribute((__stdcall__)) HICON ExtractAssociatedIconA(HINSTANCE, LPCSTR, PWORD); 
__attribute((__stdcall__)) HICON ExtractAssociatedIconW(HINSTANCE, LPCWSTR, PWORD); 
__attribute((__stdcall__)) HICON ExtractIconA(HINSTANCE, LPCSTR, UINT); 
__attribute((__stdcall__)) HICON ExtractIconW(HINSTANCE, LPCWSTR, UINT); 
__attribute((__stdcall__)) UINT ExtractIconExA(LPCSTR, int, HICON *, HICON *, UINT); 
__attribute((__stdcall__)) UINT ExtractIconExW(LPCWSTR, int, HICON *, HICON *, UINT); 
__attribute((__stdcall__)) HINSTANCE FindExecutableA(LPCSTR, LPCSTR, LPSTR); 
__attribute((__stdcall__)) HINSTANCE FindExecutableW(LPCWSTR, LPCWSTR, LPWSTR); 
__attribute((__stdcall__)) UINT SHAppBarMessage(DWORD, PAPPBARDATA); 
__attribute((__stdcall__)) BOOL Shell_NotifyIconA(DWORD, PNOTIFYICONDATAA); 
__attribute((__stdcall__)) BOOL Shell_NotifyIconW(DWORD, PNOTIFYICONDATAW); 
__attribute((__stdcall__)) int ShellAboutA(HWND, LPCSTR, LPCSTR, HICON); 
__attribute((__stdcall__)) int ShellAboutW(HWND, LPCWSTR, LPCWSTR, HICON); 
__attribute((__stdcall__)) HINSTANCE ShellExecuteA(HWND, LPCSTR, LPCSTR, LPCSTR, LPCSTR, INT); 
__attribute((__stdcall__)) HINSTANCE ShellExecuteW(HWND, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, INT); 
__attribute((__stdcall__)) BOOL ShellExecuteExA(LPSHELLEXECUTEINFOA); 
__attribute((__stdcall__)) BOOL ShellExecuteExW(LPSHELLEXECUTEINFOW); 
__attribute((__stdcall__)) int SHFileOperationA(LPSHFILEOPSTRUCTA); 
__attribute((__stdcall__)) int SHFileOperationW(LPSHFILEOPSTRUCTW); 
__attribute((__stdcall__)) void SHFreeNameMappings(HANDLE); 
__attribute((__stdcall__)) DWORD SHGetFileInfoA(LPCSTR, DWORD, SHFILEINFOA *, UINT, UINT); 
__attribute((__stdcall__)) DWORD SHGetFileInfoW(LPCWSTR, DWORD, SHFILEINFOW *, UINT, UINT); 
__attribute((__stdcall__)) HRESULT SHQueryRecycleBinA(LPCSTR, LPSHQUERYRBINFO); 
__attribute((__stdcall__)) HRESULT SHQueryRecycleBinW(LPCWSTR, LPSHQUERYRBINFO); 
__attribute((__stdcall__)) HRESULT SHEmptyRecycleBinA(HWND, LPCSTR, DWORD); 
__attribute((__stdcall__)) HRESULT SHEmptyRecycleBinW(HWND, LPCWSTR, DWORD); 
# 355 "d:\\mingw\\mingw\\include\\shellapi.h" 3
typedef NOTIFYICONDATAA NOTIFYICONDATA, *PNOTIFYICONDATA; 
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO; 
typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT, *LPSHFILEOPSTRUCT; 
typedef SHFILEINFOA SHFILEINFO; 
# 374 "d:\\mingw\\mingw\\include\\shellapi.h" 3
}
# 38 "d:\\mingw\\mingw\\include\\winperf.h" 3
extern "C" {
# 324 "d:\\mingw\\mingw\\include\\winperf.h" 3
typedef 
# 309
struct _PERF_DATA_BLOCK { 
WCHAR Signature[4]; 
DWORD LittleEndian; 
DWORD Version; 
DWORD Revision; 
DWORD TotalByteLength; 
DWORD HeaderLength; 
DWORD NumObjectTypes; 
LONG DefaultObject; 
SYSTEMTIME SystemTime; 
LARGE_INTEGER PerfTime; 
LARGE_INTEGER PerfFreq; 
LARGE_INTEGER PerfTime100nSec; 
DWORD SystemNameLength; 
DWORD SystemNameOffset; 
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK; 
# 342
typedef 
# 327
struct _PERF_OBJECT_TYPE { 
DWORD TotalByteLength; 
DWORD DefinitionLength; 
DWORD HeaderLength; 
DWORD ObjectNameTitleIndex; 
LPWSTR ObjectNameTitle; 
DWORD ObjectHelpTitleIndex; 
LPWSTR ObjectHelpTitle; 
DWORD DetailLevel; 
DWORD NumCounters; 
LONG DefaultCounter; 
LONG NumInstances; 
DWORD CodePage; 
LARGE_INTEGER PerfTime; 
LARGE_INTEGER PerfFreq; 
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE; 
# 356
typedef 
# 345
struct _PERF_COUNTER_DEFINITION { 
DWORD ByteLength; 
DWORD CounterNameTitleIndex; 
LPWSTR CounterNameTitle; 
DWORD CounterHelpTitleIndex; 
LPWSTR CounterHelpTitle; 
LONG DefaultScale; 
DWORD DetailLevel; 
DWORD CounterType; 
DWORD CounterSize; 
DWORD CounterOffset; 
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION; 
# 366
typedef 
# 359
struct _PERF_INSTANCE_DEFINITION { 
DWORD ByteLength; 
DWORD ParentObjectTitleIndex; 
DWORD ParentObjectInstance; 
LONG UniqueID; 
DWORD NameOffset; 
DWORD NameLength; 
} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION; 




typedef 
# 369
struct _PERF_COUNTER_BLOCK { 
DWORD ByteLength; 
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK; 

typedef DWORD PM_OPEN_PROC(LPWSTR) ; 
typedef DWORD PM_COLLECT_PROC(LPWSTR, PVOID *, PDWORD, PDWORD) ; 
typedef DWORD PM_CLOSE_PROC(void) ; 

}
# 8 "d:\\mingw\\mingw\\include\\commdlg.h" 3
extern "C" {

#pragma pack ( push, 1 )
# 232 "d:\\mingw\\mingw\\include\\commdlg.h" 3
typedef UINT ( __attribute((__stdcall__))*__CDHOOKPROC)(HWND, UINT, WPARAM, LPARAM) ; 
typedef __CDHOOKPROC LPCCHOOKPROC; 
typedef __CDHOOKPROC LPCFHOOKPROC; 
typedef __CDHOOKPROC LPFRHOOKPROC; 
typedef __CDHOOKPROC LPOFNHOOKPROC; 
typedef __CDHOOKPROC LPPAGEPAINTHOOK; 
typedef __CDHOOKPROC LPPAGESETUPHOOK; 
typedef __CDHOOKPROC LPSETUPHOOKPROC; 
typedef __CDHOOKPROC LPPRINTHOOKPROC; 
# 251
typedef 
# 241
struct tagCHOOSECOLORA { 
DWORD lStructSize; 
HWND hwndOwner; 
HWND hInstance; 
COLORREF rgbResult; 
COLORREF *lpCustColors; 
DWORD Flags; 
LPARAM lCustData; 
LPCCHOOKPROC lpfnHook; 
LPCSTR lpTemplateName; 
} CHOOSECOLORA, *LPCHOOSECOLORA; 
# 262
typedef 
# 252
struct tagCHOOSECOLORW { 
DWORD lStructSize; 
HWND hwndOwner; 
HWND hInstance; 
COLORREF rgbResult; 
COLORREF *lpCustColors; 
DWORD Flags; 
LPARAM lCustData; 
LPCCHOOKPROC lpfnHook; 
LPCWSTR lpTemplateName; 
} CHOOSECOLORW, *LPCHOOSECOLORW; 
# 280
typedef 
# 263
struct tagCHOOSEFONTA { 
DWORD lStructSize; 
HWND hwndOwner; 
HDC hDC; 
LPLOGFONTA lpLogFont; 
INT iPointSize; 
DWORD Flags; 
DWORD rgbColors; 
LPARAM lCustData; 
LPCFHOOKPROC lpfnHook; 
LPCSTR lpTemplateName; 
HINSTANCE hInstance; 
LPSTR lpszStyle; 
WORD nFontType; 
WORD ___MISSING_ALIGNMENT__; 
INT nSizeMin; 
INT nSizeMax; 
} CHOOSEFONTA, *LPCHOOSEFONTA; 
# 298
typedef 
# 281
struct tagCHOOSEFONTW { 
DWORD lStructSize; 
HWND hwndOwner; 
HDC hDC; 
LPLOGFONTW lpLogFont; 
INT iPointSize; 
DWORD Flags; 
DWORD rgbColors; 
LPARAM lCustData; 
LPCFHOOKPROC lpfnHook; 
LPCWSTR lpTemplateName; 
HINSTANCE hInstance; 
LPWSTR lpszStyle; 
WORD nFontType; 
WORD ___MISSING_ALIGNMENT__; 
INT nSizeMin; 
INT nSizeMax; 
} CHOOSEFONTW, *LPCHOOSEFONTW; 
# 304
typedef 
# 299
struct tagDEVNAMES { 
WORD wDriverOffset; 
WORD wDeviceOffset; 
WORD wOutputOffset; 
WORD wDefault; 
} DEVNAMES, *LPDEVNAMES; 
# 317
typedef 
# 305
struct { 
DWORD lStructSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
DWORD Flags; 
LPSTR lpstrFindWhat; 
LPSTR lpstrReplaceWith; 
WORD wFindWhatLen; 
WORD wReplaceWithLen; 
LPARAM lCustData; 
LPFRHOOKPROC lpfnHook; 
LPCSTR lpTemplateName; 
} FINDREPLACEA, *LPFINDREPLACEA; 
# 330
typedef 
# 318
struct { 
DWORD lStructSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
DWORD Flags; 
LPWSTR lpstrFindWhat; 
LPWSTR lpstrReplaceWith; 
WORD wFindWhatLen; 
WORD wReplaceWithLen; 
LPARAM lCustData; 
LPFRHOOKPROC lpfnHook; 
LPCWSTR lpTemplateName; 
} FINDREPLACEW, *LPFINDREPLACEW; 
# 357
typedef 
# 331
struct tagOFNA { 
DWORD lStructSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
LPCSTR lpstrFilter; 
LPSTR lpstrCustomFilter; 
DWORD nMaxCustFilter; 
DWORD nFilterIndex; 
LPSTR lpstrFile; 
DWORD nMaxFile; 
LPSTR lpstrFileTitle; 
DWORD nMaxFileTitle; 
LPCSTR lpstrInitialDir; 
LPCSTR lpstrTitle; 
DWORD Flags; 
WORD nFileOffset; 
WORD nFileExtension; 
LPCSTR lpstrDefExt; 
DWORD lCustData; 
LPOFNHOOKPROC lpfnHook; 
LPCSTR lpTemplateName; 

void *pvReserved; 
DWORD dwReserved; 
DWORD FlagsEx; 

} OPENFILENAMEA, *LPOPENFILENAMEA; 
# 384
typedef 
# 358
struct tagOFNW { 
DWORD lStructSize; 
HWND hwndOwner; 
HINSTANCE hInstance; 
LPCWSTR lpstrFilter; 
LPWSTR lpstrCustomFilter; 
DWORD nMaxCustFilter; 
DWORD nFilterIndex; 
LPWSTR lpstrFile; 
DWORD nMaxFile; 
LPWSTR lpstrFileTitle; 
DWORD nMaxFileTitle; 
LPCWSTR lpstrInitialDir; 
LPCWSTR lpstrTitle; 
DWORD Flags; 
WORD nFileOffset; 
WORD nFileExtension; 
LPCWSTR lpstrDefExt; 
DWORD lCustData; 
LPOFNHOOKPROC lpfnHook; 
LPCWSTR lpTemplateName; 

void *pvReserved; 
DWORD dwReserved; 
DWORD FlagsEx; 

} OPENFILENAMEW, *LPOPENFILENAMEW; 




typedef 
# 385
struct _OFNOTIFYA { 
NMHDR hdr; 
LPOPENFILENAMEA lpOFN; 
LPSTR pszFile; 
} OFNOTIFYA, *LPOFNOTIFYA; 




typedef 
# 390
struct _OFNOTIFYW { 
NMHDR hdr; 
LPOPENFILENAMEW lpOFN; 
LPWSTR pszFile; 
} OFNOTIFYW, *LPOFNOTIFYW; 
# 410
typedef 
# 395
struct tagPSDA { 
DWORD lStructSize; 
HWND hwndOwner; 
HGLOBAL hDevMode; 
HGLOBAL hDevNames; 
DWORD Flags; 
POINT ptPaperSize; 
RECT rtMinMargin; 
RECT rtMargin; 
HINSTANCE hInstance; 
LPARAM lCustData; 
LPPAGESETUPHOOK lpfnPageSetupHook; 
LPPAGEPAINTHOOK lpfnPagePaintHook; 
LPCSTR lpPageSetupTemplateName; 
HGLOBAL hPageSetupTemplate; 
} PAGESETUPDLGA, *LPPAGESETUPDLGA; 
# 426
typedef 
# 411
struct tagPSDW { 
DWORD lStructSize; 
HWND hwndOwner; 
HGLOBAL hDevMode; 
HGLOBAL hDevNames; 
DWORD Flags; 
POINT ptPaperSize; 
RECT rtMinMargin; 
RECT rtMargin; 
HINSTANCE hInstance; 
LPARAM lCustData; 
LPPAGESETUPHOOK lpfnPageSetupHook; 
LPPAGEPAINTHOOK lpfnPagePaintHook; 
LPCWSTR lpPageSetupTemplateName; 
HGLOBAL hPageSetupTemplate; 
} PAGESETUPDLGW, *LPPAGESETUPDLGW; 
# 447
typedef 
# 427
struct tagPDA { 
DWORD lStructSize; 
HWND hwndOwner; 
HANDLE hDevMode; 
HANDLE hDevNames; 
HDC hDC; 
DWORD Flags; 
WORD nFromPage; 
WORD nToPage; 
WORD nMinPage; 
WORD nMaxPage; 
WORD nCopies; 
HINSTANCE hInstance; 
DWORD lCustData; 
LPPRINTHOOKPROC lpfnPrintHook; 
LPSETUPHOOKPROC lpfnSetupHook; 
LPCSTR lpPrintTemplateName; 
LPCSTR lpSetupTemplateName; 
HANDLE hPrintTemplate; 
HANDLE hSetupTemplate; 
} PRINTDLGA, *LPPRINTDLGA; 
# 468
typedef 
# 448
struct tagPDW { 
DWORD lStructSize; 
HWND hwndOwner; 
HANDLE hDevMode; 
HANDLE hDevNames; 
HDC hDC; 
DWORD Flags; 
WORD nFromPage; 
WORD nToPage; 
WORD nMinPage; 
WORD nMaxPage; 
WORD nCopies; 
HINSTANCE hInstance; 
DWORD lCustData; 
LPPRINTHOOKPROC lpfnPrintHook; 
LPSETUPHOOKPROC lpfnSetupHook; 
LPCWSTR lpPrintTemplateName; 
LPCWSTR lpSetupTemplateName; 
HANDLE hPrintTemplate; 
HANDLE hSetupTemplate; 
} PRINTDLGW, *LPPRINTDLGW; 
# 12 "d:\\mingw\\mingw\\include\\unknwn.h" 3
extern "C" {
# 10 "d:\\mingw\\mingw\\include\\objfwd.h" 3
extern "C" {

typedef struct IMoniker *LPMONIKER; 
typedef struct IStream *LPSTREAM; 
typedef struct IMarshal *LPMARSHAL; 
typedef struct IMalloc *LPMALLOC; 
typedef struct IMallocSpy *LPMALLOCSPY; 
typedef struct IMessageFilter *LPMESSAGEFILTER; 
typedef struct IPersist *LPPERSIST; 
typedef struct IPersistStream *LPPERSISTSTREAM; 
typedef struct IRunningObjectTable *LPRUNNINGOBJECTTABLE; 
typedef struct IBindCtx *LPBINDCTX, *LPBC; 
typedef struct IAdviseSink *LPADVISESINK; 
typedef struct IAdviseSink2 *LPADVISESINK2; 
typedef struct IDataObject *LPDATAOBJECT; 
typedef struct IDataAdviseHolder *LPDATAADVISEHOLDER; 
typedef struct IEnumMoniker *LPENUMMONIKER; 
typedef struct IEnumFORMATETC *LPENUMFORMATETC; 
typedef struct IEnumSTATDATA *LPENUMSTATDATA; 
typedef struct IEnumSTATSTG *LPENUMSTATSTG; 
typedef struct IEnumSTATPROPSTG LPENUMSTATPROPSTG; 
typedef struct IEnumString *LPENUMSTRING; 
typedef struct IEnumUnknown *LPENUMUNKNOWN; 
typedef struct IStorage *LPSTORAGE; 
typedef struct IPersistStorage *LPPERSISTSTORAGE; 
typedef struct ILockBytes *LPLOCKBYTES; 
typedef struct IStdMarshalInfo *LPSTDMARSHALINFO; 
typedef struct IExternalConnection *LPEXTERNALCONNECTION; 
typedef struct IRunnableObject *LPRUNNABLEOBJECT; 
typedef struct IROTData *LPROTDATA; 
typedef struct IPersistFile *LPPERSISTFILE; 
typedef struct IRootStorage *LPROOTSTORAGE; 
typedef struct IRpcChannelBuffer *LPRPCCHANNELBUFFER; 
typedef struct IRpcProxyBuffer *LPRPCPROXYBUFFER; 
typedef struct IRpcStubBuffer *LPRPCSTUBBUFFER; 
typedef struct IPropertyStorage *LPPROPERTYSTORAGE; 
typedef struct IEnumSTATPROPSETSTG *LPENUMSTATPROPSETSTG; 
typedef struct IPropertySetStorage *LPPROPERTYSETSTORAGE; 
typedef struct IClientSecurity *LPCLIENTSECURITY; 
typedef struct IServerSecurity *LPSERVERSECURITY; 
typedef struct IClassActivator *LPCLASSACTIVATOR; 
typedef struct IFillLockBytes *LPFILLLOCKBYTES; 
typedef struct IProgressNotify *LPPROGRESSNOTIFY; 
typedef struct ILayoutStorage *LPLAYOUTSTORAGE; 

}
# 8 "d:\\mingw\\mingw\\include\\rpcnsip.h" 3
extern "C" {
# 14
typedef 
# 10
struct { 
RPC_NS_HANDLE LookupContext; 
RPC_BINDING_HANDLE ProposedHandle; 
RPC_BINDING_VECTOR *Bindings; 
} RPC_IMPORT_CONTEXT_P, *PRPC_IMPORT_CONTEXT_P; 
__attribute((__stdcall__)) RPC_STATUS I_RpcNsGetBuffer(PRPC_MESSAGE); 
__attribute((__stdcall__)) RPC_STATUS I_RpcNsSendReceive(PRPC_MESSAGE, RPC_BINDING_HANDLE *); 
__attribute((__stdcall__)) void I_RpcNsRaiseException(PRPC_MESSAGE, RPC_STATUS); 
__attribute((__stdcall__)) RPC_STATUS I_RpcReBindBuffer(PRPC_MESSAGE); 
__attribute((__stdcall__)) RPC_STATUS I_NsServerBindSearch(); 
__attribute((__stdcall__)) RPC_STATUS I_NsClientBindSearch(); 
__attribute((__stdcall__)) void I_NsClientBindDone(); 

}
# 13 "d:\\mingw\\mingw\\include\\rpcndr.h" 3
extern "C" {
# 51 "d:\\mingw\\mingw\\include\\rpcndr.h" 3
typedef unsigned char byte; 
typedef unsigned char boolean; 
# 96 "d:\\mingw\\mingw\\include\\rpcndr.h" 3
typedef void *NDR_CCONTEXT; 



typedef 
# 97
struct { 
void *pad[2]; 
void *userContext; 
} *NDR_SCONTEXT; 
typedef void ( __attribute((__stdcall__))*NDR_RUNDOWN)(void *) ; 



typedef 
# 102
struct _SCONTEXT_QUEUE { 
unsigned long NumberOfObjects; 
NDR_SCONTEXT *ArrayOfObjects; 
} SCONTEXT_QUEUE, *PSCONTEXT_QUEUE; 
struct _MIDL_STUB_MESSAGE; 
struct _MIDL_STUB_DESC; 
struct _FULL_PTR_XLAT_TABLES; 
typedef unsigned char *RPC_BUFPTR; 
typedef unsigned long RPC_LENGTH; 
typedef void ( __attribute((__stdcall__))*EXPR_EVAL)(_MIDL_STUB_MESSAGE *) ; 
typedef const unsigned char *PFORMAT_STRING; 
# 120
typedef 
# 113
struct { 
long Dimension; 
unsigned long *BufferConformanceMark; 
unsigned long *BufferVarianceMark; 
unsigned long *MaxCountArray; 
unsigned long *OffsetArray; 
unsigned long *ActualCountArray; 
} ARRAY_INFO, *PARRAY_INFO; 

__attribute((__stdcall__)) RPC_BINDING_HANDLE NDRCContextBinding(NDR_CCONTEXT); 
__attribute((__stdcall__)) void NDRCContextMarshall(NDR_CCONTEXT, void *); 
__attribute((__stdcall__)) void NDRCContextUnmarshall(NDR_CCONTEXT *, RPC_BINDING_HANDLE, void *, unsigned long); 
__attribute((__stdcall__)) void NDRSContextMarshall(NDR_SCONTEXT, void *, NDR_RUNDOWN); 
__attribute((__stdcall__)) NDR_SCONTEXT NDRSContextUnmarshall(void * pBuff, unsigned long); 
__attribute((__stdcall__)) void RpcSsDestroyClientContext(void **); 
__attribute((__stdcall__)) void NDRcopy(void *, void *, unsigned); 
__attribute((__stdcall__)) unsigned MIDL_wchar_strlen(wchar_t *); 
__attribute((__stdcall__)) void MIDL_wchar_strcpy(void *, wchar_t *); 
__attribute((__stdcall__)) void char_from_ndr(PRPC_MESSAGE, unsigned char *); 
__attribute((__stdcall__)) void char_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, unsigned char *); 
__attribute((__stdcall__)) void short_from_ndr(PRPC_MESSAGE, unsigned short *); 
__attribute((__stdcall__)) void short_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, unsigned short *); 
__attribute((__stdcall__)) void short_from_ndr_temp(unsigned char **, unsigned short *, unsigned long); 
__attribute((__stdcall__)) void long_from_ndr(PRPC_MESSAGE, unsigned long *); 
__attribute((__stdcall__)) void long_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, unsigned long *); 
__attribute((__stdcall__)) void long_from_ndr_temp(unsigned char **, unsigned long *, unsigned long); 
__attribute((__stdcall__)) void enum_from_ndr(PRPC_MESSAGE, unsigned *); 
__attribute((__stdcall__)) void float_from_ndr(PRPC_MESSAGE, void *); 
__attribute((__stdcall__)) void float_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, void *); 
__attribute((__stdcall__)) void double_from_ndr(PRPC_MESSAGE, void *); 
__attribute((__stdcall__)) void double_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, void *); 
__attribute((__stdcall__)) void hyper_from_ndr(PRPC_MESSAGE, long long *); 
__attribute((__stdcall__)) void hyper_array_from_ndr(PRPC_MESSAGE, unsigned long, unsigned long, long long *); 
__attribute((__stdcall__)) void hyper_from_ndr_temp(unsigned char **, long long *, unsigned long); 
__attribute((__stdcall__)) void data_from_ndr(PRPC_MESSAGE, void *, char *, unsigned char); 
__attribute((__stdcall__)) void data_into_ndr(void *, PRPC_MESSAGE, char *, unsigned char); 
__attribute((__stdcall__)) void tree_into_ndr(void *, PRPC_MESSAGE, char *, unsigned char); 
__attribute((__stdcall__)) void data_size_ndr(void *, PRPC_MESSAGE, char *, unsigned char); 
__attribute((__stdcall__)) void tree_size_ndr(void *, PRPC_MESSAGE, char *, unsigned char); 
__attribute((__stdcall__)) void tree_peek_ndr(PRPC_MESSAGE, unsigned char **, char *, unsigned char); 
void *midl_allocate(int) __attribute((__stdcall__)); 

#pragma pack ( push, 4 )
# 202
typedef 
# 156
struct _MIDL_STUB_MESSAGE { 
PRPC_MESSAGE RpcMsg; 
unsigned char *Buffer; 
unsigned char *BufferStart; 
unsigned char *BufferEnd; 
unsigned char *BufferMark; 
unsigned long BufferLength; 
unsigned long MemorySize; 
unsigned char *Memory; 
int IsClient; 
int ReuseBuffer; 
unsigned char *AllocAllNodesMemory; 
unsigned char *AllocAllNodesMemoryEnd; 
int IgnoreEmbeddedPointers; 
unsigned char *PointerBufferMark; 
unsigned char fBufferValid; 
unsigned char Unused; 
unsigned long MaxCount; 
unsigned long Offset; 
unsigned long ActualCount; 
void *( __attribute((__stdcall__))*pfnAllocate)(unsigned) ; 
void ( __attribute((__stdcall__))*pfnFree)(void *) ; 
unsigned char *StackTop; 
unsigned char *pPresentedType; 
unsigned char *pTransmitType; 
handle_t SavedHandle; 
const _MIDL_STUB_DESC *StubDesc; 
_FULL_PTR_XLAT_TABLES *FullPtrXlatTables; 
unsigned long FullPtrRefId; 
int fCheckBounds; 
int fInDontFree:1; 
int fDontCallFreeInst:1; 
int fInOnlyParam:1; 
int fHasReturn:1; 
unsigned long dwDestContext; 
void *pvDestContext; 
NDR_SCONTEXT *SavedContextHandles; 
long ParamNumber; 
IRpcChannelBuffer *pRpcChannelBuffer; 
PARRAY_INFO pArrayInfo; 
unsigned long *SizePtrCountArray; 
unsigned long *SizePtrOffsetArray; 
unsigned long *SizePtrLengthArray; 
void *pArgQueue; 
unsigned long dwStubPhase; 
unsigned long w2kReserved[5]; 
} MIDL_STUB_MESSAGE, *PMIDL_STUB_MESSAGE; 
#pragma pack ( pop )
typedef void *( __attribute((__stdcall__))*GENERIC_BINDING_ROUTINE)(void *) ; 
typedef void ( __attribute((__stdcall__))*GENERIC_UNBIND_ROUTINE)(void *, unsigned char *) ; 



typedef 
# 206
struct _GENERIC_BINDING_ROUTINE_PAIR { 
GENERIC_BINDING_ROUTINE pfnBind; 
GENERIC_UNBIND_ROUTINE pfnUnbind; 
} GENERIC_BINDING_ROUTINE_PAIR, *PGENERIC_BINDING_ROUTINE_PAIR; 
# 215
typedef 
# 210
struct __GENERIC_BINDING_INFO { 
void *pObj; 
unsigned Size; 
GENERIC_BINDING_ROUTINE pfnBind; 
GENERIC_UNBIND_ROUTINE pfnUnbind; 
} GENERIC_BINDING_INFO, *PGENERIC_BINDING_INFO; 
typedef void ( __attribute((__stdcall__))*XMIT_HELPER_ROUTINE)(PMIDL_STUB_MESSAGE) ; 
# 222
typedef 
# 217
struct _XMIT_ROUTINE_QUINTUPLE { 
XMIT_HELPER_ROUTINE pfnTranslateToXmit; 
XMIT_HELPER_ROUTINE pfnTranslateFromXmit; 
XMIT_HELPER_ROUTINE pfnFreeXmit; 
XMIT_HELPER_ROUTINE pfnFreeInst; 
} XMIT_ROUTINE_QUINTUPLE, *PXMIT_ROUTINE_QUINTUPLE; 



typedef 
# 223
struct _MALLOC_FREE_STRUCT { 
void *( __attribute((__stdcall__))*pfnAllocate)(unsigned) ; 
void ( __attribute((__stdcall__))*pfnFree)(void *) ; 
} MALLOC_FREE_STRUCT; 



typedef 
# 227
struct _COMM_FAULT_OFFSETS { 
short CommOffset; 
short FaultOffset; 
} COMM_FAULT_OFFSETS; 
typedef unsigned long ( __attribute((__stdcall__))*USER_MARSHAL_SIZING_ROUTINE)(unsigned long *, unsigned long, void *) ; 
typedef unsigned char *( __attribute((__stdcall__))*USER_MARSHAL_MARSHALLING_ROUTINE)(unsigned long *, unsigned char *, void *) ; 
typedef unsigned char *( __attribute((__stdcall__))*USER_MARSHAL_UNMARSHALLING_ROUTINE)(unsigned long *, unsigned char *, void *) ; 
typedef void ( __attribute((__stdcall__))*USER_MARSHAL_FREEING_ROUTINE)(unsigned long *, void *) ; 
# 240
typedef 
# 235
struct _USER_MARSHAL_ROUTINE_QUADRUPLE { 
USER_MARSHAL_SIZING_ROUTINE pfnBufferSize; 
USER_MARSHAL_MARSHALLING_ROUTINE pfnMarshall; 
USER_MARSHAL_UNMARSHALLING_ROUTINE pfnUnmarshall; 
USER_MARSHAL_FREEING_ROUTINE pfnFree; 
} USER_MARSHAL_ROUTINE_QUADRUPLE; 
typedef void ( __attribute((__stdcall__))*NDR_NOTIFY_ROUTINE)(void) ; 




typedef 
# 242
enum _IDL_CS_CONVERT { 
IDL_CS_NO_CONVERT, 
IDL_CS_IN_PLACE_CONVERT, 
IDL_CS_NEW_BUFFER_CONVERT
} IDL_CS_CONVERT; 
typedef void ( __attribute((__stdcall__))*CS_TYPE_NET_SIZE_ROUTINE)(RPC_BINDING_HANDLE, unsigned long, unsigned long, IDL_CS_CONVERT *, unsigned long *, error_status_t *) ; 
typedef void ( __attribute((__stdcall__))*CS_TYPE_LOCAL_SIZE_ROUTINE)(RPC_BINDING_HANDLE, unsigned long, unsigned long, IDL_CS_CONVERT *, unsigned long *, error_status_t *) ; 
typedef void ( __attribute((__stdcall__))*CS_TYPE_TO_NETCS_ROUTINE)(RPC_BINDING_HANDLE, unsigned long, void *, unsigned long, byte *, unsigned long *, error_status_t *) ; 
typedef void ( __attribute((__stdcall__))*CS_TYPE_FROM_NETCS_ROUTINE)(RPC_BINDING_HANDLE, unsigned long, byte *, unsigned long, unsigned long, void *, unsigned long *, error_status_t *) ; 
typedef void ( __attribute((__stdcall__))*CS_TAG_GETTING_ROUTINE)(RPC_BINDING_HANDLE, int, unsigned long *, unsigned long *, unsigned long *, error_status_t *) ; 
# 257
typedef 
# 252
struct _NDR_CS_SIZE_CONVERT_ROUTINES { 
CS_TYPE_NET_SIZE_ROUTINE pfnNetSize; 
CS_TYPE_TO_NETCS_ROUTINE pfnToNetCs; 
CS_TYPE_LOCAL_SIZE_ROUTINE pfnLocalSize; 
CS_TYPE_FROM_NETCS_ROUTINE pfnFromNetCs; 
} NDR_CS_SIZE_CONVERT_ROUTINES; 



typedef 
# 258
struct _NDR_CS_ROUTINES { 
NDR_CS_SIZE_CONVERT_ROUTINES *pSizeConvertRoutines; 
CS_TAG_GETTING_ROUTINE *pTagGettingRoutines; 
} NDR_CS_ROUTINES; 
# 287
typedef 
# 262
struct _MIDL_STUB_DESC { 
void *RpcInterfaceInformation; 
void *( __attribute((__stdcall__))*pfnAllocate)(unsigned) ; 
void ( __attribute((__stdcall__))*pfnFree)(void *) ; 
union { 
handle_t *pAutoHandle; 
handle_t *pPrimitiveHandle; 
PGENERIC_BINDING_INFO pGenericBindingInfo; 
} IMPLICIT_HANDLE_INFO; 
const NDR_RUNDOWN *apfnNdrRundownRoutines; 
const GENERIC_BINDING_ROUTINE_PAIR *aGenericBindingRoutinePairs; 
const EXPR_EVAL *apfnExprEval; 
const XMIT_ROUTINE_QUINTUPLE *aXmitQuintuple; 
const unsigned char *pFormatTypes; 
int fCheckBounds; 
unsigned long Version; 
MALLOC_FREE_STRUCT *pMallocFreeStruct; 
long MIDLVersion; 
const COMM_FAULT_OFFSETS *CommFaultOffsets; 
const USER_MARSHAL_ROUTINE_QUADRUPLE *aUserMarshalQuadruple; 
const NDR_NOTIFY_ROUTINE *NotifyRoutineTable; 
ULONG_PTR mFlags; 
const NDR_CS_ROUTINES *CsRoutineTables; 
void *Reserved4; 
ULONG_PTR Reserved5; 
} MIDL_STUB_DESC; 
typedef const MIDL_STUB_DESC *PMIDL_STUB_DESC; 
typedef void *PMIDL_XMIT_TYPE; 



typedef 
# 290
struct _MIDL_FORMAT_STRING { 
short Pad; 
unsigned char Format[1]; 
} MIDL_FORMAT_STRING; 
typedef void ( __attribute((__stdcall__))*STUB_THUNK)(PMIDL_STUB_MESSAGE) ; 
typedef long ( __attribute((__stdcall__))*SERVER_ROUTINE)(void) ; 
# 302
typedef 
# 296
struct _MIDL_SERVER_INFO_ { 
PMIDL_STUB_DESC pStubDesc; 
const SERVER_ROUTINE *DispatchTable; 
PFORMAT_STRING ProcString; 
const unsigned short *FmtStringOffset; 
const STUB_THUNK *ThunkTable; 
} MIDL_SERVER_INFO, *PMIDL_SERVER_INFO; 




typedef 
# 303
struct _MIDL_STUBLESS_PROXY_INFO { 
PMIDL_STUB_DESC pStubDesc; 
PFORMAT_STRING ProcFormatString; 
const unsigned short *FormatStringOffset; 
} MIDL_STUBLESS_PROXY_INFO; 
typedef MIDL_STUBLESS_PROXY_INFO *PMIDL_STUBLESS_PROXY_INFO; 



typedef 
# 309
union _CLIENT_CALL_RETURN { 
void *Pointer; 
long Simple; 
} CLIENT_CALL_RETURN; 
typedef enum { XLAT_SERVER = 1, XLAT_CLIENT} XLAT_SIDE; 
# 319
typedef 
# 314
struct _FULL_PTR_TO_REFID_ELEMENT { 
_FULL_PTR_TO_REFID_ELEMENT *Next; 
void *Pointer; 
unsigned long RefId; 
unsigned char State; 
} FULL_PTR_TO_REFID_ELEMENT, *PFULL_PTR_TO_REFID_ELEMENT; 
# 333
typedef 
# 320
struct _FULL_PTR_XLAT_TABLES { 
struct { 
void **XlatTable; 
unsigned char *StateTable; 
unsigned long NumberOfEntries; 
} RefIdToPointer; 
struct { 
PFULL_PTR_TO_REFID_ELEMENT *XlatTable; 
unsigned long NumberOfBuckets; 
unsigned long HashMask; 
} PointerToRefId; 
unsigned long NextRefId; 
XLAT_SIDE XlatSide; 
} FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES; 
__attribute((__stdcall__)) void NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE, unsigned char *, unsigned char); 
unsigned char *NdrPointerMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING pFormat) __attribute((__stdcall__)); 
unsigned char *NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrConformantStructMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrHardStructMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrComplexStructMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrConformantStringMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrClientContextMarshall(PMIDL_STUB_MESSAGE, NDR_CCONTEXT, int); 
__attribute((__stdcall__)) void NdrServerContextMarshall(PMIDL_STUB_MESSAGE, NDR_SCONTEXT, NDR_RUNDOWN); 
__attribute((__stdcall__)) void NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE, unsigned char *, unsigned char); 
unsigned char *NdrPointerUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrHardStructUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
unsigned char *NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE, NDR_CCONTEXT *, RPC_BINDING_HANDLE); 
__attribute((__stdcall__)) NDR_SCONTEXT NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE); 
__attribute((__stdcall__)) void NdrPointerBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrHardStructBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrContextHandleSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrPointerMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrHardStructMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrPointerFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrSimpleStructFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantStructFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrHardStructFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrComplexStructFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrFixedArrayFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantArrayFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrVaryingArrayFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrComplexArrayFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrByteCountPointerFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrInterfacePointerFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrConvert(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrClientInitializeNew(PRPC_MESSAGE, PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC, unsigned); 
unsigned char *NdrServerInitializeNew(PRPC_MESSAGE, PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrClientInitialize(PRPC_MESSAGE, PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC, unsigned); 
unsigned char *NdrServerInitialize(PRPC_MESSAGE, PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC) __attribute((__stdcall__)); 
unsigned char *NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC, PRPC_MESSAGE) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrServerInitializeMarshall(PRPC_MESSAGE, PMIDL_STUB_MESSAGE); 
unsigned char *NdrGetBuffer(PMIDL_STUB_MESSAGE, unsigned long, RPC_BINDING_HANDLE) __attribute((__stdcall__)); 
unsigned char *NdrNsGetBuffer(PMIDL_STUB_MESSAGE, unsigned long, RPC_BINDING_HANDLE) __attribute((__stdcall__)); 
unsigned char *NdrSendReceive(PMIDL_STUB_MESSAGE, unsigned char *) __attribute((__stdcall__)); 
unsigned char *NdrNsSendReceive(PMIDL_STUB_MESSAGE, unsigned char *, RPC_BINDING_HANDLE *) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrFreeBuffer(PMIDL_STUB_MESSAGE); 
__attribute((__cdecl__)) CLIENT_CALL_RETURN NdrClientCall(PMIDL_STUB_DESC, PFORMAT_STRING, ...); 
__attribute((__cdecl__)) CLIENT_CALL_RETURN NdrClientCall2(PMIDL_STUB_DESC, PFORMAT_STRING, ...); 
# 447
typedef 
# 442
enum { 
STUB_UNMARSHAL, 
STUB_CALL_SERVER, 
STUB_MARSHAL, 
STUB_CALL_SERVER_NO_HRESULT
} STUB_PHASE; 
# 454
typedef 
# 448
enum { 
PROXY_CALCSIZE, 
PROXY_GETBUFFER, 
PROXY_MARSHAL, 
PROXY_SENDRECEIVE, 
PROXY_UNMARSHAL
} PROXY_PHASE; 
__attribute((__stdcall__)) long NdrStubCall(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, unsigned long *); 
__attribute((__stdcall__)) void NdrServerCall(PRPC_MESSAGE); 
__attribute((__stdcall__)) int NdrServerUnmarshall(IRpcChannelBuffer *, PRPC_MESSAGE, PMIDL_STUB_MESSAGE, PMIDL_STUB_DESC, PFORMAT_STRING, void *); 
__attribute((__stdcall__)) void NdrServerMarshall(IRpcStubBuffer *, IRpcChannelBuffer *, PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) RPC_STATUS NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE, unsigned long *, unsigned long *, RPC_STATUS); 
__attribute((__stdcall__)) int NdrSH_UPDecision(PMIDL_STUB_MESSAGE, unsigned char **, RPC_BUFPTR); 
__attribute((__stdcall__)) int NdrSH_TLUPDecision(PMIDL_STUB_MESSAGE, unsigned char **); 
__attribute((__stdcall__)) int NdrSH_TLUPDecisionBuffer(PMIDL_STUB_MESSAGE, unsigned char **); 
__attribute((__stdcall__)) int NdrSH_IfAlloc(PMIDL_STUB_MESSAGE, unsigned char **, unsigned long); 
__attribute((__stdcall__)) int NdrSH_IfAllocRef(PMIDL_STUB_MESSAGE, unsigned char **, unsigned long); 
__attribute((__stdcall__)) int NdrSH_IfAllocSet(PMIDL_STUB_MESSAGE, unsigned char **, unsigned long); 
__attribute((__stdcall__)) RPC_BUFPTR NdrSH_IfCopy(PMIDL_STUB_MESSAGE, unsigned char **, unsigned long); 
__attribute((__stdcall__)) RPC_BUFPTR NdrSH_IfAllocCopy(PMIDL_STUB_MESSAGE, unsigned char **, unsigned long); 
__attribute((__stdcall__)) unsigned long NdrSH_Copy(unsigned char *, unsigned char *, unsigned long); 
__attribute((__stdcall__)) void NdrSH_IfFree(PMIDL_STUB_MESSAGE, unsigned char *); 
__attribute((__stdcall__)) RPC_BUFPTR NdrSH_StringMarshall(PMIDL_STUB_MESSAGE, unsigned char *, unsigned long, int); 
__attribute((__stdcall__)) RPC_BUFPTR NdrSH_StringUnMarshall(PMIDL_STUB_MESSAGE, unsigned char **, int); 
typedef void *RPC_SS_THREAD_HANDLE; 
typedef void *RPC_CLIENT_ALLOC(unsigned) __attribute((__stdcall__)) ; 
__attribute((__stdcall__)) typedef void RPC_CLIENT_FREE(void *); 
void *RpcSsAllocate(unsigned) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void RpcSsDisableAllocate(); 
__attribute((__stdcall__)) void RpcSsEnableAllocate(); 
__attribute((__stdcall__)) void RpcSsFree(void *); 
__attribute((__stdcall__)) RPC_SS_THREAD_HANDLE RpcSsGetThreadHandle(); 
__attribute((__stdcall__)) void RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC *, RPC_CLIENT_FREE *); 
__attribute((__stdcall__)) void RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE); 
__attribute((__stdcall__)) void RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC *, RPC_CLIENT_FREE *, RPC_CLIENT_ALLOC **, RPC_CLIENT_FREE **); 
void *RpcSmAllocate(unsigned, RPC_STATUS *) __attribute((__stdcall__)); 
__attribute((__stdcall__)) RPC_STATUS RpcSmClientFree(void *); 
__attribute((__stdcall__)) RPC_STATUS RpcSmDestroyClientContext(void **); 
__attribute((__stdcall__)) RPC_STATUS RpcSmDisableAllocate(); 
__attribute((__stdcall__)) RPC_STATUS RpcSmEnableAllocate(); 
__attribute((__stdcall__)) RPC_STATUS RpcSmFree(void *); 
__attribute((__stdcall__)) RPC_SS_THREAD_HANDLE RpcSmGetThreadHandle(RPC_STATUS *); 
__attribute((__stdcall__)) RPC_STATUS RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC *, RPC_CLIENT_FREE *); 
__attribute((__stdcall__)) RPC_STATUS RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE); 
__attribute((__stdcall__)) RPC_STATUS RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC *, RPC_CLIENT_FREE *, RPC_CLIENT_ALLOC **, RPC_CLIENT_FREE **); 
__attribute((__stdcall__)) void NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE); 
__attribute((__stdcall__)) void NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE); 
__attribute((__stdcall__)) void NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE); 
void *NdrRpcSmClientAllocate(unsigned) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrRpcSmClientFree(void *); 
void *NdrRpcSsDefaultAllocate(unsigned) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrRpcSsDefaultFree(void *); 
__attribute((__stdcall__)) PFULL_PTR_XLAT_TABLES NdrFullPointerXlatInit(unsigned long, XLAT_SIDE); 
__attribute((__stdcall__)) void NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES); 
__attribute((__stdcall__)) int NdrFullPointerQueryPointer(PFULL_PTR_XLAT_TABLES, void *, unsigned char, unsigned long *); 
__attribute((__stdcall__)) int NdrFullPointerQueryRefId(PFULL_PTR_XLAT_TABLES, unsigned long, unsigned char, void **); 
__attribute((__stdcall__)) void NdrFullPointerInsertRefId(PFULL_PTR_XLAT_TABLES, unsigned long, void *); 
__attribute((__stdcall__)) int NdrFullPointerFree(PFULL_PTR_XLAT_TABLES, void *); 
void *NdrAllocate(PMIDL_STUB_MESSAGE, unsigned) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrClearOutParameters(PMIDL_STUB_MESSAGE, PFORMAT_STRING, void *); 
void *NdrOleAllocate(unsigned) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrOleFree(void *); 
unsigned char *NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING) __attribute((__stdcall__)); 
unsigned char *NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE, unsigned char **, PFORMAT_STRING, unsigned char) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 
__attribute((__stdcall__)) unsigned long NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE, PFORMAT_STRING); 
__attribute((__stdcall__)) void NdrUserMarshalFree(PMIDL_STUB_MESSAGE, unsigned char *, PFORMAT_STRING); 

}
# 51 "d:\\mingw\\mingw\\include\\wtypes.h" 3
extern "C" {
# 61 "d:\\mingw\\mingw\\include\\wtypes.h" 3
}
# 71 "d:\\mingw\\mingw\\include\\wtypes.h" 3
extern "C" {
# 77
typedef 
# 74
struct _BLOB { 
ULONG cbSize; 
BYTE *pBlobData; 
} BLOB, *PBLOB, *LPBLOB; 

}
# 90 "d:\\mingw\\mingw\\include\\wtypes.h" 3
extern "C" {
# 98
typedef 
# 93
enum tagDVASPECT { 
DVASPECT_CONTENT = 1, 
DVASPECT_THUMBNAIL, 
DVASPECT_ICON = 4, 
DVASPECT_DOCPRINT = 8
} DVASPECT; 
# 104
typedef 
# 101
enum tagDVASPECT2 { 
DVASPECT_OPAQUE = 16, 
DVASPECT_TRANSPARENT = 32
} DVASPECT2; 
# 110
typedef 
# 107
enum tagSTATFLAG { 
STATFLAG_DEFAULT, 
STATFLAG_NONAME
} STATFLAG; 
# 120
typedef 
# 113
enum tagMEMCTX { 
MEMCTX_LOCAL, 
MEMCTX_TASK, 
MEMCTX_SHARED, 
MEMCTX_MACSYSTEM, 
MEMCTX_UNKNOWN = (-1), 
MEMCTX_SAME = (-2)
} MEMCTX; 
# 129
typedef 
# 123
enum tagMSHCTX { 
MSHCTX_LOCAL, 
MSHCTX_NOSHAREDMEM, 
MSHCTX_DIFFERENTMACHINE, 
MSHCTX_INPROC, 
MSHCTX_CROSSCTX
} MSHCTX; 
# 138
typedef 
# 132
enum tagCLSCTX { 
CLSCTX_INPROC_SERVER = 1, 
CLSCTX_INPROC_HANDLER, 
CLSCTX_LOCAL_SERVER = 4, 
CLSCTX_INPROC_SERVER16 = 8, 
CLSCTX_REMOTE_SERVER = 16
} CLSCTX; 
# 145
typedef 
# 141
enum tagMSHLFLAGS { 
MSHLFLAGS_NORMAL, 
MSHLFLAGS_TABLESTRONG, 
MSHLFLAGS_TABLEWEAK
} MSHLFLAGS; 
# 152
typedef 
# 148
struct _FLAGGED_WORD_BLOB { 
unsigned long fFlags; 
unsigned long clSize; 
unsigned short asData[1]; 
} FLAGGED_WORD_BLOB; 


typedef WCHAR OLECHAR; 
typedef LPWSTR LPOLESTR; 
typedef LPCWSTR LPCOLESTR; 
# 169 "d:\\mingw\\mingw\\include\\wtypes.h" 3
typedef unsigned short VARTYPE; 
typedef short VARIANT_BOOL; 
typedef VARIANT_BOOL _VARIANT_BOOL; 




typedef OLECHAR *BSTR; 
typedef FLAGGED_WORD_BLOB *wireBSTR; 
typedef BSTR *LPBSTR; 
typedef LONG SCODE; 
typedef void *HCONTEXT; 
# 189
typedef 
# 183
union tagCY { 

struct { unsigned long Lo; 
long Hi; 
}; 
LONGLONG int64; 
} CY; 

typedef double DATE; 
# 197
typedef 
# 194
struct tagBSTRBLOB { 
ULONG cbSize; 
PBYTE pData; 
} BSTRBLOB, *LPBSTRBLOB; 
# 204
typedef 
# 200
struct tagCLIPDATA { 
ULONG cbSize; 
long ulClipFmt; 
PBYTE pClipData; 
} CLIPDATA; 
# 212
typedef 
# 207
enum tagSTGC { 
STGC_DEFAULT, 
STGC_OVERWRITE, 
STGC_ONLYIFCURRENT, 
STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE
} STGC; 
# 219
typedef 
# 215
enum tagSTGMOVE { 
STGMOVE_MOVE, 
STGMOVE_COPY, 
STGMOVE_SHALLOWCOPY
} STGMOVE; 

enum VARENUM { 
VT_EMPTY, 
VT_NULL, 
VT_I2, 
VT_I4, 
VT_R4, 
VT_R8, 
VT_CY, 
VT_DATE, 
VT_BSTR, 
VT_DISPATCH, 
VT_ERROR, 
VT_BOOL, 
VT_VARIANT, 
VT_UNKNOWN, 
VT_DECIMAL, 
VT_I1 = 16, 
VT_UI1, 
VT_UI2, 
VT_UI4, 
VT_I8, 
VT_UI8, 
VT_INT, 
VT_UINT, 
VT_VOID, 
VT_HRESULT, 
VT_PTR, 
VT_SAFEARRAY, 
VT_CARRAY, 
VT_USERDEFINED, 
VT_LPSTR, 
VT_LPWSTR, 
VT_RECORD = 36, 
VT_INT_PTR, 
VT_UINT_PTR, 
VT_FILETIME = 64, 
VT_BLOB, 
VT_STREAM, 
VT_STORAGE, 
VT_STREAMED_OBJECT, 
VT_STORED_OBJECT, 
VT_BLOB_OBJECT, 
VT_CF, 
VT_CLSID, 
VT_BSTR_BLOB = 0xfff, 
VT_VECTOR, 
VT_ARRAY = 0x2000, 
VT_BYREF = 0x4000, 
VT_RESERVED = 0x8000, 
VT_ILLEGAL = 0xffff, 
VT_ILLEGALMASKED = 0xfff, 
VT_TYPEMASK = 0xfff
}; 
# 279
typedef 
# 276
struct _BYTE_SIZEDARR { 
unsigned long clSize; 
byte *pData; 
} BYTE_SIZEDARR; 
# 285
typedef 
# 282
struct _SHORT_SIZEDARR { 
unsigned long clSize; 
unsigned short *pData; 
} WORD_SIZEDARR; 
# 291
typedef 
# 288
struct _LONG_SIZEDARR { 
unsigned long clSize; 
unsigned long *pData; 
} DWORD_SIZEDARR; 
# 297
typedef 
# 294
struct _HYPER_SIZEDARR { 
unsigned long clSize; 
long long *pData; 
} HYPER_SIZEDARR; 

typedef double DOUBLE; 
# 319
typedef 
# 302
struct tagDEC { 
USHORT wReserved; 

union { 
struct { BYTE scale; 
BYTE sign; 
}; 
USHORT signscale; 
}; 
ULONG Hi32; 

union { 
struct { ULONG Lo32; 
ULONG Mid32; 
}; 
ULONGLONG Lo64; 
}; 
} DECIMAL, *LPDECIMAL; 
# 332 "d:\\mingw\\mingw\\include\\wtypes.h" 3
typedef void *HMETAFILEPICT; 

}
# 17 "d:\\mingw\\mingw\\include\\unknwn.h" 3
void *MIDL_user_allocate(size_t) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void MIDL_user_free(void *); 
extern const IID IID_IUnknown; 
extern const IID IID_IClassFactory; 



struct IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
}; 

typedef IUnknown *LPUNKNOWN; 




struct IClassFactory : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateInstance(LPUNKNOWN, const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT LockServer(BOOL) = 0; 
}; 

typedef IClassFactory *LPCLASSFACTORY; 

__attribute((__stdcall__)) HRESULT IUnknown_QueryInterface_Proxy(IUnknown *, const IID &, void **); 
__attribute((__stdcall__)) void IUnknown_QueryInterface_Stub(LPRPCSTUBBUFFER, LPRPCCHANNELBUFFER, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IUnknown_AddRef_Proxy(IUnknown *); 
__attribute((__stdcall__)) void IUnknown_AddRef_Stub(LPRPCSTUBBUFFER, LPRPCCHANNELBUFFER, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IUnknown_Release_Proxy(IUnknown *); 
__attribute((__stdcall__)) void IUnknown_Release_Stub(LPRPCSTUBBUFFER, LPRPCCHANNELBUFFER, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IClassFactory_RemoteCreateInstance_Proxy(IClassFactory *, const IID &, IUnknown **); 
__attribute((__stdcall__)) void IClassFactory_RemoteCreateInstance_Stub(LPRPCSTUBBUFFER, LPRPCCHANNELBUFFER, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IClassFactory_RemoteLockServer_Proxy(IClassFactory *, BOOL); 
__attribute((__stdcall__)) void IClassFactory_RemoteLockServer_Stub(LPRPCSTUBBUFFER, LPRPCCHANNELBUFFER, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IClassFactory_CreateInstance_Proxy(IClassFactory *, IUnknown *, const IID &, void **); 
__attribute((__stdcall__)) HRESULT IClassFactory_CreateInstance_Stub(IClassFactory *, const IID &, IUnknown **); 
__attribute((__stdcall__)) HRESULT IClassFactory_LockServer_Proxy(IClassFactory *, BOOL); 
__attribute((__stdcall__)) HRESULT IClassFactory_LockServer_Stub(IClassFactory *, BOOL); 
# 74 "d:\\mingw\\mingw\\include\\unknwn.h" 3
}
# 47 "d:\\mingw\\mingw\\include\\prsht.h" 3
extern "C" {
# 197 "d:\\mingw\\mingw\\include\\prsht.h" 3
#pragma pack ( push, 8 )
# 231
typedef 
# 203
struct _PROPSHEETPAGEA { 
DWORD dwSize; 
DWORD dwFlags; 
HINSTANCE hInstance; 


union { LPCSTR pszTemplate; 
LPCDLGTEMPLATE pResource; 
}; 


union { HICON hIcon; 
LPCSTR pszIcon; 
}; 

LPCSTR pszTitle; 
DLGPROC pfnDlgProc; 
LPARAM lParam; 
UINT ( __attribute((__stdcall__))*pfnCallback)(HWND, UINT, _PROPSHEETPAGEA *) ; 
UINT *pcRefParent; 



LPCSTR pszHeaderTitle; 
LPCSTR pszHeaderSubTitle; 



} PROPSHEETPAGEA, *LPPROPSHEETPAGEA; 



typedef const PROPSHEETPAGEA *LPCPROPSHEETPAGEA; 
# 266
typedef 
# 238
struct _PROPSHEETPAGEW { 
DWORD dwSize; 
DWORD dwFlags; 
HINSTANCE hInstance; 


union { LPCWSTR pszTemplate; 
LPCDLGTEMPLATE pResource; 
}; 


union { HICON hIcon; 
LPCWSTR pszIcon; 
}; 

LPCWSTR pszTitle; 
DLGPROC pfnDlgProc; 
LPARAM lParam; 
UINT ( __attribute((__stdcall__))*pfnCallback)(HWND, UINT, _PROPSHEETPAGEW *) ; 
UINT *pcRefParent; 



LPCWSTR pszHeaderTitle; 
LPCWSTR pszHeaderSubTitle; 



} PROPSHEETPAGEW, *LPPROPSHEETPAGEW; 

typedef const PROPSHEETPAGEW *LPCPROPSHEETPAGEW; 



typedef UINT ( __attribute((__stdcall__))*LPFNPSPCALLBACKA)(HWND, UINT, LPPROPSHEETPAGEA) ; 
typedef UINT ( __attribute((__stdcall__))*LPFNPSPCALLBACKW)(HWND, UINT, LPPROPSHEETPAGEW) ; 

typedef int ( __attribute((__stdcall__))*PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM) ; 

typedef struct HPROPSHEETPAGE__ { int i; } *HPROPSHEETPAGE; 
# 325
typedef 
# 283
struct _PROPSHEETHEADERA { 
DWORD dwSize; 
DWORD dwFlags; 
HWND hwndParent; 
HINSTANCE hInstance; 


union { HICON hIcon; 
LPCSTR pszIcon; 
}; 

LPCSTR pszCaption; 
UINT nPages; 


union { UINT nStartPage; 
LPCSTR pStartPage; 
}; 


union { LPCPROPSHEETPAGEA ppsp; 
HPROPSHEETPAGE *phpage; 
}; 

PFNPROPSHEETCALLBACK pfnCallback; 




union { HBITMAP hbmWatermark; 
LPCSTR pszbmWatermark; 
}; 

HPALETTE hplWatermark; 


union { HBITMAP hbmHeader; 
LPCSTR pszbmHeader; 
}; 



} PROPSHEETHEADERA, *LPPROPSHEETHEADERA; 
# 370
typedef 
# 328
struct _PROPSHEETHEADERW { 
DWORD dwSize; 
DWORD dwFlags; 
HWND hwndParent; 
HINSTANCE hInstance; 


union { HICON hIcon; 
LPCWSTR pszIcon; 
}; 

LPCWSTR pszCaption; 
UINT nPages; 


union { UINT nStartPage; 
LPCWSTR pStartPage; 
}; 


union { LPCPROPSHEETPAGEW ppsp; 
HPROPSHEETPAGE *phpage; 
}; 

PFNPROPSHEETCALLBACK pfnCallback; 




union { HBITMAP hbmWatermark; 
LPCWSTR pszbmWatermark; 
}; 

HPALETTE hplWatermark; 


union { HBITMAP hbmHeader; 
LPCWSTR pszbmHeader; 
}; 



} PROPSHEETHEADERW, *LPPROPSHEETHEADERW; 



typedef const PROPSHEETHEADERA *LPCPROPSHEETHEADERA; 
typedef const PROPSHEETHEADERW *LPCPROPSHEETHEADERW; 

typedef BOOL ( __attribute((__stdcall__))*LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM) ; 

typedef BOOL ( __attribute((__stdcall__))*LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM) ; 
# 386
typedef 
# 383
struct _PSHNOTIFY { 
NMHDR hdr; 
LPARAM lParam; 
} PSHNOTIFY, *LPPSHNOTIFY; 

#pragma pack ( pop )



__attribute((__stdcall__)) int PropertySheetA(LPCPROPSHEETHEADERA); 
__attribute((__stdcall__)) int PropertySheetW(LPCPROPSHEETHEADERW); 



__attribute((__stdcall__)) HPROPSHEETPAGE CreatePropertySheetPageA(LPCPROPSHEETPAGEA); 
__attribute((__stdcall__)) HPROPSHEETPAGE CreatePropertySheetPageW(LPCPROPSHEETPAGEW); 

__attribute((__stdcall__)) BOOL DestroyPropertySheetPage(HPROPSHEETPAGE); 
# 458 "d:\\mingw\\mingw\\include\\prsht.h" 3
}
# 475 "d:\\mingw\\mingw\\include\\commdlg.h" 3
typedef 
# 472
struct tagPRINTPAGERANGE { 
DWORD nFromPage; 
DWORD nToPage; 
} PRINTPAGERANGE, *LPPRINTPAGERANGE; 
# 498
typedef 
# 476
struct tagPDEXA { 
DWORD lStructSize; 
HWND hwndOwner; 
HGLOBAL hDevMode; 
HGLOBAL hDevNames; 
HDC hDC; 
DWORD Flags; 
DWORD Flags2; 
DWORD ExclusionFlags; 
DWORD nPageRanges; 
DWORD nMaxPageRanges; 
LPPRINTPAGERANGE lpPageRanges; 
DWORD nMinPage; 
DWORD nMaxPage; 
DWORD nCopies; 
HINSTANCE hInstance; 
LPCSTR lpPrintTemplateName; 
LPUNKNOWN lpCallback; 
DWORD nPropertyPages; 
HPROPSHEETPAGE *lphPropertyPages; 
DWORD nStartPage; 
DWORD dwResultAction; 
} PRINTDLGEXA, *LPPRINTDLGEXA; 
# 521
typedef 
# 499
struct tagPDEXW { 
DWORD lStructSize; 
HWND hwndOwner; 
HGLOBAL hDevMode; 
HGLOBAL hDevNames; 
HDC hDC; 
DWORD Flags; 
DWORD Flags2; 
DWORD ExclusionFlags; 
DWORD nPageRanges; 
DWORD nMaxPageRanges; 
LPPRINTPAGERANGE lpPageRanges; 
DWORD nMinPage; 
DWORD nMaxPage; 
DWORD nCopies; 
HINSTANCE hInstance; 
LPCWSTR lpPrintTemplateName; 
LPUNKNOWN lpCallback; 
DWORD nPropertyPages; 
HPROPSHEETPAGE *lphPropertyPages; 
DWORD nStartPage; 
DWORD dwResultAction; 
} PRINTDLGEXW, *LPPRINTDLGEXW; 


__attribute((__stdcall__)) BOOL ChooseColorA(LPCHOOSECOLORA); 
__attribute((__stdcall__)) BOOL ChooseColorW(LPCHOOSECOLORW); 
__attribute((__stdcall__)) BOOL ChooseFontA(LPCHOOSEFONTA); 
__attribute((__stdcall__)) BOOL ChooseFontW(LPCHOOSEFONTW); 
__attribute((__stdcall__)) DWORD CommDlgExtendedError(); 
__attribute((__stdcall__)) HWND FindTextA(LPFINDREPLACEA); 
__attribute((__stdcall__)) HWND FindTextW(LPFINDREPLACEW); 
__attribute((__stdcall__)) short GetFileTitleA(LPCSTR, LPSTR, WORD); 
__attribute((__stdcall__)) short GetFileTitleW(LPCWSTR, LPWSTR, WORD); 
__attribute((__stdcall__)) BOOL GetOpenFileNameA(LPOPENFILENAMEA); 
__attribute((__stdcall__)) BOOL GetOpenFileNameW(LPOPENFILENAMEW); 
__attribute((__stdcall__)) BOOL GetSaveFileNameA(LPOPENFILENAMEA); 
__attribute((__stdcall__)) BOOL GetSaveFileNameW(LPOPENFILENAMEW); 
__attribute((__stdcall__)) BOOL PageSetupDlgA(LPPAGESETUPDLGA); 
__attribute((__stdcall__)) BOOL PageSetupDlgW(LPPAGESETUPDLGW); 
__attribute((__stdcall__)) BOOL PrintDlgA(LPPRINTDLGA); 
__attribute((__stdcall__)) BOOL PrintDlgW(LPPRINTDLGW); 
__attribute((__stdcall__)) HWND ReplaceTextA(LPFINDREPLACEA); 
__attribute((__stdcall__)) HWND ReplaceTextW(LPFINDREPLACEW); 

__attribute((__stdcall__)) HRESULT PrintDlgExA(LPPRINTDLGEXA); 
__attribute((__stdcall__)) HRESULT PrintDlgExW(LPPRINTDLGEXW); 
# 584 "d:\\mingw\\mingw\\include\\commdlg.h" 3
typedef CHOOSECOLORA CHOOSECOLOR, *LPCHOOSECOLOR; 
typedef CHOOSEFONTA CHOOSEFONT, *LPCHOOSEFONT; 
typedef FINDREPLACEA FINDREPLACE, *LPFINDREPLACE; 
typedef OPENFILENAMEA OPENFILENAME, *LPOPENFILENAME; 
typedef OFNOTIFYA OFNOTIFY, *LPOFNOTIFY; 
typedef PAGESETUPDLGA PAGESETUPDLG, *LPPAGESETUPDLG; 
typedef PRINTDLGA PRINTDLG, *LPPRINTDLG; 
# 601 "d:\\mingw\\mingw\\include\\commdlg.h" 3
typedef PRINTDLGEXA PRINTDLGEX, *LPPRINTDLGEX; 
# 607
}
# 605
#pragma pack ( pop )
# 39 "d:\\mingw\\mingw\\include\\winspool.h" 3
extern "C" {
# 335 "d:\\mingw\\mingw\\include\\winspool.h" 3
typedef 
# 332
struct _ADDJOB_INFO_1A { 
LPSTR Path; 
DWORD JobId; 
} ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A; 
# 341
typedef 
# 338
struct _ADDJOB_INFO_1W { 
LPWSTR Path; 
DWORD JobId; 
} ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W; 

typedef ADDJOB_INFO_1A ADDJOB_INFO_1, *PADDJOB_INFO_1, *LPADDJOB_INFO_1; 




typedef 
# 346
struct _DATATYPES_INFO_1A { 
LPSTR pName; 
} DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A; 




typedef 
# 351
struct _DATATYPES_INFO_1W { 
LPWSTR pName; 
} DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W; 

typedef DATATYPES_INFO_1A DATATYPES_INFO_1, *PDATATYPES_INFO_1, *LPDATATYPES_INFO_1; 
# 372
typedef 
# 358
struct _JOB_INFO_1A { 
DWORD JobId; 
LPSTR pPrinterName; 
LPSTR pMachineName; 
LPSTR pUserName; 
LPSTR pDocument; 
LPSTR pDatatype; 
LPSTR pStatus; 
DWORD Status; 
DWORD Priority; 
DWORD Position; 
DWORD TotalPages; 
DWORD PagesPrinted; 
SYSTEMTIME Submitted; 
} JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A; 
# 389
typedef 
# 375
struct _JOB_INFO_1W { 
DWORD JobId; 
LPWSTR pPrinterName; 
LPWSTR pMachineName; 
LPWSTR pUserName; 
LPWSTR pDocument; 
LPWSTR pDatatype; 
LPWSTR pStatus; 
DWORD Status; 
DWORD Priority; 
DWORD Position; 
DWORD TotalPages; 
DWORD PagesPrinted; 
SYSTEMTIME Submitted; 
} JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W; 

typedef JOB_INFO_1A JOB_INFO_1, *PJOB_INFO_1, *LPJOB_INFO_1; 
# 418
typedef 
# 394
struct _JOB_INFO_2A { 
DWORD JobId; 
LPSTR pPrinterName; 
LPSTR pMachineName; 
LPSTR pUserName; 
LPSTR pDocument; 
LPSTR pNotifyName; 
LPSTR pDatatype; 
LPSTR pPrintProcessor; 
LPSTR pParameters; 
LPSTR pDriverName; 
LPDEVMODEA pDevMode; 
LPSTR pStatus; 
PSECURITY_DESCRIPTOR pSecurityDescriptor; 
DWORD Status; 
DWORD Priority; 
DWORD Position; 
DWORD StartTime; 
DWORD UntilTime; 
DWORD TotalPages; 
DWORD Size; 
SYSTEMTIME Submitted; 
DWORD Time; 
DWORD PagesPrinted; 
} JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A; 
# 445
typedef 
# 421
struct _JOB_INFO_2W { 
DWORD JobId; 
LPWSTR pPrinterName; 
LPWSTR pMachineName; 
LPWSTR pUserName; 
LPWSTR pDocument; 
LPWSTR pNotifyName; 
LPWSTR pDatatype; 
LPWSTR pPrintProcessor; 
LPWSTR pParameters; 
LPWSTR pDriverName; 
LPDEVMODEW pDevMode; 
LPWSTR pStatus; 
PSECURITY_DESCRIPTOR pSecurityDescriptor; 
DWORD Status; 
DWORD Priority; 
DWORD Position; 
DWORD StartTime; 
DWORD UntilTime; 
DWORD TotalPages; 
DWORD Size; 
SYSTEMTIME Submitted; 
DWORD Time; 
DWORD PagesPrinted; 
} JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W; 

typedef JOB_INFO_2A JOB_INFO_2, *PJOB_INFO_2, *LPJOB_INFO_2; 
# 454
typedef 
# 450
struct _JOB_INFO_3 { 
DWORD JobId; 
DWORD NextJobId; 
DWORD Reserved; 
} JOB_INFO_3, *PJOB_INFO_3, *LPJOB_INFO_3; 
# 461
typedef 
# 457
struct _DOC_INFO_1A { 
LPSTR pDocName; 
LPSTR pOutputFile; 
LPSTR pDatatype; 
} DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A; 
# 468
typedef 
# 464
struct _DOC_INFO_1W { 
LPWSTR pDocName; 
LPWSTR pOutputFile; 
LPWSTR pDatatype; 
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W; 

typedef DOC_INFO_1A DOC_INFO_1, *PDOC_INFO_1, *LPDOC_INFO_1; 
# 479
typedef 
# 473
struct _DOC_INFO_2A { 
LPSTR pDocName; 
LPSTR pOutputFile; 
LPSTR pDatatype; 
DWORD dwMode; 
DWORD JobId; 
} DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A; 
# 488
typedef 
# 482
struct _DOC_INFO_2W { 
LPWSTR pDocName; 
LPWSTR pOutputFile; 
LPWSTR pDatatype; 
DWORD dwMode; 
DWORD JobId; 
} DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W; 

typedef DOC_INFO_2A DOC_INFO_2, *PDOC_INFO_2, *LPDOC_INFO_2; 




typedef 
# 493
struct _DRIVER_INFO_1A { 
LPSTR pName; 
} DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A; 




typedef 
# 498
struct _DRIVER_INFO_1W { 
LPWSTR pName; 
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W; 

typedef DRIVER_INFO_1A DRIVER_INFO_1, *PDRIVER_INFO_1, *LPDRIVER_INFO_1; 
# 512
typedef 
# 505
struct _DRIVER_INFO_2A { 
DWORD cVersion; 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDriverPath; 
LPSTR pDataFile; 
LPSTR pConfigFile; 
} DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A; 
# 522
typedef 
# 515
struct _DRIVER_INFO_2W { 
DWORD cVersion; 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDriverPath; 
LPWSTR pDataFile; 
LPWSTR pConfigFile; 
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W; 

typedef DRIVER_INFO_2A DRIVER_INFO_2, *PDRIVER_INFO_2, *LPDRIVER_INFO_2; 
# 538
typedef 
# 527
struct _DRIVER_INFO_3A { 
DWORD cVersion; 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDriverPath; 
LPSTR pDataFile; 
LPSTR pConfigFile; 
LPSTR pHelpFile; 
LPSTR pDependentFiles; 
LPSTR pMonitorName; 
LPSTR pDefaultDataType; 
} DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A; 
# 552
typedef 
# 541
struct _DRIVER_INFO_3W { 
DWORD cVersion; 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDriverPath; 
LPWSTR pDataFile; 
LPWSTR pConfigFile; 
LPWSTR pHelpFile; 
LPWSTR pDependentFiles; 
LPWSTR pMonitorName; 
LPWSTR pDefaultDataType; 
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W; 

typedef DRIVER_INFO_3A DRIVER_INFO_3, *PDRIVER_INFO_3, *LPDRIVER_INFO_3; 
# 571
typedef 
# 559
struct _DRIVER_INFO_4A { 
DWORD cVersion; 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDriverPath; 
LPSTR pDataFile; 
LPSTR pConfigFile; 
LPSTR pHelpFile; 
LPSTR pDependentFiles; 
LPSTR pMonitorName; 
LPSTR pDefaultDataType; 
LPSTR pszzPreviousNames; 
} DRIVER_INFO_4A, *PDRIVER_INFO_4A, *LPDRIVER_INFO_4A; 
# 586
typedef 
# 574
struct _DRIVER_INFO_4W { 
DWORD cVersion; 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDriverPath; 
LPWSTR pDataFile; 
LPWSTR pConfigFile; 
LPWSTR pHelpFile; 
LPWSTR pDependentFiles; 
LPWSTR pMonitorName; 
LPWSTR pDefaultDataType; 
LPWSTR pszzPreviousNames; 
} DRIVER_INFO_4W, *PDRIVER_INFO_4W, *LPDRIVER_INFO_4W; 

typedef DRIVER_INFO_4A DRIVER_INFO_4, *PDRIVER_INFO_4, *LPDRIVER_INFO_4; 
# 601
typedef 
# 591
struct _DRIVER_INFO_5A { 
DWORD cVersion; 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDriverPath; 
LPSTR pDataFile; 
LPSTR pConfigFile; 
DWORD dwDriverAttributes; 
DWORD dwConfigVersion; 
DWORD dwDriverVersion; 
} DRIVER_INFO_5A, *PDRIVER_INFO_5A, *LPDRIVER_INFO_5A; 
# 614
typedef 
# 604
struct _DRIVER_INFO_5W { 
DWORD cVersion; 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDriverPath; 
LPWSTR pDataFile; 
LPWSTR pConfigFile; 
DWORD dwDriverAttributes; 
DWORD dwConfigVersion; 
DWORD dwDriverVersion; 
} DRIVER_INFO_5W, *PDRIVER_INFO_5W, *LPDRIVER_INFO_5W; 

typedef DRIVER_INFO_5A DRIVER_INFO_5, *PDRIVER_INFO_5, *LPDRIVER_INFO_5; 
# 637
typedef 
# 619
struct _DRIVER_INFO_6A { 
DWORD cVersion; 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDriverPath; 
LPSTR pDataFile; 
LPSTR pConfigFile; 
LPSTR pHelpFile; 
LPSTR pDependentFiles; 
LPSTR pMonitorName; 
LPSTR pDefaultDataType; 
LPSTR pszzPreviousNames; 
FILETIME ftDriverDate; 
DWORDLONG dwlDriverVersion; 
LPSTR pszMfgName; 
LPSTR pszOEMUrl; 
LPSTR pszHardwareID; 
LPSTR pszProvider; 
} DRIVER_INFO_6A, *PDRIVER_INFO_6A, *LPDRIVER_INFO_6A; 
# 658
typedef 
# 640
struct _DRIVER_INFO_6W { 
DWORD cVersion; 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDriverPath; 
LPWSTR pDataFile; 
LPWSTR pConfigFile; 
LPWSTR pHelpFile; 
LPWSTR pDependentFiles; 
LPWSTR pMonitorName; 
LPWSTR pDefaultDataType; 
LPWSTR pszzPreviousNames; 
FILETIME ftDriverDate; 
DWORDLONG dwlDriverVersion; 
LPWSTR pszMfgName; 
LPWSTR pszOEMUrl; 
LPWSTR pszHardwareID; 
LPWSTR pszProvider; 
} DRIVER_INFO_6W, *PDRIVER_INFO_6W, *LPDRIVER_INFO_6W; 

typedef DRIVER_INFO_6A DRIVER_INFO_6, *PDRIVER_INFO_6, *LPDRIVER_INFO_6; 
# 667
typedef 
# 665
struct _MONITOR_INFO_1A { 
LPSTR pName; 
} MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A; 




typedef 
# 670
struct _MONITOR_INFO_1W { 
LPWSTR pName; 
} MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W; 

typedef MONITOR_INFO_1A MONITOR_INFO_1, *PMONITOR_INFO_1, *LPMONITOR_INFO_1; 




typedef 
# 677
struct _PORT_INFO_1A { 
LPSTR pName; 
} PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A; 




typedef 
# 682
struct _PORT_INFO_1W { 
LPWSTR pName; 
} PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W; 

typedef PORT_INFO_1A PORT_INFO_1, *PPORT_INFO_1, *LPPORT_INFO_1; 
# 693
typedef 
# 689
struct _MONITOR_INFO_2A { 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDLLName; 
} MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A; 
# 700
typedef 
# 696
struct _MONITOR_INFO_2W { 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDLLName; 
} MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W; 

typedef MONITOR_INFO_2A MONITOR_INFO_2, *PMONITOR_INFO_2, *LPMONITOR_INFO_2; 
# 711
typedef 
# 705
struct _PORT_INFO_2A { 
LPSTR pPortName; 
LPSTR pMonitorName; 
LPSTR pDescription; 
DWORD fPortType; 
DWORD Reserved; 
} PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A; 
# 720
typedef 
# 714
struct _PORT_INFO_2W { 
LPWSTR pPortName; 
LPWSTR pMonitorName; 
LPWSTR pDescription; 
DWORD fPortType; 
DWORD Reserved; 
} PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W; 

typedef PORT_INFO_2A PORT_INFO_2, *PPORT_INFO_2, *LPPORT_INFO_2; 
# 729
typedef 
# 725
struct _PORT_INFO_3A { 
DWORD dwStatus; 
LPSTR pszStatus; 
DWORD dwSeverity; 
} PORT_INFO_3A, *PPORT_INFO_3A, *LPPORT_INFO_3A; 
# 736
typedef 
# 732
struct _PORT_INFO_3W { 
DWORD dwStatus; 
LPWSTR pszStatus; 
DWORD dwSeverity; 
} PORT_INFO_3W, *PPORT_INFO_3W, *LPPORT_INFO_3W; 

typedef PORT_INFO_3A PORT_INFO_3, *PPORT_INFO_3, *LPPORT_INFO_3; 
# 749
typedef 
# 743
struct _PRINTER_ENUM_VALUESA { 
LPSTR pValueName; 
DWORD cbValueName; 
DWORD dwType; 
LPBYTE pData; 
DWORD cbData; 
} PRINTER_ENUM_VALUESA, *PPRINTER_ENUM_VALUESA, *LPRINTER_ENUM_VALUESA; 
# 758
typedef 
# 752
struct _PRINTER_ENUM_VALUESW { 
LPWSTR pValueName; 
DWORD cbValueName; 
DWORD dwType; 
LPBYTE pData; 
DWORD cbData; 
} PRINTER_ENUM_VALUESW, *PPRINTER_ENUM_VALUESW, *LPRINTER_ENUM_VALUESW; 

typedef PRINTER_ENUM_VALUESA PRINTER_ENUM_VALUES, *PPRINTER_ENUM_VALUES; 
typedef PRINTER_ENUM_VALUES *LPRINTER_ENUM_VALUES; 
# 771
typedef 
# 766
struct _PRINTER_INFO_1A { 
DWORD Flags; 
LPSTR pDescription; 
LPSTR pName; 
LPSTR pComment; 
} PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A; 
# 779
typedef 
# 774
struct _PRINTER_INFO_1W { 
DWORD Flags; 
LPWSTR pDescription; 
LPWSTR pName; 
LPWSTR pComment; 
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W; 

typedef PRINTER_INFO_1A PRINTER_INFO_1, *PPRINTER_INFO_1, *LPPRINTER_INFO_1; 
# 806
typedef 
# 784
struct _PRINTER_INFO_2A { 
LPSTR pServerName; 
LPSTR pPrinterName; 
LPSTR pShareName; 
LPSTR pPortName; 
LPSTR pDriverName; 
LPSTR pComment; 
LPSTR pLocation; 
LPDEVMODEA pDevMode; 
LPSTR pSepFile; 
LPSTR pPrintProcessor; 
LPSTR pDatatype; 
LPSTR pParameters; 
PSECURITY_DESCRIPTOR pSecurityDescriptor; 
DWORD Attributes; 
DWORD Priority; 
DWORD DefaultPriority; 
DWORD StartTime; 
DWORD UntilTime; 
DWORD Status; 
DWORD cJobs; 
DWORD AveragePPM; 
} PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A; 
# 831
typedef 
# 809
struct _PRINTER_INFO_2W { 
LPWSTR pServerName; 
LPWSTR pPrinterName; 
LPWSTR pShareName; 
LPWSTR pPortName; 
LPWSTR pDriverName; 
LPWSTR pComment; 
LPWSTR pLocation; 
LPDEVMODEW pDevMode; 
LPWSTR pSepFile; 
LPWSTR pPrintProcessor; 
LPWSTR pDatatype; 
LPWSTR pParameters; 
PSECURITY_DESCRIPTOR pSecurityDescriptor; 
DWORD Attributes; 
DWORD Priority; 
DWORD DefaultPriority; 
DWORD StartTime; 
DWORD UntilTime; 
DWORD Status; 
DWORD cJobs; 
DWORD AveragePPM; 
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W; 

typedef PRINTER_INFO_2A PRINTER_INFO_2, *PPRINTER_INFO_2, *LPPRINTER_INFO_2; 




typedef 
# 836
struct _PRINTER_INFO_3 { 
PSECURITY_DESCRIPTOR pSecurityDescriptor; 
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3; 
# 845
typedef 
# 841
struct _PRINTER_INFO_4A { 
LPSTR pPrinterName; 
LPSTR pServerName; 
DWORD Attributes; 
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A; 
# 852
typedef 
# 848
struct _PRINTER_INFO_4W { 
LPWSTR pPrinterName; 
LPWSTR pServerName; 
DWORD Attributes; 
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W; 

typedef PRINTER_INFO_4A PRINTER_INFO_4, *PPRINTER_INFO_4, *LPPRINTER_INFO_4; 
# 863
typedef 
# 857
struct _PRINTER_INFO_5A { 
LPSTR pPrinterName; 
LPSTR pPortName; 
DWORD Attributes; 
DWORD DeviceNotSelectedTimeout; 
DWORD TransmissionRetryTimeout; 
} PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A; 
# 872
typedef 
# 866
struct _PRINTER_INFO_5W { 
LPWSTR pPrinterName; 
LPWSTR pPortName; 
DWORD Attributes; 
DWORD DeviceNotSelectedTimeout; 
DWORD TransmissionRetryTimeout; 
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W; 

typedef PRINTER_INFO_5A PRINTER_INFO_5, *PPRINTER_INFO_5, *LPPRINTER_INFO_5; 




typedef 
# 877
struct _PRINTER_INFO_6 { 
DWORD dwStatus; 
} PRINTER_INFO_6, *PPRINTER_INFO_6, *LPPRINTER_INFO_6; 
# 887
typedef 
# 884
struct _PRINTER_INFO_7A { 
LPSTR pszObjectGUID; 
DWORD dwAction; 
} PRINTER_INFO_7A, *PPRINTER_INFO_7A, *LPPRINTER_INFO_7A; 
# 893
typedef 
# 890
struct _PRINTER_INFO_7W { 
LPWSTR pszObjectGUID; 
DWORD dwAction; 
} PRINTER_INFO_7W, *PPRINTER_INFO_7W, *LPPRINTER_INFO_7W; 

typedef PRINTER_INFO_7A PRINTER_INFO_7, *PPRINTER_INFO_7, *LPPRINTER_INFO_7; 




typedef 
# 898
struct _PRINTER_INFO_8 { 
LPDEVMODE pDevMode; 
} PRINTER_INFO_8, *PPRINTER_INFO_8, *LPPRINTER_INFO_8; 




typedef 
# 903
struct _PRINTER_INFO_9 { 
LPDEVMODE pDevMode; 
} PRINTER_INFO_9, *PPRINTER_INFO_9, *LPPRINTER_INFO_9; 
# 912
typedef 
# 910
struct _PRINTPROCESSOR_INFO_1A { 
LPSTR pName; 
} PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A; 




typedef 
# 915
struct _PRINTPROCESSOR_INFO_1W { 
LPWSTR pName; 
} PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W; 

typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1, *PPRINTPROCESSOR_INFO_1; 
typedef PRINTPROCESSOR_INFO_1 *LPPRINTPROCESSOR_INFO_1; 
# 935
typedef 
# 923
struct _PRINTER_NOTIFY_INFO_DATA { 
WORD Type; 
WORD Field; 
DWORD Reserved; 
DWORD Id; 

union { DWORD adwData[2]; 

struct { DWORD cbBuf; 
PVOID pBuf; 
} Data; 
} NotifyData; 
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA; 


typedef _PRINTER_NOTIFY_INFO_DATA *LPPRINTER_NOTIFY_INFO_DATA; 
# 946
typedef 
# 941
struct _PRINTER_NOTIFY_INFO { 
DWORD Version; 
DWORD Flags; 
DWORD Count; 
PRINTER_NOTIFY_INFO_DATA aData[1]; 
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO; 
# 954
typedef 
# 949
struct _FORM_INFO_1A { 
DWORD Flags; 
LPSTR pName; 
SIZEL Size; 
RECTL ImageableArea; 
} FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A; 
# 962
typedef 
# 957
struct _FORM_INFO_1W { 
DWORD Flags; 
LPWSTR pName; 
SIZEL Size; 
RECTL ImageableArea; 
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W; 

typedef FORM_INFO_1A FORM_INFO_1, *PFORM_INFO_1, *LPFORM_INFO_1; 
# 971
typedef 
# 967
struct _PRINTER_DEFAULTSA { 
LPSTR pDatatype; 
LPDEVMODE pDevMode; 
ACCESS_MASK DesiredAccess; 
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA; 
# 978
typedef 
# 974
struct _PRINTER_DEFAULTSW { 
LPWSTR pDatatype; 
LPDEVMODE pDevMode; 
ACCESS_MASK DesiredAccess; 
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW; 

typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS, *PPRINTER_DEFAULTS, *LPPRINTER_DEFAULTS; 
# 990
typedef 
# 985
struct _PRINTPROCESSOR_CAPS_1 { 
DWORD dwLevel; 
DWORD dwNupOptions; 
DWORD dwPageOrderFlags; 
DWORD dwNumberOfCopies; 
} PRINTPROCESSOR_CAPS_1, *PPRINTPROCESSOR_CAPS_1, *LPPRINTPROCESSOR_CAPS_1; 
# 999
typedef 
# 995
struct _PROVIDOR_INFO_1A { 
LPSTR pName; 
LPSTR pEnvironment; 
LPSTR pDLLName; 
} PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A; 
# 1006
typedef 
# 1002
struct _PROVIDOR_INFO_1W { 
LPWSTR pName; 
LPWSTR pEnvironment; 
LPWSTR pDLLName; 
} PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W; 

typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1, *PPROVIDOR_INFO_1, *LPROVIDOR_INFO_1; 




typedef 
# 1011
struct _PROVIDOR_INFO_2A { 
LPSTR pOrder; 
} PROVIDOR_INFO_2A, *PPROVIDOR_INFO_2A, *LPROVIDOR_INFO_2A; 




typedef 
# 1016
struct _PROVIDOR_INFO_2W { 
LPWSTR pOrder; 
} PROVIDOR_INFO_2W, *PPROVIDOR_INFO_2W, *LPROVIDOR_INFO_2W; 

typedef PROVIDOR_INFO_2A PROVIDOR_INFO_2, *PPROVIDOR_INFO_2, *LPROVIDOR_INFO_2; 

__attribute((__stdcall__)) BOOL AbortPrinter(HANDLE); 


__attribute((__stdcall__)) BOOL AddFormA(HANDLE, DWORD, PBYTE); 
__attribute((__stdcall__)) BOOL AddFormW(HANDLE, DWORD, PBYTE); 


__attribute((__stdcall__)) BOOL AddJobA(HANDLE, DWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL AddJobW(HANDLE, DWORD, PBYTE, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL AddMonitorA(LPSTR, DWORD, PBYTE); 
__attribute((__stdcall__)) BOOL AddMonitorW(LPWSTR, DWORD, PBYTE); 


__attribute((__stdcall__)) BOOL AddPortA(LPSTR, HWND, LPSTR); 
__attribute((__stdcall__)) BOOL AddPortW(LPWSTR, HWND, LPWSTR); 


__attribute((__stdcall__)) HANDLE AddPrinterA(LPSTR, DWORD, PBYTE); 
__attribute((__stdcall__)) HANDLE AddPrinterW(LPWSTR, DWORD, PBYTE); 


__attribute((__stdcall__)) BOOL AddPrinterConnectionA(LPSTR); 
__attribute((__stdcall__)) BOOL AddPrinterConnectionW(LPWSTR); 


__attribute((__stdcall__)) BOOL AddPrinterDriverA(LPSTR, DWORD, PBYTE); 
__attribute((__stdcall__)) BOOL AddPrinterDriverW(LPWSTR, DWORD, PBYTE); 


__attribute((__stdcall__)) BOOL AddPrintProcessorA(LPSTR, LPSTR, LPSTR, LPSTR); 
__attribute((__stdcall__)) BOOL AddPrintProcessorW(LPWSTR, LPWSTR, LPWSTR, LPWSTR); 


__attribute((__stdcall__)) BOOL AddPrintProvidorA(LPSTR, DWORD, PBYTE); 
__attribute((__stdcall__)) BOOL AddPrintProvidorW(LPWSTR, DWORD, PBYTE); 



__attribute((__stdcall__)) LONG AdvancedDocumentPropertiesA(HWND, HANDLE, LPSTR, PDEVMODE, PDEVMODEA); 

__attribute((__stdcall__)) LONG AdvancedDocumentPropertiesW(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODEW); 


__attribute((__stdcall__)) BOOL ClosePrinter(HANDLE); 


__attribute((__stdcall__)) BOOL ConfigurePortA(LPSTR, HWND, LPSTR); 
__attribute((__stdcall__)) BOOL ConfigurePortW(LPWSTR, HWND, LPWSTR); 

__attribute((__stdcall__)) HANDLE ConnectToPrinterDlg(HWND, DWORD); 


__attribute((__stdcall__)) BOOL DeleteFormA(HANDLE, LPSTR); 
__attribute((__stdcall__)) BOOL DeleteFormW(HANDLE, LPWSTR); 


__attribute((__stdcall__)) BOOL DeleteMonitorA(LPSTR, LPSTR, LPSTR); 
__attribute((__stdcall__)) BOOL DeleteMonitorW(LPWSTR, LPWSTR, LPWSTR); 


__attribute((__stdcall__)) BOOL DeletePortA(LPSTR, HWND, LPSTR); 
__attribute((__stdcall__)) BOOL DeletePortW(LPWSTR, HWND, LPWSTR); 

__attribute((__stdcall__)) BOOL DeletePrinter(HANDLE); 


__attribute((__stdcall__)) BOOL DeletePrinterConnectionA(LPSTR); 
__attribute((__stdcall__)) BOOL DeletePrinterConnectionW(LPWSTR); 


__attribute((__stdcall__)) DWORD DeletePrinterDataA(HANDLE, LPSTR); 
__attribute((__stdcall__)) DWORD DeletePrinterDataW(HANDLE, LPWSTR); 


__attribute((__stdcall__)) BOOL DeletePrinterDriverA(LPSTR, LPSTR, LPSTR); 
__attribute((__stdcall__)) BOOL DeletePrinterDriverW(LPWSTR, LPWSTR, LPWSTR); 


__attribute((__stdcall__)) BOOL DeletePrintProcessorA(LPSTR, LPSTR, LPSTR); 
__attribute((__stdcall__)) BOOL DeletePrintProcessorW(LPWSTR, LPWSTR, LPWSTR); 


__attribute((__stdcall__)) BOOL DeletePrintProvidorA(LPSTR, LPSTR, LPSTR); 
__attribute((__stdcall__)) BOOL DeletePrintProvidorW(LPWSTR, LPWSTR, LPWSTR); 



__attribute((__stdcall__)) LONG DocumentPropertiesA(HWND, HANDLE, LPSTR, PDEVMODEA, PDEVMODEA, DWORD); 

__attribute((__stdcall__)) LONG DocumentPropertiesW(HWND, HANDLE, LPWSTR, PDEVMODEW, PDEVMODEW, DWORD); 


__attribute((__stdcall__)) BOOL EndDocPrinter(HANDLE); 
__attribute((__stdcall__)) BOOL EndPagePrinter(HANDLE); 


__attribute((__stdcall__)) BOOL EnumFormsA(HANDLE, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL EnumFormsW(HANDLE, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL EnumJobsA(HANDLE, DWORD, DWORD, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL EnumJobsW(HANDLE, DWORD, DWORD, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL EnumMonitorsA(LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL EnumMonitorsW(LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 


__attribute((__stdcall__)) BOOL EnumPortsA(LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL EnumPortsW(LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) DWORD EnumPrinterDataA(HANDLE, DWORD, LPSTR, DWORD, PDWORD, PDWORD, PBYTE, DWORD, PDWORD); 

__attribute((__stdcall__)) DWORD EnumPrinterDataW(HANDLE, DWORD, LPWSTR, DWORD, PDWORD, PDWORD, PBYTE, DWORD, PDWORD); 




__attribute((__stdcall__)) BOOL EnumPrinterDriversA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL EnumPrinterDriversW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL EnumPrintersA(DWORD, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 
__attribute((__stdcall__)) BOOL EnumPrintersW(DWORD, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 



__attribute((__stdcall__)) BOOL EnumPrintProcessorDatatypesA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL EnumPrintProcessorDatatypesW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 




__attribute((__stdcall__)) BOOL EnumPrintProcessorsA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 

__attribute((__stdcall__)) BOOL EnumPrintProcessorsW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD); 


__attribute((__stdcall__)) BOOL FindClosePrinterChangeNotification(HANDLE); 
__attribute((__stdcall__)) HANDLE FindFirstPrinterChangeNotification(HANDLE, DWORD, DWORD, PVOID); 
__attribute((__stdcall__)) HANDLE FindNextPrinterChangeNotification(HANDLE, PDWORD, PVOID, PVOID *); 
__attribute((__stdcall__)) BOOL FreePrinterNotifyInfo(PPRINTER_NOTIFY_INFO); 




__attribute((__stdcall__)) BOOL GetDefaultPrinterA(LPSTR, LPDWORD); 
__attribute((__stdcall__)) BOOL GetDefaultPrinterW(LPWSTR, LPDWORD); 




__attribute((__stdcall__)) BOOL GetFormA(HANDLE, LPSTR, DWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL GetFormW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL GetJobA(HANDLE, DWORD, DWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL GetJobW(HANDLE, DWORD, DWORD, PBYTE, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL GetPrinterA(HANDLE, DWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) BOOL GetPrinterW(HANDLE, DWORD, PBYTE, DWORD, PDWORD); 


__attribute((__stdcall__)) DWORD GetPrinterDataA(HANDLE, LPSTR, PDWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) DWORD GetPrinterDataW(HANDLE, LPWSTR, PDWORD, PBYTE, DWORD, PDWORD); 


__attribute((__stdcall__)) DWORD GetPrinterDriverA(HANDLE, LPSTR, DWORD, PBYTE, DWORD, PDWORD); 
__attribute((__stdcall__)) DWORD GetPrinterDriverW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD, PDWORD); 



__attribute((__stdcall__)) DWORD GetPrinterDriverDirectoryA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD); 

__attribute((__stdcall__)) DWORD GetPrinterDriverDirectoryW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD); 




__attribute((__stdcall__)) DWORD GetPrintProcessorDirectoryA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD); 

__attribute((__stdcall__)) DWORD GetPrintProcessorDirectoryW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD); 



__attribute((__stdcall__)) BOOL OpenPrinterA(LPSTR, PHANDLE, LPPRINTER_DEFAULTSA); 
__attribute((__stdcall__)) BOOL OpenPrinterW(LPWSTR, PHANDLE, LPPRINTER_DEFAULTSW); 


__attribute((__stdcall__)) DWORD PrinterMessageBoxA(HANDLE, DWORD, HWND, LPSTR, LPSTR, DWORD); 
__attribute((__stdcall__)) DWORD PrinterMessageBoxW(HANDLE, DWORD, HWND, LPWSTR, LPWSTR, DWORD); 

__attribute((__stdcall__)) BOOL PrinterProperties(HWND, HANDLE); 
__attribute((__stdcall__)) BOOL ReadPrinter(HANDLE, PVOID, DWORD, PDWORD); 


__attribute((__stdcall__)) BOOL ResetPrinterA(HANDLE, LPPRINTER_DEFAULTSA); 
__attribute((__stdcall__)) BOOL ResetPrinterW(HANDLE, LPPRINTER_DEFAULTSW); 

__attribute((__stdcall__)) BOOL ScheduleJob(HANDLE, DWORD); 


__attribute((__stdcall__)) BOOL SetFormA(HANDLE, LPSTR, DWORD, PBYTE); 
__attribute((__stdcall__)) BOOL SetFormW(HANDLE, LPWSTR, DWORD, PBYTE); 


__attribute((__stdcall__)) BOOL SetJobA(HANDLE, DWORD, DWORD, PBYTE, DWORD); 
__attribute((__stdcall__)) BOOL SetJobW(HANDLE, DWORD, DWORD, PBYTE, DWORD); 


__attribute((__stdcall__)) BOOL SetPrinterA(HANDLE, DWORD, PBYTE, DWORD); 
__attribute((__stdcall__)) BOOL SetPrinterW(HANDLE, DWORD, PBYTE, DWORD); 


__attribute((__stdcall__)) BOOL SetPrinterDataA(HANDLE, LPSTR, DWORD, PBYTE, DWORD); 
__attribute((__stdcall__)) BOOL SetPrinterDataW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD); 


__attribute((__stdcall__)) DWORD StartDocPrinterA(HANDLE, DWORD, PBYTE); 
__attribute((__stdcall__)) DWORD StartDocPrinterW(HANDLE, DWORD, PBYTE); 

__attribute((__stdcall__)) BOOL StartPagePrinter(HANDLE); 
__attribute((__stdcall__)) DWORD WaitForPrinterChange(HANDLE, DWORD); 
__attribute((__stdcall__)) BOOL WritePrinter(HANDLE, PVOID, DWORD, PDWORD); 



}
# 59 "d:\\mingw\\mingw\\include\\sys\\bsdtypes.h" 3
typedef unsigned char u_char; 
typedef unsigned short u_short; 
typedef unsigned u_int; 
typedef unsigned long u_long; 
# 128 "d:\\mingw\\mingw\\include\\winsock.h" 3
extern "C" {

typedef u_int SOCKET; 
# 150 "d:\\mingw\\mingw\\include\\winsock.h" 3
typedef 
# 147
struct fd_set { 
u_int fd_count; 
SOCKET fd_array[64]; 
} fd_set; 


int FD_ISSET(SOCKET, fd_set *); 
# 160
__attribute((__stdcall__)) int __WSAFDIsSet(SOCKET, fd_set *); 



__attribute((__always_inline__)) inline int __FD_ISSET(SOCKET __fd, fd_set *__set) 
{ return __WSAFDIsSet(__fd, __set); } 
# 180 "d:\\mingw\\mingw\\include\\winsock.h" 3
void FD_SET(SOCKET, fd_set *); 
# 196 "d:\\mingw\\mingw\\include\\winsock.h" 3
__attribute((__always_inline__)) inline void __FD_SET(SOCKET __fd, fd_set *__set) 
{ if ((__set->fd_count < 64) && !__FD_ISSET((__fd), (__set))) 
(__set->fd_array)[(__set->fd_count)++] = __fd;   
} 



void FD_CLR(SOCKET, fd_set *); 

__attribute((__always_inline__)) inline void __FD_CLR(SOCKET __fd, fd_set *__set) 
{ u_int __m, __n; for (__m = (__n = 0); __n < __set->fd_count; __n++) 
{ if (__fd != (__set->fd_array)[__n]) 
{ if (__m < __n) (__set->fd_array)[__m] = (__set->fd_array)[__n];   
++__m; 
}  
}  __set->fd_count = __m; 
} 



void FD_ZERO(fd_set *); 

__attribute((__always_inline__)) inline void __FD_ZERO(fd_set *__set) 
{ __set->fd_count = 0; } 
# 234 "d:\\mingw\\mingw\\include\\winsock.h" 3
struct hostent { 
char *h_name; 
char **h_aliases; 
short h_addrtype; 
short h_length; 

char **h_addr_list; 
}; 

struct linger { 
u_short l_onoff; 
u_short l_linger; 
}; 
# 276 "d:\\mingw\\mingw\\include\\winsock.h" 3
struct netent { 
char *n_name; 
char **n_aliases; 
short n_addrtype; 
u_long n_net; 
}; 

struct servent { 
char *s_name; 
char **s_aliases; 
short s_port; 
char *s_proto; 
}; 

struct protoent { 
char *p_name; 
char **p_aliases; 
short p_proto; 
}; 
# 341 "d:\\mingw\\mingw\\include\\winsock.h" 3
struct in_addr { 
# 349
union { struct { u_char s_b1, s_b2, s_b3, s_b4; } S_un_b; 
struct { u_short s_w1, s_w2; } S_un_w; 
u_long S_addr; 
} S_un; 
}; 
# 374 "d:\\mingw\\mingw\\include\\winsock.h" 3
struct sockaddr_in { 
short sin_family; 
u_short sin_port; 
in_addr sin_addr; 
char sin_zero[8]; 
}; 
# 393
typedef 
# 385
struct WSAData { 
WORD wVersion; 
WORD wHighVersion; 
char szDescription[256 + 1]; 
char szSystemStatus[128 + 1]; 
unsigned short iMaxSockets; 
unsigned short iMaxUdpDg; 
char *lpVendorInfo; 
} WSADATA, *LPWSADATA; 
# 485 "d:\\mingw\\mingw\\include\\winsock.h" 3
struct sockaddr { 
u_short sa_family; 
char sa_data[14]; 
}; 



struct sockproto { 
u_short sp_family; 
u_short sp_protocol; 
}; 
# 546 "d:\\mingw\\mingw\\include\\winsock.h" 3
enum { 


FD_READ_BIT, 


FD_WRITE_BIT, 


FD_OOB_BIT, 


FD_ACCEPT_BIT, 


FD_CONNECT_BIT, 


FD_CLOSE_BIT, 
# 573 "d:\\mingw\\mingw\\include\\winsock.h" 3
FD_QOS_BIT, 


FD_GROUP_QOS_BIT, 


FD_ROUTING_INTERFACE_CHANGE_BIT, 


FD_ADDRESS_LIST_CHANGE_BIT, 
# 590
FD_MAX_EVENTS

}; 
# 607 "d:\\mingw\\mingw\\include\\winsock.h" 3
__attribute((__stdcall__)) SOCKET accept(SOCKET, sockaddr *, int *); 

__attribute((__stdcall__)) int bind(SOCKET, const sockaddr *, int); 
__attribute((__stdcall__)) int closesocket(SOCKET); 
__attribute((__stdcall__)) int connect(SOCKET, const sockaddr *, int); 
__attribute((__stdcall__)) int ioctlsocket(SOCKET, long, u_long *); 
__attribute((__stdcall__)) int getpeername(SOCKET, sockaddr *, int *); 
__attribute((__stdcall__)) int getsockname(SOCKET, sockaddr *, int *); 
__attribute((__stdcall__)) int getsockopt(SOCKET, int, int, char *, int *); 

__attribute((__stdcall__)) unsigned long inet_addr(const char *); 

__attribute((__stdcall__)) char *inet_ntoa(in_addr); 

__attribute((__stdcall__)) int listen(SOCKET, int); 
__attribute((__stdcall__)) int recv(SOCKET, char *, int, int); 
__attribute((__stdcall__)) int recvfrom(SOCKET, char *, int, int, sockaddr *, int *); 
__attribute((__stdcall__)) int send(SOCKET, const char *, int, int); 
__attribute((__stdcall__)) int sendto(SOCKET, const char *, int, int, const sockaddr *, int); 
__attribute((__stdcall__)) int setsockopt(SOCKET, int, int, const char *, int); 
__attribute((__stdcall__)) int shutdown(SOCKET, int); 

__attribute((__stdcall__)) SOCKET socket(int, int, int); 

__attribute((__stdcall__)) hostent *gethostbyaddr(const char *, int, int); 
__attribute((__stdcall__)) hostent *gethostbyname(const char *); 
__attribute((__stdcall__)) servent *getservbyport(int, const char *); 
__attribute((__stdcall__)) servent *getservbyname(const char *, const char *); 
__attribute((__stdcall__)) protoent *getprotobynumber(int); 
__attribute((__stdcall__)) protoent *getprotobyname(const char *); 

__attribute((__stdcall__)) int WSAStartup(WORD, LPWSADATA); 
__attribute((__stdcall__)) int WSACleanup(); 
__attribute((__stdcall__)) void WSASetLastError(int); 
__attribute((__stdcall__)) int WSAGetLastError(); 
# 648
__attribute((__stdcall__)) BOOL WSAIsBlocking() __attribute((__deprecated__)); 
__attribute((__stdcall__)) int WSAUnhookBlockingHook() __attribute((__deprecated__)); 
__attribute((__stdcall__)) FARPROC WSASetBlockingHook(FARPROC) __attribute((__deprecated__)); 
__attribute((__stdcall__)) int WSACancelBlockingCall() __attribute((__deprecated__)); 

__attribute((__stdcall__)) HANDLE WSAAsyncGetServByName(HWND, u_int, const char *, const char *, char *, int); 
__attribute((__stdcall__)) HANDLE WSAAsyncGetServByPort(HWND, u_int, int, const char *, char *, int); 
__attribute((__stdcall__)) HANDLE WSAAsyncGetProtoByName(HWND, u_int, const char *, char *, int); 
__attribute((__stdcall__)) HANDLE WSAAsyncGetProtoByNumber(HWND, u_int, int, char *, int); 
__attribute((__stdcall__)) HANDLE WSAAsyncGetHostByName(HWND, u_int, const char *, char *, int); 
__attribute((__stdcall__)) HANDLE WSAAsyncGetHostByAddr(HWND, u_int, const char *, int, int, char *, int); 

__attribute((__stdcall__)) int WSACancelAsyncRequest(HANDLE); 
__attribute((__stdcall__)) int WSAAsyncSelect(SOCKET, HWND, u_int, long); 



__attribute((__stdcall__)) u_long htonl(u_long); 
__attribute((__stdcall__)) u_long ntohl(u_long); 
__attribute((__stdcall__)) u_short htons(u_short); 
__attribute((__stdcall__)) u_short ntohs(u_short); 
__attribute((__stdcall__)) int select(int nfds, fd_set *, fd_set *, fd_set *, const timeval *); 



__attribute((__stdcall__)) int gethostname(char *, int); 
# 682 "d:\\mingw\\mingw\\include\\winsock.h" 3
typedef sockaddr SOCKADDR, *PSOCKADDR, *LPSOCKADDR; 
typedef sockaddr_in SOCKADDR_IN, *PSOCKADDR_IN, *LPSOCKADDR_IN; 
typedef linger LINGER, *PLINGER, *LPLINGER; 
typedef in_addr IN_ADDR, *PIN_ADDR, *LPIN_ADDR; 
typedef hostent HOSTENT, *PHOSTENT, *LPHOSTENT; 
typedef servent SERVENT, *PSERVENT, *LPSERVENT; 
typedef protoent PROTOENT, *PPROTOENT, *LPPROTOENT; 
typedef timeval TIMEVAL, *PTIMEVAL, *LPTIMEVAL; 

}
# 104 "d:\\mingw\\mingw\\include\\nspapi.h" 3
extern "C" {
# 122 "d:\\mingw\\mingw\\include\\nspapi.h" 3
typedef 
# 119
struct _SOCKET_ADDRESS { 
LPSOCKADDR lpSockaddr; 
INT iSockaddrLength; 
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, *LPSOCKET_ADDRESS; 
# 134 "d:\\mingw\\mingw\\include\\nspapi.h" 3
typedef struct _CSADDR_INFO CSADDR_INFO, *PCSADDR_INFO, *LPCSADDR_INFO; 

}
# 81 "d:\\mingw\\mingw\\include\\winsock2.h" 3
extern "C" {
# 110 "d:\\mingw\\mingw\\include\\winsock2.h" 3
typedef _OVERLAPPED *LPWSAOVERLAPPED; 
# 131 "d:\\mingw\\mingw\\include\\winsock2.h" 3
typedef 
# 128
struct _WSABUF { 
unsigned long len; 
char *buf; 
} WSABUF, *LPWSABUF; 
# 139
typedef 
# 134
enum { BestEffortService, 
ControlledLoadService, 
PredictiveService, 
GuaranteedDelayService, 
GuaranteedService
} GUARANTEE; 
# 184 "d:\\mingw\\mingw\\include\\winsock2.h" 3
struct sockaddr_storage { 
short ss_family; 
char __ss_pad1[(sizeof(long long) - sizeof(short))]; 
long long __ss_align; 
char __ss_pad2[(128 - ((sizeof(short) + (sizeof(long long) - sizeof(short))) + sizeof(long long)))]; 
}; 
# 213 "d:\\mingw\\mingw\\include\\winsock2.h" 3
typedef unsigned SERVICETYPE; 
# 225
typedef 
# 216
struct _flowspec { 
unsigned TokenRate; 
unsigned TokenBucketSize; 
unsigned PeakBandwidth; 
unsigned Latency; 
unsigned DelayVariation; 
SERVICETYPE ServiceType; 
unsigned MaxSduSize; 
unsigned MinimumPolicedSize; 
} FLOWSPEC, *PFLOWSPEC, *LPFLOWSPEC; 
# 232
typedef 
# 228
struct _QualityOfService { 
FLOWSPEC SendingFlowspec; 
FLOWSPEC ReceivingFlowspec; 
WSABUF ProviderSpecific; 
} QOS, *LPQOS; 
# 238
typedef unsigned GROUP; 
# 247
typedef 
# 244
struct _WSANETWORKEVENTS { 
long lNetworkEvents; 
int iErrorCode[FD_MAX_EVENTS]; 
} WSANETWORKEVENTS, *LPWSANETWORKEVENTS; 
# 259
typedef 
# 255
enum _WSAESETSERVICEOP { 
RNRSERVICE_REGISTER, 
RNRSERVICE_DEREGISTER, 
RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP; 
# 265
typedef 
# 262
struct _AFPROTOCOLS { 
INT iAddressFamily; 
INT iProtocol; 
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS; 
# 271
typedef 
# 268
enum _WSAEcomparator { 
COMP_EQUAL, 
COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR; 
# 277
typedef 
# 274
struct _WSAVersion { 
DWORD dwVersion; 
WSAECOMPARATOR ecHow; 
} WSAVERSION, *PWSAVERSION, *LPWSAVERSION; 
# 283
typedef 
# 280
struct _SOCKET_ADDRESS_LIST { 
INT iAddressCount; 
SOCKET_ADDRESS Address[1]; 
} SOCKET_ADDRESS_LIST, *LPSOCKET_ADDRESS_LIST; 
# 302
typedef 
# 286
struct _WSAQuerySetA { 
DWORD dwSize; 
LPSTR lpszServiceInstanceName; 
LPGUID lpServiceClassId; 
LPWSAVERSION lpVersion; 
LPSTR lpszComment; 
DWORD dwNameSpace; 
LPGUID lpNSProviderId; 
LPSTR lpszContext; 
DWORD dwNumberOfProtocols; 
LPAFPROTOCOLS lpafpProtocols; 
LPSTR lpszQueryString; 
DWORD dwNumberOfCsAddrs; 
LPCSADDR_INFO lpcsaBuffer; 
DWORD dwOutputFlags; 
LPBLOB lpBlob; 
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA; 
# 321
typedef 
# 305
struct _WSAQuerySetW { 
DWORD dwSize; 
LPWSTR lpszServiceInstanceName; 
LPGUID lpServiceClassId; 
LPWSAVERSION lpVersion; 
LPWSTR lpszComment; 
DWORD dwNameSpace; 
LPGUID lpNSProviderId; 
LPWSTR lpszContext; 
DWORD dwNumberOfProtocols; 
LPAFPROTOCOLS lpafpProtocols; 
LPWSTR lpszQueryString; 
DWORD dwNumberOfCsAddrs; 
LPCSADDR_INFO lpcsaBuffer; 
DWORD dwOutputFlags; 
LPBLOB lpBlob; 
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW; 

typedef WSAQUERYSETA WSAQUERYSET; 
typedef PWSAQUERYSETA PWSAQUERYSET; 
typedef LPWSAQUERYSETA LPWSAQUERYSET; 
# 351 "d:\\mingw\\mingw\\include\\winsock2.h" 3
typedef 
# 345
struct _WSANSClassInfoA { 
LPSTR lpszName; 
DWORD dwNameSpace; 
DWORD dwValueType; 
DWORD dwValueSize; 
LPVOID lpValue; 
} WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA; 
# 360
typedef 
# 354
struct _WSANSClassInfoW { 
LPWSTR lpszName; 
DWORD dwNameSpace; 
DWORD dwValueType; 
DWORD dwValueSize; 
LPVOID lpValue; 
} WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW; 

typedef WSANSCLASSINFOA WSANSCLASSINFO; 
typedef PWSANSCLASSINFOA PWSANSCLASSINFO; 
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO; 
# 372
typedef 
# 367
struct _WSAServiceClassInfoA { 
LPGUID lpServiceClassId; 
LPSTR lpszServiceClassName; 
DWORD dwCount; 
LPWSANSCLASSINFOA lpClassInfos; 
} WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA; 
# 380
typedef 
# 375
struct _WSAServiceClassInfoW { 
LPGUID lpServiceClassId; 
LPWSTR lpszServiceClassName; 
DWORD dwCount; 
LPWSANSCLASSINFOW lpClassInfos; 
} WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW; 

typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO; 
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO; 
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO; 
# 393
typedef 
# 387
struct _WSANAMESPACE_INFOA { 
GUID NSProviderId; 
DWORD dwNameSpace; 
BOOL fActive; 
DWORD dwVersion; 
LPSTR lpszIdentifier; 
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA; 
# 402
typedef 
# 396
struct _WSANAMESPACE_INFOW { 
GUID NSProviderId; 
DWORD dwNameSpace; 
BOOL fActive; 
DWORD dwVersion; 
LPWSTR lpszIdentifier; 
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW; 

typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO; 
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO; 
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO; 
# 412
typedef 
# 409
struct _WSAPROTOCOLCHAIN { 
int ChainLen; 
DWORD ChainEntries[7]; 
} WSAPROTOCOLCHAIN, *LPWSAPROTOCOLCHAIN; 
# 438
typedef 
# 417
struct _WSAPROTOCOL_INFOA { 
DWORD dwServiceFlags1; 
DWORD dwServiceFlags2; 
DWORD dwServiceFlags3; 
DWORD dwServiceFlags4; 
DWORD dwProviderFlags; 
GUID ProviderId; 
DWORD dwCatalogEntryId; 
WSAPROTOCOLCHAIN ProtocolChain; 
int iVersion; 
int iAddressFamily; 
int iMaxSockAddr; 
int iMinSockAddr; 
int iSocketType; 
int iProtocol; 
int iProtocolMaxOffset; 
int iNetworkByteOrder; 
int iSecurityScheme; 
DWORD dwMessageSize; 
DWORD dwProviderReserved; 
CHAR szProtocol[255 + 1]; 
} WSAPROTOCOL_INFOA, *LPWSAPROTOCOL_INFOA; 
# 462
typedef 
# 441
struct _WSAPROTOCOL_INFOW { 
DWORD dwServiceFlags1; 
DWORD dwServiceFlags2; 
DWORD dwServiceFlags3; 
DWORD dwServiceFlags4; 
DWORD dwProviderFlags; 
GUID ProviderId; 
DWORD dwCatalogEntryId; 
WSAPROTOCOLCHAIN ProtocolChain; 
int iVersion; 
int iAddressFamily; 
int iMaxSockAddr; 
int iMinSockAddr; 
int iSocketType; 
int iProtocol; 
int iProtocolMaxOffset; 
int iNetworkByteOrder; 
int iSecurityScheme; 
DWORD dwMessageSize; 
DWORD dwProviderReserved; 
WCHAR szProtocol[255 + 1]; 
} WSAPROTOCOL_INFOW, *LPWSAPROTOCOL_INFOW; 

typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO; 
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO; 

typedef int ( __attribute((__stdcall__))*LPCONDITIONPROC)(LPWSABUF, LPWSABUF, LPQOS, LPQOS, LPWSABUF, LPWSABUF, GROUP *, DWORD) ; 
typedef void ( __attribute((__stdcall__))*LPWSAOVERLAPPED_COMPLETION_ROUTINE)(DWORD, DWORD, LPWSAOVERLAPPED, DWORD) ; 
# 479
typedef 
# 473
enum _WSACOMPLETIONTYPE { 
NSP_NOTIFY_IMMEDIATELY, 
NSP_NOTIFY_HWND, 
NSP_NOTIFY_EVENT, 
NSP_NOTIFY_PORT, 
NSP_NOTIFY_APC
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE, *LPWSACOMPLETIONTYPE; 
# 503
typedef 
# 482
struct _WSACOMPLETION { 
WSACOMPLETIONTYPE Type; 

union { 
struct { HWND hWnd; 
UINT uMsg; 
WPARAM context; 
} WindowMessage; 

struct { LPWSAOVERLAPPED lpOverlapped; 
} Event; 

struct { LPWSAOVERLAPPED lpOverlapped; 
LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc; 
} Apc; 

struct { LPWSAOVERLAPPED lpOverlapped; 
HANDLE hPort; 
ULONG_PTR Key; 
} Port; 
} Parameters; 
} WSACOMPLETION, *PWSACOMPLETION, *LPWSACOMPLETION; 
# 575 "d:\\mingw\\mingw\\include\\winsock2.h" 3
typedef SOCKET ( __attribute((__stdcall__))*LPFN_ACCEPT)(SOCKET, sockaddr *, int *) ; 

typedef int ( __attribute((__stdcall__))*LPFN_BIND)(SOCKET, const sockaddr *, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_CLOSESOCKET)(SOCKET) ; 
typedef int ( __attribute((__stdcall__))*LPFN_CONNECT)(SOCKET, const sockaddr *, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_IOCTLSOCKET)(SOCKET, long, u_long *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_GETPEERNAME)(SOCKET, sockaddr *, int *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_GETSOCKNAME)(SOCKET, sockaddr *, int *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_GETSOCKOPT)(SOCKET, int, int, char *, int *) ; 

typedef u_long ( __attribute((__stdcall__))*LPFN_HTONL)(u_long) ; 
typedef u_short ( __attribute((__stdcall__))*LPFN_HTONS)(u_short) ; 

typedef unsigned long ( __attribute((__stdcall__))*LPFN_INET_ADDR)(const char *) ; 

typedef char *( __attribute((__stdcall__))*LPFN_INET_NTOA)(in_addr) ; 

typedef int ( __attribute((__stdcall__))*LPFN_LISTEN)(SOCKET, int) ; 

typedef u_long ( __attribute((__stdcall__))*LPFN_NTOHL)(u_long) ; 
typedef u_short ( __attribute((__stdcall__))*LPFN_NTOHS)(u_short) ; 

typedef int ( __attribute((__stdcall__))*LPFN_RECV)(SOCKET, char *, int, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_RECVFROM)(SOCKET, char *, int, int, sockaddr *, int *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_SELECT)(int, fd_set *, fd_set *, fd_set *, const timeval *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_SEND)(SOCKET, const char *, int, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_SENDTO)(SOCKET, const char *, int, int, const sockaddr *, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_SETSOCKOPT)(SOCKET, int, int, const char *, int) ; 
typedef int ( __attribute((__stdcall__))*LPFN_SHUTDOWN)(SOCKET, int) ; 

typedef SOCKET ( __attribute((__stdcall__))*LPFN_SOCKET)(int, int, int) ; 

typedef hostent *( __attribute((__stdcall__))*LPFN_GETHOSTBYADDR)(const char *, int, int) ; 
typedef hostent *( __attribute((__stdcall__))*LPFN_GETHOSTBYNAME)(const char *) ; 

typedef int ( __attribute((__stdcall__))*LPFN_GETHOSTNAME)(char *, int) ; 

typedef servent *( __attribute((__stdcall__))*LPFN_GETSERVBYPORT)(int, const char *) ; 
typedef servent *( __attribute((__stdcall__))*LPFN_GETSERVBYNAME)(const char *, const char *) ; 
typedef protoent *( __attribute((__stdcall__))*LPFN_GETPROTOBYNUMBER)(int) ; 
typedef protoent *( __attribute((__stdcall__))*LPFN_GETPROTOBYNAME)(const char *) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSASTARTUP)(WORD, LPWSADATA) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSACLEANUP)(void) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSAGETLASTERROR)(void) ; 
typedef void ( __attribute((__stdcall__))*LPFN_WSASETLASTERROR)(int) ; 

typedef BOOL ( __attribute((__stdcall__))*LPFN_WSAISBLOCKING)(void) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSAUNHOOKBLOCKINGHOOK)(void) ; 
typedef FARPROC ( __attribute((__stdcall__))*LPFN_WSASETBLOCKINGHOOK)(FARPROC) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSACANCELBLOCKINGCALL)(void) ; 

typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSAASYNCGETSERVBYNAME)(HWND, u_int, const char *, const char *, char *, int) ; 
typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSAASYNCGETSERVBYPORT)(HWND, u_int, int, const char *, char *, int) ; 
typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSAASYNCGETPROTOBYNAME)(HWND, u_int, const char *, char *, int) ; 
typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSAASYNCGETPROTOBYNUMBER)(HWND, u_int, int, char *, int) ; 
typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSAASYNCGETHOSTBYADDR)(HWND, u_int, const char *, int, int, char *, int) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSACANCELASYNCREQUEST)(HANDLE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSAASYNCSELECT)(SOCKET, HWND, u_int, long) ; 

typedef sockaddr_storage SOCKADDR_STORAGE, *PSOCKADDR_STORAGE; 

__attribute((__stdcall__)) SOCKET WSAAccept(SOCKET, sockaddr *, LPINT, LPCONDITIONPROC, DWORD); 


__attribute((__stdcall__)) INT WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD); 
__attribute((__stdcall__)) INT WSAAddressToStringW(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD); 

__attribute((__stdcall__)) BOOL WSACloseEvent(HANDLE); 
__attribute((__stdcall__)) int WSAConnect(SOCKET, const sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS); 
__attribute((__stdcall__)) HANDLE WSACreateEvent(); 


__attribute((__stdcall__)) int WSADuplicateSocketA(SOCKET, DWORD, LPWSAPROTOCOL_INFOA); 
__attribute((__stdcall__)) int WSADuplicateSocketW(SOCKET, DWORD, LPWSAPROTOCOL_INFOW); 


__attribute((__stdcall__)) INT WSAEnumNameSpaceProvidersA(LPDWORD, LPWSANAMESPACE_INFOA); 
__attribute((__stdcall__)) INT WSAEnumNameSpaceProvidersW(LPDWORD, LPWSANAMESPACE_INFOW); 

__attribute((__stdcall__)) int WSAEnumNetworkEvents(SOCKET, HANDLE, LPWSANETWORKEVENTS); 


__attribute((__stdcall__)) int WSAEnumProtocolsA(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD); 
__attribute((__stdcall__)) int WSAEnumProtocolsW(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD); 

__attribute((__stdcall__)) int WSAEventSelect(SOCKET, HANDLE, long); 
__attribute((__stdcall__)) BOOL WSAGetOverlappedResult(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD); 
__attribute((__stdcall__)) BOOL WSAGetQOSByName(SOCKET, LPWSABUF, LPQOS); 


__attribute((__stdcall__)) INT WSAGetServiceClassInfoA(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA); 
__attribute((__stdcall__)) INT WSAGetServiceClassInfoW(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW); 


__attribute((__stdcall__)) INT WSAGetServiceClassNameByClassIdA(LPGUID, LPSTR, LPDWORD); 
__attribute((__stdcall__)) INT WSAGetServiceClassNameByClassIdW(LPGUID, LPWSTR, LPDWORD); 

__attribute((__stdcall__)) int WSAHtonl(SOCKET, unsigned long, unsigned long *); 
__attribute((__stdcall__)) int WSAHtons(SOCKET, unsigned short, unsigned short *); 


__attribute((__stdcall__)) INT WSAInstallServiceClassA(LPWSASERVICECLASSINFOA); 
__attribute((__stdcall__)) INT WSAInstallServiceClassW(LPWSASERVICECLASSINFOW); 

__attribute((__stdcall__)) int WSAIoctl(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); 
__attribute((__stdcall__)) SOCKET WSAJoinLeaf(SOCKET, const sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD); 


__attribute((__stdcall__)) INT WSALookupServiceBeginA(LPWSAQUERYSETA, DWORD, LPHANDLE); 
__attribute((__stdcall__)) INT WSALookupServiceBeginW(LPWSAQUERYSETW, DWORD, LPHANDLE); 


__attribute((__stdcall__)) INT WSALookupServiceNextA(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA); 
__attribute((__stdcall__)) INT WSALookupServiceNextW(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW); 

__attribute((__stdcall__)) INT WSALookupServiceEnd(HANDLE); 
__attribute((__stdcall__)) int WSANSPIoctl(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSACOMPLETION); 
__attribute((__stdcall__)) int WSANtohl(SOCKET, unsigned long, unsigned long *); 
__attribute((__stdcall__)) int WSANtohs(SOCKET, unsigned short, unsigned short *); 
__attribute((__stdcall__)) int WSARecv(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); 
__attribute((__stdcall__)) int WSARecvDisconnect(SOCKET, LPWSABUF); 
__attribute((__stdcall__)) int WSARecvFrom(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); 
__attribute((__stdcall__)) INT WSARemoveServiceClass(LPGUID); 
__attribute((__stdcall__)) BOOL WSAResetEvent(HANDLE); 
__attribute((__stdcall__)) int WSASend(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); 
__attribute((__stdcall__)) int WSASendDisconnect(SOCKET, LPWSABUF); 
__attribute((__stdcall__)) int WSASendTo(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); 
__attribute((__stdcall__)) BOOL WSASetEvent(HANDLE); 


__attribute((__stdcall__)) INT WSASetServiceA(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD); 
__attribute((__stdcall__)) INT WSASetServiceW(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD); 


__attribute((__stdcall__)) SOCKET WSASocketA(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD); 
__attribute((__stdcall__)) SOCKET WSASocketW(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD); 


__attribute((__stdcall__)) INT WSAStringToAddressA(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT); 
__attribute((__stdcall__)) INT WSAStringToAddressW(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT); 

__attribute((__stdcall__)) DWORD WSAWaitForMultipleEvents(DWORD, const HANDLE *, BOOL, DWORD, BOOL); 

typedef SOCKET ( __attribute((__stdcall__))*LPFN_WSAACCEPT)(SOCKET, sockaddr *, LPINT, LPCONDITIONPROC, DWORD) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSAADDRESSTOSTRINGA)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAADDRESSTOSTRINGW)(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOW, LPWSTR, LPDWORD) ; 

typedef BOOL ( __attribute((__stdcall__))*LPFN_WSACLOSEEVENT)(HANDLE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSACONNECT)(SOCKET, const sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS) ; 
typedef HANDLE ( __attribute((__stdcall__))*LPFN_WSACREATEEVENT)(void) ; 


typedef int ( __attribute((__stdcall__))*LPFN_WSADUPLICATESOCKETA)(SOCKET, DWORD, LPWSAPROTOCOL_INFOA) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSADUPLICATESOCKETW)(SOCKET, DWORD, LPWSAPROTOCOL_INFOW) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSAENUMNAMESPACEPROVIDERSA)(LPDWORD, LPWSANAMESPACE_INFOA) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAENUMNAMESPACEPROVIDERSW)(LPDWORD, LPWSANAMESPACE_INFOW) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSAENUMNETWORKEVENTS)(SOCKET, HANDLE, LPWSANETWORKEVENTS) ; 


typedef int ( __attribute((__stdcall__))*LPFN_WSAENUMPROTOCOLSA)(LPINT, LPWSAPROTOCOL_INFOA, LPDWORD) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSAENUMPROTOCOLSW)(LPINT, LPWSAPROTOCOL_INFOW, LPDWORD) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSAEVENTSELECT)(SOCKET, HANDLE, long) ; 
typedef BOOL ( __attribute((__stdcall__))*LPFN_WSAGETOVERLAPPEDRESULT)(SOCKET, LPWSAOVERLAPPED, LPDWORD, BOOL, LPDWORD) ; 
typedef BOOL ( __attribute((__stdcall__))*LPFN_WSAGETQOSBYNAME)(SOCKET, LPWSABUF, LPQOS) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSAGETSERVICECLASSINFOA)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOA) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAGETSERVICECLASSINFOW)(LPGUID, LPGUID, LPDWORD, LPWSASERVICECLASSINFOW) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDA)(LPGUID, LPSTR, LPDWORD) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAGETSERVICECLASSNAMEBYCLASSIDW)(LPGUID, LPWSTR, LPDWORD) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSAHTONL)(SOCKET, unsigned long, unsigned long *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSAHTONS)(SOCKET, unsigned short, unsigned short *) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSAINSTALLSERVICECLASSA)(LPWSASERVICECLASSINFOA) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAINSTALLSERVICECLASSW)(LPWSASERVICECLASSINFOW) ; 

typedef int ( __attribute((__stdcall__))*LPFN_WSAIOCTL)(SOCKET, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) ; 
typedef SOCKET ( __attribute((__stdcall__))*LPFN_WSAJOINLEAF)(SOCKET, const sockaddr *, int, LPWSABUF, LPWSABUF, LPQOS, LPQOS, DWORD) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSALOOKUPSERVICEBEGINA)(LPWSAQUERYSETA, DWORD, LPHANDLE) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSALOOKUPSERVICEBEGINW)(LPWSAQUERYSETW, DWORD, LPHANDLE) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSALOOKUPSERVICENEXTA)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETA) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSALOOKUPSERVICENEXTW)(HANDLE, DWORD, LPDWORD, LPWSAQUERYSETW) ; 

typedef INT ( __attribute((__stdcall__))*LPFN_WSALOOKUPSERVICEEND)(HANDLE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSANSPIoctl)(HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD, LPWSACOMPLETION) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSANTOHL)(SOCKET, unsigned long, unsigned long *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSANTOHS)(SOCKET, unsigned short, unsigned short *) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSARECV)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSARECVDISCONNECT)(SOCKET, LPWSABUF) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSARECVFROM)(SOCKET, LPWSABUF, DWORD, LPDWORD, LPDWORD, sockaddr *, LPINT, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSAREMOVESERVICECLASS)(LPGUID) ; 
typedef BOOL ( __attribute((__stdcall__))*LPFN_WSARESETEVENT)(HANDLE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSASEND)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSASENDDISCONNECT)(SOCKET, LPWSABUF) ; 
typedef int ( __attribute((__stdcall__))*LPFN_WSASENDTO)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, const sockaddr *, int, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE) ; 
typedef BOOL ( __attribute((__stdcall__))*LPFN_WSASETEVENT)(HANDLE) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSASETSERVICEA)(LPWSAQUERYSETA, WSAESETSERVICEOP, DWORD) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSASETSERVICEW)(LPWSAQUERYSETW, WSAESETSERVICEOP, DWORD) ; 


typedef SOCKET ( __attribute((__stdcall__))*LPFN_WSASOCKETA)(int, int, int, LPWSAPROTOCOL_INFOA, GROUP, DWORD) ; 
typedef SOCKET ( __attribute((__stdcall__))*LPFN_WSASOCKETW)(int, int, int, LPWSAPROTOCOL_INFOW, GROUP, DWORD) ; 


typedef INT ( __attribute((__stdcall__))*LPFN_WSASTRINGTOADDRESSA)(LPSTR, INT, LPWSAPROTOCOL_INFOA, LPSOCKADDR, LPINT) ; 
typedef INT ( __attribute((__stdcall__))*LPFN_WSASTRINGTOADDRESSW)(LPWSTR, INT, LPWSAPROTOCOL_INFOW, LPSOCKADDR, LPINT) ; 

typedef DWORD ( __attribute((__stdcall__))*LPFN_WSAWAITFORMULTIPLEEVENTS)(DWORD, const HANDLE *, BOOL, DWORD, BOOL) ; 

}
# 7 "d:\\mingw\\mingw\\include\\ole2.h" 3
#pragma pack ( push, 8 )
# 13 "d:\\mingw\\mingw\\include\\objbase.h" 3
#pragma pack ( push, 8 )
# 59 "d:\\mingw\\mingw\\include\\objbase.h" 3
typedef 
# 54
enum tagSTGFMT { 
STGFMT_STORAGE, 
STGFMT_FILE = 3, 
STGFMT_ANY, 
STGFMT_DOCFILE
} STGFMT; 
# 65
typedef 
# 60
struct tagSTGOPTIONS { 
USHORT usVersion; 
USHORT reserved; 
ULONG ulSectorSize; 
const WCHAR *pwcsTemplateFile; 
} STGOPTIONS; 




typedef 
# 66
enum tagREGCLS { 
REGCLS_SINGLEUSE, 
REGCLS_MULTIPLEUSE, 
REGCLS_MULTI_SEPARATE
} REGCLS; 
# 58 "d:\\mingw\\mingw\\include\\objidl.h" 3
typedef 
# 46
struct tagSTATSTG { 
LPOLESTR pwcsName; 
DWORD type; 
ULARGE_INTEGER cbSize; 
FILETIME mtime; 
FILETIME ctime; 
FILETIME atime; 
DWORD grfMode; 
DWORD grfLocksSupported; 
CLSID clsid; 
DWORD grfStateBits; 
DWORD reserved; 
} STATSTG; 
# 64
typedef 
# 59
enum tagSTGTY { 
STGTY_STORAGE = 1, 
STGTY_STREAM, 
STGTY_LOCKBYTES, 
STGTY_PROPERTY
} STGTY; 




typedef 
# 65
enum tagSTREAM_SEEK { 
STREAM_SEEK_SET, 
STREAM_SEEK_CUR, 
STREAM_SEEK_END
} STREAM_SEEK; 




typedef 
# 70
struct tagINTERFACEINFO { 
LPUNKNOWN pUnk; 
IID iid; 
WORD wMethod; 
} INTERFACEINFO, *LPINTERFACEINFO; 
# 81
typedef 
# 75
enum tagCALLTYPE { 
CALLTYPE_TOPLEVEL = 1, 
CALLTYPE_NESTED, 
CALLTYPE_ASYNC, 
CALLTYPE_TOPLEVEL_CALLPENDING, 
CALLTYPE_ASYNC_CALLPENDING
} CALLTYPE; 



typedef 
# 82
enum tagPENDINGTYPE { 
PENDINGTYPE_TOPLEVEL = 1, 
PENDINGTYPE_NESTED
} PENDINGTYPE; 




typedef 
# 86
enum tagPENDINGMSG { 
PENDINGMSG_CANCELCALL, 
PENDINGMSG_WAITNOPROCESS, 
PENDINGMSG_WAITDEFPROCESS
} PENDINGMSG; 
typedef OLECHAR **SNB; 



typedef 
# 92
enum tagDATADIR { 
DATADIR_GET = 1, 
DATADIR_SET
} DATADIR; 
typedef WORD CLIPFORMAT, *LPCLIPFORMAT; 
# 104
typedef 
# 97
struct tagDVTARGETDEVICE { 
DWORD tdSize; 
WORD tdDriverNameOffset; 
WORD tdDeviceNameOffset; 
WORD tdPortNameOffset; 
WORD tdExtDevmodeOffset; 
BYTE tdData[1]; 
} DVTARGETDEVICE; 
# 111
typedef 
# 105
struct tagFORMATETC { 
CLIPFORMAT cfFormat; 
DVTARGETDEVICE *ptd; 
DWORD dwAspect; 
LONG lindex; 
DWORD tymed; 
} FORMATETC, *LPFORMATETC; 
# 119
typedef 
# 112
struct tagRemSTGMEDIUM { 
DWORD tymed; 
DWORD dwHandleType; 
ULONG pData; 
unsigned long pUnkForRelease; 
unsigned long cbData; 
BYTE data[1]; 
} RemSTGMEDIUM; 



typedef 
# 120
struct tagHLITEM { 
ULONG uHLID; 
LPWSTR pwzFriendlyName; 
} HLITEM; 
# 129
typedef 
# 124
struct tagSTATDATA { 
FORMATETC formatetc; 
DWORD grfAdvf; 
IAdviseSink *pAdvSink; 
DWORD dwConnection; 
} STATDATA; 
# 137
typedef 
# 130
struct tagSTATPROPSETSTG { 
FMTID fmtid; 
CLSID clsid; 
DWORD grfFlags; 
FILETIME mtime; 
FILETIME ctime; 
FILETIME atime; 
} STATPROPSETSTG; 




typedef 
# 138
enum tagEXTCONN { 
EXTCONN_STRONG = 1, 
EXTCONN_WEAK, 
EXTCONN_CALLABLE = 4
} EXTCONN; 




typedef 
# 143
struct tagMULTI_QI { 
const IID *pIID; 
IUnknown *pItf; 
HRESULT hr; 
} MULTI_QI; 
# 156
typedef 
# 148
struct _AUTH_IDENTITY { 
USHORT *User; 
ULONG UserLength; 
USHORT *Domain; 
ULONG DomainLength; 
USHORT *Password; 
ULONG PasswordLength; 
ULONG Flags; 
} AUTH_IDENTITY; 
# 165
typedef 
# 157
struct _COAUTHINFO { 
DWORD dwAuthnSvc; 
DWORD dwAuthzSvc; 
LPWSTR pwszServerPrincName; 
DWORD dwAuthnLevel; 
DWORD dwImpersonationLevel; 
AUTH_IDENTITY *pAuthIdentityData; 
DWORD dwCapabilities; 
} COAUTHINFO; 
# 171
typedef 
# 166
struct _COSERVERINFO { 
DWORD dwReserved1; 
LPWSTR pwszName; 
COAUTHINFO *pAuthInfo; 
DWORD dwReserved2; 
} COSERVERINFO; 
# 177
typedef 
# 172
struct tagBIND_OPTS { 
DWORD cbStruct; 
DWORD grfFlags; 
DWORD grfMode; 
DWORD dwTickCountDeadline; 
} BIND_OPTS, *LPBIND_OPTS; 
# 187
typedef 
# 178
struct tagBIND_OPTS2 { 
DWORD cbStruct; 
DWORD grfFlags; 
DWORD grfMode; 
DWORD dwTickCountDeadline; 
DWORD dwTrackFlags; 
DWORD dwClassContext; 
LCID locale; 
COSERVERINFO *pServerInfo; 
} BIND_OPTS2, *LPBIND_OPTS2; 



typedef 
# 188
enum tagBIND_FLAGS { 
BIND_MAYBOTHERUSER = 1, 
BIND_JUSTTESTEXISTENCE
} BIND_FLAGS; 
# 204
typedef 
# 192
struct tagSTGMEDIUM { 
DWORD tymed; 
union { 
HBITMAP hBitmap; 
PVOID hMetaFilePict; 
HENHMETAFILE hEnhMetaFile; 
HGLOBAL hGlobal; 
LPWSTR lpszFileName; 
LPSTREAM pstm; 
LPSTORAGE pstg; 
}; 
LPUNKNOWN pUnkForRelease; 
} STGMEDIUM, *LPSTGMEDIUM; 




typedef 
# 205
enum tagLOCKTYPE { 
LOCK_WRITE = 1, 
LOCK_EXCLUSIVE, 
LOCK_ONLYONCE = 4
} LOCKTYPE; 
typedef unsigned long RPCOLEDATAREP; 
# 219
typedef 
# 211
struct tagRPCOLEMESSAGE { 
PVOID reserved1; 
RPCOLEDATAREP dataRepresentation; 
PVOID Buffer; 
ULONG cbBuffer; 
ULONG iMethod; 
PVOID reserved2[5]; 
ULONG rpcFlags; 
} RPCOLEMESSAGE, *PRPCOLEMESSAGE; 
# 227
typedef 
# 220
enum tagMKSYS { 
MKSYS_NONE, 
MKSYS_GENERICCOMPOSITE, 
MKSYS_FILEMONIKER, 
MKSYS_ANTIMONIKER, 
MKSYS_ITEMMONIKER, 
MKSYS_POINTERMONIKER
} MKSYS; 
# 233
typedef 
# 228
enum tagMKREDUCE { 
MKRREDUCE_ALL, 
MKRREDUCE_ONE = 196608, 
MKRREDUCE_TOUSER = 131072, 
MKRREDUCE_THROUGHUSER = 65536
} MKRREDUCE; 




typedef 
# 234
struct tagRemSNB { 
unsigned long ulCntStr; 
unsigned long ulCntChar; 
OLECHAR rgString[1]; 
} RemSNB; 



typedef 
# 239
enum tagADVF { 
ADVF_NODATA = 1, ADVF_PRIMEFIRST, ADVF_ONLYONCE = 4, ADVF_DATAONSTOP = 64, 
ADVFCACHE_NOHANDLER = 8, ADVFCACHE_FORCEBUILTIN = 16, ADVFCACHE_ONSAVE = 32
} ADVF; 



typedef 
# 243
enum tagTYMED { 
TYMED_HGLOBAL = 1, TYMED_FILE, TYMED_ISTREAM = 4, TYMED_ISTORAGE = 8, 
TYMED_GDI = 16, TYMED_MFPICT = 32, TYMED_ENHMF = 64, TYMED_NULL = 0
} TYMED; 


typedef 
# 247
enum tagSERVERCALL { 
SERVERCALL_ISHANDLED, SERVERCALL_REJECTED, SERVERCALL_RETRYLATER
} SERVERCALL; 



typedef 
# 250
struct tagCAUB { 
ULONG cElems; 
unsigned char *pElems; 
} CAUB; 



typedef 
# 254
struct tagCAI { 
ULONG cElems; 
short *pElems; 
} CAI; 



typedef 
# 258
struct tagCAUI { 
ULONG cElems; 
USHORT *pElems; 
} CAUI; 



typedef 
# 262
struct tagCAL { 
ULONG cElems; 
long *pElems; 
} CAL; 



typedef 
# 266
struct tagCAUL { 
ULONG cElems; 
ULONG *pElems; 
} CAUL; 



typedef 
# 270
struct tagCAFLT { 
ULONG cElems; 
float *pElems; 
} CAFLT; 



typedef 
# 274
struct tagCADBL { 
ULONG cElems; 
double *pElems; 
} CADBL; 



typedef 
# 278
struct tagCACY { 
ULONG cElems; 
CY *pElems; 
} CACY; 



typedef 
# 282
struct tagCADATE { 
ULONG cElems; 
DATE *pElems; 
} CADATE; 



typedef 
# 286
struct tagCABSTR { 
ULONG cElems; 
BSTR *pElems; 
} CABSTR; 



typedef 
# 290
struct tagCABSTRBLOB { 
ULONG cElems; 
BSTRBLOB *pElems; 
} CABSTRBLOB; 



typedef 
# 294
struct tagCABOOL { 
ULONG cElems; 
VARIANT_BOOL *pElems; 
} CABOOL; 



typedef 
# 298
struct tagCASCODE { 
ULONG cElems; 
SCODE *pElems; 
} CASCODE; 



typedef 
# 302
struct tagCAH { 
ULONG cElems; 
LARGE_INTEGER *pElems; 
} CAH; 



typedef 
# 306
struct tagCAUH { 
ULONG cElems; 
ULARGE_INTEGER *pElems; 
} CAUH; 



typedef 
# 310
struct tagCALPSTR { 
ULONG cElems; 
LPSTR *pElems; 
} CALPSTR; 



typedef 
# 314
struct tagCALPWSTR { 
ULONG cElems; 
LPWSTR *pElems; 
} CALPWSTR; 



typedef 
# 318
struct tagCAFILETIME { 
ULONG cElems; 
FILETIME *pElems; 
} CAFILETIME; 



typedef 
# 322
struct tagCACLIPDATA { 
ULONG cElems; 
CLIPDATA *pElems; 
} CACLIPDATA; 



typedef 
# 326
struct tagCACLSID { 
ULONG cElems; 
CLSID *pElems; 
} CACLSID; 
typedef struct tagPROPVARIANT *LPPROPVARIANT; 



typedef 
# 331
struct tagCAPROPVARIANT { 
ULONG cElems; 
LPPROPVARIANT pElems; 
} CAPROPVARIANT; 
# 392
typedef 
# 335
struct tagPROPVARIANT { 
VARTYPE vt; 
WORD wReserved1; 
WORD wReserved2; 
WORD wReserved3; 
union { 
CHAR cVal; 
UCHAR bVal; 
short iVal; 
USHORT uiVal; 
VARIANT_BOOL boolVal; 
# 351
long lVal; 
ULONG ulVal; 
float fltVal; 
SCODE scode; 
LARGE_INTEGER hVal; 
ULARGE_INTEGER uhVal; 
double dblVal; 
CY cyVal; 
DATE date; 
FILETIME filetime; 
CLSID *puuid; 
BLOB blob; 
CLIPDATA *pclipdata; 
LPSTREAM pStream; 
LPSTORAGE pStorage; 
BSTR bstrVal; 
BSTRBLOB bstrblobVal; 
LPSTR pszVal; 
LPWSTR pwszVal; 
CAUB caub; 
CAI cai; 
CAUI caui; 
CABOOL cabool; 
CAL cal; 
CAUL caul; 
CAFLT caflt; 
CASCODE cascode; 
CAH cah; 
CAUH cauh; 
CADBL cadbl; 
CACY cacy; 
CADATE cadate; 
CAFILETIME cafiletime; 
CACLSID cauuid; 
CACLIPDATA caclipdata; 
CABSTR cabstr; 
CABSTRBLOB cabstrblob; 
CALPSTR calpstr; 
CALPWSTR calpwstr; 
CAPROPVARIANT capropvar; 
}; 
} PROPVARIANT; 
# 399
typedef 
# 393
struct tagPROPSPEC { 
ULONG ulKind; 
union { 
PROPID propid; 
LPOLESTR lpwstr; 
}; 
} PROPSPEC; 




typedef 
# 400
struct tagSTATPROPSTG { 
LPOLESTR lpwstrName; 
PROPID propid; 
VARTYPE vt; 
} STATPROPSTG; 



typedef 
# 405
enum PROPSETFLAG { 
PROPSETFLAG_DEFAULT, PROPSETFLAG_NONSIMPLE, PROPSETFLAG_ANSI, 
PROPSETFLAG_UNBUFFERED = 4
} PROPSETFLAG; 
# 414
typedef 
# 409
struct tagSTORAGELAYOUT { 
DWORD LayoutType; 
OLECHAR *pwcsElementName; 
LARGE_INTEGER cOffset; 
LARGE_INTEGER cBytes; 
} STORAGELAYOUT; 
# 420
typedef 
# 415
struct tagSOLE_AUTHENTICATION_SERVICE { 
DWORD dwAuthnSvc; 
DWORD dwAuthzSvc; 
OLECHAR *pPrincipalName; 
HRESULT hr; 
} SOLE_AUTHENTICATION_SERVICE; 
# 438
typedef 
# 422
enum tagEOLE_AUTHENTICATION_CAPABILITIES { 
EOAC_NONE, 
EOAC_MUTUAL_AUTH, 
EOAC_STATIC_CLOAKING = 0x20, 
EOAC_DYNAMIC_CLOAKING = 0x40, 
EOAC_ANY_AUTHORITY = 0x80, 
EOAC_MAKE_FULLSIC = 0x100, 
EOAC_DEFAULT = 0x800, 
EOAC_SECURE_REFS = 0x2, 
EOAC_ACCESS_CONTROL = 0x4, 
EOAC_APPID = 0x8, 
EOAC_DYNAMIC = 0x10, 
EOAC_REQUIRE_FULLSIC = 0x200, 
EOAC_AUTO_IMPERSONATE = 0x400, 
EOAC_NO_CUSTOM_MARSHAL = 0x2000, 
EOAC_DISABLE_AAA = 0x1000
} EOLE_AUTHENTICATION_CAPABILITIES; 




typedef 
# 439
struct tagSOLE_AUTHENTICATION_INFO { 
DWORD dwAuthnSvc; 
DWORD dwAuthzSvc; 
void *pAuthInfo; 
} SOLE_AUTHENTICATION_INFO; 




typedef 
# 445
struct tagSOLE_AUTHENTICATION_LIST { 
DWORD cAuthInfo; 
SOLE_AUTHENTICATION_INFO *aAuthInfo; 
} SOLE_AUTHENTICATION_LIST; 

extern "C" const FMTID FMTID_SummaryInformation; 
extern "C" const FMTID FMTID_DocSummaryInformation; 
extern "C" const FMTID FMTID_UserDefinedProperties; 

struct IEnumFORMATETC : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, FORMATETC *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumFORMATETC **) = 0; }; 
struct IEnumHLITEM : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, HLITEM *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumHLITEM **) = 0; }; 
struct IEnumSTATDATA : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, STATDATA *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumSTATDATA **) = 0; }; 
struct IEnumSTATPROPSETSTG : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, STATPROPSETSTG *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumSTATPROPSETSTG **) = 0; }; 
struct IEnumSTATPROPSTG : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, STATPROPSTG *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumSTATPROPSTG **) = 0; }; 
struct IEnumSTATSTG : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, STATSTG *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumSTATSTG **) = 0; }; 
struct IEnumString : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, LPOLESTR *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumString **) = 0; }; 
struct IEnumMoniker : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, IMoniker **, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumMoniker **) = 0; }; 
struct IEnumUnknown : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, IUnknown **, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumUnknown **) = 0; }; 

extern "C" const IID IID_ISequentialStream; 

struct ISequentialStream : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Read(void *, ULONG, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Write(const void *, ULONG, ULONG *) = 0; 
}; 


extern "C" const IID IID_IStream; 

struct IStream : public ISequentialStream { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Read(void *, ULONG, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Write(const void *, ULONG, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetSize(ULARGE_INTEGER) = 0; 
__attribute((__stdcall__)) virtual HRESULT CopyTo(IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Commit(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Revert() = 0; 
__attribute((__stdcall__)) virtual HRESULT LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Stat(STATSTG *, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Clone(LPSTREAM *) = 0; 
}; 


extern "C" const IID IID_IMarshal; 

struct IMarshal : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetUnmarshalClass(const IID &, PVOID, DWORD, PVOID, DWORD, CLSID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMarshalSizeMax(const IID &, PVOID, DWORD, PVOID, PDWORD, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT MarshalInterface(IStream *, const IID &, PVOID, DWORD, PVOID, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT UnmarshalInterface(IStream *, const IID &, void **) = 0; 
__attribute((__stdcall__)) virtual HRESULT ReleaseMarshalData(IStream *) = 0; 
__attribute((__stdcall__)) virtual HRESULT DisconnectObject(DWORD) = 0; 
}; 


extern "C" const IID IID_IStdMarshalInfo; 

struct IStdMarshalInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassForHandler(DWORD, PVOID, CLSID *) = 0; 
}; 


extern "C" const IID IID_IMalloc; 

struct IMalloc : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
virtual void *Alloc(ULONG) __attribute((__stdcall__)) = 0; 
virtual void *Realloc(void *, ULONG) __attribute((__stdcall__)) = 0; 
__attribute((__stdcall__)) virtual void Free(void *) = 0; 
__attribute((__stdcall__)) virtual ULONG GetSize(void *) = 0; 
__attribute((__stdcall__)) virtual int DidAlloc(void *) = 0; 
__attribute((__stdcall__)) virtual void HeapMinimize() = 0; 
}; 


extern "C" const IID IID_IMallocSpy; 

struct IMallocSpy : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual ULONG PreAlloc(ULONG) = 0; 
virtual void *PostAlloc(void *) __attribute((__stdcall__)) = 0; 
virtual void *PreFree(void *, BOOL) __attribute((__stdcall__)) = 0; 
__attribute((__stdcall__)) virtual void PostFree(BOOL) = 0; 
__attribute((__stdcall__)) virtual ULONG PreRealloc(void *, ULONG, void **, BOOL) = 0; 
virtual void *PostRealloc(void *, BOOL) __attribute((__stdcall__)) = 0; 
virtual void *PreGetSize(void *, BOOL) __attribute((__stdcall__)) = 0; 
__attribute((__stdcall__)) virtual ULONG PostGetSize(ULONG, BOOL) = 0; 
virtual void *PreDidAlloc(void *, BOOL) __attribute((__stdcall__)) = 0; 
__attribute((__stdcall__)) virtual int PostDidAlloc(void *, BOOL, int) = 0; 
__attribute((__stdcall__)) virtual void PreHeapMinimize() = 0; 
__attribute((__stdcall__)) virtual void PostHeapMinimize() = 0; 
}; 


extern "C" const IID IID_IMessageFilter; 

struct IMessageFilter : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual DWORD HandleInComingCall(DWORD, HTASK, DWORD, LPINTERFACEINFO) = 0; 
__attribute((__stdcall__)) virtual DWORD RetryRejectedCall(HTASK, DWORD, DWORD) = 0; 
__attribute((__stdcall__)) virtual DWORD MessagePending(HTASK, DWORD, DWORD) = 0; 
}; 


extern "C" const IID IID_IPersist; 

struct IPersist : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassID(CLSID *) = 0; 
}; 


extern "C" const IID IID_IPersistStream; 

struct IPersistStream : public IPersist { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassID(LPCLSID) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsDirty() = 0; 
__attribute((__stdcall__)) virtual HRESULT Load(IStream *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Save(IStream *, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetSizeMax(PULARGE_INTEGER) = 0; 
}; 


extern "C" const IID IID_IRunningObjectTable; 

struct IRunningObjectTable : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Register(DWORD, LPUNKNOWN, LPMONIKER, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Revoke(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsRunning(LPMONIKER) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetObjectA(LPMONIKER, LPUNKNOWN *) = 0; 
__attribute((__stdcall__)) virtual HRESULT NoteChangeTime(DWORD, LPFILETIME) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTimeOfLastChange(LPMONIKER, LPFILETIME) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumRunning(IEnumMoniker **) = 0; 
}; 


extern "C" const IID IID_IBindCtx; 

struct IBindCtx : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT RegisterObjectBound(LPUNKNOWN) = 0; 
__attribute((__stdcall__)) virtual HRESULT RevokeObjectBound(LPUNKNOWN) = 0; 
__attribute((__stdcall__)) virtual HRESULT ReleaseBoundObjects() = 0; 
__attribute((__stdcall__)) virtual HRESULT SetBindOptions(LPBIND_OPTS) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetBindOptions(LPBIND_OPTS) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRunningObjectTable(IRunningObjectTable **) = 0; 
__attribute((__stdcall__)) virtual HRESULT RegisterObjectParam(LPOLESTR, IUnknown *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetObjectParam(LPOLESTR, IUnknown **) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumObjectParam(IEnumString **) = 0; 
__attribute((__stdcall__)) virtual HRESULT RevokeObjectParam(LPOLESTR) = 0; 
}; 


extern "C" const IID IID_IMoniker; 

struct IMoniker : public IPersistStream { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassID(LPCLSID) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsDirty() = 0; 
__attribute((__stdcall__)) virtual HRESULT Load(IStream *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Save(IStream *, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetSizeMax(PULARGE_INTEGER) = 0; 
__attribute((__stdcall__)) virtual HRESULT BindToObject(IBindCtx *, IMoniker *, const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT BindToStorage(IBindCtx *, IMoniker *, const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Reduce(IBindCtx *, DWORD, IMoniker **, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT ComposeWith(IMoniker *, BOOL, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT Enum(BOOL, IEnumMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsEqual(IMoniker *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Hash(PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsRunning(IBindCtx *, IMoniker *, IMoniker *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTimeOfLastChange(IBindCtx *, IMoniker *, LPFILETIME) = 0; 
__attribute((__stdcall__)) virtual HRESULT Inverse(IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT CommonPrefixWith(IMoniker *, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT RelativePathTo(IMoniker *, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDisplayName(IBindCtx *, IMoniker *, LPOLESTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ParseDisplayName(IBindCtx *, IMoniker *, LPOLESTR, ULONG *, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsSystemMoniker(PDWORD) = 0; 
}; 


extern "C" const IID IID_IPersistStorage; 

struct IPersistStorage : public IPersist { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassID(CLSID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsDirty() = 0; 
__attribute((__stdcall__)) virtual HRESULT InitNew(LPSTORAGE) = 0; 
__attribute((__stdcall__)) virtual HRESULT Load(LPSTORAGE) = 0; 
__attribute((__stdcall__)) virtual HRESULT Save(LPSTORAGE, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT SaveCompleted(LPSTORAGE) = 0; 
__attribute((__stdcall__)) virtual HRESULT HandsOffStorage() = 0; 
}; 


extern "C" const IID IID_IPersistFile; 

struct IPersistFile : public IPersist { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassID(CLSID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsDirty() = 0; 
__attribute((__stdcall__)) virtual HRESULT Load(LPCOLESTR, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Save(LPCOLESTR, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT SaveCompleted(LPCOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetCurFile(LPOLESTR *) = 0; 
}; 


extern "C" const IID IID_IAdviseSink; 

struct IAdviseSink : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual void OnDataChange(FORMATETC *, STGMEDIUM *) = 0; 
__attribute((__stdcall__)) virtual void OnViewChange(DWORD, LONG) = 0; 
__attribute((__stdcall__)) virtual void OnRename(IMoniker *) = 0; 
__attribute((__stdcall__)) virtual void OnSave() = 0; 
__attribute((__stdcall__)) virtual void OnClose() = 0; 
}; 


extern "C" const IID IID_IAdviseSink2; 

struct IAdviseSink2 : public IAdviseSink { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual void OnDataChange(FORMATETC *, STGMEDIUM *) = 0; 
__attribute((__stdcall__)) virtual void OnViewChange(DWORD, LONG) = 0; 
__attribute((__stdcall__)) virtual void OnRename(IMoniker *) = 0; 
__attribute((__stdcall__)) virtual void OnSave() = 0; 
__attribute((__stdcall__)) virtual void OnClose() = 0; 
__attribute((__stdcall__)) virtual void OnLinkSrcChange(IMoniker *); 
}; 


extern "C" const IID IID_IDataObject; 

struct IDataObject : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetData(FORMATETC *, STGMEDIUM *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDataHere(FORMATETC *, STGMEDIUM *) = 0; 
__attribute((__stdcall__)) virtual HRESULT QueryGetData(FORMATETC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetCanonicalFormatEtc(FORMATETC *, FORMATETC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetData(FORMATETC *, STGMEDIUM *, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumFormatEtc(DWORD, IEnumFORMATETC **) = 0; 
__attribute((__stdcall__)) virtual HRESULT DAdvise(FORMATETC *, DWORD, IAdviseSink *, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT DUnadvise(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumDAdvise(IEnumSTATDATA **) = 0; 
}; 


extern "C" const IID IID_IDataAdviseHolder; 

struct IDataAdviseHolder : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Advise(IDataObject *, FORMATETC *, DWORD, IAdviseSink *, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unadvise(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumAdvise(IEnumSTATDATA **) = 0; 
__attribute((__stdcall__)) virtual HRESULT SendOnDataChange(IDataObject *, DWORD, DWORD) = 0; 
}; 


extern "C" const IID IID_IStorage; 

struct IStorage : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateStream(LPCWSTR, DWORD, DWORD, DWORD, IStream **) = 0; 
__attribute((__stdcall__)) virtual HRESULT OpenStream(LPCWSTR, PVOID, DWORD, DWORD, IStream **) = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateStorage(LPCWSTR, DWORD, DWORD, DWORD, IStorage **) = 0; 
__attribute((__stdcall__)) virtual HRESULT OpenStorage(LPCWSTR, IStorage *, DWORD, SNB, DWORD, IStorage **) = 0; 
__attribute((__stdcall__)) virtual HRESULT CopyTo(DWORD, const IID *, SNB, IStorage *) = 0; 
__attribute((__stdcall__)) virtual HRESULT MoveElementTo(LPCWSTR, IStorage *, LPCWSTR, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Commit(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Revert() = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumElements(DWORD, PVOID, DWORD, IEnumSTATSTG **) = 0; 
__attribute((__stdcall__)) virtual HRESULT DestroyElement(LPCWSTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT RenameElement(LPCWSTR, LPCWSTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetElementTimes(LPCWSTR, const FILETIME *, const FILETIME *, const FILETIME *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetClass(const CLSID &) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetStateBits(DWORD, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Stat(STATSTG *, DWORD) = 0; 
}; 


extern "C" const IID IID_IRootStorage; 

struct IRootStorage : public IPersist { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT SwitchToFile(LPOLESTR) = 0; 
}; 


extern "C" const IID IID_IRpcChannelBuffer; 

struct IRpcChannelBuffer : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetBuffer(RPCOLEMESSAGE *, const IID &) = 0; 
__attribute((__stdcall__)) virtual HRESULT SendReceive(RPCOLEMESSAGE *, PULONG) = 0; 
__attribute((__stdcall__)) virtual HRESULT FreeBuffer(RPCOLEMESSAGE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDestCtx(PDWORD, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsConnected() = 0; 
}; 


extern "C" const IID IID_IRpcProxyBuffer; 

struct IRpcProxyBuffer : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Connect(IRpcChannelBuffer *) = 0; 
__attribute((__stdcall__)) virtual void Disconnect() = 0; 

}; 


extern "C" const IID IID_IRpcStubBuffer; 

struct IRpcStubBuffer : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Connect(LPUNKNOWN) = 0; 
__attribute((__stdcall__)) virtual void Disconnect() = 0; 
__attribute((__stdcall__)) virtual HRESULT Invoke(RPCOLEMESSAGE *, LPRPCSTUBBUFFER) = 0; 
__attribute((__stdcall__)) virtual LPRPCSTUBBUFFER IsIIDSupported(const IID &) = 0; 
__attribute((__stdcall__)) virtual ULONG CountRefs() = 0; 
__attribute((__stdcall__)) virtual HRESULT DebugServerQueryInterface(PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT DebugServerRelease(PVOID) = 0; 
}; 


extern "C" const IID IID_IPSFactoryBuffer; 

struct IPSFactoryBuffer : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateProxy(LPUNKNOWN, const IID &, LPRPCPROXYBUFFER *, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateStub(const IID &, LPUNKNOWN, LPRPCSTUBBUFFER *) = 0; 
}; 

typedef IPSFactoryBuffer *LPPSFACTORYBUFFER; 

extern "C" const IID IID_ILockBytes; 

struct ILockBytes : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT ReadAt(ULARGE_INTEGER, PVOID, ULONG, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT WriteAt(ULARGE_INTEGER, PCVOID, ULONG, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Flush() = 0; 
__attribute((__stdcall__)) virtual HRESULT SetSize(ULARGE_INTEGER) = 0; 
__attribute((__stdcall__)) virtual HRESULT LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Stat(STATSTG *, DWORD) = 0; 
}; 


extern "C" const IID IID_IExternalConnection; 

struct IExternalConnection : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual DWORD AddConnection(DWORD, DWORD) = 0; 
__attribute((__stdcall__)) virtual DWORD ReleaseConnection(DWORD, DWORD, BOOL) = 0; 
}; 


extern "C" const IID IID_IRunnableObject; 

struct IRunnableObject : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRunningClass(LPCLSID) = 0; 
__attribute((__stdcall__)) virtual HRESULT Run(LPBC) = 0; 
__attribute((__stdcall__)) virtual BOOL IsRunning() = 0; 
__attribute((__stdcall__)) virtual HRESULT LockRunning(BOOL, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetContainedObject(BOOL) = 0; 
}; 


extern "C" const IID IID_IROTData; 

struct IROTData : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetComparisonData(PVOID, ULONG, PULONG) = 0; 
}; 


extern "C" const IID IID_IChannelHook; 

struct IChannelHook : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual void ClientGetSize(const GUID &, const IID &, PULONG) = 0; 
__attribute((__stdcall__)) virtual void ClientFillBuffer(const GUID &, const IID &, PULONG, PVOID) = 0; 
__attribute((__stdcall__)) virtual void ClientNotify(const GUID &, const IID &, ULONG, PVOID, DWORD, HRESULT) = 0; 
__attribute((__stdcall__)) virtual void ServerNotify(const GUID &, const IID &, ULONG, PVOID, DWORD) = 0; 
__attribute((__stdcall__)) virtual void ServerGetSize(const GUID &, const IID &, HRESULT, PULONG) = 0; 
__attribute((__stdcall__)) virtual void ServerFillBuffer(const GUID &, const IID &, PULONG, PVOID, HRESULT) = 0; 
}; 


extern "C" const IID IID_IPropertyStorage; 

struct IPropertyStorage : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT ReadMultiple(ULONG, const PROPSPEC *, PROPVARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT WriteMultiple(ULONG, const PROPSPEC *, PROPVARIANT *, PROPID) = 0; 
__attribute((__stdcall__)) virtual HRESULT DeleteMultiple(ULONG, const PROPSPEC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ReadPropertyNames(ULONG, const PROPID *, LPWSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT WritePropertyNames(ULONG, const PROPID *, const LPWSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT DeletePropertyNames(ULONG, const PROPID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetClass(const CLSID &) = 0; 
__attribute((__stdcall__)) virtual HRESULT Commit(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Revert() = 0; 
__attribute((__stdcall__)) virtual HRESULT Enum(IEnumSTATPROPSTG **) = 0; 
__attribute((__stdcall__)) virtual HRESULT Stat(STATPROPSTG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetTimes(const FILETIME *, const FILETIME *, const FILETIME *) = 0; 
}; 


extern "C" const IID IID_IPropertySetStorage; 

struct IPropertySetStorage : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Create(const FMTID &, CLSID *, DWORD, DWORD, LPPROPERTYSTORAGE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Open(const FMTID &, DWORD, LPPROPERTYSTORAGE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Delete(const FMTID &) = 0; 
__attribute((__stdcall__)) virtual HRESULT Enum(IEnumSTATPROPSETSTG **) = 0; 
}; 


extern "C" const IID IID_IClientSecurity; 

struct IClientSecurity : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT QueryBlanket(PVOID, PDWORD, PDWORD, OLECHAR **, PDWORD, PDWORD, RPC_AUTH_IDENTITY_HANDLE **, PDWORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetBlanket(PVOID, DWORD, DWORD, LPWSTR, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE *, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT CopyProxy(LPUNKNOWN, LPUNKNOWN *) = 0; 
}; 


extern "C" const IID IID_IServerSecurity; 

struct IServerSecurity : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT QueryBlanket(PDWORD, PDWORD, OLECHAR **, PDWORD, PDWORD, RPC_AUTHZ_HANDLE *, PDWORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ImpersonateClient() = 0; 
__attribute((__stdcall__)) virtual HRESULT RevertToSelf() = 0; 
__attribute((__stdcall__)) virtual HRESULT IsImpersonating() = 0; 
}; 


extern "C" const IID IID_IClassActivator; 

struct IClassActivator : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClassObject(const CLSID &, DWORD, LCID, const IID &, PVOID *) = 0; 
}; 


extern "C" const IID IID_IFillLockBytes; 

struct IFillLockBytes : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT FillAppend(const void *, ULONG, PULONG) = 0; 
__attribute((__stdcall__)) virtual HRESULT FillAt(ULARGE_INTEGER, const void *, ULONG, PULONG) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetFillSize(ULARGE_INTEGER) = 0; 
__attribute((__stdcall__)) virtual HRESULT Terminate(BOOL) = 0; 
}; 


extern "C" const IID IID_IProgressNotify; 

struct IProgressNotify : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnProgress(DWORD, DWORD, BOOL, BOOL) = 0; 
}; 


extern "C" const IID IID_ILayoutStorage; 

struct ILayoutStorage : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT LayoutScript(STORAGELAYOUT *, DWORD, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT BeginMonitor() = 0; 
__attribute((__stdcall__)) virtual HRESULT EndMonitor() = 0; 
__attribute((__stdcall__)) virtual HRESULT ReLayoutDocfile(OLECHAR *) = 0; 
}; 


extern "C" const IID IID_IGlobalInterfaceTable; 

struct IGlobalInterfaceTable : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT RegisterInterfaceInGlobal(IUnknown *, const IID &, DWORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT RevokeInterfaceFromGlobal(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetInterfaceFromGlobal(DWORD, const IID &, void **) = 0; 
}; 
# 1065 "d:\\mingw\\mingw\\include\\objidl.h" 3
__attribute((__stdcall__)) HRESULT IMarshal_GetUnmarshalClass_Proxy(IMarshal *, const IID &, void *, DWORD, void *, DWORD, CLSID *); 
__attribute((__stdcall__)) void IMarshal_GetUnmarshalClass_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMarshal_GetMarshalSizeMax_Proxy(IMarshal *, const IID &, void *, DWORD, void *, DWORD, DWORD *); 
__attribute((__stdcall__)) void IMarshal_GetMarshalSizeMax_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMarshal_MarshalInterface_Proxy(IMarshal *, IStream *, const IID &, void *, DWORD, void *, DWORD); 
__attribute((__stdcall__)) void IMarshal_MarshalInterface_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMarshal_UnmarshalInterface_Proxy(IMarshal *, IStream *, const IID &, void **); 
__attribute((__stdcall__)) void IMarshal_UnmarshalInterface_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMarshal_ReleaseMarshalData_Proxy(IMarshal *, IStream *); 
__attribute((__stdcall__)) void IMarshal_ReleaseMarshalData_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMarshal_DisconnectObject_Proxy(IMarshal *, DWORD); 
__attribute((__stdcall__)) void IMarshal_DisconnectObject_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMalloc_Alloc_Proxy(IMalloc *, ULONG) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMalloc_Alloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMalloc_Realloc_Proxy(IMalloc *, void *, ULONG) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMalloc_Realloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IMalloc_Free_Proxy(IMalloc *, void *); 
__attribute((__stdcall__)) void IMalloc_Free_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IMalloc_GetSize_Proxy(IMalloc *, void *); 
__attribute((__stdcall__)) void IMalloc_GetSize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) int IMalloc_DidAlloc_Proxy(IMalloc *, void *); 
__attribute((__stdcall__)) void IMalloc_DidAlloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IMalloc_HeapMinimize_Proxy(IMalloc *); 
__attribute((__stdcall__)) void IMalloc_HeapMinimize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IMallocSpy_PreAlloc_Proxy(IMallocSpy *, ULONG cbRequest); 
__attribute((__stdcall__)) void IMallocSpy_PreAlloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMallocSpy_PostAlloc_Proxy(IMallocSpy *, void *) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMallocSpy_PostAlloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMallocSpy_PreFree_Proxy(IMallocSpy *, void *, BOOL) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMallocSpy_PreFree_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IMallocSpy_PostFree_Proxy(IMallocSpy *, BOOL); 
__attribute((__stdcall__)) void IMallocSpy_PostFree_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IMallocSpy_PreRealloc_Proxy(IMallocSpy *, void *, ULONG, void **, BOOL); 
__attribute((__stdcall__)) void IMallocSpy_PreRealloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMallocSpy_PostRealloc_Proxy(IMallocSpy *, void *, BOOL) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMallocSpy_PostRealloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMallocSpy_PreGetSize_Proxy(IMallocSpy *, void *, BOOL) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMallocSpy_PreGetSize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IMallocSpy_PostGetSize_Proxy(IMallocSpy *, ULONG, BOOL); 
__attribute((__stdcall__)) void IMallocSpy_PostGetSize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
void *IMallocSpy_PreDidAlloc_Proxy(IMallocSpy *, void *, BOOL) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IMallocSpy_PreDidAlloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) int IMallocSpy_PostDidAlloc_Proxy(IMallocSpy *, void *, BOOL, int); 
__attribute((__stdcall__)) void IMallocSpy_PostDidAlloc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IMallocSpy_PreHeapMinimize_Proxy(IMallocSpy *); 
__attribute((__stdcall__)) void IMallocSpy_PreHeapMinimize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IMallocSpy_PostHeapMinimize_Proxy(IMallocSpy *); 
__attribute((__stdcall__)) void IMallocSpy_PostHeapMinimize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStdMarshalInfo_GetClassForHandler_Proxy(IStdMarshalInfo *, DWORD, void *, CLSID *); 
__attribute((__stdcall__)) void IStdMarshalInfo_GetClassForHandler_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) DWORD IExternalConnection_AddConnection_Proxy(IExternalConnection *, DWORD, DWORD); 
__attribute((__stdcall__)) void IExternalConnection_AddConnection_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) DWORD IExternalConnection_ReleaseConnection_Proxy(IExternalConnection *, DWORD, DWORD, BOOL); 
__attribute((__stdcall__)) void IExternalConnection_ReleaseConnection_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_RemoteNext_Proxy(IEnumUnknown *, ULONG, IUnknown **, ULONG *); 
__attribute((__stdcall__)) void IEnumUnknown_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_Skip_Proxy(IEnumUnknown *, ULONG); 
__attribute((__stdcall__)) void IEnumUnknown_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_Reset_Proxy(IEnumUnknown *); 
__attribute((__stdcall__)) void IEnumUnknown_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_Clone_Proxy(IEnumUnknown *, IEnumUnknown **); 
__attribute((__stdcall__)) void IEnumUnknown_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_RegisterObjectBound_Proxy(IBindCtx *, IUnknown * punk); 
__attribute((__stdcall__)) void IBindCtx_RegisterObjectBound_Stub(IRpcStubBuffer *, IRpcChannelBuffer * _pRpcChannelBuffer, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_RevokeObjectBound_Proxy(IBindCtx *, IUnknown * punk); 
__attribute((__stdcall__)) void IBindCtx_RevokeObjectBound_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_ReleaseBoundObjects_Proxy(IBindCtx *); 
__attribute((__stdcall__)) void IBindCtx_ReleaseBoundObjects_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_SetBindOptions_Proxy(IBindCtx *, BIND_OPTS *); 
__attribute((__stdcall__)) void IBindCtx_SetBindOptions_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_GetBindOptions_Proxy(IBindCtx *, BIND_OPTS * pbindopts); 
__attribute((__stdcall__)) void IBindCtx_GetBindOptions_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_GetRunningObjectTable_Proxy(IBindCtx *, IRunningObjectTable **); 
__attribute((__stdcall__)) void IBindCtx_GetRunningObjectTable_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_RegisterObjectParam_Proxy(IBindCtx *, LPCSTR, IUnknown *); 
__attribute((__stdcall__)) void IBindCtx_RegisterObjectParam_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_GetObjectParam_Proxy(IBindCtx *, LPCSTR, IUnknown **); 
__attribute((__stdcall__)) void IBindCtx_GetObjectParam_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_EnumObjectParam_Proxy(IBindCtx *, IEnumString **); 
__attribute((__stdcall__)) void IBindCtx_EnumObjectParam_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IBindCtx_RevokeObjectParam_Proxy(IBindCtx *, LPCSTR); 
__attribute((__stdcall__)) void IBindCtx_RevokeObjectParam_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_RemoteNext_Proxy(IEnumMoniker *, ULONG, IMoniker **, ULONG *); 
__attribute((__stdcall__)) void IEnumMoniker_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_Skip_Proxy(IEnumMoniker *, ULONG); 
__attribute((__stdcall__)) void IEnumMoniker_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_Reset_Proxy(IEnumMoniker *); 
__attribute((__stdcall__)) void IEnumMoniker_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_Clone_Proxy(IEnumMoniker *, IEnumMoniker **); 
__attribute((__stdcall__)) void IEnumMoniker_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunnableObject_GetRunningClass_Proxy(IRunnableObject *, LPCLSID); 
__attribute((__stdcall__)) void IRunnableObject_GetRunningClass_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunnableObject_Run_Proxy(IRunnableObject *, LPBINDCTX); 
__attribute((__stdcall__)) void IRunnableObject_Run_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) BOOL IRunnableObject_IsRunning_Proxy(IRunnableObject *); 
__attribute((__stdcall__)) void IRunnableObject_IsRunning_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunnableObject_LockRunning_Proxy(IRunnableObject *, BOOL, BOOL); 
__attribute((__stdcall__)) void IRunnableObject_LockRunning_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunnableObject_SetContainedObject_Proxy(IRunnableObject *, BOOL); 
__attribute((__stdcall__)) void IRunnableObject_SetContainedObject_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_Register_Proxy(IRunningObjectTable *, DWORD, IUnknown *, IMoniker *, DWORD *); 
__attribute((__stdcall__)) void IRunningObjectTable_Register_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_Revoke_Proxy(IRunningObjectTable *, DWORD); 
__attribute((__stdcall__)) void IRunningObjectTable_Revoke_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_IsRunning_Proxy(IRunningObjectTable *, IMoniker *); 
__attribute((__stdcall__)) void IRunningObjectTable_IsRunning_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_GetObject_Proxy(IRunningObjectTable *, IMoniker *, IUnknown **); 
__attribute((__stdcall__)) void IRunningObjectTable_GetObject_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_NoteChangeTime_Proxy(IRunningObjectTable *, DWORD, FILETIME *); 
__attribute((__stdcall__)) void IRunningObjectTable_NoteChangeTime_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_GetTimeOfLastChange_Proxy(IRunningObjectTable *, IMoniker *, FILETIME *); 
__attribute((__stdcall__)) void IRunningObjectTable_GetTimeOfLastChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRunningObjectTable_EnumRunning_Proxy(IRunningObjectTable *, IEnumMoniker **); 
__attribute((__stdcall__)) void IRunningObjectTable_EnumRunning_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersist_GetClassID_Proxy(IPersist *, CLSID *); 
__attribute((__stdcall__)) void IPersist_GetClassID_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStream_IsDirty_Proxy(IPersistStream *); 
__attribute((__stdcall__)) void IPersistStream_IsDirty_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStream_Load_Proxy(IPersistStream *, IStream *); 
__attribute((__stdcall__)) void IPersistStream_Load_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStream_Save_Proxy(IPersistStream *, IStream *, BOOL); 
__attribute((__stdcall__)) void IPersistStream_Save_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStream_GetSizeMax_Proxy(IPersistStream *, ULARGE_INTEGER *); 
__attribute((__stdcall__)) void IPersistStream_GetSizeMax_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_RemoteBindToObject_Proxy(IMoniker *, IBindCtx *, IMoniker *, const IID &, IUnknown **); 
__attribute((__stdcall__)) void IMoniker_RemoteBindToObject_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_RemoteBindToStorage_Proxy(IMoniker *, IBindCtx *, IMoniker *, const IID &, IUnknown **); 
__attribute((__stdcall__)) void IMoniker_RemoteBindToStorage_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_Reduce_Proxy(IMoniker *, IBindCtx *, DWORD, IMoniker **, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_Reduce_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_ComposeWith_Proxy(IMoniker *, IMoniker *, BOOL, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_ComposeWith_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_Enum_Proxy(IMoniker *, BOOL, IEnumMoniker **); 
__attribute((__stdcall__)) void IMoniker_Enum_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_IsEqual_Proxy(IMoniker *, IMoniker *); 
__attribute((__stdcall__)) void IMoniker_IsEqual_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_Hash_Proxy(IMoniker *, DWORD *); 
__attribute((__stdcall__)) void IMoniker_Hash_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_IsRunning_Proxy(IMoniker *, IBindCtx *, IMoniker *, IMoniker *); 
__attribute((__stdcall__)) void IMoniker_IsRunning_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_GetTimeOfLastChange_Proxy(IMoniker *, IBindCtx *, IMoniker *, FILETIME *); 
__attribute((__stdcall__)) void IMoniker_GetTimeOfLastChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_Inverse_Proxy(IMoniker *, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_Inverse_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_CommonPrefixWith_Proxy(IMoniker *, IMoniker *, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_CommonPrefixWith_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_RelativePathTo_Proxy(IMoniker *, IMoniker *, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_RelativePathTo_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_GetDisplayName_Proxy(IMoniker *, IBindCtx *, IMoniker *, LPCSTR *); 
__attribute((__stdcall__)) void IMoniker_GetDisplayName_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_ParseDisplayName_Proxy(IMoniker *, IBindCtx *, IMoniker *, LPCSTR, ULONG *, IMoniker **); 
__attribute((__stdcall__)) void IMoniker_ParseDisplayName_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IMoniker_IsSystemMoniker_Proxy(IMoniker *, DWORD *); 
__attribute((__stdcall__)) void IMoniker_IsSystemMoniker_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IROTData_GetComparisonData_Proxy(IROTData *, BYTE *, ULONG cbMax, ULONG *); 
__attribute((__stdcall__)) void IROTData_GetComparisonData_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumString_RemoteNext_Proxy(IEnumString *, ULONG, LPCSTR * rgelt, ULONG *); 
__attribute((__stdcall__)) void IEnumString_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumString_Skip_Proxy(IEnumString *, ULONG); 
__attribute((__stdcall__)) void IEnumString_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumString_Reset_Proxy(IEnumString *); 
__attribute((__stdcall__)) void IEnumString_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumString_Clone_Proxy(IEnumString *, IEnumString **); 
__attribute((__stdcall__)) void IEnumString_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_RemoteRead_Proxy(IStream *, BYTE *, ULONG, ULONG *); 
__attribute((__stdcall__)) void IStream_RemoteRead_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_RemoteWrite_Proxy(IStream *, BYTE * pv, ULONG, ULONG *); 
__attribute((__stdcall__)) void IStream_RemoteWrite_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_RemoteSeek_Proxy(IStream *, LARGE_INTEGER, DWORD, ULARGE_INTEGER *); 
__attribute((__stdcall__)) void IStream_RemoteSeek_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_SetSize_Proxy(IStream *, ULARGE_INTEGER); 
__attribute((__stdcall__)) void IStream_SetSize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_RemoteCopyTo_Proxy(IStream *, IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *); 
__attribute((__stdcall__)) void IStream_RemoteCopyTo_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_Commit_Proxy(IStream *, DWORD); 
__attribute((__stdcall__)) void IStream_Commit_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_Revert_Proxy(IStream *); 
__attribute((__stdcall__)) void IStream_Revert_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_LockRegion_Proxy(IStream *, ULARGE_INTEGER, ULARGE_INTEGER, DWORD); 
__attribute((__stdcall__)) void IStream_LockRegion_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_UnlockRegion_Proxy(IStream *, ULARGE_INTEGER, ULARGE_INTEGER, DWORD); 
__attribute((__stdcall__)) void IStream_UnlockRegion_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_Stat_Proxy(IStream *, STATSTG *, DWORD); 
__attribute((__stdcall__)) void IStream_Stat_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStream_Clone_Proxy(IStream *, IStream **); 
__attribute((__stdcall__)) void IStream_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_RemoteNext_Proxy(IEnumSTATSTG *, ULONG, STATSTG *, ULONG *); 
__attribute((__stdcall__)) void IEnumSTATSTG_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_Skip_Proxy(IEnumSTATSTG *, ULONG celt); 
__attribute((__stdcall__)) void IEnumSTATSTG_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_Reset_Proxy(IEnumSTATSTG *); 
__attribute((__stdcall__)) void IEnumSTATSTG_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_Clone_Proxy(IEnumSTATSTG *, IEnumSTATSTG **); 
__attribute((__stdcall__)) void IEnumSTATSTG_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_CreateStream_Proxy(IStorage *, OLECHAR *, DWORD, DWORD, DWORD, IStream **); 
__attribute((__stdcall__)) void IStorage_CreateStream_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_RemoteOpenStream_Proxy(IStorage *, const OLECHAR *, unsigned long, BYTE *, DWORD, DWORD, IStream **); 
__attribute((__stdcall__)) void IStorage_RemoteOpenStream_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_CreateStorage_Proxy(IStorage *, OLECHAR *, DWORD, DWORD, DWORD, IStorage **); 
__attribute((__stdcall__)) void IStorage_CreateStorage_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_OpenStorage_Proxy(IStorage *, OLECHAR *, IStorage *, DWORD, SNB, DWORD, IStorage **); 
__attribute((__stdcall__)) void IStorage_OpenStorage_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_CopyTo_Proxy(IStorage *, DWORD, const IID *, SNB, IStorage *); 
__attribute((__stdcall__)) void IStorage_CopyTo_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_MoveElementTo_Proxy(IStorage *, const OLECHAR *, IStorage *, const OLECHAR *, DWORD); 
__attribute((__stdcall__)) void IStorage_MoveElementTo_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_Commit_Proxy(IStorage *, DWORD); 
__attribute((__stdcall__)) void IStorage_Commit_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_Revert_Proxy(IStorage *); 
__attribute((__stdcall__)) void IStorage_Revert_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_RemoteEnumElements_Proxy(IStorage *, DWORD, unsigned long, BYTE *, DWORD, IEnumSTATSTG **); 
__attribute((__stdcall__)) void IStorage_RemoteEnumElements_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_DestroyElement_Proxy(IStorage *, OLECHAR *); 
__attribute((__stdcall__)) void IStorage_DestroyElement_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_RenameElement_Proxy(IStorage *, const OLECHAR *, const OLECHAR *); 
__attribute((__stdcall__)) void IStorage_RenameElement_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_SetElementTimes_Proxy(IStorage *, const OLECHAR *, const FILETIME *, const FILETIME *, const FILETIME *); 
__attribute((__stdcall__)) void IStorage_SetElementTimes_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_SetClass_Proxy(IStorage *, const CLSID &); 
__attribute((__stdcall__)) void IStorage_SetClass_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_SetStateBits_Proxy(IStorage *, DWORD, DWORD); 
__attribute((__stdcall__)) void IStorage_SetStateBits_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IStorage_Stat_Proxy(IStorage *, STATSTG *, DWORD); 
__attribute((__stdcall__)) void IStorage_Stat_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistFile_IsDirty_Proxy(IPersistFile *); 
__attribute((__stdcall__)) void IPersistFile_IsDirty_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistFile_Load_Proxy(IPersistFile *, LPCOLESTR, DWORD); 
__attribute((__stdcall__)) void IPersistFile_Load_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistFile_Save_Proxy(IPersistFile *, LPCOLESTR pszFileName, BOOL); 
__attribute((__stdcall__)) void IPersistFile_Save_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistFile_SaveCompleted_Proxy(IPersistFile *, LPCOLESTR); 
__attribute((__stdcall__)) void IPersistFile_SaveCompleted_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistFile_GetCurFile_Proxy(IPersistFile *, LPCSTR *); 
__attribute((__stdcall__)) void IPersistFile_GetCurFile_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_IsDirty_Proxy(IPersistStorage *); 
__attribute((__stdcall__)) void IPersistStorage_IsDirty_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_InitNew_Proxy(IPersistStorage *, IStorage *); 
__attribute((__stdcall__)) void IPersistStorage_InitNew_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_Load_Proxy(IPersistStorage *, IStorage *); 
__attribute((__stdcall__)) void IPersistStorage_Load_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_Save_Proxy(IPersistStorage *, IStorage *, BOOL); 
__attribute((__stdcall__)) void IPersistStorage_Save_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_SaveCompleted_Proxy(IPersistStorage *, IStorage *); 
__attribute((__stdcall__)) void IPersistStorage_SaveCompleted_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPersistStorage_HandsOffStorage_Proxy(IPersistStorage *); 
__attribute((__stdcall__)) void IPersistStorage_HandsOffStorage_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_RemoteReadAt_Proxy(ILockBytes *, ULARGE_INTEGER, BYTE *, ULONG, ULONG *); 
__attribute((__stdcall__)) void ILockBytes_RemoteReadAt_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_RemoteWriteAt_Proxy(ILockBytes *, ULARGE_INTEGER, BYTE * pv, ULONG, ULONG *); 
__attribute((__stdcall__)) void ILockBytes_RemoteWriteAt_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_Flush_Proxy(ILockBytes *); 
__attribute((__stdcall__)) void ILockBytes_Flush_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_SetSize_Proxy(ILockBytes *, ULARGE_INTEGER); 
__attribute((__stdcall__)) void ILockBytes_SetSize_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_LockRegion_Proxy(ILockBytes *, ULARGE_INTEGER, ULARGE_INTEGER, DWORD); 
__attribute((__stdcall__)) void ILockBytes_LockRegion_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_UnlockRegion_Proxy(ILockBytes *, ULARGE_INTEGER, ULARGE_INTEGER, DWORD); 
__attribute((__stdcall__)) void ILockBytes_UnlockRegion_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT ILockBytes_Stat_Proxy(ILockBytes *, STATSTG *, DWORD); 
__attribute((__stdcall__)) void ILockBytes_Stat_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_RemoteNext_Proxy(IEnumFORMATETC *, ULONG, FORMATETC *, ULONG *); 
__attribute((__stdcall__)) void IEnumFORMATETC_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_Skip_Proxy(IEnumFORMATETC *, ULONG); 
__attribute((__stdcall__)) void IEnumFORMATETC_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_Reset_Proxy(IEnumFORMATETC *); 
__attribute((__stdcall__)) void IEnumFORMATETC_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_Clone_Proxy(IEnumFORMATETC *, IEnumFORMATETC **); 
__attribute((__stdcall__)) void IEnumFORMATETC_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_Next_Proxy(IEnumFORMATETC *, ULONG, FORMATETC *, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumFORMATETC_Next_Stub(IEnumFORMATETC *, ULONG, FORMATETC *, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_RemoteNext_Proxy(IEnumSTATDATA *, ULONG, STATDATA *, ULONG *); 
__attribute((__stdcall__)) void IEnumSTATDATA_RemoteNext_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_Skip_Proxy(IEnumSTATDATA *, ULONG); 
__attribute((__stdcall__)) void IEnumSTATDATA_Skip_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_Reset_Proxy(IEnumSTATDATA *); 
__attribute((__stdcall__)) void IEnumSTATDATA_Reset_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_Clone_Proxy(IEnumSTATDATA *, IEnumSTATDATA **); 
__attribute((__stdcall__)) void IEnumSTATDATA_Clone_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_Next_Proxy(IEnumSTATDATA *, ULONG, STATDATA *, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumSTATDATA_Next_Stub(IEnumSTATDATA *, ULONG, STATDATA *, ULONG *); 
__attribute((__stdcall__)) HRESULT IRootStorage_SwitchToFile_Proxy(IRootStorage *, LPCSTR); 
__attribute((__stdcall__)) void IRootStorage_SwitchToFile_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnDataChange_Proxy(IAdviseSink *, FORMATETC *, RemSTGMEDIUM *); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnDataChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnViewChange_Proxy(IAdviseSink *, DWORD, LONG); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnViewChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnRename_Proxy(IAdviseSink *, IMoniker *); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnRename_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnSave_Proxy(IAdviseSink *); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnSave_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IAdviseSink_RemoteOnClose_Proxy(IAdviseSink *); 
__attribute((__stdcall__)) void IAdviseSink_RemoteOnClose_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink_OnDataChange_Proxy(IAdviseSink *, FORMATETC *, STGMEDIUM *); 
__attribute((__stdcall__)) void IAdviseSink_OnDataChange_Stub(IAdviseSink *, FORMATETC *, RemSTGMEDIUM *); 
__attribute((__stdcall__)) void IAdviseSink_OnViewChange_Proxy(IAdviseSink *, DWORD, LONG); 
__attribute((__stdcall__)) void IAdviseSink_OnViewChange_Stub(IAdviseSink *, DWORD, LONG); 
__attribute((__stdcall__)) void IAdviseSink_OnRename_Proxy(IAdviseSink *, IMoniker *); 
__attribute((__stdcall__)) void IAdviseSink_OnRename_Stub(IAdviseSink *, IMoniker *); 
__attribute((__stdcall__)) void IAdviseSink_OnSave_Proxy(IAdviseSink *); 
__attribute((__stdcall__)) void IAdviseSink_OnSave_Stub(IAdviseSink *); 
__attribute((__stdcall__)) void IAdviseSink_OnClose_Proxy(IAdviseSink *); 
__attribute((__stdcall__)) HRESULT IAdviseSink_OnClose_Stub(IAdviseSink *); 
__attribute((__stdcall__)) void IAdviseSink2_RemoteOnLinkSrcChange_Proxy(IAdviseSink2 *, IMoniker *); 
__attribute((__stdcall__)) void IAdviseSink2_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IAdviseSink2_OnLinkSrcChange_Proxy(IAdviseSink2 *, IMoniker *); 
__attribute((__stdcall__)) void IAdviseSink2_OnLinkSrcChange_Stub(IAdviseSink2 *, IMoniker *); 
__attribute((__stdcall__)) HRESULT IDataObject_RemoteGetData_Proxy(IDataObject *, FORMATETC *, RemSTGMEDIUM **); 
__attribute((__stdcall__)) void IDataObject_RemoteGetData_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_RemoteGetDataHere_Proxy(IDataObject *, FORMATETC *, RemSTGMEDIUM **); 
__attribute((__stdcall__)) void IDataObject_RemoteGetDataHere_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_QueryGetData_Proxy(IDataObject *, FORMATETC *); 
__attribute((__stdcall__)) void IDataObject_QueryGetData_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_GetCanonicalFormatEtc_Proxy(IDataObject *, FORMATETC *, FORMATETC *); 
__attribute((__stdcall__)) void IDataObject_GetCanonicalFormatEtc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_RemoteSetData_Proxy(IDataObject *, FORMATETC *, RemSTGMEDIUM *, BOOL); 
__attribute((__stdcall__)) void IDataObject_RemoteSetData_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_EnumFormatEtc_Proxy(IDataObject *, DWORD, IEnumFORMATETC **); 
__attribute((__stdcall__)) void IDataObject_EnumFormatEtc_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_DAdvise_Proxy(IDataObject *, FORMATETC *, DWORD, IAdviseSink *, DWORD *); 
__attribute((__stdcall__)) void IDataObject_DAdvise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_DUnadvise_Proxy(IDataObject *, DWORD); 
__attribute((__stdcall__)) void IDataObject_DUnadvise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_EnumDAdvise_Proxy(IDataObject *, IEnumSTATDATA **); 
__attribute((__stdcall__)) void IDataObject_EnumDAdvise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataObject_GetData_Proxy(IDataObject *, FORMATETC *, STGMEDIUM *); 
__attribute((__stdcall__)) HRESULT IDataObject_GetData_Stub(IDataObject *, FORMATETC *, RemSTGMEDIUM **); 
__attribute((__stdcall__)) HRESULT IDataObject_GetDataHere_Proxy(IDataObject *, FORMATETC *, STGMEDIUM *); 
__attribute((__stdcall__)) HRESULT IDataObject_GetDataHere_Stub(IDataObject *, FORMATETC *, RemSTGMEDIUM **); 
__attribute((__stdcall__)) HRESULT IDataObject_SetData_Proxy(IDataObject *, FORMATETC *, STGMEDIUM *, BOOL); 
__attribute((__stdcall__)) HRESULT IDataObject_SetData_Stub(IDataObject *, FORMATETC *, RemSTGMEDIUM *, BOOL); 
__attribute((__stdcall__)) HRESULT IDataAdviseHolder_Advise_Proxy(IDataAdviseHolder *, IDataObject *, FORMATETC *, DWORD, IAdviseSink *, DWORD *); 
__attribute((__stdcall__)) void IDataAdviseHolder_Advise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataAdviseHolder_Unadvise_Proxy(IDataAdviseHolder *, DWORD); 
__attribute((__stdcall__)) void IDataAdviseHolder_Unadvise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataAdviseHolder_EnumAdvise_Proxy(IDataAdviseHolder *, IEnumSTATDATA **); 
__attribute((__stdcall__)) void IDataAdviseHolder_EnumAdvise_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IDataAdviseHolder_SendOnDataChange_Proxy(IDataAdviseHolder *, IDataObject *, DWORD, DWORD); 
__attribute((__stdcall__)) void IDataAdviseHolder_SendOnDataChange_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) DWORD IMessageFilter_HandleInComingCall_Proxy(IMessageFilter *, DWORD, HTASK, DWORD, LPINTERFACEINFO); 
__attribute((__stdcall__)) void IMessageFilter_HandleInComingCall_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) DWORD IMessageFilter_RetryRejectedCall_Proxy(IMessageFilter *, HTASK, DWORD, DWORD); 
__attribute((__stdcall__)) void IMessageFilter_RetryRejectedCall_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) DWORD IMessageFilter_MessagePending_Proxy(IMessageFilter *, HTASK, DWORD, DWORD); 
__attribute((__stdcall__)) void IMessageFilter_MessagePending_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcChannelBuffer_GetBuffer_Proxy(IRpcChannelBuffer *, RPCOLEMESSAGE *, const IID &); 
__attribute((__stdcall__)) void IRpcChannelBuffer_GetBuffer_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcChannelBuffer_SendReceive_Proxy(IRpcChannelBuffer *, RPCOLEMESSAGE *, ULONG *); 
__attribute((__stdcall__)) void IRpcChannelBuffer_SendReceive_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcChannelBuffer_FreeBuffer_Proxy(IRpcChannelBuffer *, RPCOLEMESSAGE *); 
__attribute((__stdcall__)) void IRpcChannelBuffer_FreeBuffer_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcChannelBuffer_GetDestCtx_Proxy(IRpcChannelBuffer *, DWORD *, void **); 
__attribute((__stdcall__)) void IRpcChannelBuffer_GetDestCtx_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcChannelBuffer_IsConnected_Proxy(IRpcChannelBuffer *); 
__attribute((__stdcall__)) void IRpcChannelBuffer_IsConnected_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcProxyBuffer_Connect_Proxy(IRpcProxyBuffer *, IRpcChannelBuffer * pRpcChannelBuffer); 
__attribute((__stdcall__)) void IRpcProxyBuffer_Connect_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IRpcProxyBuffer_Disconnect_Proxy(IRpcProxyBuffer *); 
__attribute((__stdcall__)) void IRpcProxyBuffer_Disconnect_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcStubBuffer_Connect_Proxy(IRpcStubBuffer *, IUnknown *); 
__attribute((__stdcall__)) void IRpcStubBuffer_Connect_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IRpcStubBuffer_Disconnect_Proxy(IRpcStubBuffer *); 
__attribute((__stdcall__)) void IRpcStubBuffer_Disconnect_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcStubBuffer_Invoke_Proxy(IRpcStubBuffer *, RPCOLEMESSAGE *, IRpcChannelBuffer *); 
__attribute((__stdcall__)) void IRpcStubBuffer_Invoke_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
IRpcStubBuffer *IRpcStubBuffer_IsIIDSupported_Proxy(IRpcStubBuffer *, const IID &) __attribute((__stdcall__)); 
__attribute((__stdcall__)) void IRpcStubBuffer_IsIIDSupported_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) ULONG IRpcStubBuffer_CountRefs_Proxy(IRpcStubBuffer *); 
__attribute((__stdcall__)) void IRpcStubBuffer_CountRefs_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IRpcStubBuffer_DebugServerQueryInterface_Proxy(IRpcStubBuffer *, void **); 
__attribute((__stdcall__)) void IRpcStubBuffer_DebugServerQueryInterface_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void IRpcStubBuffer_DebugServerRelease_Proxy(IRpcStubBuffer *, void *); 
__attribute((__stdcall__)) void IRpcStubBuffer_DebugServerRelease_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPSFactoryBuffer_CreateProxy_Proxy(IPSFactoryBuffer *, IUnknown *, const IID &, IRpcProxyBuffer **, void **); 
__attribute((__stdcall__)) void IPSFactoryBuffer_CreateProxy_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) HRESULT IPSFactoryBuffer_CreateStub_Proxy(IPSFactoryBuffer *, const IID &, IUnknown *, IRpcStubBuffer **); 
__attribute((__stdcall__)) void IPSFactoryBuffer_CreateStub_Stub(IRpcStubBuffer *, IRpcChannelBuffer *, PRPC_MESSAGE, PDWORD); 
__attribute((__stdcall__)) void SNB_to_xmit(SNB *, RemSNB **); 
__attribute((__stdcall__)) void SNB_from_xmit(RemSNB *, SNB *); 
__attribute((__stdcall__)) void SNB_free_inst(SNB *); 
__attribute((__stdcall__)) void SNB_free_xmit(RemSNB *); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_Next_Proxy(IEnumUnknown *, ULONG, IUnknown **, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumUnknown_Next_Stub(IEnumUnknown *, ULONG, IUnknown **, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_Next_Proxy(IEnumMoniker *, ULONG, IMoniker **, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumMoniker_Next_Stub(IEnumMoniker *, ULONG, IMoniker **, ULONG *); 
__attribute((__stdcall__)) HRESULT IMoniker_BindToObject_Proxy(IMoniker *, IBindCtx *, IMoniker *, const IID &, void **); 
__attribute((__stdcall__)) HRESULT IMoniker_BindToObject_Stub(IMoniker *, IBindCtx *, IMoniker *, const IID &, IUnknown **); 
__attribute((__stdcall__)) HRESULT IMoniker_BindToStorage_Proxy(IMoniker *, IBindCtx *, IMoniker *, const IID &, void **); 
__attribute((__stdcall__)) HRESULT IMoniker_BindToStorage_Stub(IMoniker *, IBindCtx *, IMoniker *, const IID &, IUnknown **); 
__attribute((__stdcall__)) HRESULT IEnumString_Next_Proxy(IEnumString *, ULONG, LPCSTR *, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumString_Next_Stub(IEnumString *, ULONG, LPCSTR *, ULONG *); 
__attribute((__stdcall__)) HRESULT IStream_Read_Proxy(IStream *, void *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT IStream_Read_Stub(IStream *, BYTE *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT IStream_Write_Proxy(IStream *, void *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT IStream_Write_Stub(IStream *, BYTE *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT IStream_Seek_Proxy(IStream *, LARGE_INTEGER, DWORD, ULARGE_INTEGER *); 
__attribute((__stdcall__)) HRESULT IStream_Seek_Stub(IStream *, LARGE_INTEGER, DWORD, ULARGE_INTEGER *); 
__attribute((__stdcall__)) HRESULT IStream_CopyTo_Proxy(IStream *, IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *); 
__attribute((__stdcall__)) HRESULT IStream_CopyTo_Stub(IStream *, IStream *, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_Next_Proxy(IEnumSTATSTG *, ULONG, STATSTG *, ULONG *); 
__attribute((__stdcall__)) HRESULT IEnumSTATSTG_Next_Stub(IEnumSTATSTG *, ULONG, STATSTG *, ULONG *); 
__attribute((__stdcall__)) HRESULT IStorage_OpenStream_Proxy(IStorage *, OLECHAR *, void *, DWORD, DWORD, IStream **); 
__attribute((__stdcall__)) HRESULT IStorage_OpenStream_Stub(IStorage *, OLECHAR *, unsigned long, BYTE *, DWORD, DWORD, IStream **); 
__attribute((__stdcall__)) HRESULT IStorage_EnumElements_Proxy(IStorage *, DWORD, void *, DWORD, IEnumSTATSTG **); 
__attribute((__stdcall__)) HRESULT IStorage_EnumElements_Stub(IStorage *, DWORD, unsigned long, BYTE *, DWORD, IEnumSTATSTG **); 
__attribute((__stdcall__)) HRESULT ILockBytes_ReadAt_Proxy(ILockBytes *, ULARGE_INTEGER, void *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT ILockBytes_ReadAt_Stub(ILockBytes *, ULARGE_INTEGER, BYTE *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT ILockBytes_WriteAt_Proxy(ILockBytes *, ULARGE_INTEGER, const void *, ULONG, ULONG *); 
__attribute((__stdcall__)) HRESULT ILockBytes_WriteAt_Stub(ILockBytes *, ULARGE_INTEGER, BYTE *, ULONG, ULONG *); 
# 76 "d:\\mingw\\mingw\\include\\objbase.h" 3
inline BOOL IsEqualGUID(const GUID &rguid1, const GUID &rguid2) 
{ return !memcmp(&rguid1, &rguid2, sizeof(GUID)); } 
inline BOOL operator==(const GUID &guidOne, const GUID &guidOther) 
{ return !memcmp(&guidOne, &guidOther, sizeof(GUID)); } 
inline BOOL operator!=(const GUID &g1, const GUID &g2) 
{ return !((g1 == g2)); } 
# 8 "d:\\mingw\\mingw\\include\\cguid.h" 3
extern "C" {

extern const IID GUID_NULL; 
extern const IID IID_IRpcChannel; 
extern const IID IID_IRpcStub; 
extern const IID IID_IStubManager; 
extern const IID IID_IRpcProxy; 
extern const IID IID_IProxyManager; 
extern const IID IID_IPSFactory; 
extern const IID IID_IInternalMoniker; 
extern const IID IID_IDfReserved1; 
extern const IID IID_IDfReserved2; 
extern const IID IID_IDfReserved3; 
extern const CLSID CLSID_StdMarshal; 
extern const IID IID_IStub; 
extern const IID IID_IProxy; 
extern const IID IID_IEnumGeneric; 
extern const IID IID_IEnumHolder; 
extern const IID IID_IEnumCallback; 
extern const IID IID_IOleManager; 
extern const IID IID_IOlePresObj; 
extern const IID IID_IDebug; 
extern const IID IID_IDebugStream; 
extern const CLSID CLSID_PSGenObject; 
extern const CLSID CLSID_PSClientSite; 
extern const CLSID CLSID_PSClassObject; 
extern const CLSID CLSID_PSInPlaceActive; 
extern const CLSID CLSID_PSInPlaceFrame; 
extern const CLSID CLSID_PSDragDrop; 
extern const CLSID CLSID_PSBindCtx; 
extern const CLSID CLSID_PSEnumerators; 
extern const CLSID CLSID_StaticMetafile; 
extern const CLSID CLSID_StaticDib; 
extern const CLSID CID_CDfsVolume; 
extern const CLSID CLSID_CCDFormKrnl; 
extern const CLSID CLSID_CCDPropertyPage; 
extern const CLSID CLSID_CCDFormDialog; 
extern const CLSID CLSID_CCDCommandButton; 
extern const CLSID CLSID_CCDComboBox; 
extern const CLSID CLSID_CCDTextBox; 
extern const CLSID CLSID_CCDCheckBox; 
extern const CLSID CLSID_CCDLabel; 
extern const CLSID CLSID_CCDOptionButton; 
extern const CLSID CLSID_CCDListBox; 
extern const CLSID CLSID_CCDScrollBar; 
extern const CLSID CLSID_CCDGroupBox; 
extern const CLSID CLSID_CCDGeneralPropertyPage; 
extern const CLSID CLSID_CCDGenericPropertyPage; 
extern const CLSID CLSID_CCDFontPropertyPage; 
extern const CLSID CLSID_CCDColorPropertyPage; 
extern const CLSID CLSID_CCDLabelPropertyPage; 
extern const CLSID CLSID_CCDCheckBoxPropertyPage; 
extern const CLSID CLSID_CCDTextBoxPropertyPage; 
extern const CLSID CLSID_CCDOptionButtonPropertyPage; 
extern const CLSID CLSID_CCDListBoxPropertyPage; 
extern const CLSID CLSID_CCDCommandButtonPropertyPage; 
extern const CLSID CLSID_CCDComboBoxPropertyPage; 
extern const CLSID CLSID_CCDScrollBarPropertyPage; 
extern const CLSID CLSID_CCDGroupBoxPropertyPage; 
extern const CLSID CLSID_CCDXObjectPropertyPage; 
extern const CLSID CLSID_CStdPropertyFrame; 
extern const CLSID CLSID_CFormPropertyPage; 
extern const CLSID CLSID_CGridPropertyPage; 
extern const CLSID CLSID_CWSJArticlePage; 
extern const CLSID CLSID_CSystemPage; 
extern const CLSID CLSID_IdentityUnmarshal; 
extern const CLSID CLSID_InProcFreeMarshaler; 
extern const CLSID CLSID_Picture_Metafile; 
extern const CLSID CLSID_Picture_EnhMetafile; 
extern const CLSID CLSID_Picture_Dib; 
extern const CLSID CLSID_StdGlobalInterfaceTable; 
extern const GUID GUID_TRISTATE; 

}
# 94 "d:\\mingw\\mingw\\include\\objbase.h" 3
typedef 
# 89
enum tagCOINIT { 
COINIT_APARTMENTTHREADED = 0x2, 
COINIT_MULTITHREADED = 0, 
COINIT_DISABLE_OLE1DDE = 0x4, 
COINIT_SPEED_OVER_MEMORY = 0x8
} COINIT; 



typedef 
# 95
enum tagSTDMSHLFLAGS { 
SMEXF_SERVER = 0x1, 
SMEXF_HANDLER
} STDMSHLFLAGS; 

extern "C" __attribute((__stdcall__)) DWORD CoBuildVersion(); 
extern "C" __attribute((__stdcall__)) HRESULT CoInitialize(PVOID); 
extern "C" __attribute((__stdcall__)) HRESULT CoInitializeEx(LPVOID, DWORD); 
extern "C" __attribute((__stdcall__)) void CoUninitialize(); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetMalloc(DWORD, LPMALLOC *); 
extern "C" __attribute((__stdcall__)) DWORD CoGetCurrentProcess(); 
extern "C" __attribute((__stdcall__)) HRESULT CoRegisterMallocSpy(LPMALLOCSPY); 
extern "C" __attribute((__stdcall__)) HRESULT CoRevokeMallocSpy(); 
extern "C" __attribute((__stdcall__)) HRESULT CoCreateStandardMalloc(DWORD, IMalloc **); 




extern "C" __attribute((__stdcall__)) HRESULT CoGetClassObject(const CLSID &, DWORD, COSERVERINFO *, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoRegisterClassObject(const CLSID &, LPUNKNOWN, DWORD, DWORD, PDWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoRevokeClassObject(DWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetMarshalSizeMax(ULONG *, const IID &, LPUNKNOWN, DWORD, PVOID, DWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoMarshalInterface(LPSTREAM, const IID &, LPUNKNOWN, DWORD, PVOID, DWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoUnmarshalInterface(LPSTREAM, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoMarshalHresult(LPSTREAM, HRESULT); 
extern "C" __attribute((__stdcall__)) HRESULT CoUnmarshalHresult(LPSTREAM, HRESULT *); 
extern "C" __attribute((__stdcall__)) HRESULT CoReleaseMarshalData(LPSTREAM); 
extern "C" __attribute((__stdcall__)) HRESULT CoDisconnectObject(LPUNKNOWN, DWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoLockObjectExternal(LPUNKNOWN, BOOL, BOOL); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetStandardMarshal(const IID &, LPUNKNOWN, DWORD, PVOID, DWORD, LPMARSHAL *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetStdMarshalEx(LPUNKNOWN, DWORD, LPUNKNOWN *); 
extern "C" __attribute((__stdcall__)) BOOL CoIsHandlerConnected(LPUNKNOWN); 
extern "C" __attribute((__stdcall__)) BOOL CoHasStrongExternalConnections(LPUNKNOWN); 
extern "C" __attribute((__stdcall__)) HRESULT CoMarshalInterThreadInterfaceInStream(const IID &, LPUNKNOWN, LPSTREAM *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetInterfaceAndReleaseStream(LPSTREAM, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoCreateFreeThreadedMarshaler(LPUNKNOWN, LPUNKNOWN *); 
extern "C" __attribute((__stdcall__)) HINSTANCE CoLoadLibrary(LPOLESTR, BOOL); 
extern "C" __attribute((__stdcall__)) void CoFreeLibrary(HINSTANCE); 
extern "C" __attribute((__stdcall__)) void CoFreeAllLibraries(); 
extern "C" __attribute((__stdcall__)) void CoFreeUnusedLibraries(); 
extern "C" __attribute((__stdcall__)) HRESULT CoCreateInstance(const CLSID &, LPUNKNOWN, DWORD, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoCreateInstanceEx(const CLSID &, IUnknown *, DWORD, COSERVERINFO *, DWORD, MULTI_QI *); 
extern "C" __attribute((__stdcall__)) HRESULT StringFromCLSID(const CLSID &, LPOLESTR *); 
extern "C" __attribute((__stdcall__)) HRESULT CLSIDFromString(LPOLESTR, LPCLSID); 
extern "C" __attribute((__stdcall__)) HRESULT StringFromIID(const IID &, LPOLESTR *); 
extern "C" __attribute((__stdcall__)) HRESULT IIDFromString(LPOLESTR, LPIID); 
extern "C" __attribute((__stdcall__)) BOOL CoIsOle1Class(const CLSID &); 
extern "C" __attribute((__stdcall__)) HRESULT ProgIDFromCLSID(const CLSID &, LPOLESTR *); 
extern "C" __attribute((__stdcall__)) HRESULT CLSIDFromProgID(LPCOLESTR, LPCLSID); 
extern "C" __attribute((__stdcall__)) int StringFromGUID2(const GUID &, LPOLESTR, int); 
extern "C" __attribute((__stdcall__)) HRESULT CoCreateGuid(GUID *); 
extern "C" __attribute((__stdcall__)) BOOL CoFileTimeToDosDateTime(FILETIME *, LPWORD, LPWORD); 
extern "C" __attribute((__stdcall__)) BOOL CoDosDateTimeToFileTime(WORD, WORD, FILETIME *); 
extern "C" __attribute((__stdcall__)) HRESULT CoFileTimeNow(FILETIME *); 
extern "C" __attribute((__stdcall__)) HRESULT CoRegisterMessageFilter(LPMESSAGEFILTER, LPMESSAGEFILTER *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetTreatAsClass(const CLSID &, LPCLSID); 
extern "C" __attribute((__stdcall__)) HRESULT CoTreatAsClass(const CLSID &, const CLSID &); 
typedef HRESULT ( __attribute((__stdcall__))*LPFNGETCLASSOBJECT)(const CLSID &, const IID &, PVOID *) ; 
typedef HRESULT ( __attribute((__stdcall__))*LPFNCANUNLOADNOW)(void) ; 
extern "C" __attribute((__stdcall__)) HRESULT DllGetClassObject(const CLSID &, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT DllCanUnloadNow(); 
extern "C" __attribute((__stdcall__)) PVOID CoTaskMemAlloc(ULONG); 
extern "C" __attribute((__stdcall__)) PVOID CoTaskMemRealloc(PVOID, ULONG); 
extern "C" __attribute((__stdcall__)) void CoTaskMemFree(PVOID); 
extern "C" __attribute((__stdcall__)) HRESULT CreateDataAdviseHolder(LPDATAADVISEHOLDER *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateDataCache(LPUNKNOWN, const CLSID &, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT StgCreateDocfile(const OLECHAR *, DWORD, DWORD, IStorage **); 
extern "C" __attribute((__stdcall__)) HRESULT StgCreateDocfileOnILockBytes(ILockBytes *, DWORD, DWORD, IStorage **); 
extern "C" __attribute((__stdcall__)) HRESULT StgOpenStorage(const OLECHAR *, IStorage *, DWORD, SNB, DWORD, IStorage **); 
extern "C" __attribute((__stdcall__)) HRESULT StgOpenStorageOnILockBytes(ILockBytes *, IStorage *, DWORD, SNB, DWORD, IStorage **); 
extern "C" __attribute((__stdcall__)) HRESULT StgIsStorageFile(const OLECHAR *); 
extern "C" __attribute((__stdcall__)) HRESULT StgIsStorageILockBytes(ILockBytes *); 
extern "C" __attribute((__stdcall__)) HRESULT StgSetTimes(const OLECHAR *, const FILETIME *, const FILETIME *, const FILETIME *); 
extern "C" __attribute((__stdcall__)) HRESULT StgCreateStorageEx(const WCHAR *, DWORD, DWORD, DWORD, STGOPTIONS *, void *, const IID &, void **); 
extern "C" __attribute((__stdcall__)) HRESULT StgOpenStorageEx(const WCHAR *, DWORD, DWORD, DWORD, STGOPTIONS *, void *, const IID &, void **); 
extern "C" __attribute((__stdcall__)) HRESULT BindMoniker(LPMONIKER, DWORD, const IID &, PVOID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetObject(LPCWSTR, BIND_OPTS *, const IID &, void **); 
extern "C" __attribute((__stdcall__)) HRESULT MkParseDisplayName(LPBC, LPCOLESTR, ULONG *, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT MonikerRelativePathTo(LPMONIKER, LPMONIKER, LPMONIKER *, BOOL); 
extern "C" __attribute((__stdcall__)) HRESULT MonikerCommonPrefixWith(LPMONIKER, LPMONIKER, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateBindCtx(DWORD, LPBC *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateGenericComposite(LPMONIKER, LPMONIKER, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT GetClassFile(LPCOLESTR, CLSID *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateFileMoniker(LPCOLESTR, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateItemMoniker(LPCOLESTR, LPCOLESTR, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateAntiMoniker(LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT CreatePointerMoniker(LPUNKNOWN, LPMONIKER *); 
extern "C" __attribute((__stdcall__)) HRESULT GetRunningObjectTable(DWORD, LPRUNNINGOBJECTTABLE *); 
extern "C" __attribute((__stdcall__)) HRESULT CoInitializeSecurity(PSECURITY_DESCRIPTOR, LONG, SOLE_AUTHENTICATION_SERVICE *, void *, DWORD, DWORD, void *, DWORD, void *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetCallContext(const IID &, void **); 
extern "C" __attribute((__stdcall__)) HRESULT CoQueryProxyBlanket(IUnknown *, DWORD *, DWORD *, OLECHAR **, DWORD *, DWORD *, RPC_AUTH_IDENTITY_HANDLE *, DWORD *); 
extern "C" __attribute((__stdcall__)) HRESULT CoSetProxyBlanket(IUnknown *, DWORD, DWORD, OLECHAR *, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD); 
extern "C" __attribute((__stdcall__)) HRESULT CoCopyProxy(IUnknown *, IUnknown **); 
extern "C" __attribute((__stdcall__)) HRESULT CoQueryClientBlanket(DWORD *, DWORD *, OLECHAR **, DWORD *, DWORD *, RPC_AUTHZ_HANDLE *, DWORD *); 
extern "C" __attribute((__stdcall__)) HRESULT CoImpersonateClient(); 
extern "C" __attribute((__stdcall__)) HRESULT CoRevertToSelf(); 
extern "C" __attribute((__stdcall__)) HRESULT CoQueryAuthenticationServices(DWORD *, SOLE_AUTHENTICATION_SERVICE **); 
extern "C" __attribute((__stdcall__)) HRESULT CoSwitchCallContext(IUnknown *, IUnknown **); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetInstanceFromFile(COSERVERINFO *, CLSID *, IUnknown *, DWORD, DWORD, OLECHAR *, DWORD, MULTI_QI *); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetInstanceFromIStorage(COSERVERINFO *, CLSID *, IUnknown *, DWORD, IStorage *, DWORD, MULTI_QI *); 
extern "C" __attribute((__stdcall__)) ULONG CoAddRefServerProcess(); 
extern "C" __attribute((__stdcall__)) ULONG CoReleaseServerProcess(); 
extern "C" __attribute((__stdcall__)) HRESULT CoResumeClassObjects(); 
extern "C" __attribute((__stdcall__)) HRESULT CoSuspendClassObjects(); 
extern "C" __attribute((__stdcall__)) HRESULT CoGetPSClsid(const IID &, CLSID *); 
extern "C" __attribute((__stdcall__)) HRESULT CoRegisterPSClsid(const IID &, const CLSID &); 

#pragma pack ( pop )
# 8 "d:\\mingw\\mingw\\include\\olectlid.h" 3
extern "C" {


extern const GUID IID_IDispatch; 
extern const GUID IID_IPropertyNotifySink; 
extern const GUID IID_IClassFactory2; 
extern const GUID IID_IProvideClassInfo; 
extern const GUID IID_IProvideClassInfo2; 
extern const GUID IID_IConnectionPointContainer; 
extern const GUID IID_IEnumConnectionPoints; 
extern const GUID IID_IConnectionPoint; 
extern const GUID IID_IEnumConnections; 
extern const GUID IID_IOleControl; 
extern const GUID IID_IOleControlSite; 
extern const GUID IID_ISimpleFrameSite; 
extern const GUID IID_IPersistStreamInit; 
extern const GUID IID_IPersistMemory; 
extern const GUID IID_IPersistPropertyBag; 
extern const GUID IID_IPropertyBag; 
extern const GUID IID_IErrorLog; 
extern const GUID IID_IPropertyFrame; 
extern const GUID IID_ISpecifyPropertyPages; 
extern const GUID IID_IPerPropertyBrowsing; 
extern const GUID IID_IPropertyPageSite; 
extern const GUID IID_IPropertyPage; 
extern const GUID IID_IPropertyPage2; 
extern const GUID CLSID_CFontPropPage; 
extern const GUID CLSID_CColorPropPage; 
extern const GUID CLSID_CPicturePropPage; 
extern const GUID CLSID_PersistPropset; 
extern const GUID CLSID_ConvertVBX; 
extern const GUID CLSID_StdFont; 
extern const GUID CLSID_StdPicture; 
extern const GUID IID_IFont; 
extern const GUID IID_IFontDisp; 
extern const GUID IID_IPicture; 
extern const GUID IID_IPictureDisp; 
extern const GUID GUID_HIMETRIC; 
extern const GUID GUID_COLOR; 
extern const GUID GUID_XPOSPIXEL; 
extern const GUID GUID_YPOSPIXEL; 
extern const GUID GUID_XSIZEPIXEL; 
extern const GUID GUID_YSIZEPIXEL; 
extern const GUID GUID_XPOS; 
extern const GUID GUID_YPOS; 
extern const GUID GUID_XSIZE; 
extern const GUID GUID_YSIZE; 
extern const GUID GUID_TRISTATE; 
extern const GUID GUID_OPTIONVALUEEXCLUSIVE; 
extern const GUID GUID_CHECKVALUEEXCLUSIVE; 
extern const GUID GUID_FONTNAME; 
extern const GUID GUID_FONTSIZE; 
extern const GUID GUID_FONTBOLD; 
extern const GUID GUID_FONTITALIC; 
extern const GUID GUID_FONTUNDERSCORE; 
extern const GUID GUID_FONTSTRIKETHROUGH; 
extern const GUID GUID_HANDLE; 
extern const GUID IID_IEnumUnknown; 
extern const GUID IID_IEnumString; 
extern const GUID IID_IEnumMoniker; 
extern const GUID IID_IEnumFORMATETC; 
extern const GUID IID_IEnumOLEVERB; 
extern const GUID IID_IEnumSTATDATA; 
extern const GUID IID_IEnumSTATSTG; 
extern const GUID IID_IEnumGeneric; 
extern const GUID IID_IEnumHolder; 
extern const GUID IID_IEnumCallback; 
extern const GUID IID_IPersistStream; 
extern const GUID IID_IPersistStorage; 
extern const GUID IID_IPersistFile; 
extern const GUID IID_IPersist; 
extern const GUID IID_IViewObject; 
extern const GUID IID_IDataObject; 
extern const GUID IID_IAdviseSink; 
extern const GUID IID_IDataAdviseHolder; 
extern const GUID IID_IOleAdviseHolder; 
extern const GUID IID_IOleObject; 
extern const GUID IID_IOleInPlaceObject; 
extern const GUID IID_IOleWindow; 
extern const GUID IID_IOleInPlaceUIWindow; 
extern const GUID IID_IOleInPlaceFrame; 
extern const GUID IID_IOleInPlaceActiveObject; 
extern const GUID IID_IOleClientSite; 
extern const GUID IID_IOleInPlaceSite; 
extern const GUID IID_IParseDisplayName; 
extern const GUID IID_IOleContainer; 
extern const GUID IID_IOleItemContainer; 
extern const GUID IID_IOleLink; 
extern const GUID IID_IOleCache; 
extern const GUID IID_IOleManager; 
extern const GUID IID_IOlePresObj; 
extern const GUID IID_IDropSource; 
extern const GUID IID_IDropTarget; 
extern const GUID IID_IDebug; 
extern const GUID IID_IDebugStream; 
extern const GUID IID_IAdviseSink2; 
extern const GUID IID_IRunnableObject; 
extern const GUID IID_IViewObject2; 
extern const GUID IID_IOleCache2; 
extern const GUID IID_IOleCacheControl; 
extern const GUID CLSID_Picture_Metafile; 
extern const GUID CLSID_Picture_Dib; 


}
# 7 "d:\\mingw\\mingw\\include\\oleauto.h" 3
#pragma pack ( push, 8 )
# 13 "d:\\mingw\\mingw\\include\\oaidl.h" 3
extern "C" {
# 66 "d:\\mingw\\mingw\\include\\oaidl.h" 3
typedef struct ITypeLib *LPTYPELIB; 
typedef struct ITypeLib2 *LPTYPELIB2; 
typedef struct ICreateTypeInfo *LPCREATETYPEINFO; 
typedef struct ICreateTypeInfo2 *LPCREATETYPEINFO2; 
typedef struct ICreateTypeLib *LPCREATETYPELIB; 
typedef struct ICreateTypeLib2 *LPCREATETYPELIB2; 
typedef struct ITypeComp *LPTYPECOMP; 
typedef struct ITypeInfo *LPTYPEINFO; 
typedef struct ITypeInfo2 *LPTYPEINFO2; 
typedef struct IErrorInfo *LPERRORINFO; 
typedef struct IDispatch *LPDISPATCH; 
typedef struct IEnumVARIANT *LPENUMVARIANT; 
typedef struct ICreateErrorInfo *LPCREATEERRORINFO; 
typedef struct ISupportErrorInfo *LPSUPPORTERRORINFO; 
typedef struct IRecordInfo *LPRECORDINFO; 

extern const IID IID_ITypeLib; 
extern const IID IID_ITypeLib2; 
extern const IID IID_ICreateTypeInfo; 
extern const IID IID_ICreateTypeInfo2; 
extern const IID IID_ICreateTypeLib; 
extern const IID IID_ICreateTypeLib2; 
extern const IID IID_ITypeInfo; 
extern const IID IID_ITypeInfo2; 
extern const IID IID_IErrorInfo; 
extern const IID IID_IDispatch; 
extern const IID IID_IEnumVARIANT; 
extern const IID IID_ICreateErrorInfo; 
extern const IID IID_ISupportErrorInfo; 
extern const IID IID_IRecordInfo; 
extern const IID IID_ITypeMarshal; 



typedef 
# 98
enum tagSYSKIND { 
SYS_WIN16, SYS_WIN32, SYS_MAC
} SYSKIND; 



typedef 
# 101
enum tagLIBFLAGS { 
LIBFLAG_FRESTRICTED = 1, LIBFLAG_FCONTROL, LIBFLAG_FHIDDEN = 4, 
LIBFLAG_FHASDISKIMAGE = 8
} LIBFLAGS; 
# 112
typedef 
# 105
struct tagTLIBATTR { 
GUID guid; 
LCID lcid; 
SYSKIND syskind; 
WORD wMajorVerNum; 
WORD wMinorVerNum; 
WORD wLibFlags; 
} TLIBATTR, *LPTLIBATTR; 
typedef CY CURRENCY; 



typedef 
# 114
struct tagSAFEARRAYBOUND { 
ULONG cElements; 
LONG lLbound; 
} SAFEARRAYBOUND, *LPSAFEARRAYBOUND; 




typedef 
# 118
struct _wireSAFEARR_BSTR { 

ULONG Size; 
wireBSTR *aBstr; 
} SAFEARR_BSTR; 



typedef 
# 123
struct _wireSAFEARR_UNKNOWN { 
ULONG Size; 
IUnknown **apUnknown; 
} SAFEARR_UNKNOWN; 



typedef 
# 127
struct _wireSAFEARR_DISPATCH { 
ULONG Size; 
LPDISPATCH *apDispatch; 
} SAFEARR_DISPATCH; 



typedef 
# 131
struct _wireSAFEARR_VARIANT { 
ULONG Size; 
struct _wireVARIANT *aVariant; 
} SAFEARR_VARIANT; 
# 145
typedef 
# 135
enum tagSF_TYPE { 
SF_ERROR = VT_ERROR, 
SF_I1 = VT_I1, 
SF_I2 = VT_I2, 
SF_I4, 
SF_I8 = VT_I8, 
SF_BSTR = VT_BSTR, 
SF_UNKNOWN = VT_UNKNOWN, 
SF_DISPATCH = VT_DISPATCH, 
SF_VARIANT = VT_VARIANT
} SF_TYPE; 
# 151
typedef 
# 146
struct _wireBRECORD { 
ULONG fFlags; 
ULONG clSize; 
LPRECORDINFO *pRecInfo; 
byte *pRecord; 
} *wireBRECORD; 



typedef 
# 152
struct _wireSAFEARR_BRECORD { 
ULONG Size; 
wireBRECORD *aRecord; 
} SAFEARR_BRECORD; 




typedef 
# 156
struct _wireSAFEARR_HAVEIID { 
ULONG Size; 
IUnknown **apUnknown; 
IID iid; 
} SAFEARR_HAVEIID; 
# 175
typedef 
# 161
struct _wireSAFEARRAY_UNION { 
ULONG sfType; 
union { 
SAFEARR_BSTR BstrStr; 
SAFEARR_UNKNOWN UnknownStr; 
SAFEARR_DISPATCH DispatchStr; 
SAFEARR_VARIANT VariantStr; 
SAFEARR_BRECORD RecordStr; 
SAFEARR_HAVEIID HaveIidStr; 
BYTE_SIZEDARR ByteStr; 
WORD_SIZEDARR WordStr; 
DWORD_SIZEDARR LongStr; 
HYPER_SIZEDARR HyperStr; 
} u; 
} SAFEARRAYUNION; 
# 183
typedef 
# 176
struct _wireSAFEARRAY { 
USHORT cDims; 
USHORT fFeatures; 
ULONG cbElements; 
ULONG cLocks; 
SAFEARRAYUNION uArrayStructs; 
SAFEARRAYBOUND rgsabound[1]; 
} *wireSAFEARRAY; 
typedef wireSAFEARRAY *wirePSAFEARRAY; 
# 192
typedef 
# 185
struct tagSAFEARRAY { 
USHORT cDims; 
USHORT fFeatures; 
ULONG cbElements; 
ULONG cLocks; 
PVOID pvData; 
SAFEARRAYBOUND rgsabound[1]; 
} SAFEARRAY, *LPSAFEARRAY; 
# 256
__extension__ typedef 
# 196
struct tagVARIANT { 
union { 
struct { 
VARTYPE vt; 
WORD wReserved1; 
WORD wReserved2; 
WORD wReserved3; 
union { 
long lVal; 
LONGLONG llVal; 
unsigned char bVal; 
short iVal; 
float fltVal; 
double dblVal; 
VARIANT_BOOL boolVal; 
SCODE scode; 
CY cyVal; 
DATE date; 
BSTR bstrVal; 
IUnknown *punkVal; 
LPDISPATCH pdispVal; 
SAFEARRAY *parray; 
unsigned char *pbVal; 
short *piVal; 
long *plVal; 
LONGLONG *pllVal; 
float *pfltVal; 
double *pdblVal; 
VARIANT_BOOL *pboolVal; 
_VARIANT_BOOL *pbool; 
SCODE *pscode; 
CY *pcyVal; 
DATE *pdate; 
BSTR *pbstrVal; 
IUnknown **ppunkVal; 
LPDISPATCH *ppdispVal; 
SAFEARRAY **pparray; 
tagVARIANT *pvarVal; 
void *byref; 
CHAR cVal; 
USHORT uiVal; 
ULONG ulVal; 
ULONGLONG ullVal; 
INT intVal; 
UINT uintVal; 
DECIMAL *pdecVal; 
CHAR *pcVal; 
USHORT *puiVal; 
ULONG *pulVal; 
ULONGLONG *pullVal; 
INT *pintVal; 
UINT *puintVal; 
struct { 
PVOID pvRecord; 
IRecordInfo *pRecInfo; 
}; 
}; 
}; 
DECIMAL decVal; 
}; 
} VARIANT, *LPVARIANT; 
typedef VARIANT VARIANTARG; 
typedef VARIANT *LPVARIANTARG; 
# 310
typedef 
# 259
struct _wireVARIANT { 
DWORD clSize; 
DWORD rpcReserved; 
USHORT vt; 
USHORT wReserved1; 
USHORT wReserved2; 
USHORT wReserved3; 
union { 
LONG lVal; 
LONGLONG llVal; 
BYTE bVal; 
SHORT iVal; 
FLOAT fltVal; 
DOUBLE dblVal; 
VARIANT_BOOL boolVal; 
SCODE scode; 
CY cyVal; 
DATE date; 
wireBSTR bstrVal; 
IUnknown *punkVal; 
LPDISPATCH pdispVal; 
wirePSAFEARRAY parray; 
wireBRECORD brecVal; 
BYTE *pbVal; 
SHORT *piVal; 
LONG *plVal; 
FLOAT *pfltVal; 
DOUBLE *pdblVal; 
VARIANT_BOOL *pboolVal; 
SCODE *pscode; 
CY *pcyVal; 
DATE *pdate; 
wireBSTR *pbstrVal; 
IUnknown **ppunkVal; 
LPDISPATCH *ppdispVal; 
wirePSAFEARRAY *pparray; 
_wireVARIANT *pvarVal; 
CHAR cVal; 
USHORT uiVal; 
ULONG ulVal; 
ULONGLONG ullVal; 
INT intVal; 
UINT uintVal; 
DECIMAL decVal; 
DECIMAL *pdecVal; 
CHAR *pcVal; 
USHORT *puiVal; 
ULONG *pulVal; 
INT *pintVal; 
UINT *puintVal; 
}; 
} *wireVARIANT; 
typedef LONG DISPID; 
typedef DISPID MEMBERID; 
typedef DWORD HREFTYPE; 



typedef 
# 314
enum tagTYPEKIND { 
TKIND_ENUM, TKIND_RECORD, TKIND_MODULE, TKIND_INTERFACE, TKIND_DISPATCH, 
TKIND_COCLASS, TKIND_ALIAS, TKIND_UNION, TKIND_MAX
} TYPEKIND; 
# 325
typedef 
# 318
struct tagTYPEDESC { 
union { 
tagTYPEDESC *lptdesc; 
struct tagARRAYDESC *lpadesc; 
HREFTYPE hreftype; 
}; 
VARTYPE vt; 
} TYPEDESC; 




typedef 
# 326
struct tagARRAYDESC { 
TYPEDESC tdescElem; 
USHORT cDims; 
SAFEARRAYBOUND rgbounds[1]; 
} ARRAYDESC; 



typedef 
# 331
struct tagPARAMDESCEX { 
ULONG cBytes; 
VARIANTARG varDefaultValue; 
} PARAMDESCEX, *LPPARAMDESCEX; 



typedef 
# 335
struct tagPARAMDESC { 
LPPARAMDESCEX pparamdescex; 
USHORT wParamFlags; 
} PARAMDESC, *LPPARAMDESC; 



typedef 
# 339
struct tagIDLDESC { 
ULONG dwReserved; 
USHORT wIDLFlags; 
} IDLDESC, *LPIDLDESC; 
# 349
typedef 
# 343
struct tagELEMDESC { 
TYPEDESC tdesc; 
union { 
IDLDESC idldesc; 
PARAMDESC paramdesc; 
}; 
} ELEMDESC, *LPELEMDESC; 
# 369
typedef 
# 350
struct tagTYPEATTR { 
GUID guid; 
LCID lcid; 
DWORD dwReserved; 
MEMBERID memidConstructor; 
MEMBERID memidDestructor; 
LPOLESTR lpstrSchema; 
ULONG cbSizeInstance; 
TYPEKIND typekind; 
WORD cFuncs; 
WORD cVars; 
WORD cImplTypes; 
WORD cbSizeVft; 
WORD cbAlignment; 
WORD wTypeFlags; 
WORD wMajorVerNum; 
WORD wMinorVerNum; 
TYPEDESC tdescAlias; 
IDLDESC idldescType; 
} TYPEATTR, *LPTYPEATTR; 
# 375
typedef 
# 370
struct tagDISPPARAMS { 
VARIANTARG *rgvarg; 
DISPID *rgdispidNamedArgs; 
UINT cArgs; 
UINT cNamedArgs; 
} DISPPARAMS; 
# 386
typedef 
# 376
struct tagEXCEPINFO { 
WORD wCode; 
WORD wReserved; 
BSTR bstrSource; 
BSTR bstrDescription; 
BSTR bstrHelpFile; 
DWORD dwHelpContext; 
PVOID pvReserved; 
HRESULT ( __attribute((__stdcall__))*pfnDeferredFillIn)(tagEXCEPINFO *) ; 
SCODE scode; 
} EXCEPINFO, *LPEXCEPINFO; 




typedef 
# 387
enum tagCALLCONV { 
CC_FASTCALL, CC_CDECL, CC_MSCPASCAL, CC_PASCAL = CC_MSCPASCAL, 
CC_MACPASCAL, CC_STDCALL, CC_FPFASTCALL, CC_SYSCALL, CC_MPWCDECL, 
CC_MPWPASCAL, CC_MAX = CC_MPWPASCAL
} CALLCONV; 



typedef 
# 392
enum tagFUNCKIND { 
FUNC_VIRTUAL, FUNC_PUREVIRTUAL, FUNC_NONVIRTUAL, 
FUNC_STATIC, FUNC_DISPATCH
} FUNCKIND; 



typedef 
# 396
enum tagINVOKEKIND { 
INVOKE_FUNC = 1, INVOKE_PROPERTYGET, INVOKE_PROPERTYPUT = 4, 
INVOKE_PROPERTYPUTREF = 8
} INVOKEKIND; 
# 413
typedef 
# 400
struct tagFUNCDESC { 
MEMBERID memid; 
SCODE *lprgscode; 
ELEMDESC *lprgelemdescParam; 
FUNCKIND funckind; 
INVOKEKIND invkind; 
CALLCONV callconv; 
SHORT cParams; 
SHORT cParamsOpt; 
SHORT oVft; 
SHORT cScodes; 
ELEMDESC elemdescFunc; 
WORD wFuncFlags; 
} FUNCDESC, *LPFUNCDESC; 


typedef 
# 414
enum tagVARKIND { 
VAR_PERINSTANCE, VAR_STATIC, VAR_CONST, VAR_DISPATCH
} VARKIND; 
# 427
typedef 
# 417
struct tagVARDESC { 
MEMBERID memid; 
LPOLESTR lpstrSchema; 
union { 
ULONG oInst; 
VARIANT *lpvarValue; 
}; 
ELEMDESC elemdescVar; 
WORD wVarFlags; 
VARKIND varkind; 
} VARDESC, *LPVARDESC; 
# 435
typedef 
# 428
enum tagTYPEFLAGS { 
TYPEFLAG_FAPPOBJECT = 1, TYPEFLAG_FCANCREATE, TYPEFLAG_FLICENSED = 4, 
TYPEFLAG_FPREDECLID = 8, TYPEFLAG_FHIDDEN = 16, TYPEFLAG_FCONTROL = 32, 
TYPEFLAG_FDUAL = 64, TYPEFLAG_FNONEXTENSIBLE = 128, 
TYPEFLAG_FOLEAUTOMATION = 256, TYPEFLAG_FRESTRICTED = 512, 
TYPEFLAG_FAGGREGATABLE = 1024, TYPEFLAG_FREPLACEABLE = 2048, 
TYPEFLAG_FDISPATCHABLE = 4096, TYPEFLAG_FREVERSEBIND = 8192
} TYPEFLAGS; 
# 442
typedef 
# 436
enum tagFUNCFLAGS { 
FUNCFLAG_FRESTRICTED = 1, FUNCFLAG_FSOURCE, FUNCFLAG_FBINDABLE = 4, 
FUNCFLAG_FREQUESTEDIT = 8, FUNCFLAG_FDISPLAYBIND = 16, FUNCFLAG_FDEFAULTBIND = 32, 
FUNCFLAG_FHIDDEN = 64, FUNCFLAG_FUSESGETLASTERROR = 128, FUNCFLAG_FDEFAULTCOLLELEM = 256, 
FUNCFLAG_FUIDEFAULT = 512, FUNCFLAG_FNONBROWSABLE = 1024, FUNCFLAG_FREPLACEABLE = 2048, 
FUNCFLAG_FIMMEDIATEBIND = 4096
} FUNCFLAGS; 
# 448
typedef 
# 443
enum tagVARFLAGS { 
VARFLAG_FREADONLY = 1, VARFLAG_FSOURCE, VARFLAG_FBINDABLE = 4, VARFLAG_FREQUESTEDIT = 8, 
VARFLAG_FDISPLAYBIND = 16, VARFLAG_FDEFAULTBIND = 32, VARFLAG_FHIDDEN = 64, VARFLAG_FRESTRICTED = 128, 
VARFLAG_FDEFAULTCOLLELEM = 256, VARFLAG_FUIDEFAULT = 512, VARFLAG_FNONBROWSABLE = 1024, 
VARFLAG_FREPLACEABLE = 2048, VARFLAG_FIMMEDIATEBIND = 4096
} VARFLAGS; 




typedef 
# 449
struct tagCLEANLOCALSTORAGE { 
IUnknown *pInterface; 
PVOID pStorage; 
DWORD flags; 
} CLEANLOCALSTORAGE; 



typedef 
# 454
struct tagCUSTDATAITEM { 
GUID guid; 
VARIANTARG varValue; 
} CUSTDATAITEM, *LPCUSTDATAITEM; 



typedef 
# 458
struct tagCUSTDATA { 
DWORD cCustData; 
LPCUSTDATAITEM prgCustData; 
} CUSTDATA, *LPCUSTDATA; 
# 468
typedef 
# 463
enum tagDESCKIND { 
DESCKIND_NONE, DESCKIND_FUNCDESC, 
DESCKIND_VARDESC, DESCKIND_TYPECOMP, 
DESCKIND_IMPLICITAPPOBJ, 
DESCKIND_MAX
} DESCKIND; 
# 474
typedef 
# 470
union tagBINDPTR { 
LPFUNCDESC lpfuncdesc; 
LPVARDESC lpvardesc; 
LPTYPECOMP lptcomp; 
} BINDPTR, *LPBINDPTR; 


struct IDispatch : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfoCount(UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfo(UINT, LCID, LPTYPEINFO *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetIDsOfNames(const IID &, LPOLESTR *, UINT, LCID, DISPID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Invoke(DISPID, const IID &, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) = 0; 
}; 
# 500 "d:\\mingw\\mingw\\include\\oaidl.h" 3
struct IEnumVARIANT : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Next(ULONG, VARIANT *, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; 
__attribute((__stdcall__)) virtual HRESULT Reset() = 0; 
__attribute((__stdcall__)) virtual HRESULT Clone(IEnumVARIANT **) = 0; 
}; 



struct ITypeComp : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Bind(LPOLESTR, ULONG, WORD, LPTYPEINFO *, DESCKIND *, LPBINDPTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT BindType(LPOLESTR, ULONG, LPTYPEINFO *, LPTYPECOMP *) = 0; 
}; 



struct ITypeInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeAttr(LPTYPEATTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeComp(LPTYPECOMP *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFuncDesc(UINT, LPFUNCDESC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetVarDesc(UINT, LPVARDESC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetNames(MEMBERID, BSTR *, UINT, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRefTypeOfImplType(UINT, HREFTYPE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetImplTypeFlags(UINT, INT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetIDsOfNames(LPOLESTR *, UINT, MEMBERID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Invoke(PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation(MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDllEntry(MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRefTypeInfo(HREFTYPE, LPTYPEINFO *) = 0; 
__attribute((__stdcall__)) virtual HRESULT AddressOfMember(MEMBERID, INVOKEKIND, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateInstance(LPUNKNOWN, const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMops(MEMBERID, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetContainingTypeLib(LPTYPELIB *, UINT *) = 0; 
__attribute((__stdcall__)) virtual void ReleaseTypeAttr(LPTYPEATTR) = 0; 
__attribute((__stdcall__)) virtual void ReleaseFuncDesc(LPFUNCDESC) = 0; 
__attribute((__stdcall__)) virtual void ReleaseVarDesc(LPVARDESC) = 0; 
}; 
# 577 "d:\\mingw\\mingw\\include\\oaidl.h" 3
struct ITypeInfo2 : public ITypeInfo { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeAttr(LPTYPEATTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeComp(LPTYPECOMP *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFuncDesc(UINT, LPFUNCDESC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetVarDesc(UINT, LPVARDESC *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetNames(MEMBERID, BSTR *, UINT, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRefTypeOfImplType(UINT, HREFTYPE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetImplTypeFlags(UINT, INT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetIDsOfNames(LPOLESTR *, UINT, MEMBERID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Invoke(PVOID, MEMBERID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation(MEMBERID, BSTR *, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDllEntry(MEMBERID, INVOKEKIND, BSTR *, BSTR *, WORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetRefTypeInfo(HREFTYPE, LPTYPEINFO *) = 0; 
__attribute((__stdcall__)) virtual HRESULT AddressOfMember(MEMBERID, INVOKEKIND, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT CreateInstance(LPUNKNOWN, const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMops(MEMBERID, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetContainingTypeLib(LPTYPELIB *, UINT *) = 0; 
__attribute((__stdcall__)) virtual void ReleaseTypeAttr(LPTYPEATTR) = 0; 
__attribute((__stdcall__)) virtual void ReleaseFuncDesc(LPFUNCDESC) = 0; 
__attribute((__stdcall__)) virtual void ReleaseVarDesc(LPVARDESC) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeKind(TYPEKIND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeFlags(ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFuncIndexOfMemId(MEMBERID, INVOKEKIND, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetVarIndexOfMemId(MEMBERID, UINT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetCustData(const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFuncCustData(UINT, const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetParamCustData(UINT, UINT, const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetVarCustData(UINT, const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetImplTypeCustData(UINT, const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation2(MEMBERID, LCID, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllCustData(CUSTDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllFuncCustData(UINT, CUSTDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllParamCustData(UINT, UINT, CUSTDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllVarCustData(UINT, CUSTDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllImplTypeCustData(UINT, CUSTDATA *) = 0; 
}; 



struct ITypeLib : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual UINT GetTypeInfoCount() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfo(UINT, ITypeInfo **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfoType(UINT, TYPEKIND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfoOfGuid(const GUID &, ITypeInfo **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetLibAttr(TLIBATTR **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeComp(ITypeComp **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation(INT, BSTR *, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsName(LPOLESTR, ULONG, BOOL *) = 0; 
__attribute((__stdcall__)) virtual HRESULT FindName(LPOLESTR, ULONG, ITypeInfo **, MEMBERID *, USHORT *) = 0; 
__attribute((__stdcall__)) virtual void ReleaseTLibAttr(TLIBATTR *) = 0; 
}; 



struct ITypeLib2 : public ITypeLib { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual UINT GetTypeInfoCount() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfo(UINT, ITypeInfo **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfoType(UINT, TYPEKIND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfoOfGuid(const GUID &, ITypeInfo **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetLibAttr(TLIBATTR **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeComp(ITypeComp **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation(INT, BSTR *, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsName(LPOLESTR, ULONG, BOOL *) = 0; 
__attribute((__stdcall__)) virtual HRESULT FindName(LPOLESTR, ULONG, ITypeInfo **, MEMBERID *, USHORT *) = 0; 
__attribute((__stdcall__)) virtual void ReleaseTLibAttr(TLIBATTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetCustData(const GUID &, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetLibStatistics(ULONG *, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDocumentation2(INT, LCID, BSTR *, DWORD *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAllCustData(CUSTDATA *) = 0; 
}; 


extern const IID IID_IErrorInfo; 

struct IErrorInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetGUID(GUID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetSource(BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetDescription(BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetHelpFile(BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetHelpContext(DWORD *) = 0; 
}; 
# 687 "d:\\mingw\\mingw\\include\\oaidl.h" 3
extern const IID IID_ICreateErrorInfo; 

struct ICreateErrorInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT SetGUID(const GUID &) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetSource(LPOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetDescription(LPOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetHelpFile(LPOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetHelpContext(DWORD) = 0; 
}; 


extern const IID IID_ISupportErrorInfo; 

struct ISupportErrorInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT InterfaceSupportsErrorInfo(const IID &) = 0; 
}; 


extern const IID IID_IRecordInfo; 

struct IRecordInfo : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT RecordInit(PVOID) = 0; 
__attribute((__stdcall__)) virtual HRESULT RecordClear(PVOID) = 0; 
__attribute((__stdcall__)) virtual HRESULT RecordCopy(PVOID, PVOID) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetGuid(GUID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetName(BSTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetSize(ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetTypeInfo(ITypeInfo **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetField(PVOID, LPCOLESTR, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFieldNoCopy(PVOID, LPCOLESTR, VARIANT *, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT PutField(ULONG, PVOID, LPCOLESTR, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT PutFieldNoCopy(ULONG, PVOID, LPCOLESTR, VARIANT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetFieldNames(ULONG *, BSTR *) = 0; 
__attribute((__stdcall__)) virtual BOOL IsMatchingType(IRecordInfo *) = 0; 
__attribute((__stdcall__)) virtual PVOID RecordCreate() = 0; 
__attribute((__stdcall__)) virtual HRESULT RecordCreateCopy(PVOID, PVOID *) = 0; 
__attribute((__stdcall__)) virtual HRESULT RecordDestroy(PVOID) = 0; 
}; 
# 761 "d:\\mingw\\mingw\\include\\oaidl.h" 3
extern const IID IID_ITypeMarshal; 

struct ITypeMarshal : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Size(PVOID, DWORD, PVOID, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Marshal(PVOID, DWORD, PVOID, ULONG, BYTE *, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unmarshal(PVOID, DWORD, ULONG, BYTE *, ULONG *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Free(PVOID) = 0; 
}; 



}
# 164 "d:\\mingw\\mingw\\include\\oleauto.h" 3
typedef 
# 160
enum tagREGKIND { 
REGKIND_DEFAULT, 
REGKIND_REGISTER, 
REGKIND_NONE
} REGKIND; 



typedef 
# 165
struct tagPARAMDATA { 
OLECHAR *szName; 
VARTYPE vt; 
} PARAMDATA, *LPPARAMDATA; 
# 178
typedef 
# 169
struct tagMETHODDATA { 
OLECHAR *szName; 
PARAMDATA *ppdata; 
DISPID dispid; 
UINT iMeth; 
CALLCONV cc; 
UINT cArgs; 
WORD wFlags; 
VARTYPE vtReturn; 
} METHODDATA, *LPMETHODDATA; 



typedef 
# 179
struct tagINTERFACEDATA { 
METHODDATA *pmethdata; 
UINT cMembers; 
} INTERFACEDATA, *LPINTERFACEDATA; 




typedef 
# 184
struct { 
SYSTEMTIME st; 
USHORT wDayOfYear; 
} UDATE; 
# 196
typedef 
# 189
struct { 
int cDig; 
unsigned long dwInFlags; 
unsigned long dwOutFlags; 
int cchUsed; 
int nBaseShift; 
int nPwr10; 
} NUMPARSE; 

extern "C" __attribute((__stdcall__)) BSTR SysAllocString(const OLECHAR *); 
extern "C" __attribute((__stdcall__)) int SysReAllocString(BSTR *, const OLECHAR *); 
extern "C" __attribute((__stdcall__)) BSTR SysAllocStringLen(const OLECHAR *, unsigned); 
extern "C" __attribute((__stdcall__)) int SysReAllocStringLen(BSTR *, const OLECHAR *, unsigned); 
extern "C" __attribute((__stdcall__)) void SysFreeString(BSTR); 
extern "C" __attribute((__stdcall__)) unsigned SysStringLen(BSTR); 
extern "C" __attribute((__stdcall__)) unsigned SysStringByteLen(BSTR); 
extern "C" __attribute((__stdcall__)) BSTR SysAllocStringByteLen(const char *, unsigned); 
extern "C" __attribute((__stdcall__)) int DosDateTimeToVariantTime(unsigned short, unsigned short, double *); 
extern "C" __attribute((__stdcall__)) int VariantTimeToDosDateTime(double, unsigned short *, unsigned short *); 
extern "C" __attribute((__stdcall__)) int VariantTimeToSystemTime(double, LPSYSTEMTIME); 
extern "C" __attribute((__stdcall__)) int SystemTimeToVariantTime(LPSYSTEMTIME, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUdate(UDATE *, ULONG, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUdateEx(UDATE *, LCID, ULONG, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUdateFromDate(DATE, ULONG, UDATE *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayAllocDescriptor(unsigned, SAFEARRAY **); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayAllocData(SAFEARRAY *); 
extern "C" SAFEARRAY *SafeArrayCreate(VARTYPE, unsigned, SAFEARRAYBOUND *) __attribute((__stdcall__)); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayDestroyDescriptor(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayDestroyData(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayDestroy(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayRedim(SAFEARRAY *, SAFEARRAYBOUND *); 
extern "C" __attribute((__stdcall__)) unsigned SafeArrayGetDim(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) unsigned SafeArrayGetElemsize(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetUBound(SAFEARRAY *, unsigned, long *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetLBound(SAFEARRAY *, unsigned, long *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayLock(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayUnlock(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayAccessData(SAFEARRAY *, void **); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayUnaccessData(SAFEARRAY *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetElement(SAFEARRAY *, long *, void *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayPutElement(SAFEARRAY *, long *, void *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayCopy(SAFEARRAY *, SAFEARRAY **); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayPtrOfIndex(SAFEARRAY *, long *, void **); 
extern "C" SAFEARRAY *SafeArrayCreateVector(VARTYPE, LONG, ULONG) __attribute((__stdcall__)); 
extern "C" SAFEARRAY *SafeArrayCreateVectorEx(VARTYPE, LONG, ULONG, LPVOID) __attribute((__stdcall__)); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayAllocDescriptorEx(VARTYPE, UINT, SAFEARRAY **); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetVartype(SAFEARRAY *, VARTYPE *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArraySetRecordInfo(SAFEARRAY *, IRecordInfo *); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetRecordInfo(SAFEARRAY *, IRecordInfo **); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArraySetIID(SAFEARRAY *, const GUID &); 
extern "C" __attribute((__stdcall__)) HRESULT SafeArrayGetIID(SAFEARRAY *, GUID *); 
extern "C" __attribute((__stdcall__)) void VariantInit(VARIANTARG *); 
extern "C" __attribute((__stdcall__)) HRESULT VariantClear(VARIANTARG *); 
extern "C" __attribute((__stdcall__)) HRESULT VariantCopy(VARIANTARG *, VARIANTARG *); 
extern "C" __attribute((__stdcall__)) HRESULT VariantCopyInd(VARIANT *, VARIANTARG *); 
extern "C" __attribute((__stdcall__)) HRESULT VariantChangeType(VARIANTARG *, VARIANTARG *, unsigned short, VARTYPE); 
extern "C" __attribute((__stdcall__)) HRESULT VariantChangeTypeEx(VARIANTARG *, VARIANTARG *, LCID, unsigned short, VARTYPE); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI2(short, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI4(long, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromR4(float, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromR8(double, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromCy(CY, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromDate(DATE, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromStr(OLECHAR *, LCID, unsigned long, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromDisp(LPDISPATCH, LCID, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromBool(VARIANT_BOOL, unsigned char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromUI1(unsigned char, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromI4(long, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromR4(float, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromR8(double, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromCy(CY cyIn, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromDate(DATE, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromStr(OLECHAR *, LCID, unsigned long, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromDisp(LPDISPATCH, LCID, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromBool(VARIANT_BOOL, short *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromUI1(unsigned char, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromI2(short, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromR4(float, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromR8(double, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromCy(CY, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromDate(DATE, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromStr(OLECHAR *, LCID, unsigned long, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromDisp(LPDISPATCH, LCID, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromBool(VARIANT_BOOL, long *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromUI1(unsigned char, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI2(short, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI4(long, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromR8(double, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromCy(CY, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromDate(DATE, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromStr(OLECHAR *, LCID, unsigned long, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromDisp(LPDISPATCH, LCID, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromBool(VARIANT_BOOL, float *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromUI1(unsigned char, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI2(short, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI4(long, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromR4(float, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromCy(CY, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDate(DATE, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromStr(OLECHAR *, LCID, unsigned long, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDisp(LPDISPATCH, LCID, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromBool(VARIANT_BOOL, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDec(DECIMAL *, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUI1(unsigned char, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI2(short, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI4(long, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromR4(float, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromR8(double, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromCy(CY, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromStr(OLECHAR *, LCID, unsigned long, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromDisp(LPDISPATCH, LCID, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromBool(VARIANT_BOOL, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromUI1(unsigned char, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI2(short, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI4(long, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromR4(float, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromR8(double, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromDate(DATE, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromStr(OLECHAR *, LCID, unsigned long, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromDisp(LPDISPATCH, LCID, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromBool(VARIANT_BOOL, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromUI1(unsigned char, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI2(short, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI4(long, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromR4(float, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromR8(double, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromCy(CY, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromDate(DATE, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromDisp(LPDISPATCH, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromBool(VARIANT_BOOL, LCID, unsigned long, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromUI1(unsigned char, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI2(short, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI4(long, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromR4(float, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromR8(double, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromDate(DATE, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromCy(CY, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromStr(OLECHAR *, LCID, unsigned long, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromDisp(LPDISPATCH, LCID, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromR8(double, DECIMAL *); 
extern "C" __attribute((__stdcall__)) ULONG LHashValOfNameSysA(SYSKIND, LCID, const char *); 
extern "C" __attribute((__stdcall__)) ULONG LHashValOfNameSys(SYSKIND, LCID, const OLECHAR *); 
extern "C" __attribute((__stdcall__)) HRESULT LoadTypeLib(const OLECHAR *, LPTYPELIB *); 
extern "C" __attribute((__stdcall__)) HRESULT LoadTypeLibEx(LPCOLESTR, REGKIND, LPTYPELIB *); 
extern "C" __attribute((__stdcall__)) HRESULT LoadRegTypeLib(const GUID &, WORD, WORD, LCID, LPTYPELIB *); 
extern "C" __attribute((__stdcall__)) HRESULT QueryPathOfRegTypeLib(const GUID &, unsigned short, unsigned short, LCID, LPBSTR); 
extern "C" __attribute((__stdcall__)) HRESULT RegisterTypeLib(LPTYPELIB, OLECHAR *, OLECHAR *); 
extern "C" __attribute((__stdcall__)) HRESULT UnRegisterTypeLib(const GUID &, WORD, WORD, LCID, SYSKIND); 
extern "C" __attribute((__stdcall__)) HRESULT CreateTypeLib(SYSKIND, const OLECHAR *, LPCREATETYPELIB *); 
extern "C" __attribute((__stdcall__)) HRESULT DispGetParam(DISPPARAMS *, UINT, VARTYPE, VARIANT *, UINT *); 
extern "C" __attribute((__stdcall__)) HRESULT DispGetIDsOfNames(LPTYPEINFO, OLECHAR **, UINT, DISPID *); 
extern "C" __attribute((__stdcall__)) HRESULT DispInvoke(void *, LPTYPEINFO, DISPID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateDispTypeInfo(INTERFACEDATA *, LCID, LPTYPEINFO *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateStdDispatch(IUnknown *, void *, LPTYPEINFO, IUnknown **); 
extern "C" __attribute((__stdcall__)) HRESULT RegisterActiveObject(IUnknown *, const CLSID &, DWORD, DWORD *); 
extern "C" __attribute((__stdcall__)) HRESULT RevokeActiveObject(DWORD, void *); 
extern "C" __attribute((__stdcall__)) HRESULT GetActiveObject(const CLSID &, void *, IUnknown **); 
extern "C" __attribute((__stdcall__)) HRESULT SetErrorInfo(unsigned long, LPERRORINFO); 
extern "C" __attribute((__stdcall__)) HRESULT GetErrorInfo(unsigned long, LPERRORINFO *); 
extern "C" __attribute((__stdcall__)) HRESULT CreateErrorInfo(LPCREATEERRORINFO *); 
extern "C" __attribute((__stdcall__)) unsigned long OaBuildVersion(); 
extern "C" __attribute((__stdcall__)) HRESULT VectorFromBstr(BSTR, SAFEARRAY **); 
extern "C" __attribute((__stdcall__)) HRESULT BstrFromVector(SAFEARRAY *, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarParseNumFromStr(OLECHAR *, LCID, ULONG, NUMPARSE *, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarNumFromParseNum(NUMPARSE *, BYTE *, ULONG, VARIANT *); 
extern "C" __attribute((__stdcall__)) HRESULT GetRecordInfoFromTypeInfo(ITypeInfo *, IRecordInfo **); 
extern "C" __attribute((__stdcall__)) HRESULT GetRecordInfoFromGuids(const GUID &, ULONG, ULONG, LCID, const GUID &, IRecordInfo **); 

extern "C" __attribute((__stdcall__)) HRESULT VarAdd(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarSub(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarMul(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarDiv(LPVARIANT, LPVARIANT, LPVARIANT); 

extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI2(SHORT, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI4(LONG, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI8(LONG64, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromR4(FLOAT, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromR8(DOUBLE, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromDate(DATE, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromBool(VARIANT_BOOL, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromI1(signed char, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromUI2(USHORT, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromUI4(ULONG, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromUI8(ULONG64, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromStr(OLECHAR *, LCID, ULONG, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromCy(CY, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromDec(DECIMAL *, BYTE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI1FromDisp(IDispatch *, LCID, BYTE *); 

extern "C" __attribute((__stdcall__)) HRESULT VarI2FromUI1(BYTE, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromI4(LONG, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromI8(LONG64, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromR4(FLOAT, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromR8(DOUBLE, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromDate(DATE, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromBool(VARIANT_BOOL, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromI1(signed char, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromUI2(USHORT, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromUI4(ULONG, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromUI8(ULONG64, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromStr(OLECHAR *, LCID, ULONG, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromCy(CY, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromDec(DECIMAL *, SHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI2FromDisp(IDispatch *, LCID, SHORT *); 

extern "C" __attribute((__stdcall__)) HRESULT VarI4FromUI1(BYTE, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromI2(SHORT, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromI8(LONG64, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromR4(FLOAT, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromR8(DOUBLE, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromDate(DATE, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromBool(VARIANT_BOOL, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromI1(signed char, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromUI2(USHORT, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromUI4(ULONG, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromUI8(ULONG64, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromStr(OLECHAR *, LCID, ULONG, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromCy(CY, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromDec(DECIMAL *, LONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI4FromDisp(IDispatch *, LCID, LONG *); 

extern "C" __attribute((__stdcall__)) HRESULT VarI8FromUI1(BYTE, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromI2(SHORT, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromI4(LONG, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromR4(FLOAT, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromR8(DOUBLE, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromDate(DATE, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromStr(OLECHAR *, LCID, ULONG, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromBool(VARIANT_BOOL, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromI1(signed char, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromUI2(USHORT, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromUI4(ULONG, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromUI8(ULONG64, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromDec(DECIMAL * pdecIn, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromInt(INT intIn, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromCy(CY, LONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI8FromDisp(IDispatch *, LCID, LONG64 *); 

extern "C" __attribute((__stdcall__)) HRESULT VarR4FromUI1(BYTE, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI2(SHORT, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI4(LONG, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI8(LONG64, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromR8(DOUBLE, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromDate(DATE, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromBool(VARIANT_BOOL, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromI1(signed char, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromUI2(USHORT, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromUI4(ULONG, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromUI8(ULONG64, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromStr(OLECHAR *, LCID, ULONG, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromCy(CY, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromDec(DECIMAL *, FLOAT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4FromDisp(IDispatch *, LCID, FLOAT *); 

extern "C" __attribute((__stdcall__)) HRESULT VarR8FromUI1(BYTE, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI2(SHORT, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI4(LONG, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI8(LONG64, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromR4(FLOAT, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDate(DATE, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromBool(VARIANT_BOOL, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromI1(signed char, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromUI2(USHORT, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromUI4(ULONG, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromUI8(ULONG64, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromStr(OLECHAR *, LCID, ULONG, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromCy(CY, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDec(DECIMAL *, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8FromDisp(IDispatch *, LCID, double *); 

extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUI1(BYTE, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI2(SHORT, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI4(LONG, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI8(LONG64, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromR4(FLOAT, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromR8(DOUBLE, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromStr(OLECHAR *, LCID, ULONG, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromI1(signed char, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUI2(USHORT, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUI4(ULONG, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromUI8(ULONG64, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromBool(VARIANT_BOOL, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromCy(CY, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromDec(DECIMAL *, DATE *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDateFromDisp(IDispatch *, LCID, DATE *); 

extern "C" __attribute((__stdcall__)) HRESULT VarCyFromUI1(BYTE, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI2(SHORT sIn, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI4(LONG, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI8(LONG64, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromR4(FLOAT, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromR8(DOUBLE, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromDate(DATE, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromStr(OLECHAR *, LCID, ULONG, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromBool(VARIANT_BOOL, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromI1(signed char, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromUI2(USHORT, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromUI4(ULONG, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromUI8(ULONG64, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromDec(DECIMAL *, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromStr(OLECHAR *, LCID, ULONG, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFromDisp(IDispatch *, LCID, CY *); 

extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromUI1(BYTE, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI2(SHORT, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI4(LONG, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI8(LONG64, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromR4(FLOAT, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromR8(DOUBLE, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromDate(DATE, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromBool(VARIANT_BOOL, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromI1(signed char, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromUI2(USHORT, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromUI8(ULONG64, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromUI4(ULONG, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromCy(CY, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromDec(DECIMAL *, LCID, ULONG, BSTR *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrFromDisp(IDispatch *, LCID, ULONG, BSTR *); 

extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromUI1(BYTE, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI2(SHORT, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI4(LONG, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI8(LONG64, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromR4(FLOAT, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromR8(DOUBLE, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromDate(DATE, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromStr(OLECHAR *, LCID, ULONG, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromI1(signed char, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromUI2(USHORT, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromUI4(ULONG, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromUI8(ULONG64, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromCy(CY, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromDec(DECIMAL *, VARIANT_BOOL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarBoolFromDisp(IDispatch *, LCID, VARIANT_BOOL *); 

extern "C" __attribute((__stdcall__)) HRESULT VarI1FromUI1(BYTE, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromI2(SHORT, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromI4(LONG, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromI8(LONG64, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromR4(FLOAT, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromR8(DOUBLE, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromDate(DATE, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromStr(OLECHAR *, LCID, ULONG, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromBool(VARIANT_BOOL, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromUI2(USHORT, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromUI4(ULONG, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromUI8(ULONG64, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromCy(CY, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromDec(DECIMAL *, signed char *); 
extern "C" __attribute((__stdcall__)) HRESULT VarI1FromDisp(IDispatch *, LCID, signed char *); 

extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromUI1(BYTE, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromI2(SHORT, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromI4(LONG, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromI8(LONG64, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromR4(FLOAT, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromR8(DOUBLE, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromDate(DATE, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromStr(OLECHAR *, LCID, ULONG, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromBool(VARIANT_BOOL, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromI1(signed char, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromUI4(ULONG, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromUI8(ULONG64, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromCy(CY, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromDec(DECIMAL *, USHORT *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI2FromDisp(IDispatch *, LCID, USHORT *); 

extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromStr(OLECHAR *, LCID, ULONG, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromUI1(BYTE, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromI2(SHORT, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromI4(LONG, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromI8(LONG64, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromR4(FLOAT, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromR8(DOUBLE, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromDate(DATE, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromBool(VARIANT_BOOL, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromI1(signed char, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromUI2(USHORT, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromUI8(ULONG64, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromCy(CY, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromDec(DECIMAL *, ULONG *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI4FromDisp(IDispatch *, LCID, ULONG *); 

extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromUI1(BYTE, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromI2(SHORT, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromI4(LONG, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromI8(LONG64, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromR4(FLOAT, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromR8(DOUBLE, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromDate(DATE, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromStr(OLECHAR *, LCID, ULONG, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromBool(VARIANT_BOOL, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromI1(signed char, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromUI2(USHORT, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromUI4(ULONG, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromDec(DECIMAL *, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromInt(INT, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromCy(CY, ULONG64 *); 
extern "C" __attribute((__stdcall__)) HRESULT VarUI8FromDisp(IDispatch *, LCID, ULONG64 *); 

extern "C" __attribute((__stdcall__)) HRESULT VarDecFromUI1(BYTE, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromI2(SHORT, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromI4(LONG, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromI8(LONG64, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromR4(FLOAT, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromR8(DOUBLE, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromDate(DATE, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromStr(OLECHAR *, LCID, ULONG, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromBool(VARIANT_BOOL, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromI1(signed char, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromUI2(USHORT, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromUI4(ULONG, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromUI8(ULONG64, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromCy(CY, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFromDisp(IDispatch *, LCID, DECIMAL *); 

extern "C" __attribute((__stdcall__)) HRESULT VarDecNeg(const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR4CmpR8(float, double); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8Pow(double, double, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarR8Round(double, int, double *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecAbs(const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecAdd(const DECIMAL *, const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecCmp(const DECIMAL *, const DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecCmpR8(const DECIMAL *, DOUBLE); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecDiv(const DECIMAL *, const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecFix(const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecInt(const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecMul(const DECIMAL *, const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecRound(const DECIMAL *, int, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarDecSub(const DECIMAL *, const DECIMAL *, DECIMAL *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyAbs(const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyAdd(const CY, const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyCmp(const CY, const CY); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyCmpR8(const CY, DOUBLE); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyFix(const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyInt(const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyMul(const CY, CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyMulI4(const CY, LONG, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyMulI8(const CY, LONG64, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyNeg(const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCyRound(const CY, INT, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarCySub(const CY, const CY, CY *); 
extern "C" __attribute((__stdcall__)) HRESULT VarAdd(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarAnd(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarCat(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarDiv(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarEqv(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarIdiv(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarImp(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarMod(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarMul(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarOr(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarPow(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarSub(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarXor(LPVARIANT, LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarAbs(LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarFix(LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarInt(LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarNeg(LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarNot(LPVARIANT, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarRound(LPVARIANT, int, LPVARIANT); 
extern "C" __attribute((__stdcall__)) HRESULT VarCmp(LPVARIANT, LPVARIANT, LCID, ULONG); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrCmp(BSTR, BSTR, LCID, ULONG); 
extern "C" __attribute((__stdcall__)) HRESULT VarBstrCat(BSTR, BSTR, BSTR *); 

#pragma pack ( pop )
# 14 "d:\\mingw\\mingw\\include\\ole2.h" 3
extern "C" {
# 8 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern "C" {
# 15
typedef struct IParseDisplayName *LPPARSEDISPLAYNAME; 
typedef struct IOleContainer *LPOLECONTAINER; 
typedef struct IOleClientSite *LPOLECLIENTSITE; 
typedef struct IOleObject *LPOLEOBJECT; 
typedef struct IDropTarget *LPDROPTARGET; 
typedef struct IDropSource *LPDROPSOURCE; 
typedef struct IEnumOleUndoUnits *LPENUMOLEUNDOUNITS; 
typedef struct IEnumOLEVERB *LPENUMOLEVERB; 
typedef struct IOleWindow *LPOLEWINDOW; 
typedef struct IOleInPlaceUIWindow *LPOLEINPLACEUIWINDOW; 
typedef struct IOleInPlaceActiveObject *LPOLEINPLACEACTIVEOBJECT; 
typedef struct IOleInPlaceFrame *LPOLEINPLACEFRAME; 
typedef struct IOleAdviseHolder *LPOLEADVISEHOLDER; 
typedef struct IViewObject *LPVIEWOBJECT; 
typedef struct IViewObject2 *LPVIEWOBJECT2; 
typedef struct IOleCache *LPOLECACHE; 
typedef struct IOleCache2 *LPOLECACHE2; 
typedef struct IOleCacheControl *LPOLECACHECONTROL; 
# 39
typedef 
# 34
enum tagBINDSPEED { 

BINDSPEED_INDEFINITE = 1, 
BINDSPEED_MODERATE, 
BINDSPEED_IMMEDIATE
} BINDSPEED; 




typedef 
# 40
enum tagOLEWHICHMK { 
OLEWHICHMK_CONTAINER = 1, 
OLEWHICHMK_OBJREL, 
OLEWHICHMK_OBJFULL
} OLEWHICHMK; 
# 50
typedef 
# 45
enum tagOLEGETMONIKER { 
OLEGETMONIKER_ONLYIFTHERE = 1, 
OLEGETMONIKER_FORCEASSIGN, 
OLEGETMONIKER_UNASSIGN, 
OLEGETMONIKER_TEMPFORUSER
} OLEGETMONIKER; 




typedef 
# 51
enum tagUSERCLASSTYPE { 
USERCLASSTYPE_FULL = 1, 
USERCLASSTYPE_SHORT, 
USERCLASSTYPE_APPNAME
} USERCLASSTYPE; 
# 66
__extension__ typedef 
# 60
enum tagDROPEFFECT { 
DROPEFFECT_NONE, 
DROPEFFECT_COPY, 
DROPEFFECT_MOVE, 
DROPEFFECT_LINK = 4U, 
DROPEFFECT_SCROLL = 0x80000000U
} DROPEFFECT; 


typedef 
# 67
struct tagOleMenuGroupWidths { 
LONG width[6]; 
} OLEMENUGROUPWIDTHS, *LPOLEMENUGROUPWIDTHS; 
typedef HGLOBAL HOLEMENU; 




typedef 
# 71
enum tagOLECLOSE { 
OLECLOSE_SAVEIFDIRTY, 
OLECLOSE_NOSAVE, 
OLECLOSE_PROMPTSAVE
} OLECLOSE; 
# 81
typedef 
# 76
struct tagOLEVERB { 
LONG lVerb; 
LPWSTR lpszVerbName; 
DWORD fuFlags; 
DWORD grfAttribs; 
} OLEVERB, *LPOLEVERB; 
typedef RECT BORDERWIDTHS; 
typedef LPRECT LPBORDERWIDTHS; 
typedef LPCRECT LPCBORDERWIDTHS; 
# 91
typedef 
# 85
struct tagOIFI { 
UINT cb; 
BOOL fMDIApp; 
HWND hwndFrame; 
HACCEL haccel; 
UINT cAccelEntries; 
} OLEINPLACEFRAMEINFO, *LPOLEINPLACEFRAMEINFO; 

struct IEnumOLEVERB : public IUnknown { __attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; __attribute((__stdcall__)) virtual ULONG AddRef() = 0; __attribute((__stdcall__)) virtual ULONG Release() = 0; __attribute((__stdcall__)) virtual HRESULT Next(ULONG, OLEVERB *, ULONG *) = 0; __attribute((__stdcall__)) virtual HRESULT Skip(ULONG) = 0; __attribute((__stdcall__)) virtual HRESULT Reset() = 0; __attribute((__stdcall__)) virtual HRESULT Clone(IEnumOLEVERB **) = 0; }; 
typedef IEnumOLEVERB IEnumOleVerb; 

extern const IID IID_IParseDisplayName; 

struct IParseDisplayName : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT ParseDisplayName(IBindCtx *, LPOLESTR, ULONG *, IMoniker **) = 0; 
}; 
# 114 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleContainer; 

struct IOleContainer : public IParseDisplayName { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT ParseDisplayName(IBindCtx *, LPOLESTR, ULONG *, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumObjects(DWORD, IEnumUnknown **) = 0; 
__attribute((__stdcall__)) virtual HRESULT LockContainer(BOOL) = 0; 
}; 


extern const IID IID_IOleItemContainer; 

struct IOleItemContainer : public IOleContainer { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT ParseDisplayName(IBindCtx *, LPOLESTR, ULONG *, IMoniker **) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumObjects(DWORD, IEnumUnknown **) = 0; 
__attribute((__stdcall__)) virtual HRESULT LockContainer(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetObjectA(LPOLESTR, DWORD, IBindCtx *, const IID &, void **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetObjectStorage(LPOLESTR, IBindCtx *, const IID &, void **) = 0; 
__attribute((__stdcall__)) virtual HRESULT IsRunning(LPOLESTR) = 0; 
}; 
# 155 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleClientSite; 

struct IOleClientSite : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT SaveObject() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMoniker(DWORD, DWORD, LPMONIKER *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetContainer(LPOLECONTAINER *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ShowObject() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnShowWindow(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT RequestNewObjectLayout() = 0; 
}; 
# 183 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleObject; 

struct IOleObject : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT SetClientSite(LPOLECLIENTSITE) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClientSite(LPOLECLIENTSITE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetHostNames(LPCOLESTR, LPCOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT Close(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetMoniker(DWORD, LPMONIKER) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMoniker(DWORD, DWORD, LPMONIKER *) = 0; 
__attribute((__stdcall__)) virtual HRESULT InitFromData(LPDATAOBJECT, BOOL, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetClipboardData(DWORD, LPDATAOBJECT *) = 0; 
__attribute((__stdcall__)) virtual HRESULT DoVerb(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumVerbs(LPENUMOLEVERB *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Update() = 0; 
__attribute((__stdcall__)) virtual HRESULT IsUpToDate() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetUserClassID(LPCLSID) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetUserType(DWORD, LPOLESTR *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetExtent(DWORD, SIZEL *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetExtent(DWORD, SIZEL *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Advise(LPADVISESINK, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unadvise(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumAdvise(LPENUMSTATDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetMiscStatus(DWORD, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetColorScheme(LPLOGPALETTE) = 0; 
}; 
# 241 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleWindow; 

struct IOleWindow : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
}; 
# 261 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleInPlaceUIWindow; 

struct IOleInPlaceUIWindow : public IOleWindow { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetBorder(LPRECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT RequestBorderSpace(LPCBORDERWIDTHS) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetBorderSpace(LPCBORDERWIDTHS) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetActiveObject(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR) = 0; 
}; 


extern const IID IID_IOleInPlaceObject; 

struct IOleInPlaceObject : public IOleWindow { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT InPlaceDeactivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT UIDeactivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT SetObjectRects(LPCRECT, LPCRECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT ReactivateAndUndo() = 0; 
}; 


extern const IID IID_IOleInPlaceActiveObject; 

struct IOleInPlaceActiveObject : public IOleWindow { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT TranslateAcceleratorA(LPMSG) = 0; 
__attribute((__stdcall__)) virtual HRESULT OnFrameWindowActivate(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT OnDocWindowActivate(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT ResizeBorder(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnableModeless(BOOL) = 0; 
}; 


extern const IID IID_IOleInPlaceFrame; 

struct IOleInPlaceFrame : public IOleInPlaceUIWindow { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetBorder(LPRECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT RequestBorderSpace(LPCBORDERWIDTHS) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetBorderSpace(LPCBORDERWIDTHS) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetActiveObject(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetMenu(HMENU, HOLEMENU, HWND) = 0; 
__attribute((__stdcall__)) virtual HRESULT RemoveMenus(HMENU) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetStatusText(LPCOLESTR) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnableModeless(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT TranslateAcceleratorA(LPMSG, WORD) = 0; 
}; 
# 350 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleInPlaceSite; 

struct IOleInPlaceSite : public IOleWindow { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindow(HWND *) = 0; 
__attribute((__stdcall__)) virtual HRESULT ContextSensitiveHelp(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT CanInPlaceActivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnInPlaceActivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnUIActivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT GetWindowContext(IOleInPlaceFrame **, IOleInPlaceUIWindow **, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO) = 0; 
__attribute((__stdcall__)) virtual HRESULT Scroll(SIZE) = 0; 
__attribute((__stdcall__)) virtual HRESULT OnUIDeactivate(BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT OnInPlaceDeactivate() = 0; 
__attribute((__stdcall__)) virtual HRESULT DiscardUndoState() = 0; 
__attribute((__stdcall__)) virtual HRESULT DeactivateAndUndo() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnPosRectChange(LPCRECT) = 0; 
}; 


extern const IID IID_IOleAdviseHolder; 

struct IOleAdviseHolder : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Advise(LPADVISESINK, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unadvise(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumAdvise(LPENUMSTATDATA *) = 0; 
__attribute((__stdcall__)) virtual HRESULT SendOnRename(LPMONIKER) = 0; 
__attribute((__stdcall__)) virtual HRESULT SendOnSave() = 0; 
__attribute((__stdcall__)) virtual HRESULT SendOnClose() = 0; 
}; 
# 400 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IDropSource; 

struct IDropSource : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT QueryContinueDrag(BOOL, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT GiveFeedback(DWORD) = 0; 
}; 
# 420 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IDropTarget; 

struct IDropTarget : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT DragEnter(LPDATAOBJECT, DWORD, POINTL, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT DragOver(DWORD, POINTL, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT DragLeave() = 0; 
__attribute((__stdcall__)) virtual HRESULT Drop(LPDATAOBJECT, DWORD, POINTL, PDWORD) = 0; 
}; 
# 444 "d:\\mingw\\mingw\\include\\oleidl.h" 3
typedef BOOL ( __attribute((__stdcall__))*__IView_pfncont)(DWORD) ; 
extern const IID IID_IViewObject; 

struct IViewObject : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Draw(DWORD, LONG, PVOID, DVTARGETDEVICE *, HDC, HDC, LPCRECTL, LPCRECTL, __IView_pfncont pfnContinue, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetColorSet(DWORD, LONG, PVOID, DVTARGETDEVICE *, HDC, LPLOGPALETTE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Freeze(DWORD, LONG, PVOID, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unfreeze(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetAdvise(DWORD, DWORD, IAdviseSink *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAdvise(PDWORD, PDWORD, IAdviseSink **) = 0; 
}; 
# 473 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IViewObject2; 

struct IViewObject2 : public IViewObject { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Draw(DWORD, LONG, PVOID, DVTARGETDEVICE *, HDC, HDC, LPCRECTL, LPCRECTL, __IView_pfncont pfnContinue, DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetColorSet(DWORD, LONG, PVOID, DVTARGETDEVICE *, HDC, LPLOGPALETTE *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Freeze(DWORD, LONG, PVOID, PDWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT Unfreeze(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetAdvise(DWORD, DWORD, IAdviseSink *) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetAdvise(PDWORD, PDWORD, IAdviseSink **) = 0; 
__attribute((__stdcall__)) virtual HRESULT GetExtent(DWORD, LONG, DVTARGETDEVICE *, LPSIZEL) = 0; 
}; 
# 503 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleCache; 

struct IOleCache : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Cache(FORMATETC *, DWORD, DWORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Uncache(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumCache(IEnumSTATDATA **); 
__attribute((__stdcall__)) virtual HRESULT InitCache(LPDATAOBJECT); 
__attribute((__stdcall__)) virtual HRESULT SetData(FORMATETC *, STGMEDIUM *, BOOL); 
}; 
# 529 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleCache2; 

struct IOleCache2 : public IOleCache { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT Cache(FORMATETC *, DWORD, DWORD *) = 0; 
__attribute((__stdcall__)) virtual HRESULT Uncache(DWORD) = 0; 
__attribute((__stdcall__)) virtual HRESULT EnumCache(IEnumSTATDATA **) = 0; 
__attribute((__stdcall__)) virtual HRESULT InitCache(LPDATAOBJECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT SetData(FORMATETC *, STGMEDIUM *, BOOL) = 0; 
__attribute((__stdcall__)) virtual HRESULT UpdateCache(LPDATAOBJECT, DWORD, LPVOID) = 0; 
__attribute((__stdcall__)) virtual HRESULT DiscardCache(DWORD) = 0; 
}; 
# 559 "d:\\mingw\\mingw\\include\\oleidl.h" 3
extern const IID IID_IOleCacheControl; 

struct IOleCacheControl : public IUnknown { 

__attribute((__stdcall__)) virtual HRESULT QueryInterface(const IID &, PVOID *) = 0; 
__attribute((__stdcall__)) virtual ULONG AddRef() = 0; 
__attribute((__stdcall__)) virtual ULONG Release() = 0; 
__attribute((__stdcall__)) virtual HRESULT OnRun(LPDATAOBJECT) = 0; 
__attribute((__stdcall__)) virtual HRESULT OnStop() = 0; 
}; 



}
# 31 "d:\\mingw\\mingw\\include\\ole2.h" 3
typedef struct _OLESTREAMVTBL *LPOLESTREAMVTBL; 


typedef 
# 32
struct _OLESTREAM { 
LPOLESTREAMVTBL lpstbl; 
} OLESTREAM, *LPOLESTREAM; 



typedef 
# 35
struct _OLESTREAMVTBL { 
DWORD ( __attribute((__stdcall__))*Get)(LPOLESTREAM, void *, DWORD) ; 
DWORD ( __attribute((__stdcall__))*Put)(LPOLESTREAM, const void *, DWORD) ; 
} OLESTREAMVTBL; 

__attribute((__stdcall__)) HRESULT CreateDataAdviseHolder(LPDATAADVISEHOLDER *); 
__attribute((__stdcall__)) DWORD OleBuildVersion(); 
__attribute((__stdcall__)) HRESULT ReadClassStg(LPSTORAGE, CLSID *); 
__attribute((__stdcall__)) HRESULT WriteClassStg(LPSTORAGE, const CLSID &); 
__attribute((__stdcall__)) HRESULT ReadClassStm(LPSTREAM, CLSID *); 
__attribute((__stdcall__)) HRESULT WriteClassStm(LPSTREAM, const CLSID &); 
__attribute((__stdcall__)) HRESULT WriteFmtUserTypeStg(LPSTORAGE, CLIPFORMAT, LPOLESTR); 
__attribute((__stdcall__)) HRESULT ReadFmtUserTypeStg(LPSTORAGE, CLIPFORMAT *, LPOLESTR *); 
__attribute((__stdcall__)) HRESULT OleInitialize(PVOID); 
__attribute((__stdcall__)) void OleUninitialize(); 
__attribute((__stdcall__)) HRESULT OleQueryLinkFromData(LPDATAOBJECT); 
__attribute((__stdcall__)) HRESULT OleQueryCreateFromData(LPDATAOBJECT); 
__attribute((__stdcall__)) HRESULT OleCreate(const CLSID &, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateFromData(LPDATAOBJECT, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateLinkFromData(LPDATAOBJECT, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateStaticFromData(LPDATAOBJECT, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateLink(LPMONIKER, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateLinkToFile(LPCOLESTR, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateFromFile(const CLSID &, LPCOLESTR, const IID &, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleLoad(LPSTORAGE, const IID &, LPOLECLIENTSITE, PVOID *); 
__attribute((__stdcall__)) HRESULT OleSave(LPPERSISTSTORAGE, LPSTORAGE, BOOL); 
__attribute((__stdcall__)) HRESULT OleLoadFromStream(LPSTREAM, const IID &, PVOID *); 
__attribute((__stdcall__)) HRESULT OleSaveToStream(LPPERSISTSTREAM, LPSTREAM); 
__attribute((__stdcall__)) HRESULT OleSetContainedObject(LPUNKNOWN, BOOL); 
__attribute((__stdcall__)) HRESULT OleNoteObjectVisible(LPUNKNOWN, BOOL); 
__attribute((__stdcall__)) HRESULT RegisterDragDrop(HWND, LPDROPTARGET); 
__attribute((__stdcall__)) HRESULT RevokeDragDrop(HWND); 
__attribute((__stdcall__)) HRESULT DoDragDrop(LPDATAOBJECT, LPDROPSOURCE, DWORD, PDWORD); 
__attribute((__stdcall__)) HRESULT OleSetClipboard(LPDATAOBJECT); 
__attribute((__stdcall__)) HRESULT OleGetClipboard(LPDATAOBJECT *); 
__attribute((__stdcall__)) HRESULT OleFlushClipboard(); 
__attribute((__stdcall__)) HRESULT OleIsCurrentClipboard(LPDATAOBJECT); 
__attribute((__stdcall__)) HOLEMENU OleCreateMenuDescriptor(HMENU, LPOLEMENUGROUPWIDTHS); 
__attribute((__stdcall__)) HRESULT OleSetMenuDescriptor(HOLEMENU, HWND, HWND, LPOLEINPLACEFRAME, LPOLEINPLACEACTIVEOBJECT); 
__attribute((__stdcall__)) HRESULT OleDestroyMenuDescriptor(HOLEMENU); 
__attribute((__stdcall__)) HRESULT OleTranslateAccelerator(LPOLEINPLACEFRAME, LPOLEINPLACEFRAMEINFO, LPMSG); 
__attribute((__stdcall__)) HANDLE OleDuplicateData(HANDLE, CLIPFORMAT, UINT); 
__attribute((__stdcall__)) HRESULT OleDraw(LPUNKNOWN, DWORD, HDC, LPCRECT); 
__attribute((__stdcall__)) HRESULT OleRun(LPUNKNOWN); 
__attribute((__stdcall__)) BOOL OleIsRunning(LPOLEOBJECT); 
__attribute((__stdcall__)) HRESULT OleLockRunning(LPUNKNOWN, BOOL, BOOL); 
__attribute((__stdcall__)) void ReleaseStgMedium(LPSTGMEDIUM); 
__attribute((__stdcall__)) HRESULT CreateOleAdviseHolder(LPOLEADVISEHOLDER *); 
__attribute((__stdcall__)) HRESULT OleCreateDefaultHandler(const CLSID &, LPUNKNOWN, const IID &, PVOID *); 
__attribute((__stdcall__)) HRESULT OleCreateEmbeddingHelper(const CLSID &, LPUNKNOWN, DWORD, LPCLASSFACTORY, const IID &, PVOID *); 
__attribute((__stdcall__)) BOOL IsAccelerator(HACCEL, int, LPMSG, WORD *); 
__attribute((__stdcall__)) HGLOBAL OleGetIconOfFile(LPOLESTR, BOOL); 
__attribute((__stdcall__)) HGLOBAL OleGetIconOfClass(const CLSID &, LPOLESTR, BOOL); 
__attribute((__stdcall__)) HGLOBAL OleMetafilePictFromIconAndLabel(HICON, LPOLESTR, LPOLESTR, UINT); 
__attribute((__stdcall__)) HRESULT OleRegGetUserType(const CLSID &, DWORD, LPOLESTR *); 
__attribute((__stdcall__)) HRESULT OleRegGetMiscStatus(const CLSID &, DWORD, DWORD *); 
__attribute((__stdcall__)) HRESULT OleRegEnumFormatEtc(const CLSID &, DWORD, LPENUMFORMATETC *); 
__attribute((__stdcall__)) HRESULT OleRegEnumVerbs(const CLSID &, LPENUMOLEVERB *); 
__attribute((__stdcall__)) HRESULT OleConvertOLESTREAMToIStorage(LPOLESTREAM, LPSTORAGE, const DVTARGETDEVICE *); 
__attribute((__stdcall__)) HRESULT OleConvertIStorageToOLESTREAM(LPSTORAGE, LPOLESTREAM); 
__attribute((__stdcall__)) HRESULT GetHGlobalFromILockBytes(LPLOCKBYTES, HGLOBAL *); 
__attribute((__stdcall__)) HRESULT CreateILockBytesOnHGlobal(HGLOBAL, BOOL, LPLOCKBYTES *); 
__attribute((__stdcall__)) HRESULT GetHGlobalFromStream(LPSTREAM, HGLOBAL *); 
__attribute((__stdcall__)) HRESULT CreateStreamOnHGlobal(HGLOBAL, BOOL, LPSTREAM *); 
__attribute((__stdcall__)) HRESULT OleDoAutoConvert(LPSTORAGE, LPCLSID); 
__attribute((__stdcall__)) HRESULT OleGetAutoConvert(const CLSID &, LPCLSID); 
__attribute((__stdcall__)) HRESULT OleSetAutoConvert(const CLSID &, const CLSID &); 
__attribute((__stdcall__)) HRESULT GetConvertStg(LPSTORAGE); 
__attribute((__stdcall__)) HRESULT SetConvertStg(LPSTORAGE, BOOL); 
__attribute((__stdcall__)) HRESULT OleConvertIStorageToOLESTREAMEx(LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM); 
__attribute((__stdcall__)) HRESULT OleConvertOLESTREAMToIStorageEx(LPOLESTREAM, LPSTORAGE, CLIPFORMAT *, LONG *, LONG *, DWORD *, LPSTGMEDIUM); 

}

#pragma pack ( pop )
# 65 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
namespace testing { 
# 72
__attribute((visibility("default"))) extern bool FLAGS_gtest_death_test_use_fork; 

namespace internal { 



__attribute((visibility("default"))) extern const TypeId kTestTypeIdInGoogleTest; 


const char kAlsoRunDisabledTestsFlag[] = "also_run_disabled_tests"; 
const char kBreakOnFailureFlag[] = "break_on_failure"; 
const char kCatchExceptionsFlag[] = "catch_exceptions"; 
const char kColorFlag[] = "color"; 
const char kFilterFlag[] = "filter"; 
const char kListTestsFlag[] = "list_tests"; 
const char kOutputFlag[] = "output"; 
const char kPrintTimeFlag[] = "print_time"; 
const char kPrintUTF8Flag[] = "print_utf8"; 
const char kRandomSeedFlag[] = "random_seed"; 
const char kRepeatFlag[] = "repeat"; 
const char kShuffleFlag[] = "shuffle"; 
const char kStackTraceDepthFlag[] = "stack_trace_depth"; 
const char kStreamResultToFlag[] = "stream_result_to"; 
const char kThrowOnFailureFlag[] = "throw_on_failure"; 
const char kFlagfileFlag[] = "flagfile"; 


const int kMaxRandomSeed = 99999; 



__attribute((visibility("default"))) extern bool g_help_flag; 


__attribute((visibility("default"))) TimeInMillis GetTimeInMillis(); 


__attribute((visibility("default"))) bool ShouldUseColor(bool stdout_is_tty); 


__attribute((visibility("default"))) std::string FormatTimeInMillisAsSeconds(TimeInMillis ms); 
# 118
__attribute((visibility("default"))) std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms); 
# 124
__attribute((visibility("default"))) bool ParseInt32Flag(const char * str, const char * flag, Int32 * value); 




inline int GetRandomSeedFromFlag(Int32 random_seed_flag) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(274 + 0 + 1U - 1);
const unsigned raw_seed = (random_seed_flag == 0) ? static_cast< unsigned>(GetTimeInMillis()) : (static_cast< unsigned>(random_seed_flag)); cpptestFastCoverageStmt(274 + 0 + 2U - 1);
# 136
const int normalized_seed = static_cast< int>((raw_seed - 1U) % static_cast< unsigned>(kMaxRandomSeed)) + 1; cpptestFastCoverageStmt(274 + 0 + 3U - 1);


return normalized_seed; 
} 




inline int GetNextRandomSeed(int seed) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(277 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(277 + 0 + 2U - 1), ::testing::internal::IsTrue(1 <= seed && seed <= kMaxRandomSeed))) {cpptestFastCoverageStmt(277 + 0 + 3U - 1);; } else {cpptestFastCoverageStmt(277 + 0 + 4U - 1);((((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" "", 146).GetStream() << ("Condition 1 <= seed && seed <= kMaxRandomSeed failed. ")) << ("Invalid random seed ")) << seed) << (" - must be in [1, ")) << kMaxRandomSeed) << ("].")); }  }  cpptestFastCoverageStmt(277 + 0 + 5U - 1);


const int next_seed = seed + 1; cpptestFastCoverageStmt(277 + 0 + 6U - 1);
return (next_seed > kMaxRandomSeed) ? 1 : next_seed; 
} 



class GTestFlagSaver { 


public: GTestFlagSaver() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(283 + 0 + 1U - 1);
also_run_disabled_tests_ = FLAGS_gtest_also_run_disabled_tests; cpptestFastCoverageStmt(283 + 0 + 2U - 1);
break_on_failure_ = FLAGS_gtest_break_on_failure; cpptestFastCoverageStmt(283 + 0 + 3U - 1);
catch_exceptions_ = FLAGS_gtest_catch_exceptions; cpptestFastCoverageStmt(283 + 0 + 4U - 1);
(color_ = FLAGS_gtest_color); cpptestFastCoverageStmt(283 + 0 + 5U - 1);
(death_test_style_ = FLAGS_gtest_death_test_style); cpptestFastCoverageStmt(283 + 0 + 6U - 1);
death_test_use_fork_ = FLAGS_gtest_death_test_use_fork; cpptestFastCoverageStmt(283 + 0 + 7U - 1);
(filter_ = FLAGS_gtest_filter); cpptestFastCoverageStmt(283 + 0 + 8U - 1);
(internal_run_death_test_ = FLAGS_gtest_internal_run_death_test); cpptestFastCoverageStmt(283 + 0 + 9U - 1);
list_tests_ = FLAGS_gtest_list_tests; cpptestFastCoverageStmt(283 + 0 + 10U - 1);
(output_ = FLAGS_gtest_output); cpptestFastCoverageStmt(283 + 0 + 11U - 1);
print_time_ = FLAGS_gtest_print_time; cpptestFastCoverageStmt(283 + 0 + 12U - 1);
print_utf8_ = FLAGS_gtest_print_utf8; cpptestFastCoverageStmt(283 + 0 + 13U - 1);
random_seed_ = FLAGS_gtest_random_seed; cpptestFastCoverageStmt(283 + 0 + 14U - 1);
repeat_ = FLAGS_gtest_repeat; cpptestFastCoverageStmt(283 + 0 + 15U - 1);
shuffle_ = FLAGS_gtest_shuffle; cpptestFastCoverageStmt(283 + 0 + 16U - 1);
stack_trace_depth_ = FLAGS_gtest_stack_trace_depth; cpptestFastCoverageStmt(283 + 0 + 17U - 1);
(stream_result_to_ = FLAGS_gtest_stream_result_to); cpptestFastCoverageStmt(283 + 0 + 18U - 1);
throw_on_failure_ = FLAGS_gtest_throw_on_failure; 
} 


~GTestFlagSaver() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(301 + 0 + 1U - 1);
FLAGS_gtest_also_run_disabled_tests = also_run_disabled_tests_; cpptestFastCoverageStmt(301 + 0 + 2U - 1);
FLAGS_gtest_break_on_failure = break_on_failure_; cpptestFastCoverageStmt(301 + 0 + 3U - 1);
FLAGS_gtest_catch_exceptions = catch_exceptions_; cpptestFastCoverageStmt(301 + 0 + 4U - 1);
(FLAGS_gtest_color = color_); cpptestFastCoverageStmt(301 + 0 + 5U - 1);
(FLAGS_gtest_death_test_style = death_test_style_); cpptestFastCoverageStmt(301 + 0 + 6U - 1);
FLAGS_gtest_death_test_use_fork = death_test_use_fork_; cpptestFastCoverageStmt(301 + 0 + 7U - 1);
(FLAGS_gtest_filter = filter_); cpptestFastCoverageStmt(301 + 0 + 8U - 1);
(FLAGS_gtest_internal_run_death_test = internal_run_death_test_); cpptestFastCoverageStmt(301 + 0 + 9U - 1);
FLAGS_gtest_list_tests = list_tests_; cpptestFastCoverageStmt(301 + 0 + 10U - 1);
(FLAGS_gtest_output = output_); cpptestFastCoverageStmt(301 + 0 + 11U - 1);
FLAGS_gtest_print_time = print_time_; cpptestFastCoverageStmt(301 + 0 + 12U - 1);
FLAGS_gtest_print_utf8 = print_utf8_; cpptestFastCoverageStmt(301 + 0 + 13U - 1);
FLAGS_gtest_random_seed = random_seed_; cpptestFastCoverageStmt(301 + 0 + 14U - 1);
FLAGS_gtest_repeat = repeat_; cpptestFastCoverageStmt(301 + 0 + 15U - 1);
FLAGS_gtest_shuffle = shuffle_; cpptestFastCoverageStmt(301 + 0 + 16U - 1);
FLAGS_gtest_stack_trace_depth = stack_trace_depth_; cpptestFastCoverageStmt(301 + 0 + 17U - 1);
(FLAGS_gtest_stream_result_to = stream_result_to_); cpptestFastCoverageStmt(301 + 0 + 18U - 1);
FLAGS_gtest_throw_on_failure = throw_on_failure_; 
} 



private: bool also_run_disabled_tests_; 
bool break_on_failure_; 
bool catch_exceptions_; 
std::string color_; 
std::string death_test_style_; 
bool death_test_use_fork_; 
std::string filter_; 
std::string internal_run_death_test_; 
bool list_tests_; 
std::string output_; 
bool print_time_; 
bool print_utf8_; 
Int32 random_seed_; 
Int32 repeat_; 
bool shuffle_; 
Int32 stack_trace_depth_; 
std::string stream_result_to_; 
bool throw_on_failure_; 
} __attribute((unused)); 
# 229
__attribute((visibility("default"))) std::string CodePointToUtf8(UInt32 code_point); 
# 244 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
__attribute((visibility("default"))) std::string WideStringToUtf8(const wchar_t * str, int num_chars); 
# 250
void WriteToShardStatusFileIfNeeded(); 
# 258
__attribute((visibility("default"))) bool ShouldShard(const char * total_shards_str, const char * shard_index_str, bool in_subprocess_for_death_test); 
# 265
__attribute((visibility("default"))) Int32 Int32FromEnvOrDie(const char * env_var, Int32 default_val); 
# 271
__attribute((visibility("default"))) bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id); 
# 278
template < class Container , typename Predicate > 
inline int CountIf (const Container & c , Predicate predicate) { 


int count = 0 ; 
for (typename Container :: const_iterator it = c . begin () ; it != c . end () ; ++ it) { 
if (predicate (* it)) 
++ count ; 
} 
return count ; 
} 


template < class Container , typename Functor > 
void ForEach (const Container & c , Functor functor) { 
std :: for_each (c . begin () , c . end () , functor) ; 
} 



template < typename E > 
inline E GetElementOr (const std :: vector < E > & v , int i , E default_value) { 
return (i < 0 || i >= static_cast < int > (v . size ())) ? default_value : v [ i ] ; 
} 
# 307
template < typename E > 
void ShuffleRange (internal :: Random * random , int begin , int end , 
std :: vector < E > * v) { 
const int size = static_cast < int > (v -> size ()) ; 
switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (0 <= begin && begin <= size)) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" , 311) . GetStream () << "Condition " "0 <= begin && begin <= size" " failed. " 
<< "Invalid shuffle range start " << begin << ": must be in range [0, " 
<< size << "]." ; 
switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (begin <= end && end <= size)) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" , 314) . GetStream () << "Condition " "begin <= end && end <= size" " failed. " 
<< "Invalid shuffle range finish " << end << ": must be in range [" 
<< begin << ", " << size << "]." ; 



for (int range_width = end - begin ; range_width >= 2 ; range_width --) { 
const int last_in_range = begin + range_width - 1 ; 
const int selected = begin + random -> Generate (range_width) ; 
std :: swap ((* v) [ selected ] , (* v) [ last_in_range ]) ; 
} 
} 


template < typename E > 
inline void Shuffle (internal :: Random * random , std :: vector < E > * v) { 
ShuffleRange (random , 0 , static_cast < int > (v -> size ()) , v) ; 
} 



template < typename T > 
static void Delete (T * x) { 
delete x ; 
} 




class TestPropertyKeyIs { 




public: explicit TestPropertyKeyIs(const std::string &key) : key_(key) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(319 + 0 + 1U - 1);} 


bool operator()(const TestProperty &test_property) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(320 + 0 + 1U - 1);
return (test_property.key() == key_); 
} 


private: std::string key_; 
}; 
# 369 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
class __attribute((visibility("default"))) UnitTestOptions { 




public: static std::string GetOutputFormat(); 




static std::string GetAbsolutePathToOutputFile(); 
# 388 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
static bool PatternMatchesString(const char * pattern, const char * str); 



static bool FilterMatchesTest(const std::string & test_case_name, const std::string & test_name); 
# 401
static int GTestShouldProcessSEH(DWORD exception_code); 




static bool MatchesFilter(const std::string & name, const char * filter); 
}; 



__attribute((visibility("default"))) FilePath GetCurrentExecutableName(); 


class OsStackTraceGetterInterface { 

public: OsStackTraceGetterInterface() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(321 + 0 + 1U - 1);} 
virtual ~OsStackTraceGetterInterface() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(322 + 0 + 1U - 1);} 
# 425
virtual std::string CurrentStackTrace(int max_depth, int skip_count) = 0; 




virtual void UponLeavingGTest() = 0; 



static const char *const kElidedFramesMarker; 


private: OsStackTraceGetterInterface(const OsStackTraceGetterInterface &) = delete;void operator=(const OsStackTraceGetterInterface &) = delete;
}; 


class OsStackTraceGetter : public OsStackTraceGetterInterface { 

public: OsStackTraceGetter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(323 + 0 + 1U - 1);} 

virtual std::string CurrentStackTrace(int max_depth, int skip_count); 
virtual void UponLeavingGTest(); 
# 459 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
private: OsStackTraceGetter(const OsStackTraceGetter &) = delete;void operator=(const OsStackTraceGetter &) = delete;
}; 


struct TraceInfo { 
const char *file; 
int line; 
std::string message; 
}; 



class DefaultGlobalTestPartResultReporter : public TestPartResultReporterInterface { 


public: explicit DefaultGlobalTestPartResultReporter(UnitTestImpl * unit_test); 


virtual void ReportTestPartResult(const TestPartResult & result); 


private: UnitTestImpl *const unit_test_; 

DefaultGlobalTestPartResultReporter(const DefaultGlobalTestPartResultReporter &) = delete;void operator=(const DefaultGlobalTestPartResultReporter &) = delete;
}; 



class DefaultPerThreadTestPartResultReporter : public TestPartResultReporterInterface { 


public: explicit DefaultPerThreadTestPartResultReporter(UnitTestImpl * unit_test); 


virtual void ReportTestPartResult(const TestPartResult & result); 


private: UnitTestImpl *const unit_test_; 

DefaultPerThreadTestPartResultReporter(const DefaultPerThreadTestPartResultReporter &) = delete;void operator=(const DefaultPerThreadTestPartResultReporter &) = delete;
}; 
# 505
class __attribute((visibility("default"))) UnitTestImpl { 

public: explicit UnitTestImpl(UnitTest * parent); 
virtual ~UnitTestImpl(); 
# 518 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
TestPartResultReporterInterface *GetGlobalTestPartResultReporter(); 


void SetGlobalTestPartResultReporter(TestPartResultReporterInterface * reporter); 



TestPartResultReporterInterface *GetTestPartResultReporterForCurrentThread(); 


void SetTestPartResultReporterForCurrentThread(TestPartResultReporterInterface * reporter); 



int successful_test_case_count() const; 


int failed_test_case_count() const; 


int total_test_case_count() const; 



int test_case_to_run_count() const; 


int successful_test_count() const; 


int skipped_test_count() const; 


int failed_test_count() const; 


int reportable_disabled_test_count() const; 


int disabled_test_count() const; 


int reportable_test_count() const; 


int total_test_count() const; 


int test_to_run_count() const; 



TimeInMillis start_timestamp() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(324 + 0 + 1U - 1);return start_timestamp_; } 


TimeInMillis elapsed_time() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(325 + 0 + 1U - 1);return elapsed_time_; } 


bool Passed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(326 + 0 + 1U - 1);return !this->Failed(); } 



bool Failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(327 + 0 + 1U - 1);
return this->failed_test_case_count() > 0 || this->ad_hoc_test_result()->Failed(); 
} 



const TestCase *GetTestCase(int i) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(328 + 0 + 1U - 1);
const int index = GetElementOr(test_case_indices_, i, -1); cpptestFastCoverageStmt(328 + 0 + 2U - 1);
return (index < 0) ? nullptr : test_cases_[i]; 
} 



TestCase *GetMutableTestCase(int i) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(330 + 0 + 1U - 1);
const int index = GetElementOr(test_case_indices_, i, -1); cpptestFastCoverageStmt(330 + 0 + 2U - 1);
return (index < 0) ? nullptr : test_cases_[index]; 
} 


TestEventListeners *listeners() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(332 + 0 + 1U - 1);return &(listeners_); } 



TestResult *current_test_result(); 


const TestResult *ad_hoc_test_result() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(333 + 0 + 1U - 1);return &(ad_hoc_test_result_); } 
# 613
void set_os_stack_trace_getter(OsStackTraceGetterInterface * getter); 




OsStackTraceGetterInterface *os_stack_trace_getter(); 
# 630 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
std::string CurrentOsStackTraceExceptTop(int skip_count) __attribute((noinline)); 
# 642 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
TestCase *GetTestCase(const char * test_case_name, const char * type_param, Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc tear_down_tc); 
# 654 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
void AddTestInfo(Test::SetUpTestCaseFunc set_up_tc, Test::TearDownTestCaseFunc 
tear_down_tc, TestInfo *
test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
# 664
if (((void)cpptestFastCoverageStmt(334 + 0 + 1U - 1), (original_working_dir_).IsEmpty())) { cpptestFastCoverageStmt(334 + 0 + 2U - 1);
(original_working_dir_).Set(FilePath::GetCurrentDir()); 
switch (((void)cpptestFastCoverageStmt(334 + 0 + 3U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(334 + 0 + 4U - 1), ::testing::internal::IsTrue(!(original_working_dir_).IsEmpty()))) {cpptestFastCoverageStmt(334 + 0 + 5U - 1);; } else {cpptestFastCoverageStmt(334 + 0 + 6U - 1);((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" "", 666).GetStream() << ("Condition !original_working_dir_.IsEmpty() failed. ")) << ("Failed to get the current working directory.")); }  }  

}  cpptestFastCoverageStmt(334 + 0 + 7U - 1);

this->GetTestCase(test_info->test_case_name(), test_info->type_param(), set_up_tc, tear_down_tc)->AddTestInfo(test_info); 



} 



ParameterizedTestCaseRegistry &parameterized_test_registry() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(341 + 0 + 1U - 1);
return parameterized_test_registry_; 
} 


void set_current_test_case(TestCase *a_current_test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(342 + 0 + 1U - 1);
current_test_case_ = a_current_test_case; 
} 




void set_current_test_info(TestInfo *a_current_test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(343 + 0 + 1U - 1);
current_test_info_ = a_current_test_info; 
} 
# 700
void RegisterParameterizedTests(); 
# 706
bool RunAllTests(); 


void ClearNonAdHocTestResult() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(344 + 0 + 1U - 1);
ForEach(test_cases_, TestCase::ClearTestCaseResult); 
} 


void ClearAdHocTestResult() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(345 + 0 + 1U - 1);
(ad_hoc_test_result_).Clear(); 
} 
# 722
void RecordProperty(const TestProperty & test_property); 

enum ReactionToSharding { 
HONOR_SHARDING_PROTOCOL, 
IGNORE_SHARDING_PROTOCOL
}; 
# 735
int FilterTests(ReactionToSharding shard_tests); 


void ListTestsMatchingFilter(); 

const TestCase *current_test_case() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(346 + 0 + 1U - 1);return current_test_case_; } 
TestInfo *current_test_info() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(347 + 0 + 1U - 1);return current_test_info_; } 
const TestInfo *current_test_info() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(348 + 0 + 1U - 1);return current_test_info_; } 



std::vector< Environment *>  &environments() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(349 + 0 + 1U - 1);return environments_; } 


std::vector< TraceInfo>  &gtest_trace_stack() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(350 + 0 + 1U - 1);
return *((gtest_trace_stack_).pointer()); 
} 
const std::vector< TraceInfo>  &gtest_trace_stack() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(351 + 0 + 1U - 1);
return (gtest_trace_stack_).get(); 
} 


void InitDeathTestSubprocessControlInfo() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(352 + 0 + 1U - 1);
(internal_run_death_test_flag_).reset(ParseInternalRunDeathTestFlag()); 
} 




const InternalRunDeathTestFlag *internal_run_death_test_flag() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(353 + 0 + 1U - 1);
return (internal_run_death_test_flag_).get(); 
} 


DeathTestFactory *death_test_factory() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(354 + 0 + 1U - 1);
return (death_test_factory_).get(); 
} 

void SuppressTestEventsIfInSubprocess(); 

friend class ReplaceDeathTestFactory; 




void ConfigureXmlOutput(); 
# 793 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
void PostFlagParsingInit(); 


int random_seed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(355 + 0 + 1U - 1);return random_seed_; } 


Random *random() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(356 + 0 + 1U - 1);return &(random_); } 



void ShuffleTests(); 


void UnshuffleTests(); 



bool catch_exceptions() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(357 + 0 + 1U - 1);return catch_exceptions_; } 


friend class testing::UnitTest; 



private: void set_catch_exceptions(bool value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(358 + 0 + 1U - 1);catch_exceptions_ = value; } 


UnitTest *const parent_; 



FilePath original_working_dir_; 


DefaultGlobalTestPartResultReporter default_global_test_part_result_reporter_; 

DefaultPerThreadTestPartResultReporter default_per_thread_test_part_result_reporter_; 


TestPartResultReporterInterface *global_test_part_result_repoter_; 


Mutex global_test_part_result_reporter_mutex_; 



ThreadLocal< TestPartResultReporterInterface *>  per_thread_test_part_result_reporter_; 



std::vector< Environment *>  environments_; 



std::vector< TestCase *>  test_cases_; 
# 853
std::vector< int>  test_case_indices_; 



ParameterizedTestCaseRegistry parameterized_test_registry_; 


bool parameterized_tests_registered_; 


int last_death_test_case_; 
# 869
TestCase *current_test_case_; 
# 875
TestInfo *current_test_info_; 
# 885 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
TestResult ad_hoc_test_result_; 



TestEventListeners listeners_; 
# 895
OsStackTraceGetterInterface *os_stack_trace_getter_; 


bool post_flag_parse_init_performed_; 


int random_seed_; 


Random random_; 



TimeInMillis start_timestamp_; 


TimeInMillis elapsed_time_; 




scoped_ptr< InternalRunDeathTestFlag>  internal_run_death_test_flag_; 
scoped_ptr< DeathTestFactory>  death_test_factory_; 



ThreadLocal< std::vector< TraceInfo> >  gtest_trace_stack_; 



bool catch_exceptions_; 

UnitTestImpl(const UnitTestImpl &) = delete;void operator=(const UnitTestImpl &) = delete;
}; 



inline UnitTestImpl *GetUnitTestImpl() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(359 + 0 + 1U - 1);
return UnitTest::GetInstance()->impl(); 
} 
# 940
__attribute((visibility("default"))) bool IsInSet(char ch, const char * str); 
__attribute((visibility("default"))) bool IsAsciiDigit(char ch); 
__attribute((visibility("default"))) bool IsAsciiPunct(char ch); 
__attribute((visibility("default"))) bool IsRepeat(char ch); 
__attribute((visibility("default"))) bool IsAsciiWhiteSpace(char ch); 
__attribute((visibility("default"))) bool IsAsciiWordChar(char ch); 
__attribute((visibility("default"))) bool IsValidEscape(char ch); 
__attribute((visibility("default"))) bool AtomMatchesChar(bool escaped, char pattern, char ch); 
__attribute((visibility("default"))) bool ValidateRegex(const char * regex); 
__attribute((visibility("default"))) bool MatchRegexAtHead(const char * regex, const char * str); 
__attribute((visibility("default"))) bool MatchRepetitionAndRegexAtHead(bool escaped, char ch, char repeat, const char * regex, const char * str); 

__attribute((visibility("default"))) bool MatchRegexAnywhere(const char * regex, const char * str); 
# 958
__attribute((visibility("default"))) void ParseGoogleTestFlagsOnly(int * argc, char ** argv); 
__attribute((visibility("default"))) void ParseGoogleTestFlagsOnly(int * argc, wchar_t ** argv); 
# 965
__attribute((visibility("default"))) std::string GetLastErrnoDescription(); 
# 971
template < typename Integer > 
bool ParseNaturalNumber (const :: std :: string & str , Integer * number) { 



if (str . empty () || ! IsDigit (str [ 0 ])) { 
return false ; 
} 
# 979 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" 3
(* _errno ()) 
# 979 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
= 0 ; 

char * end ; 
# 993 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
typedef unsigned long long BiggestConvertible ; 
const BiggestConvertible parsed = strtoull (str . c_str () , & end , 10) ; 



const bool parse_success = * end == '\0' && 
# 998 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" 3
(* _errno ()) 
# 998 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
== 0 ; 



switch (0) case 0 : default : if (:: testing :: internal :: IsTrue (sizeof (Integer) <= sizeof (parsed))) ; else :: testing :: internal :: GTestLog (:: testing :: internal :: GTEST_FATAL , "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h" , 1002) . GetStream () << "Condition " "sizeof(Integer) <= sizeof(parsed)" " failed. " ; 

const Integer result = static_cast < Integer > (parsed) ; 
if (parse_success && static_cast < BiggestConvertible > (result) == parsed) { 
* number = result ; 
return true ; 
} 
return false ; 
} 
# 1019 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
class TestResultAccessor { 

public: static void RecordProperty(TestResult *test_result, const std::string &
xml_element, const TestProperty &
property) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(360 + 0 + 1U - 1);
test_result->RecordProperty(xml_element, property); 
} 

static void ClearTestPartResults(TestResult *test_result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(361 + 0 + 1U - 1);
test_result->ClearTestPartResults(); 
} 

static const std::vector< TestPartResult>  &test_part_results(const TestResult &
test_result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(362 + 0 + 1U - 1);
return test_result.test_part_results(); 
} 
}; 
# 1184 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-internal-inl.h"
}
}
# 154 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
namespace testing { 

using internal::CountIf;
using internal::ForEach;
using internal::GetElementOr;
using internal::Shuffle;
# 165
static const char kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*"; 




static const char kDeathTestCaseFilter[] = "*DeathTest:*DeathTest/*"; 


static const char kUniversalFilter[] = "*"; 


static const char kDefaultOutputFormat[] = "xml"; 

static const char kDefaultOutputFile[] = "test_detail"; 


static const char kTestShardIndex[] = "GTEST_SHARD_INDEX"; 

static const char kTestTotalShards[] = "GTEST_TOTAL_SHARDS"; 

static const char kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE"; 

namespace internal { 



extern const char kStackTraceMarker[] = "\nStack trace:\n"; 



bool g_help_flag = false; 


static FILE *OpenFileForWriting(const std::string &output_file) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(363 + 0 + 1U - 1);
FILE *fileout = (nullptr); cpptestFastCoverageStmt(363 + 0 + 2U - 1);
FilePath output_file_path(output_file); cpptestFastCoverageStmt(363 + 0 + 3U - 1);
FilePath output_dir(output_file_path.RemoveFileName()); 

if (((void)cpptestFastCoverageStmt(363 + 0 + 4U - 1), output_dir.CreateDirectoriesRecursively())) { cpptestFastCoverageStmt(363 + 0 + 5U - 1);
fileout = posix::FOpen(output_file.c_str(), "w"); 
}  
if (((void)cpptestFastCoverageStmt(363 + 0 + 6U - 1), fileout == (nullptr))) { cpptestFastCoverageStmt(363 + 0 + 7U - 1);
(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 207).GetStream() << ("Unable to open file \"")) << output_file) << ("\"")); 
}  cpptestFastCoverageStmt(363 + 0 + 8U - 1);
return fileout; 
} 

}



static const char *GetDefaultFilter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(371 + 0 + 1U - 1);
const char *const testbridge_test_only = internal::posix::GetEnv("TESTBRIDGE_TEST_ONLY"); 

if (((void)cpptestFastCoverageStmt(371 + 0 + 2U - 1), testbridge_test_only != (nullptr))) { cpptestFastCoverageStmt(371 + 0 + 3U - 1);
return testbridge_test_only; 
}  cpptestFastCoverageStmt(371 + 0 + 4U - 1);
return kUniversalFilter; 
} 

__attribute((visibility("default"))) bool FLAGS_gtest_also_run_disabled_tests = (internal::BoolFromGTestEnv("also_run_disabled_tests", false)); 




__attribute((visibility("default"))) bool FLAGS_gtest_break_on_failure = (internal::BoolFromGTestEnv("break_on_failure", false)); 




__attribute((visibility("default"))) bool FLAGS_gtest_catch_exceptions = (internal::BoolFromGTestEnv("catch_exceptions", true)); 
# 241
__attribute((visibility("default"))) std::string FLAGS_gtest_color = (internal::StringFromGTestEnv("color", "auto")); 
# 249
__attribute((visibility("default"))) std::string FLAGS_gtest_filter = (internal::StringFromGTestEnv("filter", GetDefaultFilter())); 
# 258
__attribute((visibility("default"))) bool FLAGS_gtest_install_failure_signal_handler = (internal::BoolFromGTestEnv("install_failure_signal_handler", false)); 
# 265
__attribute((visibility("default"))) bool FLAGS_gtest_list_tests = (false); 
# 273
__attribute((visibility("default"))) std::string FLAGS_gtest_output = (internal::StringFromGTestEnv("output", (internal::OutputFlagAlsoCheckEnvVar()).c_str())); 
# 286 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
__attribute((visibility("default"))) bool FLAGS_gtest_print_time = (internal::BoolFromGTestEnv("print_time", true)); 
# 292
__attribute((visibility("default"))) bool FLAGS_gtest_print_utf8 = (internal::BoolFromGTestEnv("print_utf8", true)); 
# 298
__attribute((visibility("default"))) internal::Int32 FLAGS_gtest_random_seed = (internal::Int32FromGTestEnv("random_seed", 0)); 
# 304
__attribute((visibility("default"))) internal::Int32 FLAGS_gtest_repeat = (internal::Int32FromGTestEnv("repeat", 1)); 
# 310
__attribute((visibility("default"))) bool FLAGS_gtest_show_internal_stack_frames = (false); 




__attribute((visibility("default"))) bool FLAGS_gtest_shuffle = (internal::BoolFromGTestEnv("shuffle", false)); 
# 321
__attribute((visibility("default"))) internal::Int32 FLAGS_gtest_stack_trace_depth = (internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth)); 
# 327
__attribute((visibility("default"))) std::string FLAGS_gtest_stream_result_to = (internal::StringFromGTestEnv("stream_result_to", "")); 
# 334
__attribute((visibility("default"))) bool FLAGS_gtest_throw_on_failure = (internal::BoolFromGTestEnv("throw_on_failure", false)); 
# 342
__attribute((visibility("default"))) std::string FLAGS_gtest_flagfile = (internal::StringFromGTestEnv("flagfile", "")); 
# 348
namespace internal { 




UInt32 Random::Generate(UInt32 range) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(375 + 0 + 1U - 1);


state_ = static_cast< UInt32>(1103515245ULL * state_ + 12345U) % kMaxRange; 

switch (((void)cpptestFastCoverageStmt(375 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(375 + 0 + 3U - 1), ::testing::internal::IsTrue(range > 0))) {cpptestFastCoverageStmt(375 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(375 + 0 + 5U - 1);((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 358).GetStream() << ("Condition range > 0 failed. ")) << ("Cannot generate a number in the range [0, 0).")); }  }  

switch (((void)cpptestFastCoverageStmt(375 + 0 + 6U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(375 + 0 + 7U - 1), ::testing::internal::IsTrue(range <= kMaxRange))) {cpptestFastCoverageStmt(375 + 0 + 8U - 1);; } else {cpptestFastCoverageStmt(375 + 0 + 9U - 1);(((((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 360).GetStream() << ("Condition range <= kMaxRange failed. ")) << ("Generation of a number in [0, ")) << range) << (") was requested, ")) << ("but this can only generate numbers in [0, ")) << kMaxRange) << (").")); }  }  cpptestFastCoverageStmt(375 + 0 + 10U - 1);
# 367
return state_ % range; 
} 




static bool GTestIsInitialized() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(385 + 0 + 1U - 1);return (GetArgvs()).size() > 0; } 




static int SumOverTestCaseList(const std::vector< TestCase *>  &case_list, int (TestCase::*
method)(void) const) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(386 + 0 + 1U - 1);
int sum = 0; cpptestFastCoverageStmt(386 + 0 + 2U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(386 + 0 + 3U - 1), i < case_list.size()); ((void)cpptestFastCoverageStmt(386 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(386 + 0 + 5U - 1);
sum += ((case_list[i])->*method)(); 
}  cpptestFastCoverageStmt(386 + 0 + 6U - 1);
return sum; 
} 


static bool TestCasePassed(const TestCase *test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(392 + 0 + 1U - 1);
return test_case->should_run() && test_case->Passed(); 
} 


static bool TestCaseFailed(const TestCase *test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(393 + 0 + 1U - 1);
return test_case->should_run() && test_case->Failed(); 
} 



static bool ShouldRunTestCase(const TestCase *test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(394 + 0 + 1U - 1);
return test_case->should_run(); 
} 


AssertHelper::AssertHelper(TestPartResult::Type type, const char *
file, int 
line, const char *
message) : data_(new AssertHelperData(type, file, line, message)) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(395 + 0 + 1U - 1);
} 

AssertHelper::~AssertHelper() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(396 + 0 + 1U - 1);
delete (data_); 
} 


void AssertHelper::operator=(const Message &message) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(397 + 0 + 1U - 1);
UnitTest::GetInstance()->AddTestPartResult(data_->type, data_->file, data_->line, AppendUserMessage(data_->message, message), UnitTest::GetInstance()->impl()->CurrentOsStackTraceExceptTop(1)); 
# 424
} 


__attribute((visibility("default"))) Mutex g_linked_ptr_mutex(::testing::internal::Mutex::kStaticMutex); 


static std::vector< std::__cxx11::basic_string< char> >  g_argvs; 

std::vector< std::__cxx11::basic_string< char> >  GetArgvs() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(398 + 0 + 1U - 1);
# 439
return g_argvs; 

} 



FilePath GetCurrentExecutableName() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(399 + 0 + 1U - 1);
FilePath result; cpptestFastCoverageStmt(399 + 0 + 2U - 1);


result.Set(((FilePath)(GetArgvs()[0])).RemoveExtension("exe")); cpptestFastCoverageStmt(399 + 0 + 3U - 1);




return result.RemoveDirectoryName(); 
} 




std::string UnitTestOptions::GetOutputFormat() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(402 + 0 + 1U - 1);
const char *const gtest_output_flag = FLAGS_gtest_output.c_str(); cpptestFastCoverageStmt(402 + 0 + 2U - 1);
const char *const colon = strchr(gtest_output_flag, ':'); cpptestFastCoverageStmt(402 + 0 + 3U - 1);
return ((colon == (nullptr)) ? ((std::__cxx11::basic_string< char> )(gtest_output_flag)) : std::string(gtest_output_flag, colon - gtest_output_flag)); 


} 



std::string UnitTestOptions::GetAbsolutePathToOutputFile() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(405 + 0 + 1U - 1);
const char *const gtest_output_flag = FLAGS_gtest_output.c_str(); cpptestFastCoverageStmt(405 + 0 + 2U - 1);

std::string format = GetOutputFormat(); 
if (((void)cpptestFastCoverageStmt(405 + 0 + 3U - 1), format.empty())) {cpptestFastCoverageStmt(405 + 0 + 4U - 1);
(format = ((std::__cxx11::basic_string< char> )(kDefaultOutputFormat))); }  cpptestFastCoverageStmt(405 + 0 + 5U - 1);

const char *const colon = strchr(gtest_output_flag, ':'); 
if (((void)cpptestFastCoverageStmt(405 + 0 + 6U - 1), colon == (nullptr))) {cpptestFastCoverageStmt(405 + 0 + 7U - 1);
return (internal::FilePath::MakeFileName(((FilePath)(UnitTest::GetInstance()->original_working_dir())), ((FilePath)(kDefaultOutputFile)), 0, format.c_str())).string(); }  cpptestFastCoverageStmt(405 + 0 + 8U - 1);
# 485
FilePath output_name(colon + 1); 
if (((void)cpptestFastCoverageStmt(405 + 0 + 9U - 1), !output_name.IsAbsolutePath())) {cpptestFastCoverageStmt(405 + 0 + 10U - 1);




(output_name = internal::FilePath::ConcatPaths(((FilePath)(UnitTest::GetInstance()->original_working_dir())), ((FilePath)(colon + 1)))); }  



if (((void)cpptestFastCoverageStmt(405 + 0 + 11U - 1), !output_name.IsDirectory())) {cpptestFastCoverageStmt(405 + 0 + 12U - 1);
return output_name.string(); }  cpptestFastCoverageStmt(405 + 0 + 13U - 1);

FilePath result(internal::FilePath::GenerateUniqueFileName(output_name, internal::GetCurrentExecutableName(), (GetOutputFormat()).c_str())); cpptestFastCoverageStmt(405 + 0 + 14U - 1);


return result.string(); 
} 
# 509
bool UnitTestOptions::PatternMatchesString(const char *pattern, const char *
str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(419 + 0 + 1U - 1), *pattern)) { 
case '\000':  
case ':':  cpptestFastCoverageStmt(419 + 0 + 2U - 1);
return *str == '\000'; 
case '\?':  cpptestFastCoverageStmt(419 + 0 + 3U - 1);
return *str != '\000' && PatternMatchesString(pattern + 1, str + 1); 
case '*':  cpptestFastCoverageStmt(419 + 0 + 4U - 1);
return (*str != '\000' && PatternMatchesString(pattern, str + 1)) || PatternMatchesString(pattern + 1, str); 

default:  cpptestFastCoverageStmt(419 + 0 + 5U - 1);
return *pattern == *str && PatternMatchesString(pattern + 1, str + 1); 

}  
} 

bool UnitTestOptions::MatchesFilter(const std::string &
name, const char *filter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(424 + 0 + 1U - 1);
const char *cur_pattern = filter; 
for (; 1;) { 
if (((void)cpptestFastCoverageStmt(424 + 0 + 2U - 1), PatternMatchesString(cur_pattern, name.c_str()))) { cpptestFastCoverageStmt(424 + 0 + 3U - 1);
return true; 
}  cpptestFastCoverageStmt(424 + 0 + 4U - 1);


cur_pattern = strchr(cur_pattern, ':'); 


if (((void)cpptestFastCoverageStmt(424 + 0 + 5U - 1), cur_pattern == (nullptr))) { cpptestFastCoverageStmt(424 + 0 + 6U - 1);
return false; 
}  cpptestFastCoverageStmt(424 + 0 + 7U - 1);


cur_pattern++; 
}  
} 



bool UnitTestOptions::FilterMatchesTest(const std::string &test_case_name, const std::string &
test_name) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(431 + 0 + 1U - 1);
const std::string &full_name = ((test_case_name + (".")) + test_name.c_str()); cpptestFastCoverageStmt(431 + 0 + 2U - 1);



const char *const p = FLAGS_gtest_filter.c_str(); cpptestFastCoverageStmt(431 + 0 + 3U - 1);
const char *const dash = strchr(p, '-'); cpptestFastCoverageStmt(431 + 0 + 4U - 1);
std::string positive; cpptestFastCoverageStmt(431 + 0 + 5U - 1);
std::string negative; 
if (((void)cpptestFastCoverageStmt(431 + 0 + 6U - 1), dash == (nullptr))) { cpptestFastCoverageStmt(431 + 0 + 7U - 1);
(positive = FLAGS_gtest_filter.c_str()); cpptestFastCoverageStmt(431 + 0 + 8U - 1);
(negative = ("")); 
} else { cpptestFastCoverageStmt(431 + 0 + 9U - 1);
(positive = std::string(p, dash)); cpptestFastCoverageStmt(431 + 0 + 10U - 1);
(negative = ((std::__cxx11::basic_string< char> )(dash + 1))); 
if (((void)cpptestFastCoverageStmt(431 + 0 + 11U - 1), positive.empty())) { cpptestFastCoverageStmt(431 + 0 + 12U - 1);

(positive = (kUniversalFilter)); 
}  
}  cpptestFastCoverageStmt(431 + 0 + 13U - 1);



return (MatchesFilter(full_name, positive.c_str()) && !MatchesFilter(full_name, negative.c_str())); 

} 
# 605 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}




ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(TestPartResultArray *
result) : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD), result_(result) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(444 + 0 + 1U - 1);
this->Init(); 
} 




ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(InterceptMode 
intercept_mode, TestPartResultArray *result) : intercept_mode_(intercept_mode), result_(result) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(445 + 0 + 1U - 1);
this->Init(); 
} 

void ScopedFakeTestPartResultReporter::Init() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(446 + 0 + 1U - 1);
internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); 
if (((void)cpptestFastCoverageStmt(446 + 0 + 2U - 1), intercept_mode_ == INTERCEPT_ALL_THREADS)) { cpptestFastCoverageStmt(446 + 0 + 3U - 1);
old_reporter_ = impl->GetGlobalTestPartResultReporter(); cpptestFastCoverageStmt(446 + 0 + 4U - 1);
impl->SetGlobalTestPartResultReporter(this); 
} else { cpptestFastCoverageStmt(446 + 0 + 5U - 1);
old_reporter_ = impl->GetTestPartResultReporterForCurrentThread(); cpptestFastCoverageStmt(446 + 0 + 6U - 1);
impl->SetTestPartResultReporterForCurrentThread(this); 
}  
} 



ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(452 + 0 + 1U - 1);
internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); 
if (((void)cpptestFastCoverageStmt(452 + 0 + 2U - 1), intercept_mode_ == INTERCEPT_ALL_THREADS)) { cpptestFastCoverageStmt(452 + 0 + 3U - 1);
impl->SetGlobalTestPartResultReporter(old_reporter_); 
} else { cpptestFastCoverageStmt(452 + 0 + 4U - 1);
impl->SetTestPartResultReporterForCurrentThread(old_reporter_); 
}  
} 



void ScopedFakeTestPartResultReporter::ReportTestPartResult(const TestPartResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(456 + 0 + 1U - 1);
(result_)->Append(result); 
} 

namespace internal { 
# 667 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
TypeId GetTestTypeId() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(457 + 0 + 1U - 1);
return GetTypeId< Test> (); 
} 



extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId(); 




static AssertionResult HasOneFailure(const char *, const char *, const char *, const TestPartResultArray &


results, TestPartResult::Type 
type, const std::string &
substr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(458 + 0 + 1U - 1);
const std::string expected((type == TestPartResult::kFatalFailure) ? "1 fatal failure" : ("1 non-fatal failure")); cpptestFastCoverageStmt(458 + 0 + 2U - 1);


Message msg; 
if (((void)cpptestFastCoverageStmt(458 + 0 + 3U - 1), results.size() != 1)) { cpptestFastCoverageStmt(458 + 0 + 4U - 1);
((((((msg << ("Expected: ")) << expected) << ("\n")) << ("  Actual: ")) << results.size()) << (" failures")); cpptestFastCoverageStmt(458 + 0 + 5U - 1);

for (int i = 0; ((void)cpptestFastCoverageStmt(458 + 0 + 6U - 1), i < results.size()); ((void)cpptestFastCoverageStmt(458 + 0 + 7U - 1), i++)) { cpptestFastCoverageStmt(458 + 0 + 8U - 1);
((msg << ("\n")) << results.GetTestPartResult(i)); 
}  cpptestFastCoverageStmt(458 + 0 + 9U - 1);
return (AssertionFailure() << msg); 
}  cpptestFastCoverageStmt(458 + 0 + 10U - 1);

const TestPartResult &r = results.GetTestPartResult(0); 
if (((void)cpptestFastCoverageStmt(458 + 0 + 11U - 1), r.type() != type)) { cpptestFastCoverageStmt(458 + 0 + 12U - 1);
return (((((AssertionFailure() << ("Expected: ")) << expected) << ("\n")) << ("  Actual:\n")) << r); 


}  

if (((void)cpptestFastCoverageStmt(458 + 0 + 13U - 1), strstr(r.message(), substr.c_str()) == (nullptr))) { cpptestFastCoverageStmt(458 + 0 + 14U - 1);
return (((((((AssertionFailure() << ("Expected: ")) << expected) << (" containing \"")) << substr) << ("\"\n")) << ("  Actual:\n")) << r); 



}  cpptestFastCoverageStmt(458 + 0 + 15U - 1);

return AssertionSuccess(); 
} 




SingleFailureChecker::SingleFailureChecker(const TestPartResultArray *results, TestPartResult::Type 
type, const std::string &
substr) : results_(results), type_(type), substr_(substr) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(473 + 0 + 1U - 1);} 
# 726
SingleFailureChecker::~SingleFailureChecker() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(474 + 0 + 1U - 1), 0)) { case 0:  default:  if (const AssertionResult gtest_ar = (cpptestFastCoverageStmt(474 + 0 + 2U - 1), HasOneFailure("*results_", "type_", "substr_", *(results_), type_, substr_))) {cpptestFastCoverageStmt(474 + 0 + 3U - 1);; } else {cpptestFastCoverageStmt(474 + 0 + 4U - 1);(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 727, gtest_ar.failure_message()) = Message()); }  }  
} 

DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(UnitTestImpl *
unit_test) : unit_test_(unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(478 + 0 + 1U - 1);} 

void DefaultGlobalTestPartResultReporter::ReportTestPartResult(const TestPartResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(479 + 0 + 1U - 1);
(unit_test_)->current_test_result()->AddTestPartResult(result); cpptestFastCoverageStmt(479 + 0 + 2U - 1);
(unit_test_)->listeners()->repeater()->OnTestPartResult(result); 
} 

DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(UnitTestImpl *
unit_test) : unit_test_(unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(481 + 0 + 1U - 1);} 

void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(const TestPartResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(482 + 0 + 1U - 1);
(unit_test_)->GetGlobalTestPartResultReporter()->ReportTestPartResult(result); 
} 



TestPartResultReporterInterface *UnitTestImpl::GetGlobalTestPartResultReporter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(483 + 0 + 1U - 1);
MutexLock lock(&(global_test_part_result_reporter_mutex_)); cpptestFastCoverageStmt(483 + 0 + 2U - 1);
return global_test_part_result_repoter_; 
} 


void UnitTestImpl::SetGlobalTestPartResultReporter(TestPartResultReporterInterface *
reporter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(485 + 0 + 1U - 1);
MutexLock lock(&(global_test_part_result_reporter_mutex_)); cpptestFastCoverageStmt(485 + 0 + 2U - 1);
global_test_part_result_repoter_ = reporter; 
} 



TestPartResultReporterInterface *UnitTestImpl::GetTestPartResultReporterForCurrentThread() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(487 + 0 + 1U - 1);
return (per_thread_test_part_result_reporter_).get(); 
} 


void UnitTestImpl::SetTestPartResultReporterForCurrentThread(TestPartResultReporterInterface *
reporter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(488 + 0 + 1U - 1);
(per_thread_test_part_result_reporter_).set(reporter); 
} 


int UnitTestImpl::successful_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(489 + 0 + 1U - 1);
return CountIf(test_cases_, TestCasePassed); 
} 


int UnitTestImpl::failed_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(490 + 0 + 1U - 1);
return CountIf(test_cases_, TestCaseFailed); 
} 


int UnitTestImpl::total_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(491 + 0 + 1U - 1);
return static_cast< int>((test_cases_).size()); 
} 



int UnitTestImpl::test_case_to_run_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(492 + 0 + 1U - 1);
return CountIf(test_cases_, ShouldRunTestCase); 
} 


int UnitTestImpl::successful_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(493 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::successful_test_count); 
} 


int UnitTestImpl::skipped_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(494 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::skipped_test_count); 
} 


int UnitTestImpl::failed_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(495 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::failed_test_count); 
} 


int UnitTestImpl::reportable_disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(496 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::reportable_disabled_test_count); 

} 


int UnitTestImpl::disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(497 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::disabled_test_count); 
} 


int UnitTestImpl::reportable_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(498 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::reportable_test_count); 
} 


int UnitTestImpl::total_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(499 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::total_test_count); 
} 


int UnitTestImpl::test_to_run_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(500 + 0 + 1U - 1);
return SumOverTestCaseList(test_cases_, &TestCase::test_to_run_count); 
} 
# 845 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(501 + 0 + 1U - 1);
return this->os_stack_trace_getter()->CurrentStackTrace(static_cast< int>(FLAGS_gtest_stack_trace_depth), skip_count + 1); 
# 852
} 


TimeInMillis GetTimeInMillis() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(502 + 0 + 1U - 1);
# 890 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
timeval now; cpptestFastCoverageStmt(502 + 0 + 2U - 1);
gettimeofday(&now, nullptr); cpptestFastCoverageStmt(502 + 0 + 3U - 1);
return static_cast< TimeInMillis>(now.tv_sec) * 1000 + now.tv_usec / 1000; 



} 
# 943 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
bool String::CStringEquals(const char *lhs, const char *rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(505 + 0 + 1U - 1), lhs == (nullptr))) {cpptestFastCoverageStmt(505 + 0 + 2U - 1);return rhs == (nullptr); }  

if (((void)cpptestFastCoverageStmt(505 + 0 + 3U - 1), rhs == (nullptr))) {cpptestFastCoverageStmt(505 + 0 + 4U - 1);return false; }  cpptestFastCoverageStmt(505 + 0 + 5U - 1);

return strcmp(lhs, rhs) == 0; 
} 
# 955
static void StreamWideCharsToMessage(const wchar_t *wstr, size_t length, Message *
msg) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(510 + 0 + 1U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(510 + 0 + 2U - 1), i != length);) { 
if (((void)cpptestFastCoverageStmt(510 + 0 + 3U - 1), wstr[i] != L'\x0')) { cpptestFastCoverageStmt(510 + 0 + 4U - 1);
(*msg << WideStringToUtf8(wstr + i, static_cast< int>(length - i))); 
while (((void)cpptestFastCoverageStmt(510 + 0 + 5U - 1), i != length && wstr[i] != L'\x0')) {cpptestFastCoverageStmt(510 + 0 + 6U - 1);
i++; }  
} else { cpptestFastCoverageStmt(510 + 0 + 7U - 1);
(*msg << '\000'); cpptestFastCoverageStmt(510 + 0 + 8U - 1);
i++; 
}  
}  
} 



void SplitString(const std::string &str, char delimiter, std::vector< std::__cxx11::basic_string< char> >  *
dest) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(518 + 0 + 1U - 1);
std::vector< std::__cxx11::basic_string< char> >  parsed; cpptestFastCoverageStmt(518 + 0 + 2U - 1);
std::__cxx11::basic_string< char> ::size_type pos = (0); 
while (((void)cpptestFastCoverageStmt(518 + 0 + 3U - 1), ::testing::internal::AlwaysTrue())) { cpptestFastCoverageStmt(518 + 0 + 4U - 1);
const std::__cxx11::basic_string< char> ::size_type colon = str.find(delimiter, pos); 
if (((void)cpptestFastCoverageStmt(518 + 0 + 5U - 1), colon == ::std::string::npos)) { cpptestFastCoverageStmt(518 + 0 + 6U - 1);
parsed.push_back(str.substr(pos)); cpptestFastCoverageStmt(518 + 0 + 7U - 1);
break; 
} else { cpptestFastCoverageStmt(518 + 0 + 8U - 1);
parsed.push_back(str.substr(pos, colon - pos)); cpptestFastCoverageStmt(518 + 0 + 9U - 1);
pos = colon + 1; 
}  
}  cpptestFastCoverageStmt(518 + 0 + 10U - 1);
dest->swap(parsed); 
} 

}
# 995
Message::Message() : ss_(new std::stringstream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(528 + 0 + 1U - 1);


((*ss_) << std::setprecision(std::numeric_limits< double> ::digits10 + 2)); 
} 



Message &Message::operator<<(const wchar_t *wide_c_str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(529 + 0 + 1U - 1);
return (*this << internal::String::ShowWideCString(wide_c_str)); 
} 
Message &Message::operator<<(wchar_t *wide_c_str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(530 + 0 + 1U - 1);
return (*this << internal::String::ShowWideCString(wide_c_str)); 
} 




Message &Message::operator<<(const std::wstring &wstr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(531 + 0 + 1U - 1);
internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this); cpptestFastCoverageStmt(531 + 0 + 2U - 1);
return *this; 
} 
# 1030 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string Message::GetString() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(533 + 0 + 1U - 1);
return internal::StringStreamToString((ss_).get()); 
} 



AssertionResult::AssertionResult(const AssertionResult &other) : success_(other.success_), message_(((other.message_).get() != (nullptr)) ? new std::string((*other.message_)) : (static_cast< std::string *>(nullptr))) 



{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(534 + 0 + 1U - 1);} 


void AssertionResult::swap(AssertionResult &other) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(535 + 0 + 1U - 1);
using std::swap;cpptestFastCoverageStmt(535 + 0 + 2U - 1);
swap(success_, other.success_); cpptestFastCoverageStmt(535 + 0 + 3U - 1);
swap(message_, other.message_); 
} 


AssertionResult AssertionResult::operator!() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(538 + 0 + 1U - 1);
AssertionResult negation(!success_); 
if (((void)cpptestFastCoverageStmt(538 + 0 + 2U - 1), (message_).get() != (nullptr))) {cpptestFastCoverageStmt(538 + 0 + 3U - 1);(negation << (*message_)); }  cpptestFastCoverageStmt(538 + 0 + 4U - 1);
return negation; 
} 


AssertionResult AssertionSuccess() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(542 + 0 + 1U - 1);
return ((AssertionResult)(true)); 
} 


AssertionResult AssertionFailure() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(543 + 0 + 1U - 1);
return ((AssertionResult)(false)); 
} 



AssertionResult AssertionFailure(const Message &message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(544 + 0 + 1U - 1);
return (AssertionFailure() << message); 
} 

namespace internal { 

namespace edit_distance { 
std::vector< EditType>  CalculateOptimalEdits(const std::vector< unsigned>  &left, const std::vector< unsigned>  &
right) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(545 + 0 + 1U - 1);
std::vector< std::vector< double> >  costs(left.size() + 1, ((std::vector< double> )(right.size() + 1))); cpptestFastCoverageStmt(545 + 0 + 2U - 1);

std::vector< std::vector< EditType> >  best_move(left.size() + 1, ((std::vector< EditType> )(right.size() + 1))); cpptestFastCoverageStmt(545 + 0 + 3U - 1);



for (size_t l_i = (0); ((void)cpptestFastCoverageStmt(545 + 0 + 4U - 1), l_i < costs.size()); ((void)cpptestFastCoverageStmt(545 + 0 + 5U - 1), ++l_i)) { cpptestFastCoverageStmt(545 + 0 + 6U - 1);
costs[l_i][0] = static_cast< double>(l_i); cpptestFastCoverageStmt(545 + 0 + 7U - 1);
best_move[l_i][0] = kRemove; 
}  cpptestFastCoverageStmt(545 + 0 + 8U - 1);

for (size_t r_i = (1); ((void)cpptestFastCoverageStmt(545 + 0 + 9U - 1), r_i < costs[0].size()); ((void)cpptestFastCoverageStmt(545 + 0 + 10U - 1), ++r_i)) { cpptestFastCoverageStmt(545 + 0 + 11U - 1);
costs[0][r_i] = static_cast< double>(r_i); cpptestFastCoverageStmt(545 + 0 + 12U - 1);
best_move[0][r_i] = kAdd; 
}  cpptestFastCoverageStmt(545 + 0 + 13U - 1);

for (size_t l_i = (0); ((void)cpptestFastCoverageStmt(545 + 0 + 14U - 1), l_i < left.size()); ((void)cpptestFastCoverageStmt(545 + 0 + 15U - 1), ++l_i)) { cpptestFastCoverageStmt(545 + 0 + 16U - 1);
for (size_t r_i = (0); ((void)cpptestFastCoverageStmt(545 + 0 + 17U - 1), r_i < right.size()); ((void)cpptestFastCoverageStmt(545 + 0 + 18U - 1), ++r_i)) { { 
if (((void)cpptestFastCoverageStmt(545 + 0 + 19U - 1), left[l_i] == right[r_i])) { cpptestFastCoverageStmt(545 + 0 + 20U - 1);

costs[l_i + 1][r_i + 1] = costs[l_i][r_i]; cpptestFastCoverageStmt(545 + 0 + 21U - 1);
best_move[l_i + 1][r_i + 1] = kMatch; cpptestFastCoverageStmt(545 + 0 + 22U - 1);
continue; 
}  cpptestFastCoverageStmt(545 + 0 + 23U - 1);

const double add = costs[l_i + 1][r_i]; cpptestFastCoverageStmt(545 + 0 + 24U - 1);
const double remove = costs[l_i][r_i + 1]; cpptestFastCoverageStmt(545 + 0 + 25U - 1);
const double replace = costs[l_i][r_i]; 
if (((void)cpptestFastCoverageStmt(545 + 0 + 26U - 1), add < remove && add < replace)) { cpptestFastCoverageStmt(545 + 0 + 27U - 1);
costs[l_i + 1][r_i + 1] = add + 1; cpptestFastCoverageStmt(545 + 0 + 28U - 1);
best_move[l_i + 1][r_i + 1] = kAdd; 
} else if (((void)cpptestFastCoverageStmt(545 + 0 + 29U - 1), remove < add && remove < replace)) { cpptestFastCoverageStmt(545 + 0 + 30U - 1);
costs[l_i + 1][r_i + 1] = remove + 1; cpptestFastCoverageStmt(545 + 0 + 31U - 1);
best_move[l_i + 1][r_i + 1] = kRemove; 
} else { cpptestFastCoverageStmt(545 + 0 + 32U - 1);


costs[l_i + 1][r_i + 1] = replace + (1.000010000000000066); cpptestFastCoverageStmt(545 + 0 + 33U - 1);
best_move[l_i + 1][r_i + 1] = kReplace; 
}    
} }  
}  cpptestFastCoverageStmt(545 + 0 + 34U - 1);


std::vector< EditType>  best_path; cpptestFastCoverageStmt(545 + 0 + 35U - 1);
for (size_t l_i = left.size(), r_i = right.size(); ((void)cpptestFastCoverageStmt(545 + 0 + 36U - 1), l_i > 0 || r_i > 0);) { cpptestFastCoverageStmt(545 + 0 + 37U - 1);
EditType move = best_move[l_i][r_i]; cpptestFastCoverageStmt(545 + 0 + 38U - 1);
best_path.push_back(move); cpptestFastCoverageStmt(545 + 0 + 39U - 1);
l_i -= move != kAdd; cpptestFastCoverageStmt(545 + 0 + 40U - 1);
r_i -= move != kRemove; 
}  cpptestFastCoverageStmt(545 + 0 + 41U - 1);
std::reverse(best_path.begin(), best_path.end()); cpptestFastCoverageStmt(545 + 0 + 42U - 1);
return best_path; 
} 

namespace { 


class InternalStrings { 

public: size_t GetId(const std::string &str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(587 + 0 + 1U - 1);
std::map< std::__cxx11::basic_string< char> , unsigned> ::iterator it = (ids_).find(str); 
if (((void)cpptestFastCoverageStmt(587 + 0 + 2U - 1), (it != (ids_).end()))) {cpptestFastCoverageStmt(587 + 0 + 3U - 1);return it->second; }  cpptestFastCoverageStmt(587 + 0 + 4U - 1);
size_t id = (ids_).size(); cpptestFastCoverageStmt(587 + 0 + 5U - 1);
return ids_[str] = id; 
} 


private: typedef std::map< std::__cxx11::basic_string< char> , unsigned>  IdMap; 
IdMap ids_; 
}; 

}

std::vector< EditType>  CalculateOptimalEdits(const std::vector< std::__cxx11::basic_string< char> >  &
left, const std::vector< std::__cxx11::basic_string< char> >  &
right) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(592 + 0 + 1U - 1);
std::vector< unsigned>  left_ids, right_ids; 
{ cpptestFastCoverageStmt(592 + 0 + 2U - 1);
edit_distance::InternalStrings intern_table; cpptestFastCoverageStmt(592 + 0 + 3U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(592 + 0 + 4U - 1), i < left.size()); ((void)cpptestFastCoverageStmt(592 + 0 + 5U - 1), ++i)) { cpptestFastCoverageStmt(592 + 0 + 6U - 1);
left_ids.push_back(intern_table.GetId(left[i])); 
}  cpptestFastCoverageStmt(592 + 0 + 7U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(592 + 0 + 8U - 1), i < right.size()); ((void)cpptestFastCoverageStmt(592 + 0 + 9U - 1), ++i)) { cpptestFastCoverageStmt(592 + 0 + 10U - 1);
right_ids.push_back(intern_table.GetId(right[i])); 
}  
} cpptestFastCoverageStmt(592 + 0 + 11U - 1);
return CalculateOptimalEdits(left_ids, right_ids); 
} 

namespace { 
# 1173
class Hunk { 

public: Hunk(size_t left_start, size_t right_start) : left_start_(left_start), right_start_(right_start), adds_(), removes_(), common_() 




{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(603 + 0 + 1U - 1);} 

void PushLine(char edit, const char *line) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(604 + 0 + 1U - 1), edit)) { 
case ' ':  cpptestFastCoverageStmt(604 + 0 + 2U - 1);
++common_; cpptestFastCoverageStmt(604 + 0 + 3U - 1);
this->FlushEdits(); cpptestFastCoverageStmt(604 + 0 + 4U - 1);
(hunk_).push_back(std::make_pair(' ', line)); cpptestFastCoverageStmt(604 + 0 + 5U - 1);
break; 
case '-':  cpptestFastCoverageStmt(604 + 0 + 6U - 1);
++removes_; cpptestFastCoverageStmt(604 + 0 + 7U - 1);
(hunk_removes_).push_back(std::make_pair('-', line)); cpptestFastCoverageStmt(604 + 0 + 8U - 1);
break; 
case '+':  cpptestFastCoverageStmt(604 + 0 + 9U - 1);
++adds_; cpptestFastCoverageStmt(604 + 0 + 10U - 1);
(hunk_adds_).push_back(std::make_pair('+', line)); cpptestFastCoverageStmt(604 + 0 + 11U - 1);
break; 
}  
} 

void PrintTo(std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(615 + 0 + 1U - 1);
this->PrintHeader(os); cpptestFastCoverageStmt(615 + 0 + 2U - 1);
this->FlushEdits(); cpptestFastCoverageStmt(615 + 0 + 3U - 1);
for (std::__cxx11::list< std::pair< char, const char *> > ::const_iterator it = (hunk_).begin(); ((void)cpptestFastCoverageStmt(615 + 0 + 4U - 1), it != (hunk_).end()); ((void)cpptestFastCoverageStmt(615 + 0 + 5U - 1), ++it)) 

{ cpptestFastCoverageStmt(615 + 0 + 6U - 1);
(((*os << it->first) << it->second) << ("\n")); 
}  
} 

bool has_edits() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(621 + 0 + 1U - 1);return adds_ || removes_; } 


private: void FlushEdits() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(622 + 0 + 1U - 1);
(hunk_).splice((hunk_).end(), hunk_removes_); cpptestFastCoverageStmt(622 + 0 + 2U - 1);
(hunk_).splice((hunk_).end(), hunk_adds_); 
} 
# 1222
void PrintHeader(std::ostream *ss) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(624 + 0 + 1U - 1);
(*ss << ("@@ ")); 
if (((void)cpptestFastCoverageStmt(624 + 0 + 2U - 1), removes_)) { cpptestFastCoverageStmt(624 + 0 + 3U - 1);
((((*ss << ("-")) << left_start_) << (",")) << (removes_ + common_)); 
}  
if (((void)cpptestFastCoverageStmt(624 + 0 + 4U - 1), removes_ && adds_)) { cpptestFastCoverageStmt(624 + 0 + 5U - 1);
(*ss << (" ")); 
}  
if (((void)cpptestFastCoverageStmt(624 + 0 + 6U - 1), adds_)) { cpptestFastCoverageStmt(624 + 0 + 7U - 1);
((((*ss << ("+")) << right_start_) << (",")) << (adds_ + common_)); 
}  cpptestFastCoverageStmt(624 + 0 + 8U - 1);
(*ss << (" @@\n")); 
} 

size_t left_start_, right_start_; 
size_t adds_, removes_, common_; 
std::__cxx11::list< std::pair< char, const char *> >  hunk_, hunk_adds_, hunk_removes_; 
}; 

}
# 1250 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string CreateUnifiedDiff(const std::vector< std::__cxx11::basic_string< char> >  &left, const std::vector< std::__cxx11::basic_string< char> >  &
right, size_t 
context) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(632 + 0 + 1U - 1);
const std::vector< EditType>  edits = CalculateOptimalEdits(left, right); cpptestFastCoverageStmt(632 + 0 + 2U - 1);

size_t l_i = (0), r_i = (0), edit_i = (0); cpptestFastCoverageStmt(632 + 0 + 3U - 1);
std::stringstream ss; 
while (((void)cpptestFastCoverageStmt(632 + 0 + 4U - 1), edit_i < edits.size())) { 

while (((void)cpptestFastCoverageStmt(632 + 0 + 5U - 1), edit_i < edits.size() && edits[edit_i] == kMatch)) { cpptestFastCoverageStmt(632 + 0 + 6U - 1);
++l_i; cpptestFastCoverageStmt(632 + 0 + 7U - 1);
++r_i; cpptestFastCoverageStmt(632 + 0 + 8U - 1);
++edit_i; 
}  cpptestFastCoverageStmt(632 + 0 + 9U - 1);


const size_t prefix_context = std::min(l_i, context); cpptestFastCoverageStmt(632 + 0 + 10U - 1);
edit_distance::Hunk hunk((l_i - prefix_context) + 1, (r_i - prefix_context) + 1); cpptestFastCoverageStmt(632 + 0 + 11U - 1);
for (size_t i = prefix_context; ((void)cpptestFastCoverageStmt(632 + 0 + 12U - 1), i > 0); ((void)cpptestFastCoverageStmt(632 + 0 + 13U - 1), --i)) { cpptestFastCoverageStmt(632 + 0 + 14U - 1);
hunk.PushLine(' ', left[l_i - i].c_str()); 
}  cpptestFastCoverageStmt(632 + 0 + 15U - 1);



size_t n_suffix = (0); 
for (; ((void)cpptestFastCoverageStmt(632 + 0 + 16U - 1), edit_i < edits.size()); ((void)cpptestFastCoverageStmt(632 + 0 + 17U - 1), ++edit_i)) { 
if (((void)cpptestFastCoverageStmt(632 + 0 + 18U - 1), n_suffix >= context)) { cpptestFastCoverageStmt(632 + 0 + 19U - 1);

std::vector< EditType> ::const_iterator it = (edits.begin() + edit_i); 
while (((void)cpptestFastCoverageStmt(632 + 0 + 20U - 1), (it != edits.end()) && (*it) == kMatch)) {cpptestFastCoverageStmt(632 + 0 + 21U - 1);(++it); }  
if (((void)cpptestFastCoverageStmt(632 + 0 + 22U - 1), (it == edits.end()) || ((it - edits.begin())) - edit_i >= context)) { cpptestFastCoverageStmt(632 + 0 + 23U - 1);

break; 
}  
}  cpptestFastCoverageStmt(632 + 0 + 24U - 1);

EditType edit = edits[edit_i]; cpptestFastCoverageStmt(632 + 0 + 25U - 1);

n_suffix = (edit == kMatch) ? n_suffix + 1 : 0; 

if (((void)cpptestFastCoverageStmt(632 + 0 + 26U - 1), (edit == kMatch || edit == kRemove) || edit == kReplace)) { cpptestFastCoverageStmt(632 + 0 + 27U - 1);
hunk.PushLine((edit == kMatch) ? ' ' : '-', left[l_i].c_str()); 
}  
if (((void)cpptestFastCoverageStmt(632 + 0 + 28U - 1), edit == kAdd || edit == kReplace)) { cpptestFastCoverageStmt(632 + 0 + 29U - 1);
hunk.PushLine('+', right[r_i].c_str()); 
}  cpptestFastCoverageStmt(632 + 0 + 30U - 1);


l_i += edit != kAdd; cpptestFastCoverageStmt(632 + 0 + 31U - 1);
r_i += edit != kRemove; 
}  

if (((void)cpptestFastCoverageStmt(632 + 0 + 32U - 1), !hunk.has_edits())) { cpptestFastCoverageStmt(632 + 0 + 33U - 1);

break; 
}  cpptestFastCoverageStmt(632 + 0 + 34U - 1);

hunk.PrintTo(&ss); 
}  cpptestFastCoverageStmt(632 + 0 + 35U - 1);
return ss.str(); 
} 

}

namespace { 




std::vector< std::__cxx11::basic_string< char> >  SplitEscapedString(const std::string &str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(667 + 0 + 1U - 1);
std::vector< std::__cxx11::basic_string< char> >  lines; cpptestFastCoverageStmt(667 + 0 + 2U - 1);
size_t start = (0), end = str.size(); 
if (((void)cpptestFastCoverageStmt(667 + 0 + 3U - 1), (end > 2 && str[0] == '\"') && str[end - 1] == '\"')) { cpptestFastCoverageStmt(667 + 0 + 4U - 1);
++start; cpptestFastCoverageStmt(667 + 0 + 5U - 1);
--end; 
}  cpptestFastCoverageStmt(667 + 0 + 6U - 1);
bool escaped = false; cpptestFastCoverageStmt(667 + 0 + 7U - 1);
for (size_t i = start; ((void)cpptestFastCoverageStmt(667 + 0 + 8U - 1), i + 1 < end); ((void)cpptestFastCoverageStmt(667 + 0 + 9U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(667 + 0 + 10U - 1), escaped)) { cpptestFastCoverageStmt(667 + 0 + 11U - 1);
escaped = false; 
if (((void)cpptestFastCoverageStmt(667 + 0 + 12U - 1), str[i] == 'n')) { cpptestFastCoverageStmt(667 + 0 + 13U - 1);
lines.push_back(str.substr(start, (i - start) - 1)); cpptestFastCoverageStmt(667 + 0 + 14U - 1);
start = i + 1; 
}  
} else { cpptestFastCoverageStmt(667 + 0 + 15U - 1);
escaped = str[i] == '\\'; 
}  
}  cpptestFastCoverageStmt(667 + 0 + 16U - 1);
lines.push_back(str.substr(start, end - start)); cpptestFastCoverageStmt(667 + 0 + 17U - 1);
return lines; 
} 

}
# 1359 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
AssertionResult EqFailure(const char *lhs_expression, const char *
rhs_expression, const std::string &
lhs_value, const std::string &
rhs_value, bool 
ignoring_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(684 + 0 + 1U - 1);
Message msg; cpptestFastCoverageStmt(684 + 0 + 2U - 1);
(msg << ("Expected equality of these values:")); cpptestFastCoverageStmt(684 + 0 + 3U - 1);
((msg << ("\n  ")) << lhs_expression); 
if (((void)cpptestFastCoverageStmt(684 + 0 + 4U - 1), (lhs_value != lhs_expression))) { cpptestFastCoverageStmt(684 + 0 + 5U - 1);
((msg << ("\n    Which is: ")) << lhs_value); 
}  cpptestFastCoverageStmt(684 + 0 + 6U - 1);
((msg << ("\n  ")) << rhs_expression); 
if (((void)cpptestFastCoverageStmt(684 + 0 + 7U - 1), (rhs_value != rhs_expression))) { cpptestFastCoverageStmt(684 + 0 + 8U - 1);
((msg << ("\n    Which is: ")) << rhs_value); 
}  

if (((void)cpptestFastCoverageStmt(684 + 0 + 9U - 1), ignoring_case)) { cpptestFastCoverageStmt(684 + 0 + 10U - 1);
(msg << ("\nIgnoring case")); 
}  

if (((void)cpptestFastCoverageStmt(684 + 0 + 11U - 1), !lhs_value.empty() && !rhs_value.empty())) { cpptestFastCoverageStmt(684 + 0 + 12U - 1);
const std::vector< std::__cxx11::basic_string< char> >  lhs_lines = SplitEscapedString(lhs_value); cpptestFastCoverageStmt(684 + 0 + 13U - 1);

const std::vector< std::__cxx11::basic_string< char> >  rhs_lines = SplitEscapedString(rhs_value); 

if (((void)cpptestFastCoverageStmt(684 + 0 + 14U - 1), lhs_lines.size() > 1 || rhs_lines.size() > 1)) { cpptestFastCoverageStmt(684 + 0 + 15U - 1);
((msg << ("\nWith diff:\n")) << edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines)); 

}  
}  cpptestFastCoverageStmt(684 + 0 + 16U - 1);

return (AssertionFailure() << msg); 
} 


std::string GetBoolAssertionFailureMessage(const AssertionResult &
assertion_result, const char *
expression_text, const char *
actual_predicate_value, const char *
expected_predicate_value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(700 + 0 + 1U - 1);
const char *actual_message = assertion_result.message(); cpptestFastCoverageStmt(700 + 0 + 2U - 1);
Message msg; cpptestFastCoverageStmt(700 + 0 + 3U - 1);
((((msg << ("Value of: ")) << expression_text) << ("\n  Actual: ")) << actual_predicate_value); 

if (((void)cpptestFastCoverageStmt(700 + 0 + 4U - 1), actual_message[0] != '\000')) {cpptestFastCoverageStmt(700 + 0 + 5U - 1);
(((msg << (" (")) << actual_message) << (")")); }  cpptestFastCoverageStmt(700 + 0 + 6U - 1);
((msg << ("\nExpected: ")) << expected_predicate_value); cpptestFastCoverageStmt(700 + 0 + 7U - 1);
return msg.GetString(); 
} 


AssertionResult DoubleNearPredFormat(const char *expr1, const char *
expr2, const char *
abs_error_expr, double 
val1, double 
val2, double 
abs_error) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(707 + 0 + 1U - 1);
const double diff = fabs(val1 - val2); 
if (((void)cpptestFastCoverageStmt(707 + 0 + 2U - 1), diff <= abs_error)) {cpptestFastCoverageStmt(707 + 0 + 3U - 1);return AssertionSuccess(); }  cpptestFastCoverageStmt(707 + 0 + 4U - 1);



return (((((((((((((((((((((AssertionFailure() << ("The difference between ")) << expr1) << (" and ")) << expr2) << (" is ")) << diff) << (", which exceeds ")) << abs_error_expr) << (", where\n")) << expr1) << (" evaluates to ")) << val1) << (",\n")) << expr2) << (" evaluates to ")) << val2) << (", and\n")) << abs_error_expr) << (" evaluates to ")) << abs_error) << (".")); 
# 1427
} 



template < typename RawType > 
AssertionResult FloatingPointLE (const char * expr1 , 
const char * expr2 , 
RawType val1 , 
RawType val2) { 

if (val1 < val2) { 
return AssertionSuccess () ; 
} 


const FloatingPoint < RawType > lhs (val1) , rhs (val2) ; 
if (lhs . AlmostEquals (rhs)) { 
return AssertionSuccess () ; 
} 
# 1451
:: std :: stringstream val1_ss ; 
val1_ss << std :: setprecision (std :: numeric_limits < RawType > :: digits10 + 2) 
<< val1 ; 

:: std :: stringstream val2_ss ; 
val2_ss << std :: setprecision (std :: numeric_limits < RawType > :: digits10 + 2) 
<< val2 ; 

return AssertionFailure () 
<< "Expected: (" << expr1 << ") <= (" << expr2 << ")\n" 
<< "  Actual: " << StringStreamToString (& val1_ss) << " vs " 
<< StringStreamToString (& val2_ss) ; 
} 

}



AssertionResult FloatLE(const char *expr1, const char *expr2, float 
val1, float val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(711 + 0 + 1U - 1);
return internal::FloatingPointLE< float> (expr1, expr2, val1, val2); 
} 



AssertionResult DoubleLE(const char *expr1, const char *expr2, double 
val1, double val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(712 + 0 + 1U - 1);
return internal::FloatingPointLE< double> (expr1, expr2, val1, val2); 
} 

namespace internal { 



AssertionResult CmpHelperEQ(const char *lhs_expression, const char *
rhs_expression, BiggestInt 
lhs, BiggestInt 
rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(713 + 0 + 1U - 1), lhs == rhs)) { cpptestFastCoverageStmt(713 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(713 + 0 + 3U - 1);

return EqFailure(lhs_expression, rhs_expression, FormatForComparisonFailureMessage(lhs, rhs), FormatForComparisonFailureMessage(rhs, lhs), false); 




} 
# 1518 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
AssertionResult CmpHelperNE(const char *expr1, const char *expr2, BiggestInt val1, BiggestInt val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(716 + 0 + 1U - 1), val1 != val2)) { cpptestFastCoverageStmt(716 + 0 + 2U - 1);return AssertionSuccess(); } else { cpptestFastCoverageStmt(716 + 0 + 3U - 1);return ((((((((AssertionFailure() << ("Expected: (")) << expr1) << (") != (")) << expr2) << ("), actual: ")) << FormatForComparisonFailureMessage(val1, val2)) << (" vs ")) << FormatForComparisonFailureMessage(val2, val1)); }  } 


AssertionResult CmpHelperLE(const char *expr1, const char *expr2, BiggestInt val1, BiggestInt val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(719 + 0 + 1U - 1), val1 <= val2)) { cpptestFastCoverageStmt(719 + 0 + 2U - 1);return AssertionSuccess(); } else { cpptestFastCoverageStmt(719 + 0 + 3U - 1);return ((((((((AssertionFailure() << ("Expected: (")) << expr1) << (") <= (")) << expr2) << ("), actual: ")) << FormatForComparisonFailureMessage(val1, val2)) << (" vs ")) << FormatForComparisonFailureMessage(val2, val1)); }  } 


AssertionResult CmpHelperLT(const char *expr1, const char *expr2, BiggestInt val1, BiggestInt val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(722 + 0 + 1U - 1), val1 < val2)) { cpptestFastCoverageStmt(722 + 0 + 2U - 1);return AssertionSuccess(); } else { cpptestFastCoverageStmt(722 + 0 + 3U - 1);return ((((((((AssertionFailure() << ("Expected: (")) << expr1) << (") < (")) << expr2) << ("), actual: ")) << FormatForComparisonFailureMessage(val1, val2)) << (" vs ")) << FormatForComparisonFailureMessage(val2, val1)); }  } 


AssertionResult CmpHelperGE(const char *expr1, const char *expr2, BiggestInt val1, BiggestInt val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(725 + 0 + 1U - 1), val1 >= val2)) { cpptestFastCoverageStmt(725 + 0 + 2U - 1);return AssertionSuccess(); } else { cpptestFastCoverageStmt(725 + 0 + 3U - 1);return ((((((((AssertionFailure() << ("Expected: (")) << expr1) << (") >= (")) << expr2) << ("), actual: ")) << FormatForComparisonFailureMessage(val1, val2)) << (" vs ")) << FormatForComparisonFailureMessage(val2, val1)); }  } 


AssertionResult CmpHelperGT(const char *expr1, const char *expr2, BiggestInt val1, BiggestInt val2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(728 + 0 + 1U - 1), val1 > val2)) { cpptestFastCoverageStmt(728 + 0 + 2U - 1);return AssertionSuccess(); } else { cpptestFastCoverageStmt(728 + 0 + 3U - 1);return ((((((((AssertionFailure() << ("Expected: (")) << expr1) << (") > (")) << expr2) << ("), actual: ")) << FormatForComparisonFailureMessage(val1, val2)) << (" vs ")) << FormatForComparisonFailureMessage(val2, val1)); }  } 




AssertionResult CmpHelperSTREQ(const char *lhs_expression, const char *
rhs_expression, const char *
lhs, const char *
rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(731 + 0 + 1U - 1), String::CStringEquals(lhs, rhs))) { cpptestFastCoverageStmt(731 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(731 + 0 + 3U - 1);

return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs), PrintToString(rhs), false); 




} 


AssertionResult CmpHelperSTRCASEEQ(const char *lhs_expression, const char *
rhs_expression, const char *
lhs, const char *
rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(734 + 0 + 1U - 1), String::CaseInsensitiveCStringEquals(lhs, rhs))) { cpptestFastCoverageStmt(734 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(734 + 0 + 3U - 1);

return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs), PrintToString(rhs), true); 




} 


AssertionResult CmpHelperSTRNE(const char *s1_expression, const char *
s2_expression, const char *
s1, const char *
s2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(737 + 0 + 1U - 1), !String::CStringEquals(s1, s2))) { cpptestFastCoverageStmt(737 + 0 + 2U - 1);
return AssertionSuccess(); 
} else { cpptestFastCoverageStmt(737 + 0 + 3U - 1);
return (((((((((AssertionFailure() << ("Expected: (")) << s1_expression) << (") != (")) << s2_expression) << ("), actual: \"")) << s1) << ("\" vs \"")) << s2) << ("\"")); 


}  
} 


AssertionResult CmpHelperSTRCASENE(const char *s1_expression, const char *
s2_expression, const char *
s1, const char *
s2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(740 + 0 + 1U - 1), !String::CaseInsensitiveCStringEquals(s1, s2))) { cpptestFastCoverageStmt(740 + 0 + 2U - 1);
return AssertionSuccess(); 
} else { cpptestFastCoverageStmt(740 + 0 + 3U - 1);
return (((((((((AssertionFailure() << ("Expected: (")) << s1_expression) << (") != (")) << s2_expression) << (") (ignoring case), actual: \"")) << s1) << ("\" vs \"")) << s2) << ("\"")); 



}  
} 

}

namespace { 
# 1605
bool IsSubstringPred(const char *needle, const char *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(743 + 0 + 1U - 1), needle == (nullptr) || haystack == (nullptr))) {cpptestFastCoverageStmt(743 + 0 + 2U - 1);return needle == haystack; }  cpptestFastCoverageStmt(743 + 0 + 3U - 1);

return strstr(haystack, needle) != (nullptr); 
} 

bool IsSubstringPred(const wchar_t *needle, const wchar_t *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(746 + 0 + 1U - 1), needle == (nullptr) || haystack == (nullptr))) {cpptestFastCoverageStmt(746 + 0 + 2U - 1);return needle == haystack; }  cpptestFastCoverageStmt(746 + 0 + 3U - 1);

return wcsstr(haystack, needle) != (nullptr); 
} 


template < typename StringType > 
bool IsSubstringPred (const StringType & needle , 
const StringType & haystack) { 
return haystack . find (needle) != StringType :: npos ; 
} 
# 1628
template < typename StringType > 
AssertionResult IsSubstringImpl (
bool expected_to_be_substring , 
const char * needle_expr , const char * haystack_expr , 
const StringType & needle , const StringType & haystack) { 
if (IsSubstringPred (needle , haystack) == expected_to_be_substring) 
return AssertionSuccess () ; 

const bool is_wide_string = sizeof (needle [ 0 ]) > 1 ; 
const char * const begin_string_quote = is_wide_string ? "L\"" : "\"" ; 
return AssertionFailure () 
<< "Value of: " << needle_expr << "\n" 
<< "  Actual: " << begin_string_quote << needle << "\"\n" 
<< "Expected: " << (expected_to_be_substring ? "" : "not ") 
<< "a substring of " << haystack_expr << "\n" 
<< "Which is: " << begin_string_quote << haystack << "\"" ; 
} 

}
# 1652
AssertionResult IsSubstring(const char *
needle_expr, const char *haystack_expr, const char *
needle, const char *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(749 + 0 + 1U - 1);
return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsSubstring(const char *
needle_expr, const char *haystack_expr, const wchar_t *
needle, const wchar_t *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(750 + 0 + 1U - 1);
return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsNotSubstring(const char *
needle_expr, const char *haystack_expr, const char *
needle, const char *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(751 + 0 + 1U - 1);
return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsNotSubstring(const char *
needle_expr, const char *haystack_expr, const wchar_t *
needle, const wchar_t *haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(752 + 0 + 1U - 1);
return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsSubstring(const char *
needle_expr, const char *haystack_expr, const std::string &
needle, const std::string &haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(753 + 0 + 1U - 1);
return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsNotSubstring(const char *
needle_expr, const char *haystack_expr, const std::string &
needle, const std::string &haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(754 + 0 + 1U - 1);
return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack); 
} 


AssertionResult IsSubstring(const char *
needle_expr, const char *haystack_expr, const std::wstring &
needle, const std::wstring &haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(755 + 0 + 1U - 1);
return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack); 
} 

AssertionResult IsNotSubstring(const char *
needle_expr, const char *haystack_expr, const std::wstring &
needle, const std::wstring &haystack) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(756 + 0 + 1U - 1);
return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack); 
} 


namespace internal { 



namespace { 


AssertionResult HRESULTFailureHelper(const char *expr, const char *
expected, long 
hr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(757 + 0 + 1U - 1);
# 1722 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const DWORD kFlags = (4096 | 512); cpptestFastCoverageStmt(757 + 0 + 2U - 1);
# 1724 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const DWORD kBufSize = (4096); cpptestFastCoverageStmt(757 + 0 + 3U - 1);

char error_text[kBufSize] = {'\000'}; cpptestFastCoverageStmt(757 + 0 + 4U - 1);
DWORD message_length = ::FormatMessageA(kFlags, 0, hr, 0, error_text, kBufSize, __null); 
# 1735 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
for (; ((void)cpptestFastCoverageStmt(757 + 0 + 5U - 1), message_length && IsSpace((error_text)[message_length - 1])); ((void)cpptestFastCoverageStmt(757 + 0 + 6U - 1), --message_length)) 
{ cpptestFastCoverageStmt(757 + 0 + 7U - 1);
(error_text)[message_length - 1] = '\000'; 
}  cpptestFastCoverageStmt(757 + 0 + 8U - 1);



const std::string error_hex((("0x") + String::FormatHexInt(hr))); cpptestFastCoverageStmt(757 + 0 + 9U - 1);
return ((((((((((::testing::AssertionFailure() << ("Expected: ")) << expr) << (" ")) << expected) << (".\n")) << ("  Actual: ")) << error_hex) << (" ")) << error_text) << ("\n")); 


} 

}

AssertionResult IsHRESULTSuccess(const char *expr, long hr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(766 + 0 + 1U - 1), ((HRESULT)(hr) >= 0))) 
# 1751 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
{ cpptestFastCoverageStmt(766 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(766 + 0 + 3U - 1);
return HRESULTFailureHelper(expr, "succeeds", hr); 
} 

AssertionResult IsHRESULTFailure(const char *expr, long hr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(769 + 0 + 1U - 1), ((HRESULT)(hr) < 0))) 
# 1758 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
{ cpptestFastCoverageStmt(769 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(769 + 0 + 3U - 1);
return HRESULTFailureHelper(expr, "fails", hr); 
} 
# 1779 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const UInt32 kMaxCodePoint1 = ((static_cast< UInt32>(1) << 7) - 1); 


const UInt32 kMaxCodePoint2 = ((static_cast< UInt32>(1) << (5 + 6)) - 1); 


const UInt32 kMaxCodePoint3 = ((static_cast< UInt32>(1) << (4 + 2 * 6)) - 1); 


const UInt32 kMaxCodePoint4 = ((static_cast< UInt32>(1) << (3 + 3 * 6)) - 1); 




inline UInt32 ChopLowBits(UInt32 *bits, int n) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(772 + 0 + 1U - 1);
const UInt32 low_bits = *bits & ((static_cast< UInt32>(1) << n) - 1); cpptestFastCoverageStmt(772 + 0 + 2U - 1);
*bits >>= n; cpptestFastCoverageStmt(772 + 0 + 3U - 1);
return low_bits; 
} 
# 1805
std::string CodePointToUtf8(UInt32 code_point) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(775 + 0 + 1U - 1), code_point > kMaxCodePoint4)) { cpptestFastCoverageStmt(775 + 0 + 2U - 1);
return ((("(Invalid Unicode 0x") + String::FormatHexInt(code_point)) + (")")); 
}  cpptestFastCoverageStmt(775 + 0 + 3U - 1);

char str[5]; 
if (((void)cpptestFastCoverageStmt(775 + 0 + 4U - 1), code_point <= kMaxCodePoint1)) { cpptestFastCoverageStmt(775 + 0 + 5U - 1);
(str)[1] = '\000'; cpptestFastCoverageStmt(775 + 0 + 6U - 1);
(str)[0] = static_cast< char>(code_point); 
} else if (((void)cpptestFastCoverageStmt(775 + 0 + 7U - 1), code_point <= kMaxCodePoint2)) { cpptestFastCoverageStmt(775 + 0 + 8U - 1);
(str)[2] = '\000'; cpptestFastCoverageStmt(775 + 0 + 9U - 1);
(str)[1] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 10U - 1);
(str)[0] = static_cast< char>(0xc0 | code_point); 
} else if (((void)cpptestFastCoverageStmt(775 + 0 + 11U - 1), code_point <= kMaxCodePoint3)) { cpptestFastCoverageStmt(775 + 0 + 12U - 1);
(str)[3] = '\000'; cpptestFastCoverageStmt(775 + 0 + 13U - 1);
(str)[2] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 14U - 1);
(str)[1] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 15U - 1);
(str)[0] = static_cast< char>(0xe0 | code_point); 
} else { cpptestFastCoverageStmt(775 + 0 + 16U - 1);
(str)[4] = '\000'; cpptestFastCoverageStmt(775 + 0 + 17U - 1);
(str)[3] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 18U - 1);
(str)[2] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 19U - 1);
(str)[1] = static_cast< char>(0x80 | ChopLowBits(&code_point, 6)); cpptestFastCoverageStmt(775 + 0 + 20U - 1);
(str)[0] = static_cast< char>(0xf0 | code_point); 
}      cpptestFastCoverageStmt(775 + 0 + 21U - 1);
return str; 
} 
# 1840 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(796 + 0 + 1U - 1);
return (sizeof(wchar_t) == 2 && (first & 0xfc00) == 0xd800) && (second & 0xfc00) == 0xdc00; 

} 


inline UInt32 CreateCodePointFromUtf16SurrogatePair(wchar_t first, wchar_t 
second) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(797 + 0 + 1U - 1);
const UInt32 mask = ((1 << 10) - 1); cpptestFastCoverageStmt(797 + 0 + 2U - 1);
return (sizeof(wchar_t) == 2) ? (((first & mask) << 10) | (second & mask)) + 0x10000 : (static_cast< UInt32>(first)); 




} 
# 1869 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string WideStringToUtf8(const wchar_t *str, int num_chars) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(799 + 0 + 1U - 1), num_chars == -1)) {cpptestFastCoverageStmt(799 + 0 + 2U - 1);
num_chars = static_cast< int>(wcslen(str)); }  cpptestFastCoverageStmt(799 + 0 + 3U - 1);

std::stringstream stream; cpptestFastCoverageStmt(799 + 0 + 4U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(799 + 0 + 5U - 1), i < num_chars); ((void)cpptestFastCoverageStmt(799 + 0 + 6U - 1), ++i)) { cpptestFastCoverageStmt(799 + 0 + 7U - 1);
UInt32 unicode_code_point; 

if (((void)cpptestFastCoverageStmt(799 + 0 + 8U - 1), str[i] == L'\x0')) { cpptestFastCoverageStmt(799 + 0 + 9U - 1);
break; 
} else if (((void)cpptestFastCoverageStmt(799 + 0 + 10U - 1), i + 1 < num_chars && IsUtf16SurrogatePair(str[i], str[i + 1]))) { cpptestFastCoverageStmt(799 + 0 + 11U - 1);
unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i], str[i + 1]); cpptestFastCoverageStmt(799 + 0 + 12U - 1);

i++; 
} else { cpptestFastCoverageStmt(799 + 0 + 13U - 1);
unicode_code_point = static_cast< UInt32>(str[i]); 
}    cpptestFastCoverageStmt(799 + 0 + 14U - 1);

(stream << CodePointToUtf8(unicode_code_point)); 
}  cpptestFastCoverageStmt(799 + 0 + 15U - 1);
return StringStreamToString(&stream); 
} 



std::string String::ShowWideCString(const wchar_t *wide_c_str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(814 + 0 + 1U - 1), wide_c_str == (nullptr))) {cpptestFastCoverageStmt(814 + 0 + 2U - 1);return "(null)"; }  cpptestFastCoverageStmt(814 + 0 + 3U - 1);

return internal::WideStringToUtf8(wide_c_str, -1); 
} 
# 1906
bool String::WideCStringEquals(const wchar_t *lhs, const wchar_t *rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(817 + 0 + 1U - 1), lhs == (nullptr))) {cpptestFastCoverageStmt(817 + 0 + 2U - 1);return rhs == (nullptr); }  

if (((void)cpptestFastCoverageStmt(817 + 0 + 3U - 1), rhs == (nullptr))) {cpptestFastCoverageStmt(817 + 0 + 4U - 1);return false; }  cpptestFastCoverageStmt(817 + 0 + 5U - 1);

return wcscmp(lhs, rhs) == 0; 
} 


AssertionResult CmpHelperSTREQ(const char *lhs_expression, const char *
rhs_expression, const wchar_t *
lhs, const wchar_t *
rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(822 + 0 + 1U - 1), String::WideCStringEquals(lhs, rhs))) { cpptestFastCoverageStmt(822 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(822 + 0 + 3U - 1);

return EqFailure(lhs_expression, rhs_expression, PrintToString(lhs), PrintToString(rhs), false); 




} 


AssertionResult CmpHelperSTRNE(const char *s1_expression, const char *
s2_expression, const wchar_t *
s1, const wchar_t *
s2) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(825 + 0 + 1U - 1), !String::WideCStringEquals(s1, s2))) { cpptestFastCoverageStmt(825 + 0 + 2U - 1);
return AssertionSuccess(); 
}  cpptestFastCoverageStmt(825 + 0 + 3U - 1);

return ((((((((AssertionFailure() << ("Expected: (")) << s1_expression) << (") != (")) << s2_expression) << ("), actual: ")) << PrintToString(s1)) << (" vs ")) << PrintToString(s2)); 



} 
# 1951
bool String::CaseInsensitiveCStringEquals(const char *lhs, const char *rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(828 + 0 + 1U - 1), lhs == (nullptr))) {cpptestFastCoverageStmt(828 + 0 + 2U - 1);return rhs == (nullptr); }  
if (((void)cpptestFastCoverageStmt(828 + 0 + 3U - 1), rhs == (nullptr))) {cpptestFastCoverageStmt(828 + 0 + 4U - 1);return false; }  cpptestFastCoverageStmt(828 + 0 + 5U - 1);
return posix::StrCaseCmp(lhs, rhs) == 0; 
} 
# 1969 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
bool String::CaseInsensitiveWideCStringEquals(const wchar_t *lhs, const wchar_t *
rhs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(833 + 0 + 1U - 1), lhs == (nullptr))) {cpptestFastCoverageStmt(833 + 0 + 2U - 1);return rhs == (nullptr); }  

if (((void)cpptestFastCoverageStmt(833 + 0 + 3U - 1), rhs == (nullptr))) {cpptestFastCoverageStmt(833 + 0 + 4U - 1);return false; }  cpptestFastCoverageStmt(833 + 0 + 5U - 1);


return _wcsicmp(lhs, rhs) == 0; 
# 1989 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 



bool String::EndsWithCaseInsensitive(const std::string &
str, const std::string &suffix) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(838 + 0 + 1U - 1);
const size_t str_len = str.length(); cpptestFastCoverageStmt(838 + 0 + 2U - 1);
const size_t suffix_len = suffix.length(); cpptestFastCoverageStmt(838 + 0 + 3U - 1);
return (str_len >= suffix_len) && CaseInsensitiveCStringEquals((str.c_str() + str_len) - suffix_len, suffix.c_str()); 


} 


std::string String::FormatIntWidth2(int value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(841 + 0 + 1U - 1);
std::stringstream ss; cpptestFastCoverageStmt(841 + 0 + 2U - 1);
(((ss << std::setfill('0')) << std::setw(2)) << value); cpptestFastCoverageStmt(841 + 0 + 3U - 1);
return ss.str(); 
} 


std::string String::FormatHexInt(int value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(844 + 0 + 1U - 1);
std::stringstream ss; cpptestFastCoverageStmt(844 + 0 + 2U - 1);
(((ss << (std::hex)) << (std::uppercase)) << value); cpptestFastCoverageStmt(844 + 0 + 3U - 1);
return ss.str(); 
} 


std::string String::FormatByte(unsigned char value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(847 + 0 + 1U - 1);
std::stringstream ss; cpptestFastCoverageStmt(847 + 0 + 2U - 1);
(((((ss << std::setfill('0')) << std::setw(2)) << (std::hex)) << (std::uppercase)) << static_cast< unsigned>(value)); cpptestFastCoverageStmt(847 + 0 + 3U - 1);

return ss.str(); 
} 



std::string StringStreamToString(std::stringstream *ss) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(850 + 0 + 1U - 1);
const std::string &str = ss->str(); cpptestFastCoverageStmt(850 + 0 + 2U - 1);
const char *const start = str.c_str(); cpptestFastCoverageStmt(850 + 0 + 3U - 1);
const char *const end = start + str.length(); cpptestFastCoverageStmt(850 + 0 + 4U - 1);

std::string result; cpptestFastCoverageStmt(850 + 0 + 5U - 1);
result.reserve(2 * (end - start)); cpptestFastCoverageStmt(850 + 0 + 6U - 1);
for (const char *ch = start; ((void)cpptestFastCoverageStmt(850 + 0 + 7U - 1), ch != end); ((void)cpptestFastCoverageStmt(850 + 0 + 8U - 1), ++ch)) { 
if (((void)cpptestFastCoverageStmt(850 + 0 + 9U - 1), *ch == '\000')) { cpptestFastCoverageStmt(850 + 0 + 10U - 1);
(result += ("\\0")); 
} else { cpptestFastCoverageStmt(850 + 0 + 11U - 1);
(result += *ch); 
}  
}  cpptestFastCoverageStmt(850 + 0 + 12U - 1);

return result; 
} 


std::string AppendUserMessage(const std::string &gtest_msg, const Message &
user_msg) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(862 + 0 + 1U - 1);

const std::string user_msg_string = user_msg.GetString(); 
if (((void)cpptestFastCoverageStmt(862 + 0 + 2U - 1), user_msg_string.empty())) { cpptestFastCoverageStmt(862 + 0 + 3U - 1);
return gtest_msg; 
}  cpptestFastCoverageStmt(862 + 0 + 4U - 1);

return ((gtest_msg + ("\n")) + user_msg_string); 
} 

}




TestResult::TestResult() : death_test_count_(0), elapsed_time_((0)) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(866 + 0 + 1U - 1);
} 


TestResult::~TestResult() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(867 + 0 + 1U - 1);
} 




const TestPartResult &TestResult::GetTestPartResult(int i) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(868 + 0 + 1U - 1), i < 0 || i >= this->total_part_count())) {cpptestFastCoverageStmt(868 + 0 + 2U - 1);
internal::posix::Abort(); }  cpptestFastCoverageStmt(868 + 0 + 3U - 1);
return (test_part_results_).at(i); 
} 




const TestProperty &TestResult::GetTestProperty(int i) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(871 + 0 + 1U - 1), i < 0 || i >= this->test_property_count())) {cpptestFastCoverageStmt(871 + 0 + 2U - 1);
internal::posix::Abort(); }  cpptestFastCoverageStmt(871 + 0 + 3U - 1);
return (test_properties_).at(i); 
} 


void TestResult::ClearTestPartResults() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(874 + 0 + 1U - 1);
(test_part_results_).clear(); 
} 


void TestResult::AddTestPartResult(const TestPartResult &test_part_result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(875 + 0 + 1U - 1);
(test_part_results_).push_back(test_part_result); 
} 




void TestResult::RecordProperty(const std::string &xml_element, const TestProperty &
test_property) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(876 + 0 + 1U - 1), !ValidateTestProperty(xml_element, test_property))) { cpptestFastCoverageStmt(876 + 0 + 2U - 1);
return; 
}  cpptestFastCoverageStmt(876 + 0 + 3U - 1);
internal::MutexLock lock(&(test_properites_mutex_)); cpptestFastCoverageStmt(876 + 0 + 4U - 1);
const std::vector< TestProperty> ::iterator property_with_matching_key = std::find_if((test_properties_).begin(), (test_properties_).end(), ((internal::TestPropertyKeyIs)(test_property.key()))); 


if (((void)cpptestFastCoverageStmt(876 + 0 + 5U - 1), (property_with_matching_key == (test_properties_).end()))) { cpptestFastCoverageStmt(876 + 0 + 6U - 1);
(test_properties_).push_back(test_property); cpptestFastCoverageStmt(876 + 0 + 7U - 1);
return; 
}  cpptestFastCoverageStmt(876 + 0 + 8U - 1);
property_with_matching_key->SetValue(test_property.value()); 
} 



static const char *const kReservedTestSuitesAttributes[] = {("disabled"), ("errors"), ("failures"), ("name"), ("random_seed"), ("tests"), ("time"), ("timestamp")}; 
# 2132
static const char *const kReservedTestSuiteAttributes[] = {("disabled"), ("errors"), ("failures"), ("name"), ("tests"), ("time")}; 
# 2142
static const char *const kReservedTestCaseAttributes[] = {("classname"), ("name"), ("status"), ("time"), ("type_param"), ("value_param"), ("file"), ("line")}; 



template < int kSize > 
std :: vector < std :: string > ArrayAsVector (const char * const (& array) [ kSize ]) { 
return std :: vector < std :: string > (array , array + kSize) ; 
} 

static std::vector< std::__cxx11::basic_string< char> >  GetReservedAttributesForElement(const std::string &
xml_element) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(884 + 0 + 1U - 1), (xml_element == ("testsuites")))) { cpptestFastCoverageStmt(884 + 0 + 2U - 1);
return ArrayAsVector(kReservedTestSuitesAttributes); 
} else if (((void)cpptestFastCoverageStmt(884 + 0 + 3U - 1), (xml_element == ("testsuite")))) { cpptestFastCoverageStmt(884 + 0 + 4U - 1);
return ArrayAsVector(kReservedTestSuiteAttributes); 
} else if (((void)cpptestFastCoverageStmt(884 + 0 + 5U - 1), (xml_element == ("testcase")))) { cpptestFastCoverageStmt(884 + 0 + 6U - 1);
return ArrayAsVector(kReservedTestCaseAttributes); 
} else { 
switch (((void)cpptestFastCoverageStmt(884 + 0 + 7U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(884 + 0 + 8U - 1), ::testing::internal::IsTrue(false))) {cpptestFastCoverageStmt(884 + 0 + 9U - 1);; } else {cpptestFastCoverageStmt(884 + 0 + 10U - 1);(((internal::GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 2160).GetStream() << ("Condition false failed. ")) << ("Unrecognized xml_element provided: ")) << xml_element); }  }  
}      cpptestFastCoverageStmt(884 + 0 + 11U - 1);

return std::vector< std::__cxx11::basic_string< char> > (); 
} 

static std::string FormatWordList(const std::vector< std::__cxx11::basic_string< char> >  &words) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(895 + 0 + 1U - 1);
Message word_list; cpptestFastCoverageStmt(895 + 0 + 2U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(895 + 0 + 3U - 1), i < words.size()); ((void)cpptestFastCoverageStmt(895 + 0 + 4U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(895 + 0 + 5U - 1), i > 0 && words.size() > 2)) { cpptestFastCoverageStmt(895 + 0 + 6U - 1);
(word_list << (", ")); 
}  
if (((void)cpptestFastCoverageStmt(895 + 0 + 7U - 1), i == words.size() - 1)) { cpptestFastCoverageStmt(895 + 0 + 8U - 1);
(word_list << ("and ")); 
}  cpptestFastCoverageStmt(895 + 0 + 9U - 1);
(((word_list << ("\'")) << words[i]) << ("\'")); 
}  cpptestFastCoverageStmt(895 + 0 + 10U - 1);
return word_list.GetString(); 
} 

static bool ValidateTestPropertyName(const std::string &
property_name, const std::vector< std::__cxx11::basic_string< char> >  &
reserved_names) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(905 + 0 + 1U - 1), (std::find(reserved_names.begin(), reserved_names.end(), property_name) != reserved_names.end()))) 
{ cpptestFastCoverageStmt(905 + 0 + 2U - 1);
(internal::AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 2185, "Failed") = (((((((Message() << ("Reserved key used in RecordProperty(): ")) << property_name) << (" (")) << FormatWordList(reserved_names)) << (" are reserved by ")) << ("Google Test")) << (")"))); cpptestFastCoverageStmt(905 + 0 + 3U - 1);


return false; 
}  cpptestFastCoverageStmt(905 + 0 + 4U - 1);
return true; 
} 



bool TestResult::ValidateTestProperty(const std::string &xml_element, const TestProperty &
test_property) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(909 + 0 + 1U - 1);
return ValidateTestPropertyName(test_property.key(), GetReservedAttributesForElement(xml_element)); 

} 


void TestResult::Clear() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(910 + 0 + 1U - 1);
(test_part_results_).clear(); cpptestFastCoverageStmt(910 + 0 + 2U - 1);
(test_properties_).clear(); cpptestFastCoverageStmt(910 + 0 + 3U - 1);
death_test_count_ = 0; cpptestFastCoverageStmt(910 + 0 + 4U - 1);
elapsed_time_ = 0; 
} 


static bool TestPartSkipped(const TestPartResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(914 + 0 + 1U - 1);
return result.skipped(); 
} 


bool TestResult::Skipped() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(915 + 0 + 1U - 1);
return !this->Failed() && CountIf(test_part_results_, TestPartSkipped) > 0; 
} 


bool TestResult::Failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(916 + 0 + 1U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(916 + 0 + 2U - 1), i < this->total_part_count()); ((void)cpptestFastCoverageStmt(916 + 0 + 3U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(916 + 0 + 4U - 1), this->GetTestPartResult(i).failed())) {cpptestFastCoverageStmt(916 + 0 + 5U - 1);
return true; }  
}  cpptestFastCoverageStmt(916 + 0 + 6U - 1);
return false; 
} 


static bool TestPartFatallyFailed(const TestPartResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(922 + 0 + 1U - 1);
return result.fatally_failed(); 
} 


bool TestResult::HasFatalFailure() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(923 + 0 + 1U - 1);
return CountIf(test_part_results_, TestPartFatallyFailed) > 0; 
} 


static bool TestPartNonfatallyFailed(const TestPartResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(924 + 0 + 1U - 1);
return result.nonfatally_failed(); 
} 


bool TestResult::HasNonfatalFailure() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(925 + 0 + 1U - 1);
return CountIf(test_part_results_, TestPartNonfatallyFailed) > 0; 
} 



int TestResult::total_part_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(926 + 0 + 1U - 1);
return static_cast< int>((test_part_results_).size()); 
} 


int TestResult::test_property_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(927 + 0 + 1U - 1);
return static_cast< int>((test_properties_).size()); 
} 
# 2264
Test::Test() : gtest_flag_saver_(new internal::GTestFlagSaver) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(928 + 0 + 1U - 1);
} 




Test::~Test() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(929 + 0 + 1U - 1);
} 




void Test::SetUp() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(930 + 0 + 1U - 1);
} 




void Test::TearDown() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(931 + 0 + 1U - 1);
} 


void Test::RecordProperty(const std::string &key, const std::string &value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(932 + 0 + 1U - 1);
UnitTest::GetInstance()->RecordProperty(key, value); 
} 


void Test::RecordProperty(const std::string &key, int value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(933 + 0 + 1U - 1);
Message value_message; cpptestFastCoverageStmt(933 + 0 + 2U - 1);
(value_message << value); cpptestFastCoverageStmt(933 + 0 + 3U - 1);
RecordProperty(key, (value_message.GetString()).c_str()); 
} 

namespace internal { 

void ReportFailureInUnknownLocation(TestPartResult::Type result_type, const std::string &
message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(936 + 0 + 1U - 1);


UnitTest::GetInstance()->AddTestPartResult(result_type, nullptr, -1, message, ""); 
# 2310
} 

}
# 2319
bool Test::HasSameFixtureClass() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(937 + 0 + 1U - 1);
internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); cpptestFastCoverageStmt(937 + 0 + 2U - 1);
const TestCase *const test_case = impl->current_test_case(); cpptestFastCoverageStmt(937 + 0 + 3U - 1);


const TestInfo *const first_test_info = test_case->test_info_list()[0]; cpptestFastCoverageStmt(937 + 0 + 4U - 1);
const internal::TypeId first_fixture_id = first_test_info->fixture_class_id_; cpptestFastCoverageStmt(937 + 0 + 5U - 1);
const char *const first_test_name = first_test_info->name(); cpptestFastCoverageStmt(937 + 0 + 6U - 1);


const TestInfo *const this_test_info = impl->current_test_info(); cpptestFastCoverageStmt(937 + 0 + 7U - 1);
const internal::TypeId this_fixture_id = this_test_info->fixture_class_id_; cpptestFastCoverageStmt(937 + 0 + 8U - 1);
const char *const this_test_name = this_test_info->name(); 

if (((void)cpptestFastCoverageStmt(937 + 0 + 9U - 1), this_fixture_id != first_fixture_id)) { cpptestFastCoverageStmt(937 + 0 + 10U - 1);

const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId(); cpptestFastCoverageStmt(937 + 0 + 11U - 1);

const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId(); 

if (((void)cpptestFastCoverageStmt(937 + 0 + 12U - 1), first_is_TEST || this_is_TEST)) { cpptestFastCoverageStmt(937 + 0 + 13U - 1);
# 2346
const char *const TEST_name = first_is_TEST ? first_test_name : this_test_name; cpptestFastCoverageStmt(937 + 0 + 14U - 1);

const char *const TEST_F_name = first_is_TEST ? this_test_name : first_test_name; cpptestFastCoverageStmt(937 + 0 + 15U - 1);


(internal::AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 2351, "Failed") = (((((((((((((Message() << ("All tests in the same test case must use the same test fixture\n")) << ("class, so mixing TEST_F and TEST in the same test case is\n")) << ("illegal.  In test case ")) << this_test_info->test_case_name()) << (",\n")) << ("test ")) << TEST_F_name) << (" is defined using TEST_F but\n")) << ("test ")) << TEST_name) << (" is defined using TEST.  You probably\n")) << ("want to change the TEST to TEST_F or move it to another test\n")) << ("case."))); 
# 2360
} else { cpptestFastCoverageStmt(937 + 0 + 16U - 1);


(internal::AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 2363, "Failed") = (((((((((((((Message() << ("All tests in the same test case must use the same test fixture\n")) << ("class.  However, in test case ")) << this_test_info->test_case_name()) << (",\n")) << ("you defined test ")) << first_test_name) << (" and test ")) << this_test_name) << ("\n")) << ("using two different test fixture classes.  This can happen if\n")) << ("the two classes are from different namespaces or translation\n")) << ("units and have the same name.  You should probably rename one\n")) << ("of the classes to put the tests into different test cases."))); 
# 2373
}  cpptestFastCoverageStmt(937 + 0 + 17U - 1);
return false; 
}  cpptestFastCoverageStmt(937 + 0 + 18U - 1);

return true; 
} 
# 2397 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
namespace internal { 




static std::string FormatCxxExceptionMessage(const char *description, const char *
location) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(955 + 0 + 1U - 1);
Message message; 
if (((void)cpptestFastCoverageStmt(955 + 0 + 2U - 1), description != __null)) 
# 2405 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
{ cpptestFastCoverageStmt(955 + 0 + 3U - 1);
(((message << ("C++ exception with description \"")) << description) << ("\"")); 
} else { cpptestFastCoverageStmt(955 + 0 + 4U - 1);
(message << ("Unknown C++ exception")); 
}  cpptestFastCoverageStmt(955 + 0 + 5U - 1);
(((message << (" thrown in ")) << location) << (".")); cpptestFastCoverageStmt(955 + 0 + 6U - 1);

return message.GetString(); 
} 

static std::string PrintTestPartResultToString(const TestPartResult & test_part_result); 


GoogleTestFailureException::GoogleTestFailureException(const TestPartResult &
failure) : std::runtime_error((PrintTestPartResultToString(failure)).c_str()) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(961 + 0 + 1U - 1);} 
# 2432 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
template < class T , typename Result > 
Result HandleSehExceptionsInMethodIfSupported (
T * object , Result (T :: * method) () , const char * location) { 
# 2451 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
(void) location ; 
return (object ->* method) () ; 

} 




template < class T , typename Result > 
Result HandleExceptionsInMethodIfSupported (
T * object , Result (T :: * method) () , const char * location) { 
# 2485 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
if (internal :: GetUnitTestImpl () -> catch_exceptions ()) { 

try { 
return HandleSehExceptionsInMethodIfSupported (object , method , location) ; 
} catch (const AssertionException &) { 

} catch (const internal :: GoogleTestFailureException &) { 



throw ; 
} catch (const std :: exception & e) { 
internal :: ReportFailureInUnknownLocation (
TestPartResult :: kFatalFailure , 
FormatCxxExceptionMessage (e . what () , location)) ; 
} catch (...) { 
internal :: ReportFailureInUnknownLocation (
TestPartResult :: kFatalFailure , 
FormatCxxExceptionMessage (
# 2503 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc" 3
__null 
# 2503 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
, location)) ; 
} 
return static_cast < Result > (0) ; 



} else { 
return (object ->* method) () ; 
} 
} 

}


void Test::Run() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(962 + 0 + 1U - 1), !HasSameFixtureClass())) {cpptestFastCoverageStmt(962 + 0 + 2U - 1);return; }  cpptestFastCoverageStmt(962 + 0 + 3U - 1);

internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); cpptestFastCoverageStmt(962 + 0 + 4U - 1);
impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(962 + 0 + 5U - 1);
internal::HandleExceptionsInMethodIfSupported(this, &Test::SetUp, "SetUp()"); 

if (((void)cpptestFastCoverageStmt(962 + 0 + 6U - 1), !HasFatalFailure())) { cpptestFastCoverageStmt(962 + 0 + 7U - 1);
impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(962 + 0 + 8U - 1);
internal::HandleExceptionsInMethodIfSupported(this, &Test::TestBody, "the test body"); 

}  cpptestFastCoverageStmt(962 + 0 + 9U - 1);




impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(962 + 0 + 10U - 1);
internal::HandleExceptionsInMethodIfSupported(this, &Test::TearDown, "TearDown()"); 

} 


bool Test::HasFatalFailure() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(972 + 0 + 1U - 1);
return internal::GetUnitTestImpl()->current_test_result()->HasFatalFailure(); 
} 


bool Test::HasNonfatalFailure() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(973 + 0 + 1U - 1);
return internal::GetUnitTestImpl()->current_test_result()->HasNonfatalFailure(); 

} 


bool Test::IsSkipped() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(974 + 0 + 1U - 1);
return internal::GetUnitTestImpl()->current_test_result()->Skipped(); 
} 
# 2558
TestInfo::TestInfo(const std::string &a_test_case_name, const std::string &
a_name, const char *a_type_param, const char *
a_value_param, internal::CodeLocation 
a_code_location, internal::TypeId 
fixture_class_id, internal::TestFactoryBase *
factory) : test_case_name_(a_test_case_name), name_(a_name), type_param_((a_type_param) ? new std::string(a_type_param) : (nullptr)), value_param_((a_value_param) ? new std::string(a_value_param) : (nullptr)), location_(a_code_location), fixture_class_id_(fixture_class_id), should_run_(false), is_disabled_(false), matches_filter_(false), factory_(factory), result_() 
# 2574
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(975 + 0 + 1U - 1);} 


TestInfo::~TestInfo() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(976 + 0 + 1U - 1);delete (factory_); } 

namespace internal { 
# 2599 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
TestInfo *MakeAndRegisterTestInfo(const char *
test_case_name, const char *
name, const char *
type_param, const char *
value_param, CodeLocation 
code_location, TypeId 
fixture_class_id, SetUpTestCaseFunc 
set_up_tc, TearDownTestCaseFunc 
tear_down_tc, TestFactoryBase *
factory) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(977 + 0 + 1U - 1);
TestInfo *const test_info = new TestInfo(test_case_name, name, type_param, value_param, code_location, fixture_class_id, factory); cpptestFastCoverageStmt(977 + 0 + 2U - 1);


GetUnitTestImpl()->AddTestInfo(set_up_tc, tear_down_tc, test_info); cpptestFastCoverageStmt(977 + 0 + 3U - 1);
return test_info; 
} 

void ReportInvalidTestCaseType(const char *test_case_name, CodeLocation 
code_location) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(980 + 0 + 1U - 1);
Message errors; cpptestFastCoverageStmt(980 + 0 + 2U - 1);
((((((((((((errors << ("Attempted redefinition of test case ")) << test_case_name) << (".\n")) << ("All tests in the same test case must use the same test fixture\n")) << ("class.  However, in test case ")) << test_case_name) << (", you tried\n")) << ("to define a test using a fixture class different from the one\n")) << ("used earlier. This can happen if the two fixture classes are\n")) << ("from different namespaces and have the same name. You should\n")) << ("probably rename one of the classes to put the tests into different\n")) << ("test cases.")); cpptestFastCoverageStmt(980 + 0 + 3U - 1);
# 2629
(((GTestLog(::testing::internal::GTEST_ERROR, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 2629).GetStream() << FormatFileLocation((code_location.file).c_str(), code_location.line)) << (" ")) << errors.GetString()); 


} 
}

namespace { 
# 2645 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
class TestNameIs { 




public: explicit TestNameIs(const char *name) : name_(name) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(983 + 0 + 1U - 1);} 


bool operator()(const TestInfo *test_info) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(984 + 0 + 1U - 1);
return test_info && (test_info->name() == name_); 
} 


private: std::string name_; 
}; 

}

namespace internal { 




void UnitTestImpl::RegisterParameterizedTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(985 + 0 + 1U - 1), !parameterized_tests_registered_)) { cpptestFastCoverageStmt(985 + 0 + 2U - 1);
(parameterized_test_registry_).RegisterTests(); cpptestFastCoverageStmt(985 + 0 + 3U - 1);
parameterized_tests_registered_ = true; 
}  
} 

}



void TestInfo::Run() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(988 + 0 + 1U - 1), !should_run_)) {cpptestFastCoverageStmt(988 + 0 + 2U - 1);return; }  cpptestFastCoverageStmt(988 + 0 + 3U - 1);


internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); cpptestFastCoverageStmt(988 + 0 + 4U - 1);
impl->set_current_test_info(this); cpptestFastCoverageStmt(988 + 0 + 5U - 1);

TestEventListener *repeater = UnitTest::GetInstance()->listeners().repeater(); cpptestFastCoverageStmt(988 + 0 + 6U - 1);


repeater->OnTestStart(*this); cpptestFastCoverageStmt(988 + 0 + 7U - 1);

const TimeInMillis start = internal::GetTimeInMillis(); cpptestFastCoverageStmt(988 + 0 + 8U - 1);

impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(988 + 0 + 9U - 1);


Test *const test = internal::HandleExceptionsInMethodIfSupported(factory_, &internal::TestFactoryBase::CreateTest, "the test fixture\'s constructor"); 
# 2703
if (((void)cpptestFastCoverageStmt(988 + 0 + 10U - 1), !Test::HasFatalFailure())) { cpptestFastCoverageStmt(988 + 0 + 11U - 1);


test->Run(); 
}  cpptestFastCoverageStmt(988 + 0 + 12U - 1);


impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(988 + 0 + 13U - 1);
internal::HandleExceptionsInMethodIfSupported(test, &Test::DeleteSelf_, "the test fixture\'s destructor"); cpptestFastCoverageStmt(988 + 0 + 14U - 1);


(result_).set_elapsed_time(internal::GetTimeInMillis() - start); cpptestFastCoverageStmt(988 + 0 + 15U - 1);


repeater->OnTestEnd(*this); cpptestFastCoverageStmt(988 + 0 + 16U - 1);



impl->set_current_test_info(nullptr); 
} 




int TestCase::successful_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1004 + 0 + 1U - 1);
return CountIf(test_info_list_, TestPassed); 
} 


int TestCase::skipped_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1005 + 0 + 1U - 1);
return CountIf(test_info_list_, TestSkipped); 
} 


int TestCase::failed_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1006 + 0 + 1U - 1);
return CountIf(test_info_list_, TestFailed); 
} 


int TestCase::reportable_disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1007 + 0 + 1U - 1);
return CountIf(test_info_list_, TestReportableDisabled); 
} 


int TestCase::disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1008 + 0 + 1U - 1);
return CountIf(test_info_list_, TestDisabled); 
} 


int TestCase::reportable_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1009 + 0 + 1U - 1);
return CountIf(test_info_list_, TestReportable); 
} 


int TestCase::test_to_run_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1010 + 0 + 1U - 1);
return CountIf(test_info_list_, ShouldRunTest); 
} 


int TestCase::total_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1011 + 0 + 1U - 1);
return static_cast< int>((test_info_list_).size()); 
} 
# 2775 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
TestCase::TestCase(const char *a_name, const char *a_type_param, Test::SetUpTestCaseFunc 
set_up_tc, Test::TearDownTestCaseFunc 
tear_down_tc) : name_(a_name), type_param_((a_type_param) ? new std::string(a_type_param) : (nullptr)), set_up_tc_(set_up_tc), tear_down_tc_(tear_down_tc), should_run_(false), elapsed_time_((0)) 
# 2783
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1012 + 0 + 1U - 1);} 


TestCase::~TestCase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1013 + 0 + 1U - 1);

ForEach(test_info_list_, internal::Delete< TestInfo> ); 
} 



const TestInfo *TestCase::GetTestInfo(int i) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1014 + 0 + 1U - 1);
const int index = GetElementOr(test_indices_, i, -1); cpptestFastCoverageStmt(1014 + 0 + 2U - 1);
return (index < 0) ? nullptr : test_info_list_[index]; 
} 



TestInfo *TestCase::GetMutableTestInfo(int i) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1016 + 0 + 1U - 1);
const int index = GetElementOr(test_indices_, i, -1); cpptestFastCoverageStmt(1016 + 0 + 2U - 1);
return (index < 0) ? nullptr : test_info_list_[index]; 
} 



void TestCase::AddTestInfo(TestInfo *test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1018 + 0 + 1U - 1);
(test_info_list_).push_back(test_info); cpptestFastCoverageStmt(1018 + 0 + 2U - 1);
(test_indices_).push_back(static_cast< int>((test_indices_).size())); 
} 


void TestCase::Run() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1020 + 0 + 1U - 1), !should_run_)) {cpptestFastCoverageStmt(1020 + 0 + 2U - 1);return; }  cpptestFastCoverageStmt(1020 + 0 + 3U - 1);

internal::UnitTestImpl *const impl = internal::GetUnitTestImpl(); cpptestFastCoverageStmt(1020 + 0 + 4U - 1);
impl->set_current_test_case(this); cpptestFastCoverageStmt(1020 + 0 + 5U - 1);

TestEventListener *repeater = UnitTest::GetInstance()->listeners().repeater(); cpptestFastCoverageStmt(1020 + 0 + 6U - 1);

repeater->OnTestCaseStart(*this); cpptestFastCoverageStmt(1020 + 0 + 7U - 1);
impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(1020 + 0 + 8U - 1);
internal::HandleExceptionsInMethodIfSupported(this, &TestCase::RunSetUpTestCase, "SetUpTestCase()"); cpptestFastCoverageStmt(1020 + 0 + 9U - 1);


const internal::TimeInMillis start = internal::GetTimeInMillis(); cpptestFastCoverageStmt(1020 + 0 + 10U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1020 + 0 + 11U - 1), i < this->total_test_count()); ((void)cpptestFastCoverageStmt(1020 + 0 + 12U - 1), i++)) { cpptestFastCoverageStmt(1020 + 0 + 13U - 1);
this->GetMutableTestInfo(i)->Run(); 
}  cpptestFastCoverageStmt(1020 + 0 + 14U - 1);
elapsed_time_ = internal::GetTimeInMillis() - start; cpptestFastCoverageStmt(1020 + 0 + 15U - 1);

impl->os_stack_trace_getter()->UponLeavingGTest(); cpptestFastCoverageStmt(1020 + 0 + 16U - 1);
internal::HandleExceptionsInMethodIfSupported(this, &TestCase::RunTearDownTestCase, "TearDownTestCase()"); cpptestFastCoverageStmt(1020 + 0 + 17U - 1);


repeater->OnTestCaseEnd(*this); cpptestFastCoverageStmt(1020 + 0 + 18U - 1);
impl->set_current_test_case(nullptr); 
} 


void TestCase::ClearResult() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1038 + 0 + 1U - 1);
(ad_hoc_test_result_).Clear(); cpptestFastCoverageStmt(1038 + 0 + 2U - 1);
ForEach(test_info_list_, TestInfo::ClearTestResult); 
} 


void TestCase::ShuffleTests(internal::Random *random) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1040 + 0 + 1U - 1);
Shuffle(random, &(test_indices_)); 
} 


void TestCase::UnshuffleTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1041 + 0 + 1U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1041 + 0 + 2U - 1), i < (test_indices_).size()); ((void)cpptestFastCoverageStmt(1041 + 0 + 3U - 1), i++)) { cpptestFastCoverageStmt(1041 + 0 + 4U - 1);
test_indices_[i] = static_cast< int>(i); 
}  
} 
# 2863
static std::string FormatCountableNoun(int count, const char *
singular_form, const char *
plural_form) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1045 + 0 + 1U - 1);
return ((internal::StreamableToString(count) + (" ")) + ((count == 1) ? singular_form : plural_form)); 

} 


static std::string FormatTestCount(int test_count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1046 + 0 + 1U - 1);
return FormatCountableNoun(test_count, "test", "tests"); 
} 


static std::string FormatTestCaseCount(int test_case_count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1047 + 0 + 1U - 1);
return FormatCountableNoun(test_case_count, "test case", "test cases"); 
} 
# 2884
static const char *TestPartResultTypeToString(TestPartResult::Type type) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(1048 + 0 + 1U - 1), type)) { 
case TestPartResult::kSkip:  cpptestFastCoverageStmt(1048 + 0 + 2U - 1);
return "Skipped"; 
case TestPartResult::kSuccess:  cpptestFastCoverageStmt(1048 + 0 + 3U - 1);
return "Success"; 

case TestPartResult::kNonFatalFailure:  
case TestPartResult::kFatalFailure:  cpptestFastCoverageStmt(1048 + 0 + 4U - 1);



return "Failure\n"; 

default:  cpptestFastCoverageStmt(1048 + 0 + 5U - 1);
return "Unknown result type"; 
}  
} 

namespace internal { 


static std::string PrintTestPartResultToString(const TestPartResult &
test_part_result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1053 + 0 + 1U - 1);
return (((((Message() << internal::FormatFileLocation(test_part_result.file_name(), test_part_result.line_number())) << (" ")) << TestPartResultTypeToString(test_part_result.type())) << test_part_result.message())).GetString(); 




} 


static void PrintTestPartResult(const TestPartResult &test_part_result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1054 + 0 + 1U - 1);
const std::string &result = PrintTestPartResultToString(test_part_result); cpptestFastCoverageStmt(1054 + 0 + 2U - 1);

printf("%s\n", result.c_str()); cpptestFastCoverageStmt(1054 + 0 + 3U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1054 + 0 + 4U - 1);
# 2929 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
::OutputDebugStringA(result.c_str()); cpptestFastCoverageStmt(1054 + 0 + 5U - 1);
::OutputDebugStringA("\n"); 

} 
# 2983 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static const char *GetAnsiColorCode(GTestColor color) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(1059 + 0 + 1U - 1), color)) { 
case COLOR_RED:  cpptestFastCoverageStmt(1059 + 0 + 2U - 1);return "1"; 
case COLOR_GREEN:  cpptestFastCoverageStmt(1059 + 0 + 3U - 1);return "2"; 
case COLOR_YELLOW:  cpptestFastCoverageStmt(1059 + 0 + 4U - 1);return "3"; 
default:  cpptestFastCoverageStmt(1059 + 0 + 5U - 1);
return nullptr; 
}  cpptestFastCoverageStmt(1059 + 0 + 6U - 1);; 
} 




bool ShouldUseColor(bool stdout_is_tty) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1065 + 0 + 1U - 1);
const char *const gtest_color = FLAGS_gtest_color.c_str(); 

if (((void)cpptestFastCoverageStmt(1065 + 0 + 2U - 1), String::CaseInsensitiveCStringEquals(gtest_color, "auto"))) { cpptestFastCoverageStmt(1065 + 0 + 3U - 1);
# 3006
const char *const term = posix::GetEnv("TERM"); cpptestFastCoverageStmt(1065 + 0 + 4U - 1);
const bool term_supports_color = (((((((((String::CStringEquals(term, "xterm") || String::CStringEquals(term, "xterm-color")) || String::CStringEquals(term, "xterm-256color")) || String::CStringEquals(term, "screen")) || String::CStringEquals(term, "screen-256color")) || String::CStringEquals(term, "tmux")) || String::CStringEquals(term, "tmux-256color")) || String::CStringEquals(term, "rxvt-unicode")) || String::CStringEquals(term, "rxvt-unicode-256color")) || String::CStringEquals(term, "linux")) || String::CStringEquals(term, "cygwin"); cpptestFastCoverageStmt(1065 + 0 + 5U - 1);
# 3019
return stdout_is_tty && term_supports_color; 

}  cpptestFastCoverageStmt(1065 + 0 + 6U - 1);

return ((String::CaseInsensitiveCStringEquals(gtest_color, "yes") || String::CaseInsensitiveCStringEquals(gtest_color, "true")) || String::CaseInsensitiveCStringEquals(gtest_color, "t")) || String::CStringEquals(gtest_color, "1"); 
# 3030
} 
# 3036
void ColoredPrintf(GTestColor color, const char *fmt, ...) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1071 + 0 + 1U - 1);
va_list args; cpptestFastCoverageStmt(1071 + 0 + 2U - 1);
# 3038 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc" 3
__builtin_va_start(args,fmt); cpptestFastCoverageStmt(1071 + 0 + 3U - 1);
# 3044 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static const bool in_color_mode = ShouldUseColor(posix::IsATTY(posix::FileNo((&((_iob)[1])))) != 0); cpptestFastCoverageStmt(1071 + 0 + 4U - 1);
# 3046 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const bool use_color = in_color_mode && (color != COLOR_DEFAULT); 



if (((void)cpptestFastCoverageStmt(1071 + 0 + 5U - 1), !use_color)) { cpptestFastCoverageStmt(1071 + 0 + 6U - 1);
vprintf(fmt, args); cpptestFastCoverageStmt(1071 + 0 + 7U - 1);
# 3052 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc" 3
__builtin_va_end(args); cpptestFastCoverageStmt(1071 + 0 + 8U - 1);
# 3053 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
return; 
}  cpptestFastCoverageStmt(1071 + 0 + 9U - 1);
# 3078 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
printf("\033[0;3%sm", GetAnsiColorCode(color)); cpptestFastCoverageStmt(1071 + 0 + 10U - 1);
vprintf(fmt, args); cpptestFastCoverageStmt(1071 + 0 + 11U - 1);
printf("\033[m"); cpptestFastCoverageStmt(1071 + 0 + 12U - 1);
# 3082 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc" 3
__builtin_va_end(args); 
# 3083 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 



static const char kTypeParamLabel[] = "TypeParam"; 
static const char kValueParamLabel[] = "GetParam()"; 

static void PrintFullTestCommentIfPresent(const TestInfo &test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1083 + 0 + 1U - 1);
const char *const type_param = test_info.type_param(); cpptestFastCoverageStmt(1083 + 0 + 2U - 1);
const char *const value_param = test_info.value_param(); 

if (((void)cpptestFastCoverageStmt(1083 + 0 + 3U - 1), type_param != (nullptr) || value_param != (nullptr))) { cpptestFastCoverageStmt(1083 + 0 + 4U - 1);
printf(", where "); 
if (((void)cpptestFastCoverageStmt(1083 + 0 + 5U - 1), type_param != (nullptr))) { cpptestFastCoverageStmt(1083 + 0 + 6U - 1);
printf("%s = %s", kTypeParamLabel, type_param); 
if (((void)cpptestFastCoverageStmt(1083 + 0 + 7U - 1), value_param != (nullptr))) {cpptestFastCoverageStmt(1083 + 0 + 8U - 1);printf(" and "); }  
}  
if (((void)cpptestFastCoverageStmt(1083 + 0 + 9U - 1), value_param != (nullptr))) { cpptestFastCoverageStmt(1083 + 0 + 10U - 1);
printf("%s = %s", kValueParamLabel, value_param); 
}  
}  
} 




class PrettyUnitTestResultPrinter : public TestEventListener { 

public: PrettyUnitTestResultPrinter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1093 + 0 + 1U - 1);} 
static void PrintTestName(const char *test_case, const char *test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1094 + 0 + 1U - 1);
printf("%s.%s", test_case, test); 
} 


virtual void OnTestProgramStart(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1095 + 0 + 1U - 1);} 
virtual void OnTestIterationStart(const UnitTest & unit_test, int iteration); 
virtual void OnEnvironmentsSetUpStart(const UnitTest & unit_test); 
virtual void OnEnvironmentsSetUpEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1096 + 0 + 1U - 1);} 
virtual void OnTestCaseStart(const TestCase & test_case); 
virtual void OnTestStart(const TestInfo & test_info); 
virtual void OnTestPartResult(const TestPartResult & result); 
virtual void OnTestEnd(const TestInfo & test_info); 
virtual void OnTestCaseEnd(const TestCase & test_case); 
virtual void OnEnvironmentsTearDownStart(const UnitTest & unit_test); 
virtual void OnEnvironmentsTearDownEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1097 + 0 + 1U - 1);} 
virtual void OnTestIterationEnd(const UnitTest & unit_test, int iteration); 
virtual void OnTestProgramEnd(const UnitTest &) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1098 + 0 + 1U - 1);} 


private: static void PrintFailedTests(const UnitTest & unit_test); 
static void PrintSkippedTests(const UnitTest & unit_test); 
}; 


void PrettyUnitTestResultPrinter::OnTestIterationStart(const UnitTest &
unit_test, int iteration) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1099 + 0 + 1U - 1), FLAGS_gtest_repeat != 1)) {cpptestFastCoverageStmt(1099 + 0 + 2U - 1);
printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1); }  cpptestFastCoverageStmt(1099 + 0 + 3U - 1);

const char *const filter = FLAGS_gtest_filter.c_str(); 



if (((void)cpptestFastCoverageStmt(1099 + 0 + 4U - 1), !String::CStringEquals(filter, kUniversalFilter))) { cpptestFastCoverageStmt(1099 + 0 + 5U - 1);
ColoredPrintf(COLOR_YELLOW, "Note: %s filter = %s\n", "Google Test", filter); 

}  

if (((void)cpptestFastCoverageStmt(1099 + 0 + 6U - 1), internal::ShouldShard(kTestTotalShards, kTestShardIndex, false))) { cpptestFastCoverageStmt(1099 + 0 + 7U - 1);
const Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1); cpptestFastCoverageStmt(1099 + 0 + 8U - 1);
ColoredPrintf(COLOR_YELLOW, "Note: This is test shard %d of %s.\n", static_cast< int>(shard_index) + 1, internal::posix::GetEnv(kTestTotalShards)); 



}  

if (((void)cpptestFastCoverageStmt(1099 + 0 + 9U - 1), FLAGS_gtest_shuffle)) { cpptestFastCoverageStmt(1099 + 0 + 10U - 1);
ColoredPrintf(COLOR_YELLOW, "Note: Randomizing tests\' orders with a seed of %d .\n", unit_test.random_seed()); 


}  cpptestFastCoverageStmt(1099 + 0 + 11U - 1);

ColoredPrintf(COLOR_GREEN, "[==========] "); cpptestFastCoverageStmt(1099 + 0 + 12U - 1);
printf("Running %s from %s.\n", (FormatTestCount(unit_test.test_to_run_count())).c_str(), (FormatTestCaseCount(unit_test.test_case_to_run_count())).c_str()); cpptestFastCoverageStmt(1099 + 0 + 13U - 1);


fflush((&((_iob)[1]))); 
# 3170 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 

void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(const UnitTest &) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1112 + 0 + 1U - 1);
ColoredPrintf(COLOR_GREEN, "[----------] "); cpptestFastCoverageStmt(1112 + 0 + 2U - 1);
printf("Global test environment set-up.\n"); cpptestFastCoverageStmt(1112 + 0 + 3U - 1);
fflush((&((_iob)[1]))); 
# 3177 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 

void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase &test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1115 + 0 + 1U - 1);
const std::string counts = FormatCountableNoun(test_case.test_to_run_count(), "test", "tests"); cpptestFastCoverageStmt(1115 + 0 + 2U - 1);

ColoredPrintf(COLOR_GREEN, "[----------] "); cpptestFastCoverageStmt(1115 + 0 + 3U - 1);
printf("%s from %s", counts.c_str(), test_case.name()); 
if (((void)cpptestFastCoverageStmt(1115 + 0 + 4U - 1), test_case.type_param() == (nullptr))) { cpptestFastCoverageStmt(1115 + 0 + 5U - 1);
printf("\n"); 
} else { cpptestFastCoverageStmt(1115 + 0 + 6U - 1);
printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param()); 
}  cpptestFastCoverageStmt(1115 + 0 + 7U - 1);
fflush((&((_iob)[1]))); 
# 3190 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 

void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo &test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1122 + 0 + 1U - 1);
ColoredPrintf(COLOR_GREEN, "[ RUN      ] "); cpptestFastCoverageStmt(1122 + 0 + 2U - 1);
PrintTestName(test_info.test_case_name(), test_info.name()); cpptestFastCoverageStmt(1122 + 0 + 3U - 1);
printf("\n"); cpptestFastCoverageStmt(1122 + 0 + 4U - 1);
fflush((&((_iob)[1]))); 
# 3197 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 


void PrettyUnitTestResultPrinter::OnTestPartResult(const TestPartResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(1126 + 0 + 1U - 1), result.type())) { 


case TestPartResult::kSkip:  
case TestPartResult::kSuccess:  cpptestFastCoverageStmt(1126 + 0 + 2U - 1);
return; 
default:  cpptestFastCoverageStmt(1126 + 0 + 3U - 1);


PrintTestPartResult(result); cpptestFastCoverageStmt(1126 + 0 + 4U - 1);
fflush((&((_iob)[1]))); 
# 3213 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}  
} 

void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo &test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1130 + 0 + 1U - 1), test_info.result()->Passed())) { cpptestFastCoverageStmt(1130 + 0 + 2U - 1);
ColoredPrintf(COLOR_GREEN, "[       OK ] "); 
} else if (((void)cpptestFastCoverageStmt(1130 + 0 + 3U - 1), test_info.result()->Skipped())) { cpptestFastCoverageStmt(1130 + 0 + 4U - 1);
ColoredPrintf(COLOR_GREEN, "[  SKIPPED ] "); 
} else { cpptestFastCoverageStmt(1130 + 0 + 5U - 1);
ColoredPrintf(COLOR_RED, "[  FAILED  ] "); 
}    cpptestFastCoverageStmt(1130 + 0 + 6U - 1);
PrintTestName(test_info.test_case_name(), test_info.name()); 
if (((void)cpptestFastCoverageStmt(1130 + 0 + 7U - 1), test_info.result()->Failed())) {cpptestFastCoverageStmt(1130 + 0 + 8U - 1);
PrintFullTestCommentIfPresent(test_info); }  

if (((void)cpptestFastCoverageStmt(1130 + 0 + 9U - 1), FLAGS_gtest_print_time)) { cpptestFastCoverageStmt(1130 + 0 + 10U - 1);
printf(" (%s ms)\n", (internal::StreamableToString(test_info.result()->elapsed_time())).c_str()); 

} else { cpptestFastCoverageStmt(1130 + 0 + 11U - 1);
printf("\n"); 
}  cpptestFastCoverageStmt(1130 + 0 + 12U - 1);
fflush((&((_iob)[1]))); 
# 3235 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 

void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase &test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1142 + 0 + 1U - 1), !FLAGS_gtest_print_time)) {cpptestFastCoverageStmt(1142 + 0 + 2U - 1);return; }  cpptestFastCoverageStmt(1142 + 0 + 3U - 1);

const std::string counts = FormatCountableNoun(test_case.test_to_run_count(), "test", "tests"); cpptestFastCoverageStmt(1142 + 0 + 4U - 1);

ColoredPrintf(COLOR_GREEN, "[----------] "); cpptestFastCoverageStmt(1142 + 0 + 5U - 1);
printf("%s from %s (%s ms total)\n\n", counts.c_str(), test_case.name(), (internal::StreamableToString(test_case.elapsed_time())).c_str()); cpptestFastCoverageStmt(1142 + 0 + 6U - 1);


fflush((&((_iob)[1]))); 
# 3247 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 

void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(const UnitTest &) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1148 + 0 + 1U - 1);
ColoredPrintf(COLOR_GREEN, "[----------] "); cpptestFastCoverageStmt(1148 + 0 + 2U - 1);
printf("Global test environment tear-down\n"); cpptestFastCoverageStmt(1148 + 0 + 3U - 1);
fflush((&((_iob)[1]))); 
# 3254 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 


void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest &unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1151 + 0 + 1U - 1);
const int failed_test_count = unit_test.failed_test_count(); 
if (((void)cpptestFastCoverageStmt(1151 + 0 + 2U - 1), failed_test_count == 0)) { cpptestFastCoverageStmt(1151 + 0 + 3U - 1);
return; 
}  cpptestFastCoverageStmt(1151 + 0 + 4U - 1);

for (int i = 0; ((void)cpptestFastCoverageStmt(1151 + 0 + 5U - 1), i < unit_test.total_test_case_count()); ((void)cpptestFastCoverageStmt(1151 + 0 + 6U - 1), ++i)) { { cpptestFastCoverageStmt(1151 + 0 + 7U - 1);
const TestCase &test_case = *unit_test.GetTestCase(i); 
if (((void)cpptestFastCoverageStmt(1151 + 0 + 8U - 1), !test_case.should_run() || (test_case.failed_test_count() == 0))) { cpptestFastCoverageStmt(1151 + 0 + 9U - 1);
continue; 
}  cpptestFastCoverageStmt(1151 + 0 + 10U - 1);
for (int j = 0; ((void)cpptestFastCoverageStmt(1151 + 0 + 11U - 1), j < test_case.total_test_count()); ((void)cpptestFastCoverageStmt(1151 + 0 + 12U - 1), ++j)) { { cpptestFastCoverageStmt(1151 + 0 + 13U - 1);
const TestInfo &test_info = *test_case.GetTestInfo(j); 
if (((void)cpptestFastCoverageStmt(1151 + 0 + 14U - 1), !test_info.should_run() || !test_info.result()->Failed())) { cpptestFastCoverageStmt(1151 + 0 + 15U - 1);
continue; 
}  cpptestFastCoverageStmt(1151 + 0 + 16U - 1);
ColoredPrintf(COLOR_RED, "[  FAILED  ] "); cpptestFastCoverageStmt(1151 + 0 + 17U - 1);
printf("%s.%s", test_case.name(), test_info.name()); cpptestFastCoverageStmt(1151 + 0 + 18U - 1);
PrintFullTestCommentIfPresent(test_info); cpptestFastCoverageStmt(1151 + 0 + 19U - 1);
printf("\n"); 
} }  
} }  
} 


void PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest &unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1170 + 0 + 1U - 1);
const int skipped_test_count = unit_test.skipped_test_count(); 
if (((void)cpptestFastCoverageStmt(1170 + 0 + 2U - 1), skipped_test_count == 0)) { cpptestFastCoverageStmt(1170 + 0 + 3U - 1);
return; 
}  cpptestFastCoverageStmt(1170 + 0 + 4U - 1);

for (int i = 0; ((void)cpptestFastCoverageStmt(1170 + 0 + 5U - 1), i < unit_test.total_test_case_count()); ((void)cpptestFastCoverageStmt(1170 + 0 + 6U - 1), ++i)) { { cpptestFastCoverageStmt(1170 + 0 + 7U - 1);
const TestCase &test_case = *unit_test.GetTestCase(i); 
if (((void)cpptestFastCoverageStmt(1170 + 0 + 8U - 1), !test_case.should_run() || (test_case.skipped_test_count() == 0))) { cpptestFastCoverageStmt(1170 + 0 + 9U - 1);
continue; 
}  cpptestFastCoverageStmt(1170 + 0 + 10U - 1);
for (int j = 0; ((void)cpptestFastCoverageStmt(1170 + 0 + 11U - 1), j < test_case.total_test_count()); ((void)cpptestFastCoverageStmt(1170 + 0 + 12U - 1), ++j)) { { cpptestFastCoverageStmt(1170 + 0 + 13U - 1);
const TestInfo &test_info = *test_case.GetTestInfo(j); 
if (((void)cpptestFastCoverageStmt(1170 + 0 + 14U - 1), !test_info.should_run() || !test_info.result()->Skipped())) { cpptestFastCoverageStmt(1170 + 0 + 15U - 1);
continue; 
}  cpptestFastCoverageStmt(1170 + 0 + 16U - 1);
ColoredPrintf(COLOR_GREEN, "[  SKIPPED ] "); cpptestFastCoverageStmt(1170 + 0 + 17U - 1);
printf("%s.%s", test_case.name(), test_info.name()); cpptestFastCoverageStmt(1170 + 0 + 18U - 1);
printf("\n"); 
} }  
} }  
} 

void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest &unit_test, int) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1188 + 0 + 1U - 1);
ColoredPrintf(COLOR_GREEN, "[==========] "); cpptestFastCoverageStmt(1188 + 0 + 2U - 1);
printf("%s from %s ran.", (FormatTestCount(unit_test.test_to_run_count())).c_str(), (FormatTestCaseCount(unit_test.test_case_to_run_count())).c_str()); 


if (((void)cpptestFastCoverageStmt(1188 + 0 + 3U - 1), FLAGS_gtest_print_time)) { cpptestFastCoverageStmt(1188 + 0 + 4U - 1);
printf(" (%s ms total)", (internal::StreamableToString(unit_test.elapsed_time())).c_str()); 

}  cpptestFastCoverageStmt(1188 + 0 + 5U - 1);
printf("\n"); cpptestFastCoverageStmt(1188 + 0 + 6U - 1);
ColoredPrintf(COLOR_GREEN, "[  PASSED  ] "); cpptestFastCoverageStmt(1188 + 0 + 7U - 1);
printf("%s.\n", (FormatTestCount(unit_test.successful_test_count())).c_str()); cpptestFastCoverageStmt(1188 + 0 + 8U - 1);

const int skipped_test_count = unit_test.skipped_test_count(); 
if (((void)cpptestFastCoverageStmt(1188 + 0 + 9U - 1), skipped_test_count > 0)) { cpptestFastCoverageStmt(1188 + 0 + 10U - 1);
ColoredPrintf(COLOR_GREEN, "[  SKIPPED ] "); cpptestFastCoverageStmt(1188 + 0 + 11U - 1);
printf("%s, listed below:\n", (FormatTestCount(skipped_test_count)).c_str()); cpptestFastCoverageStmt(1188 + 0 + 12U - 1);
PrintSkippedTests(unit_test); 
}  cpptestFastCoverageStmt(1188 + 0 + 13U - 1);

int num_failures = unit_test.failed_test_count(); 
if (((void)cpptestFastCoverageStmt(1188 + 0 + 14U - 1), !unit_test.Passed())) { cpptestFastCoverageStmt(1188 + 0 + 15U - 1);
const int failed_test_count = unit_test.failed_test_count(); cpptestFastCoverageStmt(1188 + 0 + 16U - 1);
ColoredPrintf(COLOR_RED, "[  FAILED  ] "); cpptestFastCoverageStmt(1188 + 0 + 17U - 1);
printf("%s, listed below:\n", (FormatTestCount(failed_test_count)).c_str()); cpptestFastCoverageStmt(1188 + 0 + 18U - 1);
PrintFailedTests(unit_test); cpptestFastCoverageStmt(1188 + 0 + 19U - 1);
printf("\n%2d FAILED %s\n", num_failures, (num_failures == 1) ? "TEST" : ("TESTS")); 

}  cpptestFastCoverageStmt(1188 + 0 + 20U - 1);

int num_disabled = unit_test.reportable_disabled_test_count(); 
if (((void)cpptestFastCoverageStmt(1188 + 0 + 21U - 1), num_disabled && !FLAGS_gtest_also_run_disabled_tests)) { 
if (((void)cpptestFastCoverageStmt(1188 + 0 + 22U - 1), !num_failures)) { cpptestFastCoverageStmt(1188 + 0 + 23U - 1);
printf("\n"); 
}  cpptestFastCoverageStmt(1188 + 0 + 24U - 1);
ColoredPrintf(COLOR_YELLOW, "  YOU HAVE %d DISABLED %s\n\n", num_disabled, (num_disabled == 1) ? "TEST" : ("TESTS")); 



}  cpptestFastCoverageStmt(1188 + 0 + 25U - 1);

fflush((&((_iob)[1]))); 
# 3348 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 
# 3355
class TestEventRepeater : public TestEventListener { 

public: TestEventRepeater() : forwarding_enabled_(true) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1213 + 0 + 1U - 1);} 
virtual ~TestEventRepeater(); 
void Append(TestEventListener * listener); 
TestEventListener *Release(TestEventListener * listener); 



bool forwarding_enabled() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1214 + 0 + 1U - 1);return forwarding_enabled_; } 
void set_forwarding_enabled(bool enable) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1215 + 0 + 1U - 1);forwarding_enabled_ = enable; } 

virtual void OnTestProgramStart(const UnitTest & unit_test); 
virtual void OnTestIterationStart(const UnitTest & unit_test, int iteration); 
virtual void OnEnvironmentsSetUpStart(const UnitTest & unit_test); 
virtual void OnEnvironmentsSetUpEnd(const UnitTest & unit_test); 
virtual void OnTestCaseStart(const TestCase & test_case); 
virtual void OnTestStart(const TestInfo & test_info); 
virtual void OnTestPartResult(const TestPartResult & result); 
virtual void OnTestEnd(const TestInfo & test_info); 
virtual void OnTestCaseEnd(const TestCase & test_case); 
virtual void OnEnvironmentsTearDownStart(const UnitTest & unit_test); 
virtual void OnEnvironmentsTearDownEnd(const UnitTest & unit_test); 
virtual void OnTestIterationEnd(const UnitTest & unit_test, int iteration); 
virtual void OnTestProgramEnd(const UnitTest & unit_test); 




private: bool forwarding_enabled_; 

std::vector< TestEventListener *>  listeners_; 

TestEventRepeater(const TestEventRepeater &) = delete;void operator=(const TestEventRepeater &) = delete;
}; 

TestEventRepeater::~TestEventRepeater() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1216 + 0 + 1U - 1);
ForEach(listeners_, Delete< TestEventListener> ); 
} 

void TestEventRepeater::Append(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1217 + 0 + 1U - 1);
(listeners_).push_back(listener); 
} 


TestEventListener *TestEventRepeater::Release(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1218 + 0 + 1U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1218 + 0 + 2U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1218 + 0 + 3U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1218 + 0 + 4U - 1), listeners_[i] == listener)) { cpptestFastCoverageStmt(1218 + 0 + 5U - 1);
(listeners_).erase(((listeners_).begin() + i)); cpptestFastCoverageStmt(1218 + 0 + 6U - 1);
return listener; 
}  
}  cpptestFastCoverageStmt(1218 + 0 + 7U - 1);

return nullptr; 
} 
# 3432 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
void TestEventRepeater::OnTestProgramStart(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1225 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1225 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1225 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1225 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1225 + 0 + 5U - 1);listeners_[i]->OnTestProgramStart(parameter); }  }  } 
void TestEventRepeater::OnEnvironmentsSetUpStart(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1230 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1230 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1230 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1230 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1230 + 0 + 5U - 1);listeners_[i]->OnEnvironmentsSetUpStart(parameter); }  }  } 
void TestEventRepeater::OnTestCaseStart(const TestCase &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1235 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1235 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1235 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1235 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1235 + 0 + 5U - 1);listeners_[i]->OnTestCaseStart(parameter); }  }  } 
void TestEventRepeater::OnTestStart(const TestInfo &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1240 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1240 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1240 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1240 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1240 + 0 + 5U - 1);listeners_[i]->OnTestStart(parameter); }  }  } 
void TestEventRepeater::OnTestPartResult(const TestPartResult &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1245 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1245 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1245 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1245 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1245 + 0 + 5U - 1);listeners_[i]->OnTestPartResult(parameter); }  }  } 
void TestEventRepeater::OnEnvironmentsTearDownStart(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1250 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1250 + 0 + 2U - 1);for (size_t i = (0); ((void)cpptestFastCoverageStmt(1250 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1250 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1250 + 0 + 5U - 1);listeners_[i]->OnEnvironmentsTearDownStart(parameter); }  }  } 
void TestEventRepeater::OnEnvironmentsSetUpEnd(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1255 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1255 + 0 + 2U - 1);for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1255 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1255 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1255 + 0 + 5U - 1);listeners_[i]->OnEnvironmentsSetUpEnd(parameter); }  }  } 
void TestEventRepeater::OnEnvironmentsTearDownEnd(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1260 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1260 + 0 + 2U - 1);for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1260 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1260 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1260 + 0 + 5U - 1);listeners_[i]->OnEnvironmentsTearDownEnd(parameter); }  }  } 
void TestEventRepeater::OnTestEnd(const TestInfo &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1265 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1265 + 0 + 2U - 1);for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1265 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1265 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1265 + 0 + 5U - 1);listeners_[i]->OnTestEnd(parameter); }  }  } 
void TestEventRepeater::OnTestCaseEnd(const TestCase &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1270 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1270 + 0 + 2U - 1);for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1270 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1270 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1270 + 0 + 5U - 1);listeners_[i]->OnTestCaseEnd(parameter); }  }  } 
void TestEventRepeater::OnTestProgramEnd(const UnitTest &parameter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);if (((void)cpptestFastCoverageStmt(1275 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1275 + 0 + 2U - 1);for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1275 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1275 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1275 + 0 + 5U - 1);listeners_[i]->OnTestProgramEnd(parameter); }  }  } 




void TestEventRepeater::OnTestIterationStart(const UnitTest &unit_test, int 
iteration) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1280 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1280 + 0 + 2U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1280 + 0 + 3U - 1), i < (listeners_).size()); ((void)cpptestFastCoverageStmt(1280 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1280 + 0 + 5U - 1);
listeners_[i]->OnTestIterationStart(unit_test, iteration); 
}  
}  
} 

void TestEventRepeater::OnTestIterationEnd(const UnitTest &unit_test, int 
iteration) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1285 + 0 + 1U - 1), forwarding_enabled_)) { cpptestFastCoverageStmt(1285 + 0 + 2U - 1);
for (int i = static_cast< int>((listeners_).size()) - 1; ((void)cpptestFastCoverageStmt(1285 + 0 + 3U - 1), i >= 0); ((void)cpptestFastCoverageStmt(1285 + 0 + 4U - 1), i--)) { cpptestFastCoverageStmt(1285 + 0 + 5U - 1);
listeners_[i]->OnTestIterationEnd(unit_test, iteration); 
}  
}  
} 




class XmlUnitTestResultPrinter : public EmptyTestEventListener { 

public: explicit XmlUnitTestResultPrinter(const char * output_file); 

virtual void OnTestIterationEnd(const UnitTest & unit_test, int iteration); 
void ListTestsMatchingFilter(const std::vector< TestCase *>  & test_cases); 


static void PrintXmlTestsList(std::ostream * stream, const std::vector< TestCase *>  & test_cases); 
# 3482
private: static bool IsNormalizableWhitespace(char c) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1290 + 0 + 1U - 1);
return (c == 0x9 || c == 0xa) || c == 0xd; 
} 


static bool IsValidXmlCharacter(char c) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1291 + 0 + 1U - 1);
return IsNormalizableWhitespace(c) || c >= 0x20; 
} 
# 3495
static std::string EscapeXml(const std::string & str, bool is_attribute); 


static std::string RemoveInvalidXmlCharacters(const std::string & str); 


static std::string EscapeXmlAttribute(const std::string &str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1292 + 0 + 1U - 1);
return EscapeXml(str, true); 
} 


static std::string EscapeXmlText(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1293 + 0 + 1U - 1);
return EscapeXml(str, false); 
} 



static void OutputXmlAttribute(std::ostream * stream, const std::string & element_name, const std::string & name, const std::string & value); 
# 3518
static void OutputXmlCDataSection(std::ostream * stream, const char * data); 


static void OutputXmlTestInfo(std::ostream * stream, const char * test_case_name, const TestInfo & test_info); 




static void PrintXmlTestCase(std::ostream * stream, const TestCase & test_case); 



static void PrintXmlUnitTest(std::ostream * stream, const UnitTest & unit_test); 
# 3537
static std::string TestPropertiesAsXmlAttributes(const TestResult & result); 



static void OutputXmlTestProperties(std::ostream * stream, const TestResult & result); 



const std::string output_file_; 

XmlUnitTestResultPrinter(const XmlUnitTestResultPrinter &) = delete;void operator=(const XmlUnitTestResultPrinter &) = delete;
}; 


XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char *output_file) : output_file_(output_file) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1294 + 0 + 1U - 1), (output_file_).empty())) { cpptestFastCoverageStmt(1294 + 0 + 2U - 1);
(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 3554).GetStream() << ("XML output file may not be null")); 
}  
} 


void XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest &unit_test, int) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1296 + 0 + 1U - 1);
FILE *xmlout = OpenFileForWriting(output_file_); cpptestFastCoverageStmt(1296 + 0 + 2U - 1);
std::stringstream stream; cpptestFastCoverageStmt(1296 + 0 + 3U - 1);
PrintXmlUnitTest(&stream, unit_test); cpptestFastCoverageStmt(1296 + 0 + 4U - 1);
fprintf(xmlout, "%s", (StringStreamToString(&stream)).c_str()); cpptestFastCoverageStmt(1296 + 0 + 5U - 1);
fclose(xmlout); 
} 

void XmlUnitTestResultPrinter::ListTestsMatchingFilter(const std::vector< TestCase *>  &
test_cases) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1301 + 0 + 1U - 1);
FILE *xmlout = OpenFileForWriting(output_file_); cpptestFastCoverageStmt(1301 + 0 + 2U - 1);
std::stringstream stream; cpptestFastCoverageStmt(1301 + 0 + 3U - 1);
PrintXmlTestsList(&stream, test_cases); cpptestFastCoverageStmt(1301 + 0 + 4U - 1);
fprintf(xmlout, "%s", (StringStreamToString(&stream)).c_str()); cpptestFastCoverageStmt(1301 + 0 + 5U - 1);
fclose(xmlout); 
} 
# 3589 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string XmlUnitTestResultPrinter::EscapeXml(const std::string &
str, bool is_attribute) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1306 + 0 + 1U - 1);
Message m; cpptestFastCoverageStmt(1306 + 0 + 2U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(1306 + 0 + 3U - 1), i < str.size()); ((void)cpptestFastCoverageStmt(1306 + 0 + 4U - 1), ++i)) { cpptestFastCoverageStmt(1306 + 0 + 5U - 1);
const char ch = str[i]; 
switch (((void)cpptestFastCoverageStmt(1306 + 0 + 6U - 1), ch)) { 
case '<':  cpptestFastCoverageStmt(1306 + 0 + 7U - 1);
(m << ("&lt;")); cpptestFastCoverageStmt(1306 + 0 + 8U - 1);
break; 
case '>':  cpptestFastCoverageStmt(1306 + 0 + 9U - 1);
(m << ("&gt;")); cpptestFastCoverageStmt(1306 + 0 + 10U - 1);
break; 
case '&':  cpptestFastCoverageStmt(1306 + 0 + 11U - 1);
(m << ("&amp;")); cpptestFastCoverageStmt(1306 + 0 + 12U - 1);
break; 
case '\'':  
if (((void)cpptestFastCoverageStmt(1306 + 0 + 13U - 1), is_attribute)) {cpptestFastCoverageStmt(1306 + 0 + 14U - 1);
(m << ("&apos;")); } else {cpptestFastCoverageStmt(1306 + 0 + 15U - 1);

(m << '\''); }  cpptestFastCoverageStmt(1306 + 0 + 16U - 1);
break; 
case '\"':  
if (((void)cpptestFastCoverageStmt(1306 + 0 + 17U - 1), is_attribute)) {cpptestFastCoverageStmt(1306 + 0 + 18U - 1);
(m << ("&quot;")); } else {cpptestFastCoverageStmt(1306 + 0 + 19U - 1);

(m << '\"'); }  cpptestFastCoverageStmt(1306 + 0 + 20U - 1);
break; 
default:  
if (((void)cpptestFastCoverageStmt(1306 + 0 + 21U - 1), IsValidXmlCharacter(ch))) { 
if (((void)cpptestFastCoverageStmt(1306 + 0 + 22U - 1), is_attribute && IsNormalizableWhitespace(ch))) {cpptestFastCoverageStmt(1306 + 0 + 23U - 1);
(((m << ("&#x")) << String::FormatByte(static_cast< unsigned char>(ch))) << (";")); } else {cpptestFastCoverageStmt(1306 + 0 + 24U - 1);


(m << ch); }  
}  cpptestFastCoverageStmt(1306 + 0 + 25U - 1);
break; 
}  
}  cpptestFastCoverageStmt(1306 + 0 + 26U - 1);

return m.GetString(); 
} 




std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(const std::string &
str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1332 + 0 + 1U - 1);
std::string output; cpptestFastCoverageStmt(1332 + 0 + 2U - 1);
output.reserve(str.size()); cpptestFastCoverageStmt(1332 + 0 + 3U - 1);
for (std::__cxx11::basic_string< char> ::const_iterator it = str.begin(); ((void)cpptestFastCoverageStmt(1332 + 0 + 4U - 1), it != str.end()); ((void)cpptestFastCoverageStmt(1332 + 0 + 5U - 1), ++it)) 
if (((void)cpptestFastCoverageStmt(1332 + 0 + 6U - 1), IsValidXmlCharacter((*it)))) {cpptestFastCoverageStmt(1332 + 0 + 7U - 1);
output.push_back((*it)); }    cpptestFastCoverageStmt(1332 + 0 + 8U - 1);

return output; 
} 
# 3664 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1340 + 0 + 1U - 1);
std::stringstream ss; cpptestFastCoverageStmt(1340 + 0 + 2U - 1);
(ss << (static_cast< double>(ms) * (0.001000000000000000021))); cpptestFastCoverageStmt(1340 + 0 + 3U - 1);
return ss.str(); 
} 

static bool PortableLocaltime(time_t seconds, tm *out) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1343 + 0 + 1U - 1);
# 3676
tm *tm_ptr = localtime(&seconds); 
if (((void)cpptestFastCoverageStmt(1343 + 0 + 2U - 1), tm_ptr == __null)) {cpptestFastCoverageStmt(1343 + 0 + 3U - 1);
# 3678 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
return false; }  cpptestFastCoverageStmt(1343 + 0 + 4U - 1);
*out = *tm_ptr; cpptestFastCoverageStmt(1343 + 0 + 5U - 1);
return true; 



} 



std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1348 + 0 + 1U - 1);
tm time_struct; 
if (((void)cpptestFastCoverageStmt(1348 + 0 + 2U - 1), !PortableLocaltime(static_cast< time_t>(ms / 1000), &time_struct))) {cpptestFastCoverageStmt(1348 + 0 + 3U - 1);
return ""; }  cpptestFastCoverageStmt(1348 + 0 + 4U - 1);

return ((((((((((StreamableToString(time_struct.tm_year + 1900) + ("-")) + String::FormatIntWidth2(time_struct.tm_mon + 1)) + ("-")) + String::FormatIntWidth2(time_struct.tm_mday)) + ("T")) + String::FormatIntWidth2(time_struct.tm_hour)) + (":")) + String::FormatIntWidth2(time_struct.tm_min)) + (":")) + String::FormatIntWidth2(time_struct.tm_sec)); 
# 3699
} 


void XmlUnitTestResultPrinter::OutputXmlCDataSection(std::ostream *stream, const char *
data) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1352 + 0 + 1U - 1);
const char *segment = data; cpptestFastCoverageStmt(1352 + 0 + 2U - 1);
(*stream << ("<![CDATA[")); 
for (; 1;) { cpptestFastCoverageStmt(1352 + 0 + 3U - 1);
const char *const next_segment = strstr(segment, "]]>"); 
if (((void)cpptestFastCoverageStmt(1352 + 0 + 4U - 1), next_segment != (nullptr))) { cpptestFastCoverageStmt(1352 + 0 + 5U - 1);
stream->write(segment, static_cast< std::streamsize>(next_segment - segment)); cpptestFastCoverageStmt(1352 + 0 + 6U - 1);

(*stream << ("]]>]]&gt;<![CDATA[")); cpptestFastCoverageStmt(1352 + 0 + 7U - 1);
segment = next_segment + strlen("]]>"); 
} else { cpptestFastCoverageStmt(1352 + 0 + 8U - 1);
(*stream << segment); cpptestFastCoverageStmt(1352 + 0 + 9U - 1);
break; 
}  
}  cpptestFastCoverageStmt(1352 + 0 + 10U - 1);
(*stream << ("]]>")); 
} 

void XmlUnitTestResultPrinter::OutputXmlAttribute(std::ostream *
stream, const std::string &
element_name, const std::string &
name, const std::string &
value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1362 + 0 + 1U - 1);
const std::vector< std::__cxx11::basic_string< char> >  &allowed_names = GetReservedAttributesForElement(element_name); 


switch (((void)cpptestFastCoverageStmt(1362 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(1362 + 0 + 3U - 1), ::testing::internal::IsTrue((std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end())))) {cpptestFastCoverageStmt(1362 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(1362 + 0 + 5U - 1);((((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 3729).GetStream() << ("Condition std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end() failed. ")) << ("Attribute ")) << name) << (" is not allowed for element <")) << element_name) << (">.")); }  }  cpptestFastCoverageStmt(1362 + 0 + 6U - 1);




(((((*stream << (" ")) << name) << ("=\"")) << EscapeXmlAttribute(value)) << ("\"")); 
} 



void XmlUnitTestResultPrinter::OutputXmlTestInfo(std::ostream *stream, const char *
test_case_name, const TestInfo &
test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1368 + 0 + 1U - 1);
const TestResult &result = *test_info.result(); cpptestFastCoverageStmt(1368 + 0 + 2U - 1);
const std::string kTestcase = "testcase"; 

if (((void)cpptestFastCoverageStmt(1368 + 0 + 3U - 1), test_info.is_in_another_shard())) { cpptestFastCoverageStmt(1368 + 0 + 4U - 1);
return; 
}  cpptestFastCoverageStmt(1368 + 0 + 5U - 1);

(*stream << ("    <testcase")); cpptestFastCoverageStmt(1368 + 0 + 6U - 1);
OutputXmlAttribute(stream, kTestcase, "name", test_info.name()); 

if (((void)cpptestFastCoverageStmt(1368 + 0 + 7U - 1), test_info.value_param() != (nullptr))) { cpptestFastCoverageStmt(1368 + 0 + 8U - 1);
OutputXmlAttribute(stream, kTestcase, "value_param", test_info.value_param()); 

}  
if (((void)cpptestFastCoverageStmt(1368 + 0 + 9U - 1), test_info.type_param() != (nullptr))) { cpptestFastCoverageStmt(1368 + 0 + 10U - 1);
OutputXmlAttribute(stream, kTestcase, "type_param", test_info.type_param()); 
}  
if (((void)cpptestFastCoverageStmt(1368 + 0 + 11U - 1), FLAGS_gtest_list_tests)) { cpptestFastCoverageStmt(1368 + 0 + 12U - 1);
OutputXmlAttribute(stream, kTestcase, "file", test_info.file()); cpptestFastCoverageStmt(1368 + 0 + 13U - 1);
OutputXmlAttribute(stream, kTestcase, "line", StreamableToString(test_info.line())); cpptestFastCoverageStmt(1368 + 0 + 14U - 1);

(*stream << (" />\n")); cpptestFastCoverageStmt(1368 + 0 + 15U - 1);
return; 
}  cpptestFastCoverageStmt(1368 + 0 + 16U - 1);

OutputXmlAttribute(stream, kTestcase, "status", test_info.should_run() ? "run" : ("notrun")); cpptestFastCoverageStmt(1368 + 0 + 17U - 1);

OutputXmlAttribute(stream, kTestcase, "time", FormatTimeInMillisAsSeconds(result.elapsed_time())); cpptestFastCoverageStmt(1368 + 0 + 18U - 1);

OutputXmlAttribute(stream, kTestcase, "classname", test_case_name); cpptestFastCoverageStmt(1368 + 0 + 19U - 1);

int failures = 0; cpptestFastCoverageStmt(1368 + 0 + 20U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1368 + 0 + 21U - 1), i < result.total_part_count()); ((void)cpptestFastCoverageStmt(1368 + 0 + 22U - 1), ++i)) { cpptestFastCoverageStmt(1368 + 0 + 23U - 1);
const TestPartResult &part = result.GetTestPartResult(i); 
if (((void)cpptestFastCoverageStmt(1368 + 0 + 24U - 1), part.failed())) { 
if (((void)cpptestFastCoverageStmt(1368 + 0 + 25U - 1), ++failures == 1)) { cpptestFastCoverageStmt(1368 + 0 + 26U - 1);
(*stream << (">\n")); 
}  cpptestFastCoverageStmt(1368 + 0 + 27U - 1);
const std::string location = internal::FormatCompilerIndependentFileLocation(part.file_name(), part.line_number()); cpptestFastCoverageStmt(1368 + 0 + 28U - 1);


const std::string summary = ((location + ("\n")) + part.summary()); cpptestFastCoverageStmt(1368 + 0 + 29U - 1);
(((*stream << ("      <failure message=\"")) << EscapeXmlAttribute(summary.c_str())) << ("\" type=\"\">")); cpptestFastCoverageStmt(1368 + 0 + 30U - 1);


const std::string detail = ((location + ("\n")) + part.message()); cpptestFastCoverageStmt(1368 + 0 + 31U - 1);
OutputXmlCDataSection(stream, (RemoveInvalidXmlCharacters(detail)).c_str()); cpptestFastCoverageStmt(1368 + 0 + 32U - 1);
(*stream << ("</failure>\n")); 
}  
}  

if (((void)cpptestFastCoverageStmt(1368 + 0 + 33U - 1), failures == 0 && result.test_property_count() == 0)) { cpptestFastCoverageStmt(1368 + 0 + 34U - 1);
(*stream << (" />\n")); 
} else { 
if (((void)cpptestFastCoverageStmt(1368 + 0 + 35U - 1), failures == 0)) { cpptestFastCoverageStmt(1368 + 0 + 36U - 1);
(*stream << (">\n")); 
}  cpptestFastCoverageStmt(1368 + 0 + 37U - 1);
OutputXmlTestProperties(stream, result); cpptestFastCoverageStmt(1368 + 0 + 38U - 1);
(*stream << ("    </testcase>\n")); 
}  
} 


void XmlUnitTestResultPrinter::PrintXmlTestCase(std::ostream *stream, const TestCase &
test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1406 + 0 + 1U - 1);
const std::string kTestsuite = "testsuite"; cpptestFastCoverageStmt(1406 + 0 + 2U - 1);
((*stream << ("  <")) << kTestsuite); cpptestFastCoverageStmt(1406 + 0 + 3U - 1);
OutputXmlAttribute(stream, kTestsuite, "name", test_case.name()); cpptestFastCoverageStmt(1406 + 0 + 4U - 1);
OutputXmlAttribute(stream, kTestsuite, "tests", StreamableToString(test_case.reportable_test_count())); 

if (((void)cpptestFastCoverageStmt(1406 + 0 + 5U - 1), !FLAGS_gtest_list_tests)) { cpptestFastCoverageStmt(1406 + 0 + 6U - 1);
OutputXmlAttribute(stream, kTestsuite, "failures", StreamableToString(test_case.failed_test_count())); cpptestFastCoverageStmt(1406 + 0 + 7U - 1);

OutputXmlAttribute(stream, kTestsuite, "disabled", StreamableToString(test_case.reportable_disabled_test_count())); cpptestFastCoverageStmt(1406 + 0 + 8U - 1);


OutputXmlAttribute(stream, kTestsuite, "errors", "0"); cpptestFastCoverageStmt(1406 + 0 + 9U - 1);
OutputXmlAttribute(stream, kTestsuite, "time", FormatTimeInMillisAsSeconds(test_case.elapsed_time())); cpptestFastCoverageStmt(1406 + 0 + 10U - 1);

(*stream << TestPropertiesAsXmlAttributes(test_case.ad_hoc_test_result())); 
}  cpptestFastCoverageStmt(1406 + 0 + 11U - 1);
(*stream << (">\n")); cpptestFastCoverageStmt(1406 + 0 + 12U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1406 + 0 + 13U - 1), i < test_case.total_test_count()); ((void)cpptestFastCoverageStmt(1406 + 0 + 14U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1406 + 0 + 15U - 1), test_case.GetTestInfo(i)->is_reportable())) {cpptestFastCoverageStmt(1406 + 0 + 16U - 1);
OutputXmlTestInfo(stream, test_case.name(), *test_case.GetTestInfo(i)); }  
}  cpptestFastCoverageStmt(1406 + 0 + 17U - 1);
(((*stream << ("  </")) << kTestsuite) << (">\n")); 
} 


void XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream *stream, const UnitTest &
unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1423 + 0 + 1U - 1);
const std::string kTestsuites = "testsuites"; cpptestFastCoverageStmt(1423 + 0 + 2U - 1);

(*stream << ("<\?xml version=\"1.0\" encoding=\"UTF-8\"\?>\n")); cpptestFastCoverageStmt(1423 + 0 + 3U - 1);
((*stream << ("<")) << kTestsuites); cpptestFastCoverageStmt(1423 + 0 + 4U - 1);

OutputXmlAttribute(stream, kTestsuites, "tests", StreamableToString(unit_test.reportable_test_count())); cpptestFastCoverageStmt(1423 + 0 + 5U - 1);

OutputXmlAttribute(stream, kTestsuites, "failures", StreamableToString(unit_test.failed_test_count())); cpptestFastCoverageStmt(1423 + 0 + 6U - 1);

OutputXmlAttribute(stream, kTestsuites, "disabled", StreamableToString(unit_test.reportable_disabled_test_count())); cpptestFastCoverageStmt(1423 + 0 + 7U - 1);


OutputXmlAttribute(stream, kTestsuites, "errors", "0"); cpptestFastCoverageStmt(1423 + 0 + 8U - 1);
OutputXmlAttribute(stream, kTestsuites, "timestamp", FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp())); cpptestFastCoverageStmt(1423 + 0 + 9U - 1);


OutputXmlAttribute(stream, kTestsuites, "time", FormatTimeInMillisAsSeconds(unit_test.elapsed_time())); 


if (((void)cpptestFastCoverageStmt(1423 + 0 + 10U - 1), FLAGS_gtest_shuffle)) { cpptestFastCoverageStmt(1423 + 0 + 11U - 1);
OutputXmlAttribute(stream, kTestsuites, "random_seed", StreamableToString(unit_test.random_seed())); 

}  cpptestFastCoverageStmt(1423 + 0 + 12U - 1);
(*stream << TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result())); cpptestFastCoverageStmt(1423 + 0 + 13U - 1);

OutputXmlAttribute(stream, kTestsuites, "name", "AllTests"); cpptestFastCoverageStmt(1423 + 0 + 14U - 1);
(*stream << (">\n")); cpptestFastCoverageStmt(1423 + 0 + 15U - 1);

for (int i = 0; ((void)cpptestFastCoverageStmt(1423 + 0 + 16U - 1), i < unit_test.total_test_case_count()); ((void)cpptestFastCoverageStmt(1423 + 0 + 17U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1423 + 0 + 18U - 1), unit_test.GetTestCase(i)->reportable_test_count() > 0)) {cpptestFastCoverageStmt(1423 + 0 + 19U - 1);
PrintXmlTestCase(stream, *unit_test.GetTestCase(i)); }  
}  cpptestFastCoverageStmt(1423 + 0 + 20U - 1);
(((*stream << ("</")) << kTestsuites) << (">\n")); 
} 

void XmlUnitTestResultPrinter::PrintXmlTestsList(std::ostream *
stream, const std::vector< TestCase *>  &test_cases) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1443 + 0 + 1U - 1);
const std::string kTestsuites = "testsuites"; cpptestFastCoverageStmt(1443 + 0 + 2U - 1);

(*stream << ("<\?xml version=\"1.0\" encoding=\"UTF-8\"\?>\n")); cpptestFastCoverageStmt(1443 + 0 + 3U - 1);
((*stream << ("<")) << kTestsuites); cpptestFastCoverageStmt(1443 + 0 + 4U - 1);

int total_tests = 0; cpptestFastCoverageStmt(1443 + 0 + 5U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1443 + 0 + 6U - 1), i < test_cases.size()); ((void)cpptestFastCoverageStmt(1443 + 0 + 7U - 1), ++i)) { cpptestFastCoverageStmt(1443 + 0 + 8U - 1);
total_tests += test_cases[i]->total_test_count(); 
}  cpptestFastCoverageStmt(1443 + 0 + 9U - 1);
OutputXmlAttribute(stream, kTestsuites, "tests", StreamableToString(total_tests)); cpptestFastCoverageStmt(1443 + 0 + 10U - 1);

OutputXmlAttribute(stream, kTestsuites, "name", "AllTests"); cpptestFastCoverageStmt(1443 + 0 + 11U - 1);
(*stream << (">\n")); cpptestFastCoverageStmt(1443 + 0 + 12U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(1443 + 0 + 13U - 1), i < test_cases.size()); ((void)cpptestFastCoverageStmt(1443 + 0 + 14U - 1), ++i)) { cpptestFastCoverageStmt(1443 + 0 + 15U - 1);
PrintXmlTestCase(stream, *test_cases[i]); 
}  cpptestFastCoverageStmt(1443 + 0 + 16U - 1);
(((*stream << ("</")) << kTestsuites) << (">\n")); 
} 



std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(const TestResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1459 + 0 + 1U - 1);
Message attributes; cpptestFastCoverageStmt(1459 + 0 + 2U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1459 + 0 + 3U - 1), i < result.test_property_count()); ((void)cpptestFastCoverageStmt(1459 + 0 + 4U - 1), ++i)) { cpptestFastCoverageStmt(1459 + 0 + 5U - 1);
const TestProperty &property = result.GetTestProperty(i); cpptestFastCoverageStmt(1459 + 0 + 6U - 1);
((((((attributes << (" ")) << property.key()) << ("=")) << ("\"")) << EscapeXmlAttribute(property.value())) << ("\"")); 

}  cpptestFastCoverageStmt(1459 + 0 + 7U - 1);
return attributes.GetString(); 
} 

void XmlUnitTestResultPrinter::OutputXmlTestProperties(std::ostream *
stream, const TestResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1466 + 0 + 1U - 1);
const std::string kProperties = "properties"; cpptestFastCoverageStmt(1466 + 0 + 2U - 1);
const std::string kProperty = "property"; 

if (((void)cpptestFastCoverageStmt(1466 + 0 + 3U - 1), result.test_property_count() <= 0)) { cpptestFastCoverageStmt(1466 + 0 + 4U - 1);
return; 
}  cpptestFastCoverageStmt(1466 + 0 + 5U - 1);

(((*stream << ("<")) << kProperties) << (">\n")); cpptestFastCoverageStmt(1466 + 0 + 6U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1466 + 0 + 7U - 1), i < result.test_property_count()); ((void)cpptestFastCoverageStmt(1466 + 0 + 8U - 1), ++i)) { cpptestFastCoverageStmt(1466 + 0 + 9U - 1);
const TestProperty &property = result.GetTestProperty(i); cpptestFastCoverageStmt(1466 + 0 + 10U - 1);
((*stream << ("<")) << kProperty); cpptestFastCoverageStmt(1466 + 0 + 11U - 1);
(((*stream << (" name=\"")) << EscapeXmlAttribute(property.key())) << ("\"")); cpptestFastCoverageStmt(1466 + 0 + 12U - 1);
(((*stream << (" value=\"")) << EscapeXmlAttribute(property.value())) << ("\"")); cpptestFastCoverageStmt(1466 + 0 + 13U - 1);
(*stream << ("/>\n")); 
}  cpptestFastCoverageStmt(1466 + 0 + 14U - 1);
(((*stream << ("</")) << kProperties) << (">\n")); 
} 




class JsonUnitTestResultPrinter : public EmptyTestEventListener { 

public: explicit JsonUnitTestResultPrinter(const char * output_file); 

virtual void OnTestIterationEnd(const UnitTest & unit_test, int iteration); 


static void PrintJsonTestList(std::ostream * stream, const std::vector< TestCase *>  & test_cases); 




private: static std::string EscapeJson(const std::string & str); 



static void OutputJsonKey(std::ostream * stream, const std::string & element_name, const std::string & name, const std::string & value, const std::string & indent, bool comma = true); 
# 3949
static void OutputJsonKey(std::ostream * stream, const std::string & element_name, const std::string & name, int value, const std::string & indent, bool comma = true); 
# 3957
static void OutputJsonTestInfo(std::ostream * stream, const char * test_case_name, const TestInfo & test_info); 




static void PrintJsonTestCase(std::ostream * stream, const TestCase & test_case); 



static void PrintJsonUnitTest(std::ostream * stream, const UnitTest & unit_test); 




static std::string TestPropertiesAsJson(const TestResult & result, const std::string & indent); 



const std::string output_file_; 

JsonUnitTestResultPrinter(const JsonUnitTestResultPrinter &) = delete;void operator=(const JsonUnitTestResultPrinter &) = delete;
}; 


JsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char *output_file) : output_file_(output_file) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1480 + 0 + 1U - 1), (output_file_).empty())) { cpptestFastCoverageStmt(1480 + 0 + 2U - 1);
(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 3984).GetStream() << ("JSON output file may not be null")); 
}  
} 

void JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest &unit_test, int) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1482 + 0 + 1U - 1);
FILE *jsonout = OpenFileForWriting(output_file_); cpptestFastCoverageStmt(1482 + 0 + 2U - 1);
std::stringstream stream; cpptestFastCoverageStmt(1482 + 0 + 3U - 1);
PrintJsonUnitTest(&stream, unit_test); cpptestFastCoverageStmt(1482 + 0 + 4U - 1);
fprintf(jsonout, "%s", (StringStreamToString(&stream)).c_str()); cpptestFastCoverageStmt(1482 + 0 + 5U - 1);
fclose(jsonout); 
} 


std::string JsonUnitTestResultPrinter::EscapeJson(const std::string &str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1487 + 0 + 1U - 1);
Message m; cpptestFastCoverageStmt(1487 + 0 + 2U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(1487 + 0 + 3U - 1), i < str.size()); ((void)cpptestFastCoverageStmt(1487 + 0 + 4U - 1), ++i)) { cpptestFastCoverageStmt(1487 + 0 + 5U - 1);
const char ch = str[i]; 
switch (((void)cpptestFastCoverageStmt(1487 + 0 + 6U - 1), ch)) { 
case '\\':  
case '\"':  
case '/':  cpptestFastCoverageStmt(1487 + 0 + 7U - 1);
((m << '\\') << ch); cpptestFastCoverageStmt(1487 + 0 + 8U - 1);
break; 
case '\b':  cpptestFastCoverageStmt(1487 + 0 + 9U - 1);
(m << ("\\b")); cpptestFastCoverageStmt(1487 + 0 + 10U - 1);
break; 
case '	':  cpptestFastCoverageStmt(1487 + 0 + 11U - 1);
(m << ("\\t")); cpptestFastCoverageStmt(1487 + 0 + 12U - 1);
break; 
case '\n':  cpptestFastCoverageStmt(1487 + 0 + 13U - 1);
(m << ("\\n")); cpptestFastCoverageStmt(1487 + 0 + 14U - 1);
break; 
case '\f':  cpptestFastCoverageStmt(1487 + 0 + 15U - 1);
(m << ("\\f")); cpptestFastCoverageStmt(1487 + 0 + 16U - 1);
break; 
case '\r':  cpptestFastCoverageStmt(1487 + 0 + 17U - 1);
(m << ("\\r")); cpptestFastCoverageStmt(1487 + 0 + 18U - 1);
break; 
default:  
if (((void)cpptestFastCoverageStmt(1487 + 0 + 19U - 1), ch < ' ')) { cpptestFastCoverageStmt(1487 + 0 + 20U - 1);
((m << ("\\u00")) << String::FormatByte(static_cast< unsigned char>(ch))); 
} else { cpptestFastCoverageStmt(1487 + 0 + 21U - 1);
(m << ch); 
}  cpptestFastCoverageStmt(1487 + 0 + 22U - 1);
break; 
}  
}  cpptestFastCoverageStmt(1487 + 0 + 23U - 1);

return m.GetString(); 
} 
# 4041
static std::string FormatTimeInMillisAsDuration(TimeInMillis ms) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1510 + 0 + 1U - 1);
std::stringstream ss; cpptestFastCoverageStmt(1510 + 0 + 2U - 1);
((ss << (static_cast< double>(ms) * (0.001000000000000000021))) << ("s")); cpptestFastCoverageStmt(1510 + 0 + 3U - 1);
return ss.str(); 
} 



static std::string FormatEpochTimeInMillisAsRFC3339(TimeInMillis ms) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1513 + 0 + 1U - 1);
tm time_struct; 
if (((void)cpptestFastCoverageStmt(1513 + 0 + 2U - 1), !PortableLocaltime(static_cast< time_t>(ms / 1000), &time_struct))) {cpptestFastCoverageStmt(1513 + 0 + 3U - 1);
return ""; }  cpptestFastCoverageStmt(1513 + 0 + 4U - 1);

return (((((((((((StreamableToString(time_struct.tm_year + 1900) + ("-")) + String::FormatIntWidth2(time_struct.tm_mon + 1)) + ("-")) + String::FormatIntWidth2(time_struct.tm_mday)) + ("T")) + String::FormatIntWidth2(time_struct.tm_hour)) + (":")) + String::FormatIntWidth2(time_struct.tm_min)) + (":")) + String::FormatIntWidth2(time_struct.tm_sec)) + ("Z")); 
# 4060
} 

static inline std::string Indent(int width) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1517 + 0 + 1U - 1);
return std::string(width, ' '); 
} 

void JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *
stream, const std::string &
element_name, const std::string &
name, const std::string &
value, const std::string &
indent, bool 
comma) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1518 + 0 + 1U - 1);
const std::vector< std::__cxx11::basic_string< char> >  &allowed_names = GetReservedAttributesForElement(element_name); 


switch (((void)cpptestFastCoverageStmt(1518 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(1518 + 0 + 3U - 1), ::testing::internal::IsTrue((std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end())))) {cpptestFastCoverageStmt(1518 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(1518 + 0 + 5U - 1);((((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 4076).GetStream() << ("Condition std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end() failed. ")) << ("Key \"")) << name) << ("\" is not allowed for value \"")) << element_name) << ("\".")); }  }  cpptestFastCoverageStmt(1518 + 0 + 6U - 1);




((((((*stream << indent) << ("\"")) << name) << ("\": \"")) << EscapeJson(value)) << ("\"")); 
if (((void)cpptestFastCoverageStmt(1518 + 0 + 7U - 1), comma)) {cpptestFastCoverageStmt(1518 + 0 + 8U - 1);
(*stream << (",\n")); }  
} 

void JsonUnitTestResultPrinter::OutputJsonKey(std::ostream *
stream, const std::string &
element_name, const std::string &
name, int 
value, const std::string &
indent, bool 
comma) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1526 + 0 + 1U - 1);
const std::vector< std::__cxx11::basic_string< char> >  &allowed_names = GetReservedAttributesForElement(element_name); 


switch (((void)cpptestFastCoverageStmt(1526 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(1526 + 0 + 3U - 1), ::testing::internal::IsTrue((std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end())))) {cpptestFastCoverageStmt(1526 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(1526 + 0 + 5U - 1);((((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 4096).GetStream() << ("Condition std::find(allowed_names.begin(), allowed_names.end(), name) != allowed_names.end() failed. ")) << ("Key \"")) << name) << ("\" is not allowed for value \"")) << element_name) << ("\".")); }  }  cpptestFastCoverageStmt(1526 + 0 + 6U - 1);




(((((*stream << indent) << ("\"")) << name) << ("\": ")) << StreamableToString(value)); 
if (((void)cpptestFastCoverageStmt(1526 + 0 + 7U - 1), comma)) {cpptestFastCoverageStmt(1526 + 0 + 8U - 1);
(*stream << (",\n")); }  
} 


void JsonUnitTestResultPrinter::OutputJsonTestInfo(std::ostream *stream, const char *
test_case_name, const TestInfo &
test_info) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1534 + 0 + 1U - 1);
const TestResult &result = *test_info.result(); cpptestFastCoverageStmt(1534 + 0 + 2U - 1);
const std::string kTestcase = "testcase"; cpptestFastCoverageStmt(1534 + 0 + 3U - 1);
const std::string kIndent = Indent(10); cpptestFastCoverageStmt(1534 + 0 + 4U - 1);

((*stream << Indent(8)) << ("{\n")); cpptestFastCoverageStmt(1534 + 0 + 5U - 1);
OutputJsonKey(stream, kTestcase, "name", test_info.name(), kIndent); 

if (((void)cpptestFastCoverageStmt(1534 + 0 + 6U - 1), test_info.value_param() != (nullptr))) { cpptestFastCoverageStmt(1534 + 0 + 7U - 1);
OutputJsonKey(stream, kTestcase, "value_param", test_info.value_param(), kIndent); 

}  
if (((void)cpptestFastCoverageStmt(1534 + 0 + 8U - 1), test_info.type_param() != (nullptr))) { cpptestFastCoverageStmt(1534 + 0 + 9U - 1);
OutputJsonKey(stream, kTestcase, "type_param", test_info.type_param(), kIndent); 

}  
if (((void)cpptestFastCoverageStmt(1534 + 0 + 10U - 1), FLAGS_gtest_list_tests)) { cpptestFastCoverageStmt(1534 + 0 + 11U - 1);
OutputJsonKey(stream, kTestcase, "file", test_info.file(), kIndent); cpptestFastCoverageStmt(1534 + 0 + 12U - 1);
OutputJsonKey(stream, kTestcase, "line", test_info.line(), kIndent, false); cpptestFastCoverageStmt(1534 + 0 + 13U - 1);
(((*stream << ("\n")) << Indent(8)) << ("}")); cpptestFastCoverageStmt(1534 + 0 + 14U - 1);
return; 
}  cpptestFastCoverageStmt(1534 + 0 + 15U - 1);

OutputJsonKey(stream, kTestcase, "status", test_info.should_run() ? "RUN" : ("NOTRUN"), kIndent); cpptestFastCoverageStmt(1534 + 0 + 16U - 1);

OutputJsonKey(stream, kTestcase, "time", FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent); cpptestFastCoverageStmt(1534 + 0 + 17U - 1);

OutputJsonKey(stream, kTestcase, "classname", test_case_name, kIndent, false); cpptestFastCoverageStmt(1534 + 0 + 18U - 1);
(*stream << TestPropertiesAsJson(result, kIndent)); cpptestFastCoverageStmt(1534 + 0 + 19U - 1);

int failures = 0; cpptestFastCoverageStmt(1534 + 0 + 20U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1534 + 0 + 21U - 1), i < result.total_part_count()); ((void)cpptestFastCoverageStmt(1534 + 0 + 22U - 1), ++i)) { cpptestFastCoverageStmt(1534 + 0 + 23U - 1);
const TestPartResult &part = result.GetTestPartResult(i); 
if (((void)cpptestFastCoverageStmt(1534 + 0 + 24U - 1), part.failed())) { cpptestFastCoverageStmt(1534 + 0 + 25U - 1);
(*stream << (",\n")); 
if (((void)cpptestFastCoverageStmt(1534 + 0 + 26U - 1), ++failures == 1)) { cpptestFastCoverageStmt(1534 + 0 + 27U - 1);
((((*stream << kIndent) << ("\"")) << ("failures")) << ("\": [\n")); 
}  cpptestFastCoverageStmt(1534 + 0 + 28U - 1);
const std::string location = internal::FormatCompilerIndependentFileLocation(part.file_name(), part.line_number()); cpptestFastCoverageStmt(1534 + 0 + 29U - 1);


const std::string message = EscapeJson(((location + ("\n")) + part.message())); cpptestFastCoverageStmt(1534 + 0 + 30U - 1);
((((((((((*stream << kIndent) << ("  {\n")) << kIndent) << ("    \"failure\": \"")) << message) << ("\",\n")) << kIndent) << ("    \"type\": \"\"\n")) << kIndent) << ("  }")); 



}  
}  

if (((void)cpptestFastCoverageStmt(1534 + 0 + 31U - 1), failures > 0)) {cpptestFastCoverageStmt(1534 + 0 + 32U - 1);
(((*stream << ("\n")) << kIndent) << ("]")); }  cpptestFastCoverageStmt(1534 + 0 + 33U - 1);
(((*stream << ("\n")) << Indent(8)) << ("}")); 
} 


void JsonUnitTestResultPrinter::PrintJsonTestCase(std::ostream *stream, const TestCase &
test_case) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1567 + 0 + 1U - 1);
const std::string kTestsuite = "testsuite"; cpptestFastCoverageStmt(1567 + 0 + 2U - 1);
const std::string kIndent = Indent(6); cpptestFastCoverageStmt(1567 + 0 + 3U - 1);

((*stream << Indent(4)) << ("{\n")); cpptestFastCoverageStmt(1567 + 0 + 4U - 1);
OutputJsonKey(stream, kTestsuite, "name", test_case.name(), kIndent); cpptestFastCoverageStmt(1567 + 0 + 5U - 1);
OutputJsonKey(stream, kTestsuite, "tests", test_case.reportable_test_count(), kIndent); 

if (((void)cpptestFastCoverageStmt(1567 + 0 + 6U - 1), !FLAGS_gtest_list_tests)) { cpptestFastCoverageStmt(1567 + 0 + 7U - 1);
OutputJsonKey(stream, kTestsuite, "failures", test_case.failed_test_count(), kIndent); cpptestFastCoverageStmt(1567 + 0 + 8U - 1);

OutputJsonKey(stream, kTestsuite, "disabled", test_case.reportable_disabled_test_count(), kIndent); cpptestFastCoverageStmt(1567 + 0 + 9U - 1);

OutputJsonKey(stream, kTestsuite, "errors", 0, kIndent); cpptestFastCoverageStmt(1567 + 0 + 10U - 1);
OutputJsonKey(stream, kTestsuite, "time", FormatTimeInMillisAsDuration(test_case.elapsed_time()), kIndent, false); cpptestFastCoverageStmt(1567 + 0 + 11U - 1);


((*stream << TestPropertiesAsJson(test_case.ad_hoc_test_result(), kIndent)) << (",\n")); 

}  cpptestFastCoverageStmt(1567 + 0 + 12U - 1);

((((*stream << kIndent) << ("\"")) << kTestsuite) << ("\": [\n")); cpptestFastCoverageStmt(1567 + 0 + 13U - 1);

bool comma = false; cpptestFastCoverageStmt(1567 + 0 + 14U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1567 + 0 + 15U - 1), i < test_case.total_test_count()); ((void)cpptestFastCoverageStmt(1567 + 0 + 16U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1567 + 0 + 17U - 1), test_case.GetTestInfo(i)->is_reportable())) { 
if (((void)cpptestFastCoverageStmt(1567 + 0 + 18U - 1), comma)) { cpptestFastCoverageStmt(1567 + 0 + 19U - 1);
(*stream << (",\n")); 
} else { cpptestFastCoverageStmt(1567 + 0 + 20U - 1);
comma = true; 
}  cpptestFastCoverageStmt(1567 + 0 + 21U - 1);
OutputJsonTestInfo(stream, test_case.name(), *test_case.GetTestInfo(i)); 
}  
}  cpptestFastCoverageStmt(1567 + 0 + 22U - 1);
(((((*stream << ("\n")) << kIndent) << ("]\n")) << Indent(4)) << ("}")); 
} 


void JsonUnitTestResultPrinter::PrintJsonUnitTest(std::ostream *stream, const UnitTest &
unit_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1589 + 0 + 1U - 1);
const std::string kTestsuites = "testsuites"; cpptestFastCoverageStmt(1589 + 0 + 2U - 1);
const std::string kIndent = Indent(2); cpptestFastCoverageStmt(1589 + 0 + 3U - 1);
(*stream << ("{\n")); cpptestFastCoverageStmt(1589 + 0 + 4U - 1);

OutputJsonKey(stream, kTestsuites, "tests", unit_test.reportable_test_count(), kIndent); cpptestFastCoverageStmt(1589 + 0 + 5U - 1);

OutputJsonKey(stream, kTestsuites, "failures", unit_test.failed_test_count(), kIndent); cpptestFastCoverageStmt(1589 + 0 + 6U - 1);

OutputJsonKey(stream, kTestsuites, "disabled", unit_test.reportable_disabled_test_count(), kIndent); cpptestFastCoverageStmt(1589 + 0 + 7U - 1);

OutputJsonKey(stream, kTestsuites, "errors", 0, kIndent); 
if (((void)cpptestFastCoverageStmt(1589 + 0 + 8U - 1), FLAGS_gtest_shuffle)) { cpptestFastCoverageStmt(1589 + 0 + 9U - 1);
OutputJsonKey(stream, kTestsuites, "random_seed", unit_test.random_seed(), kIndent); 

}  cpptestFastCoverageStmt(1589 + 0 + 10U - 1);
OutputJsonKey(stream, kTestsuites, "timestamp", FormatEpochTimeInMillisAsRFC3339(unit_test.start_timestamp()), kIndent); cpptestFastCoverageStmt(1589 + 0 + 11U - 1);


OutputJsonKey(stream, kTestsuites, "time", FormatTimeInMillisAsDuration(unit_test.elapsed_time()), kIndent, false); cpptestFastCoverageStmt(1589 + 0 + 12U - 1);



((*stream << TestPropertiesAsJson(unit_test.ad_hoc_test_result(), kIndent)) << (",\n")); cpptestFastCoverageStmt(1589 + 0 + 13U - 1);


OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent); cpptestFastCoverageStmt(1589 + 0 + 14U - 1);
((((*stream << kIndent) << ("\"")) << kTestsuites) << ("\": [\n")); cpptestFastCoverageStmt(1589 + 0 + 15U - 1);

bool comma = false; cpptestFastCoverageStmt(1589 + 0 + 16U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1589 + 0 + 17U - 1), i < unit_test.total_test_case_count()); ((void)cpptestFastCoverageStmt(1589 + 0 + 18U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1589 + 0 + 19U - 1), unit_test.GetTestCase(i)->reportable_test_count() > 0)) { 
if (((void)cpptestFastCoverageStmt(1589 + 0 + 20U - 1), comma)) { cpptestFastCoverageStmt(1589 + 0 + 21U - 1);
(*stream << (",\n")); 
} else { cpptestFastCoverageStmt(1589 + 0 + 22U - 1);
comma = true; 
}  cpptestFastCoverageStmt(1589 + 0 + 23U - 1);
PrintJsonTestCase(stream, *unit_test.GetTestCase(i)); 
}  
}  cpptestFastCoverageStmt(1589 + 0 + 24U - 1);

((((*stream << ("\n")) << kIndent) << ("]\n")) << ("}\n")); 
} 

void JsonUnitTestResultPrinter::PrintJsonTestList(std::ostream *
stream, const std::vector< TestCase *>  &test_cases) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1613 + 0 + 1U - 1);
const std::string kTestsuites = "testsuites"; cpptestFastCoverageStmt(1613 + 0 + 2U - 1);
const std::string kIndent = Indent(2); cpptestFastCoverageStmt(1613 + 0 + 3U - 1);
(*stream << ("{\n")); cpptestFastCoverageStmt(1613 + 0 + 4U - 1);
int total_tests = 0; cpptestFastCoverageStmt(1613 + 0 + 5U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1613 + 0 + 6U - 1), i < test_cases.size()); ((void)cpptestFastCoverageStmt(1613 + 0 + 7U - 1), ++i)) { cpptestFastCoverageStmt(1613 + 0 + 8U - 1);
total_tests += test_cases[i]->total_test_count(); 
}  cpptestFastCoverageStmt(1613 + 0 + 9U - 1);
OutputJsonKey(stream, kTestsuites, "tests", total_tests, kIndent); cpptestFastCoverageStmt(1613 + 0 + 10U - 1);

OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent); cpptestFastCoverageStmt(1613 + 0 + 11U - 1);
((((*stream << kIndent) << ("\"")) << kTestsuites) << ("\": [\n")); cpptestFastCoverageStmt(1613 + 0 + 12U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(1613 + 0 + 13U - 1), i < test_cases.size()); ((void)cpptestFastCoverageStmt(1613 + 0 + 14U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(1613 + 0 + 15U - 1), i != 0)) { cpptestFastCoverageStmt(1613 + 0 + 16U - 1);
(*stream << (",\n")); 
}  cpptestFastCoverageStmt(1613 + 0 + 17U - 1);
PrintJsonTestCase(stream, *test_cases[i]); 
}  cpptestFastCoverageStmt(1613 + 0 + 18U - 1);

((((*stream << ("\n")) << kIndent) << ("]\n")) << ("}\n")); 


} 


std::string JsonUnitTestResultPrinter::TestPropertiesAsJson(const TestResult &
result, const std::string &indent) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1631 + 0 + 1U - 1);
Message attributes; cpptestFastCoverageStmt(1631 + 0 + 2U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1631 + 0 + 3U - 1), i < result.test_property_count()); ((void)cpptestFastCoverageStmt(1631 + 0 + 4U - 1), ++i)) { cpptestFastCoverageStmt(1631 + 0 + 5U - 1);
const TestProperty &property = result.GetTestProperty(i); cpptestFastCoverageStmt(1631 + 0 + 6U - 1);
((((((((attributes << (",\n")) << indent) << ("\"")) << property.key()) << ("\": ")) << ("\"")) << EscapeJson(property.value())) << ("\"")); 

}  cpptestFastCoverageStmt(1631 + 0 + 7U - 1);
return attributes.GetString(); 
} 
# 4360 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const char *const OsStackTraceGetterInterface::kElidedFramesMarker = ("... Google Test internal frames ..."); 


std::string OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1638 + 0 + 1U - 1);
# 4407 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static_cast< void>(max_depth); cpptestFastCoverageStmt(1638 + 0 + 2U - 1);
static_cast< void>(skip_count); cpptestFastCoverageStmt(1638 + 0 + 3U - 1);
return ""; 

} 

void OsStackTraceGetter::UponLeavingGTest() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1641 + 0 + 1U - 1);
# 4423 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 



class ScopedPrematureExitFile { 

public: explicit ScopedPrematureExitFile(const char *premature_exit_filepath) : premature_exit_filepath_((premature_exit_filepath) ? premature_exit_filepath : ("")) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);

if (((void)cpptestFastCoverageStmt(1642 + 0 + 1U - 1), !(premature_exit_filepath_).empty())) { cpptestFastCoverageStmt(1642 + 0 + 2U - 1);



FILE *pfile = posix::FOpen(premature_exit_filepath, "w"); cpptestFastCoverageStmt(1642 + 0 + 3U - 1);
fwrite("0", 1, 1, pfile); cpptestFastCoverageStmt(1642 + 0 + 4U - 1);
fclose(pfile); 
}  
} 

~ScopedPrematureExitFile() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1646 + 0 + 1U - 1), !(premature_exit_filepath_).empty())) { cpptestFastCoverageStmt(1646 + 0 + 2U - 1);
int retval = remove((premature_exit_filepath_).c_str()); 
if (((void)cpptestFastCoverageStmt(1646 + 0 + 3U - 1), retval)) { cpptestFastCoverageStmt(1646 + 0 + 4U - 1);
((((GTestLog(::testing::internal::GTEST_ERROR, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 4447).GetStream() << ("Failed to remove premature exit filepath \"")) << premature_exit_filepath_) << ("\" with error ")) << retval); 


}  
}  
} 


private: const std::string premature_exit_filepath_; 

ScopedPrematureExitFile(const ScopedPrematureExitFile &) = delete;void operator=(const ScopedPrematureExitFile &) = delete;
}; 

}



TestEventListeners::TestEventListeners() : repeater_(new internal::TestEventRepeater()), default_result_printer_((nullptr)), default_xml_generator_((nullptr)) 


{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1650 + 0 + 1U - 1);} 

TestEventListeners::~TestEventListeners() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1651 + 0 + 1U - 1);delete (repeater_); } 
# 4475
void TestEventListeners::Append(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1652 + 0 + 1U - 1);
(repeater_)->Append(listener); 
} 




TestEventListener *TestEventListeners::Release(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1653 + 0 + 1U - 1), listener == default_result_printer_)) {cpptestFastCoverageStmt(1653 + 0 + 2U - 1);
default_result_printer_ = (nullptr); } else 
if (((void)cpptestFastCoverageStmt(1653 + 0 + 3U - 1), listener == default_xml_generator_)) {cpptestFastCoverageStmt(1653 + 0 + 4U - 1);
default_xml_generator_ = (nullptr); }    cpptestFastCoverageStmt(1653 + 0 + 5U - 1);
return (repeater_)->Release(listener); 
} 



TestEventListener *TestEventListeners::repeater() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1658 + 0 + 1U - 1);return repeater_; } 
# 4499
void TestEventListeners::SetDefaultResultPrinter(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1659 + 0 + 1U - 1), default_result_printer_ != listener)) { cpptestFastCoverageStmt(1659 + 0 + 2U - 1);


delete this->Release(default_result_printer_); cpptestFastCoverageStmt(1659 + 0 + 3U - 1);
default_result_printer_ = listener; 
if (((void)cpptestFastCoverageStmt(1659 + 0 + 4U - 1), listener != (nullptr))) {cpptestFastCoverageStmt(1659 + 0 + 5U - 1);this->Append(listener); }  
}  
} 
# 4514
void TestEventListeners::SetDefaultXmlGenerator(TestEventListener *listener) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1664 + 0 + 1U - 1), default_xml_generator_ != listener)) { cpptestFastCoverageStmt(1664 + 0 + 2U - 1);


delete this->Release(default_xml_generator_); cpptestFastCoverageStmt(1664 + 0 + 3U - 1);
default_xml_generator_ = listener; 
if (((void)cpptestFastCoverageStmt(1664 + 0 + 4U - 1), listener != (nullptr))) {cpptestFastCoverageStmt(1664 + 0 + 5U - 1);this->Append(listener); }  
}  
} 



bool TestEventListeners::EventForwardingEnabled() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1669 + 0 + 1U - 1);
return (repeater_)->forwarding_enabled(); 
} 

void TestEventListeners::SuppressEventForwarding() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1670 + 0 + 1U - 1);
(repeater_)->set_forwarding_enabled(false); 
} 
# 4543 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
UnitTest *UnitTest::GetInstance() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1671 + 0 + 1U - 1);
# 4559 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static UnitTest instance; cpptestFastCoverageStmt(1671 + 0 + 2U - 1);
return &instance; 

} 


int UnitTest::successful_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1673 + 0 + 1U - 1);
return this->impl()->successful_test_case_count(); 
} 


int UnitTest::failed_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1674 + 0 + 1U - 1);
return this->impl()->failed_test_case_count(); 
} 


int UnitTest::total_test_case_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1675 + 0 + 1U - 1);
return this->impl()->total_test_case_count(); 
} 



int UnitTest::test_case_to_run_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1676 + 0 + 1U - 1);
return this->impl()->test_case_to_run_count(); 
} 


int UnitTest::successful_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1677 + 0 + 1U - 1);
return this->impl()->successful_test_count(); 
} 


int UnitTest::skipped_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1678 + 0 + 1U - 1);
return this->impl()->skipped_test_count(); 
} 


int UnitTest::failed_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1679 + 0 + 1U - 1);return this->impl()->failed_test_count(); } 


int UnitTest::reportable_disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1680 + 0 + 1U - 1);
return this->impl()->reportable_disabled_test_count(); 
} 


int UnitTest::disabled_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1681 + 0 + 1U - 1);
return this->impl()->disabled_test_count(); 
} 


int UnitTest::reportable_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1682 + 0 + 1U - 1);
return this->impl()->reportable_test_count(); 
} 


int UnitTest::total_test_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1683 + 0 + 1U - 1);return this->impl()->total_test_count(); } 


int UnitTest::test_to_run_count() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1684 + 0 + 1U - 1);return this->impl()->test_to_run_count(); } 



internal::TimeInMillis UnitTest::start_timestamp() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1685 + 0 + 1U - 1);
return this->impl()->start_timestamp(); 
} 


internal::TimeInMillis UnitTest::elapsed_time() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1686 + 0 + 1U - 1);
return this->impl()->elapsed_time(); 
} 


bool UnitTest::Passed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1687 + 0 + 1U - 1);return this->impl()->Passed(); } 



bool UnitTest::Failed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1688 + 0 + 1U - 1);return this->impl()->Failed(); } 



const TestCase *UnitTest::GetTestCase(int i) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1689 + 0 + 1U - 1);
return this->impl()->GetTestCase(i); 
} 



const TestResult &UnitTest::ad_hoc_test_result() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1690 + 0 + 1U - 1);
return *this->impl()->ad_hoc_test_result(); 
} 



TestCase *UnitTest::GetMutableTestCase(int i) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1691 + 0 + 1U - 1);
return this->impl()->GetMutableTestCase(i); 
} 



TestEventListeners &UnitTest::listeners() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1692 + 0 + 1U - 1);
return *this->impl()->listeners(); 
} 
# 4671 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
Environment *UnitTest::AddEnvironment(Environment *env) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1693 + 0 + 1U - 1), env == (nullptr))) { cpptestFastCoverageStmt(1693 + 0 + 2U - 1);
return nullptr; 
}  cpptestFastCoverageStmt(1693 + 0 + 3U - 1);

(impl_)->environments().push_back(env); cpptestFastCoverageStmt(1693 + 0 + 4U - 1);
return env; 
} 
# 4684
void UnitTest::AddTestPartResult(TestPartResult::Type 
result_type, const char *
file_name, int 
line_number, const std::string &
message, const std::string &
os_stack_trace) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1697 + 0 + 1U - 1);
Message msg; cpptestFastCoverageStmt(1697 + 0 + 2U - 1);
(msg << message); cpptestFastCoverageStmt(1697 + 0 + 3U - 1);

internal::MutexLock lock(&(mutex_)); 
if (((void)cpptestFastCoverageStmt(1697 + 0 + 4U - 1), (impl_)->gtest_trace_stack().size() > 0)) { cpptestFastCoverageStmt(1697 + 0 + 5U - 1);
(((msg << ("\n")) << ("Google Test")) << (" trace:")); cpptestFastCoverageStmt(1697 + 0 + 6U - 1);

for (int i = static_cast< int>((impl_)->gtest_trace_stack().size()); ((void)cpptestFastCoverageStmt(1697 + 0 + 7U - 1), i > 0); ((void)cpptestFastCoverageStmt(1697 + 0 + 8U - 1), --i)) 
{ cpptestFastCoverageStmt(1697 + 0 + 9U - 1);
const internal::TraceInfo &trace = (impl_)->gtest_trace_stack()[i - 1]; cpptestFastCoverageStmt(1697 + 0 + 10U - 1);
((((msg << ("\n")) << internal::FormatFileLocation(trace.file, trace.line)) << (" ")) << trace.message); 

}  
}  

if (((void)cpptestFastCoverageStmt(1697 + 0 + 11U - 1), os_stack_trace.c_str() != (nullptr) && !os_stack_trace.empty())) { cpptestFastCoverageStmt(1697 + 0 + 12U - 1);
((msg << internal::kStackTraceMarker) << os_stack_trace); 
}  cpptestFastCoverageStmt(1697 + 0 + 13U - 1);

const TestPartResult result = TestPartResult(result_type, file_name, line_number, (msg.GetString()).c_str()); cpptestFastCoverageStmt(1697 + 0 + 14U - 1);

(impl_)->GetTestPartResultReporterForCurrentThread()->ReportTestPartResult(result); 


if (((void)cpptestFastCoverageStmt(1697 + 0 + 15U - 1), result_type != TestPartResult::kSuccess && result_type != TestPartResult::kSkip)) 
{ 
# 4721
if (((void)cpptestFastCoverageStmt(1697 + 0 + 16U - 1), FLAGS_gtest_break_on_failure)) { cpptestFastCoverageStmt(1697 + 0 + 17U - 1);




DebugBreak(); 
# 4739 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} else if (((void)cpptestFastCoverageStmt(1697 + 0 + 18U - 1), FLAGS_gtest_throw_on_failure)) { cpptestFastCoverageStmt(1697 + 0 + 19U - 1);

throw ((internal::GoogleTestFailureException)(result)); 
# 4747
}    
}  
} 
# 4756
void UnitTest::RecordProperty(const std::string &key, const std::string &
value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1716 + 0 + 1U - 1);
(impl_)->RecordProperty(TestProperty(key, value)); 
} 
# 4766
int UnitTest::Run() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1717 + 0 + 1U - 1);
const bool in_death_test_child_process = internal::FLAGS_gtest_internal_run_death_test.length() > 0; cpptestFastCoverageStmt(1717 + 0 + 2U - 1);
# 4791 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const internal::ScopedPrematureExitFile premature_exit_file(in_death_test_child_process ? nullptr : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE")); cpptestFastCoverageStmt(1717 + 0 + 3U - 1);
# 4798
this->impl()->set_catch_exceptions(FLAGS_gtest_catch_exceptions); 
# 4805
if (((void)cpptestFastCoverageStmt(1717 + 0 + 4U - 1), this->impl()->catch_exceptions() || in_death_test_child_process)) { cpptestFastCoverageStmt(1717 + 0 + 5U - 1);


SetErrorMode(((0x1 | 0x4) | 0x2) | 0x8000); cpptestFastCoverageStmt(1717 + 0 + 6U - 1);
# 4816 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
_set_error_mode(1); 
# 4836 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}  cpptestFastCoverageStmt(1717 + 0 + 7U - 1);


return internal::HandleExceptionsInMethodIfSupported(this->impl(), &internal::UnitTestImpl::RunAllTests, "auxiliary test code (environments or event listeners)") ? 0 : 1; 



} 



const char *UnitTest::original_working_dir() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1724 + 0 + 1U - 1);
return (impl_->original_working_dir_).c_str(); 
} 



const TestCase *UnitTest::current_test_case() const 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1725 + 0 + 1U - 1);
internal::MutexLock lock(&(mutex_)); cpptestFastCoverageStmt(1725 + 0 + 2U - 1);
return (impl_)->current_test_case(); 
} 



const TestInfo *UnitTest::current_test_info() const 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1727 + 0 + 1U - 1);
internal::MutexLock lock(&(mutex_)); cpptestFastCoverageStmt(1727 + 0 + 2U - 1);
return (impl_)->current_test_info(); 
} 


int UnitTest::random_seed() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1729 + 0 + 1U - 1);return (impl_)->random_seed(); } 




internal::ParameterizedTestCaseRegistry &UnitTest::parameterized_test_registry() 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1730 + 0 + 1U - 1);
return (impl_)->parameterized_test_registry(); 
} 


UnitTest::UnitTest() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1731 + 0 + 1U - 1);
impl_ = (new internal::UnitTestImpl(this)); 
} 


UnitTest::~UnitTest() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1732 + 0 + 1U - 1);
delete (impl_); 
} 



void UnitTest::PushGTestTrace(const internal::TraceInfo &trace) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1733 + 0 + 1U - 1);
internal::MutexLock lock(&(mutex_)); cpptestFastCoverageStmt(1733 + 0 + 2U - 1);
(impl_)->gtest_trace_stack().push_back(trace); 
} 


void UnitTest::PopGTestTrace() 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1735 + 0 + 1U - 1);
internal::MutexLock lock(&(mutex_)); cpptestFastCoverageStmt(1735 + 0 + 2U - 1);
(impl_)->gtest_trace_stack().pop_back(); 
} 

namespace internal { 

UnitTestImpl::UnitTestImpl(UnitTest *parent) : parent_(parent), default_global_test_part_result_reporter_(this), default_per_thread_test_part_result_reporter_(this), global_test_part_result_repoter_(&(default_global_test_part_result_reporter_)), per_thread_test_part_result_reporter_(&(default_per_thread_test_part_result_reporter_)), parameterized_test_registry_(), parameterized_tests_registered_(false), last_death_test_case_((-1)), current_test_case_((nullptr)), current_test_info_((nullptr)), ad_hoc_test_result_(), os_stack_trace_getter_((nullptr)), post_flag_parse_init_performed_(false), random_seed_(0), random_(0), start_timestamp_((0)), elapsed_time_((0)), death_test_factory_(new DefaultDeathTestFactory), catch_exceptions_(false) 
# 4930
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1737 + 0 + 1U - 1);
this->listeners()->SetDefaultResultPrinter(new PrettyUnitTestResultPrinter); 
} 

UnitTestImpl::~UnitTestImpl() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1738 + 0 + 1U - 1);

ForEach(test_cases_, internal::Delete< TestCase> ); cpptestFastCoverageStmt(1738 + 0 + 2U - 1);


ForEach(environments_, internal::Delete< Environment> ); cpptestFastCoverageStmt(1738 + 0 + 3U - 1);

delete (os_stack_trace_getter_); 
} 
# 4949
void UnitTestImpl::RecordProperty(const TestProperty &test_property) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1741 + 0 + 1U - 1);
std::string xml_element; cpptestFastCoverageStmt(1741 + 0 + 2U - 1);
TestResult *test_result; 

if (((void)cpptestFastCoverageStmt(1741 + 0 + 3U - 1), current_test_info_ != (nullptr))) { cpptestFastCoverageStmt(1741 + 0 + 4U - 1);
(xml_element = ("testcase")); cpptestFastCoverageStmt(1741 + 0 + 5U - 1);
test_result = &(current_test_info_->result_); 
} else if (((void)cpptestFastCoverageStmt(1741 + 0 + 6U - 1), current_test_case_ != (nullptr))) { cpptestFastCoverageStmt(1741 + 0 + 7U - 1);
(xml_element = ("testsuite")); cpptestFastCoverageStmt(1741 + 0 + 8U - 1);
test_result = &(current_test_case_->ad_hoc_test_result_); 
} else { cpptestFastCoverageStmt(1741 + 0 + 9U - 1);
(xml_element = ("testsuites")); cpptestFastCoverageStmt(1741 + 0 + 10U - 1);
test_result = &(ad_hoc_test_result_); 
}    cpptestFastCoverageStmt(1741 + 0 + 11U - 1);
test_result->RecordProperty(xml_element, test_property); 
} 




void UnitTestImpl::SuppressTestEventsIfInSubprocess() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1752 + 0 + 1U - 1), (internal_run_death_test_flag_).get() != (nullptr))) {cpptestFastCoverageStmt(1752 + 0 + 2U - 1);
this->listeners()->SuppressEventForwarding(); }  
} 




void UnitTestImpl::ConfigureXmlOutput() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1754 + 0 + 1U - 1);
const std::string &output_format = UnitTestOptions::GetOutputFormat(); 
if (((void)cpptestFastCoverageStmt(1754 + 0 + 2U - 1), (output_format == ("xml")))) { cpptestFastCoverageStmt(1754 + 0 + 3U - 1);
this->listeners()->SetDefaultXmlGenerator(new XmlUnitTestResultPrinter((UnitTestOptions::GetAbsolutePathToOutputFile()).c_str())); 

} else if (((void)cpptestFastCoverageStmt(1754 + 0 + 4U - 1), (output_format == ("json")))) { cpptestFastCoverageStmt(1754 + 0 + 5U - 1);
this->listeners()->SetDefaultXmlGenerator(new JsonUnitTestResultPrinter((UnitTestOptions::GetAbsolutePathToOutputFile()).c_str())); 

} else if (((void)cpptestFastCoverageStmt(1754 + 0 + 6U - 1), (output_format != ("")))) { cpptestFastCoverageStmt(1754 + 0 + 7U - 1);
(((GTestLog(::testing::internal::GTEST_WARNING, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 4986).GetStream() << ("WARNING: unrecognized output format \"")) << output_format) << ("\" ignored.")); 

}      
} 
# 5014 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
void UnitTestImpl::PostFlagParsingInit() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);

if (((void)cpptestFastCoverageStmt(1761 + 0 + 1U - 1), !post_flag_parse_init_performed_)) { cpptestFastCoverageStmt(1761 + 0 + 2U - 1);
post_flag_parse_init_performed_ = true; cpptestFastCoverageStmt(1761 + 0 + 3U - 1);
# 5025
this->InitDeathTestSubprocessControlInfo(); cpptestFastCoverageStmt(1761 + 0 + 4U - 1);
this->SuppressTestEventsIfInSubprocess(); cpptestFastCoverageStmt(1761 + 0 + 5U - 1);
# 5032
this->RegisterParameterizedTests(); cpptestFastCoverageStmt(1761 + 0 + 6U - 1);



this->ConfigureXmlOutput(); 
# 5049 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}  
} 
# 5060 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
class TestCaseNameIs { 


public: explicit TestCaseNameIs(const std::string &name) : name_(name) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1767 + 0 + 1U - 1);} 


bool operator()(const TestCase *test_case) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1768 + 0 + 1U - 1);
return test_case != (nullptr) && strcmp(test_case->name(), (name_).c_str()) == 0; 

} 


private: std::string name_; 
}; 
# 5088 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
TestCase *UnitTestImpl::GetTestCase(const char *test_case_name, const char *
type_param, Test::SetUpTestCaseFunc 
set_up_tc, Test::TearDownTestCaseFunc 
tear_down_tc) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1769 + 0 + 1U - 1);

const std::vector< TestCase *> ::const_reverse_iterator test_case = std::find_if((test_cases_).rbegin(), (test_cases_).rend(), ((TestCaseNameIs)(test_case_name))); 



if (((void)cpptestFastCoverageStmt(1769 + 0 + 2U - 1), (test_case != (test_cases_).rend()))) {cpptestFastCoverageStmt(1769 + 0 + 3U - 1);
return (*test_case); }  cpptestFastCoverageStmt(1769 + 0 + 4U - 1);


TestCase *const new_test_case = new TestCase(test_case_name, type_param, set_up_tc, tear_down_tc); 



if (((void)cpptestFastCoverageStmt(1769 + 0 + 5U - 1), internal::UnitTestOptions::MatchesFilter(test_case_name, kDeathTestCaseFilter))) 
{ cpptestFastCoverageStmt(1769 + 0 + 6U - 1);




++last_death_test_case_; cpptestFastCoverageStmt(1769 + 0 + 7U - 1);
(test_cases_).insert(((test_cases_).begin() + last_death_test_case_), new_test_case); 

} else { cpptestFastCoverageStmt(1769 + 0 + 8U - 1);

(test_cases_).push_back(new_test_case); 
}  cpptestFastCoverageStmt(1769 + 0 + 9U - 1);

(test_case_indices_).push_back(static_cast< int>((test_case_indices_).size())); cpptestFastCoverageStmt(1769 + 0 + 10U - 1);
return new_test_case; 
} 



static void SetUpEnvironment(Environment *env) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1779 + 0 + 1U - 1);env->SetUp(); } 
static void TearDownEnvironment(Environment *env) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1780 + 0 + 1U - 1);env->TearDown(); } 
# 5137 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
bool UnitTestImpl::RunAllTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1781 + 0 + 1U - 1);

const bool gtest_is_initialized_before_run_all_tests = GTestIsInitialized(); 


if (((void)cpptestFastCoverageStmt(1781 + 0 + 2U - 1), g_help_flag)) {cpptestFastCoverageStmt(1781 + 0 + 3U - 1);
return true; }  cpptestFastCoverageStmt(1781 + 0 + 4U - 1);



this->PostFlagParsingInit(); cpptestFastCoverageStmt(1781 + 0 + 5U - 1);




internal::WriteToShardStatusFileIfNeeded(); cpptestFastCoverageStmt(1781 + 0 + 6U - 1);



bool in_subprocess_for_death_test = false; cpptestFastCoverageStmt(1781 + 0 + 7U - 1);


in_subprocess_for_death_test = ((internal_run_death_test_flag_).get() != (nullptr)); cpptestFastCoverageStmt(1781 + 0 + 8U - 1);
# 5168
const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex, in_subprocess_for_death_test); cpptestFastCoverageStmt(1781 + 0 + 9U - 1);




const bool has_tests_to_run = this->FilterTests(should_shard ? HONOR_SHARDING_PROTOCOL : IGNORE_SHARDING_PROTOCOL) > 0; 




if (((void)cpptestFastCoverageStmt(1781 + 0 + 10U - 1), FLAGS_gtest_list_tests)) { cpptestFastCoverageStmt(1781 + 0 + 11U - 1);

this->ListTestsMatchingFilter(); cpptestFastCoverageStmt(1781 + 0 + 12U - 1);
return true; 
}  cpptestFastCoverageStmt(1781 + 0 + 13U - 1);

random_seed_ = FLAGS_gtest_shuffle ? GetRandomSeedFromFlag(FLAGS_gtest_random_seed) : 0; cpptestFastCoverageStmt(1781 + 0 + 14U - 1);



bool failed = false; cpptestFastCoverageStmt(1781 + 0 + 15U - 1);

TestEventListener *repeater = this->listeners()->repeater(); cpptestFastCoverageStmt(1781 + 0 + 16U - 1);

start_timestamp_ = GetTimeInMillis(); cpptestFastCoverageStmt(1781 + 0 + 17U - 1);
repeater->OnTestProgramStart(*(parent_)); cpptestFastCoverageStmt(1781 + 0 + 18U - 1);



const int repeat = in_subprocess_for_death_test ? 1 : FLAGS_gtest_repeat; cpptestFastCoverageStmt(1781 + 0 + 19U - 1);

const bool forever = repeat < 0; cpptestFastCoverageStmt(1781 + 0 + 20U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1781 + 0 + 21U - 1), forever || i != repeat); ((void)cpptestFastCoverageStmt(1781 + 0 + 22U - 1), i++)) { cpptestFastCoverageStmt(1781 + 0 + 23U - 1);


this->ClearNonAdHocTestResult(); cpptestFastCoverageStmt(1781 + 0 + 24U - 1);

const TimeInMillis start = GetTimeInMillis(); 


if (((void)cpptestFastCoverageStmt(1781 + 0 + 25U - 1), has_tests_to_run && FLAGS_gtest_shuffle)) { cpptestFastCoverageStmt(1781 + 0 + 26U - 1);
this->random()->Reseed(random_seed_); cpptestFastCoverageStmt(1781 + 0 + 27U - 1);



this->ShuffleTests(); 
}  cpptestFastCoverageStmt(1781 + 0 + 28U - 1);


repeater->OnTestIterationStart(*(parent_), i); 


if (((void)cpptestFastCoverageStmt(1781 + 0 + 29U - 1), has_tests_to_run)) { cpptestFastCoverageStmt(1781 + 0 + 30U - 1);

repeater->OnEnvironmentsSetUpStart(*(parent_)); cpptestFastCoverageStmt(1781 + 0 + 31U - 1);
ForEach(environments_, SetUpEnvironment); cpptestFastCoverageStmt(1781 + 0 + 32U - 1);
repeater->OnEnvironmentsSetUpEnd(*(parent_)); 



if (((void)cpptestFastCoverageStmt(1781 + 0 + 33U - 1), !Test::HasFatalFailure())) { cpptestFastCoverageStmt(1781 + 0 + 34U - 1);
for (int test_index = 0; ((void)cpptestFastCoverageStmt(1781 + 0 + 35U - 1), test_index < this->total_test_case_count()); ((void)cpptestFastCoverageStmt(1781 + 0 + 36U - 1), test_index++)) 
{ cpptestFastCoverageStmt(1781 + 0 + 37U - 1);
this->GetMutableTestCase(test_index)->Run(); 
}  
}  cpptestFastCoverageStmt(1781 + 0 + 38U - 1);


repeater->OnEnvironmentsTearDownStart(*(parent_)); cpptestFastCoverageStmt(1781 + 0 + 39U - 1);
std::for_each((environments_).rbegin(), (environments_).rend(), TearDownEnvironment); cpptestFastCoverageStmt(1781 + 0 + 40U - 1);

repeater->OnEnvironmentsTearDownEnd(*(parent_)); 
}  cpptestFastCoverageStmt(1781 + 0 + 41U - 1);

elapsed_time_ = GetTimeInMillis() - start; cpptestFastCoverageStmt(1781 + 0 + 42U - 1);


repeater->OnTestIterationEnd(*(parent_), i); 


if (((void)cpptestFastCoverageStmt(1781 + 0 + 43U - 1), !this->Passed())) { cpptestFastCoverageStmt(1781 + 0 + 44U - 1);
failed = true; 
}  cpptestFastCoverageStmt(1781 + 0 + 45U - 1);
# 5258
this->UnshuffleTests(); 

if (((void)cpptestFastCoverageStmt(1781 + 0 + 46U - 1), FLAGS_gtest_shuffle)) { cpptestFastCoverageStmt(1781 + 0 + 47U - 1);

random_seed_ = GetNextRandomSeed(random_seed_); 
}  
}  cpptestFastCoverageStmt(1781 + 0 + 48U - 1);

repeater->OnTestProgramEnd(*(parent_)); 

if (((void)cpptestFastCoverageStmt(1781 + 0 + 49U - 1), !gtest_is_initialized_before_run_all_tests)) { cpptestFastCoverageStmt(1781 + 0 + 50U - 1);
ColoredPrintf(COLOR_RED, "\nIMPORTANT NOTICE - DO NOT IGNORE:\nThis test program did NOT call testing::InitGoogleTest() before calling RUN_ALL_TESTS(). Th" "is is INVALID. Soon Google Test will start to enforce the valid usage. Please fix it ASAP, or IT WILL START TO FAIL.\n"); 
# 5280
}  cpptestFastCoverageStmt(1781 + 0 + 51U - 1);

return !failed; 
} 
# 5289
void WriteToShardStatusFileIfNeeded() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1832 + 0 + 1U - 1);
const char *const test_shard_file = posix::GetEnv(kTestShardStatusFile); 
if (((void)cpptestFastCoverageStmt(1832 + 0 + 2U - 1), test_shard_file != (nullptr))) { cpptestFastCoverageStmt(1832 + 0 + 3U - 1);
FILE *const file = posix::FOpen(test_shard_file, "w"); 
if (((void)cpptestFastCoverageStmt(1832 + 0 + 4U - 1), file == (nullptr))) { cpptestFastCoverageStmt(1832 + 0 + 5U - 1);
ColoredPrintf(COLOR_RED, "Could not write to the test shard status file \"%s\" specified by the %s environment variable.\n", test_shard_file, kTestShardStatusFile); cpptestFastCoverageStmt(1832 + 0 + 6U - 1);



fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1832 + 0 + 7U - 1);
# 5299 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
exit(1); 
# 5300 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}  cpptestFastCoverageStmt(1832 + 0 + 8U - 1);
fclose(file); 
}  
} 
# 5311
bool ShouldShard(const char *total_shards_env, const char *
shard_index_env, bool 
in_subprocess_for_death_test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1840 + 0 + 1U - 1), in_subprocess_for_death_test)) { cpptestFastCoverageStmt(1840 + 0 + 2U - 1);
return false; 
}  cpptestFastCoverageStmt(1840 + 0 + 3U - 1);

const Int32 total_shards = Int32FromEnvOrDie(total_shards_env, -1); cpptestFastCoverageStmt(1840 + 0 + 4U - 1);
const Int32 shard_index = Int32FromEnvOrDie(shard_index_env, -1); 

if (((void)cpptestFastCoverageStmt(1840 + 0 + 5U - 1), total_shards == -1 && shard_index == -1)) { cpptestFastCoverageStmt(1840 + 0 + 6U - 1);
return false; 
} else if (((void)cpptestFastCoverageStmt(1840 + 0 + 7U - 1), total_shards == -1 && shard_index != -1)) { cpptestFastCoverageStmt(1840 + 0 + 8U - 1);
const Message msg = (((((((Message() << ("Invalid environment variables: you have ")) << kTestShardIndex) << (" = ")) << shard_index) << (", but have left ")) << kTestTotalShards) << (" unset.\n")); cpptestFastCoverageStmt(1840 + 0 + 9U - 1);



ColoredPrintf(COLOR_RED, "%s", (msg.GetString()).c_str()); cpptestFastCoverageStmt(1840 + 0 + 10U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1840 + 0 + 11U - 1);
# 5330 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
exit(1); 
# 5331 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} else if (((void)cpptestFastCoverageStmt(1840 + 0 + 12U - 1), total_shards != -1 && shard_index == -1)) { cpptestFastCoverageStmt(1840 + 0 + 13U - 1);
const Message msg = (((((((Message() << ("Invalid environment variables: you have ")) << kTestTotalShards) << (" = ")) << total_shards) << (", but have left ")) << kTestShardIndex) << (" unset.\n")); cpptestFastCoverageStmt(1840 + 0 + 14U - 1);



ColoredPrintf(COLOR_RED, "%s", (msg.GetString()).c_str()); cpptestFastCoverageStmt(1840 + 0 + 15U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1840 + 0 + 16U - 1);
# 5338 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
exit(1); 
# 5339 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} else if (((void)cpptestFastCoverageStmt(1840 + 0 + 17U - 1), shard_index < 0 || shard_index >= total_shards)) { cpptestFastCoverageStmt(1840 + 0 + 18U - 1);
const Message msg = (((((((((((((Message() << ("Invalid environment variables: we require 0 <= ")) << kTestShardIndex) << (" < ")) << kTestTotalShards) << (", but you have ")) << kTestShardIndex) << ("=")) << shard_index) << (", ")) << kTestTotalShards) << ("=")) << total_shards) << (".\n")); cpptestFastCoverageStmt(1840 + 0 + 19U - 1);




ColoredPrintf(COLOR_RED, "%s", (msg.GetString()).c_str()); cpptestFastCoverageStmt(1840 + 0 + 20U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1840 + 0 + 21U - 1);
# 5347 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
exit(1); 
# 5348 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}        cpptestFastCoverageStmt(1840 + 0 + 22U - 1);

return total_shards > 1; 
} 




Int32 Int32FromEnvOrDie(const char *var, Int32 default_val) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1862 + 0 + 1U - 1);
const char *str_val = posix::GetEnv(var); 
if (((void)cpptestFastCoverageStmt(1862 + 0 + 2U - 1), str_val == (nullptr))) { cpptestFastCoverageStmt(1862 + 0 + 3U - 1);
return default_val; 
}  cpptestFastCoverageStmt(1862 + 0 + 4U - 1);

Int32 result; 
if (((void)cpptestFastCoverageStmt(1862 + 0 + 5U - 1), !ParseInt32(((Message() << ("The value of environment variable ")) << var), str_val, &result))) 
{ cpptestFastCoverageStmt(1862 + 0 + 6U - 1);
exit(1); 
# 5366 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
}  cpptestFastCoverageStmt(1862 + 0 + 7U - 1);
return result; 
} 
# 5374
bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1869 + 0 + 1U - 1);
return (test_id % total_shards) == shard_index; 
} 
# 5385 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1870 + 0 + 1U - 1);
const Int32 total_shards = (shard_tests == HONOR_SHARDING_PROTOCOL) ? Int32FromEnvOrDie(kTestTotalShards, -1) : (-1); cpptestFastCoverageStmt(1870 + 0 + 2U - 1);

const Int32 shard_index = (shard_tests == HONOR_SHARDING_PROTOCOL) ? Int32FromEnvOrDie(kTestShardIndex, -1) : (-1); cpptestFastCoverageStmt(1870 + 0 + 3U - 1);
# 5395
int num_runnable_tests = 0; cpptestFastCoverageStmt(1870 + 0 + 4U - 1);
int num_selected_tests = 0; cpptestFastCoverageStmt(1870 + 0 + 5U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1870 + 0 + 6U - 1), i < (test_cases_).size()); ((void)cpptestFastCoverageStmt(1870 + 0 + 7U - 1), i++)) { cpptestFastCoverageStmt(1870 + 0 + 8U - 1);
TestCase *const test_case = test_cases_[i]; cpptestFastCoverageStmt(1870 + 0 + 9U - 1);
const std::string &test_case_name = test_case->name(); cpptestFastCoverageStmt(1870 + 0 + 10U - 1);
test_case->set_should_run(false); cpptestFastCoverageStmt(1870 + 0 + 11U - 1);

for (size_t j = (0); ((void)cpptestFastCoverageStmt(1870 + 0 + 12U - 1), j < test_case->test_info_list().size()); ((void)cpptestFastCoverageStmt(1870 + 0 + 13U - 1), j++)) { cpptestFastCoverageStmt(1870 + 0 + 14U - 1);
TestInfo *const test_info = test_case->test_info_list()[j]; cpptestFastCoverageStmt(1870 + 0 + 15U - 1);
const std::string test_name(test_info->name()); cpptestFastCoverageStmt(1870 + 0 + 16U - 1);


const bool is_disabled = internal::UnitTestOptions::MatchesFilter(test_case_name, kDisableTestFilter) || internal::UnitTestOptions::MatchesFilter(test_name, kDisableTestFilter); cpptestFastCoverageStmt(1870 + 0 + 17U - 1);




test_info->is_disabled_ = is_disabled; cpptestFastCoverageStmt(1870 + 0 + 18U - 1);

const bool matches_filter = internal::UnitTestOptions::FilterMatchesTest(test_case_name, test_name); cpptestFastCoverageStmt(1870 + 0 + 19U - 1);


test_info->matches_filter_ = matches_filter; cpptestFastCoverageStmt(1870 + 0 + 20U - 1);

const bool is_runnable = (FLAGS_gtest_also_run_disabled_tests || !is_disabled) && matches_filter; cpptestFastCoverageStmt(1870 + 0 + 21U - 1);



const bool is_in_another_shard = shard_tests != IGNORE_SHARDING_PROTOCOL && !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests); cpptestFastCoverageStmt(1870 + 0 + 22U - 1);


test_info->is_in_another_shard_ = is_in_another_shard; cpptestFastCoverageStmt(1870 + 0 + 23U - 1);
const bool is_selected = is_runnable && !is_in_another_shard; cpptestFastCoverageStmt(1870 + 0 + 24U - 1);

num_runnable_tests += is_runnable; cpptestFastCoverageStmt(1870 + 0 + 25U - 1);
num_selected_tests += is_selected; cpptestFastCoverageStmt(1870 + 0 + 26U - 1);

test_info->should_run_ = is_selected; cpptestFastCoverageStmt(1870 + 0 + 27U - 1);
test_case->set_should_run(test_case->should_run() || is_selected); 
}  
}  cpptestFastCoverageStmt(1870 + 0 + 28U - 1);
return num_selected_tests; 
} 
# 5443
static void PrintOnOneLine(const char *str, int max_length) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1898 + 0 + 1U - 1), str != (nullptr))) { cpptestFastCoverageStmt(1898 + 0 + 2U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(1898 + 0 + 3U - 1), *str != '\000'); ((void)cpptestFastCoverageStmt(1898 + 0 + 4U - 1), ++str)) { 
if (((void)cpptestFastCoverageStmt(1898 + 0 + 5U - 1), i >= max_length)) { cpptestFastCoverageStmt(1898 + 0 + 6U - 1);
printf("..."); cpptestFastCoverageStmt(1898 + 0 + 7U - 1);
break; 
}  
if (((void)cpptestFastCoverageStmt(1898 + 0 + 8U - 1), *str == '\n')) { cpptestFastCoverageStmt(1898 + 0 + 9U - 1);
printf("\\n"); cpptestFastCoverageStmt(1898 + 0 + 10U - 1);
i += 2; 
} else { cpptestFastCoverageStmt(1898 + 0 + 11U - 1);
printf("%c", *str); cpptestFastCoverageStmt(1898 + 0 + 12U - 1);
++i; 
}  
}  
}  
} 


void UnitTestImpl::ListTestsMatchingFilter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1910 + 0 + 1U - 1);

const int kMaxParamLength = 250; cpptestFastCoverageStmt(1910 + 0 + 2U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(1910 + 0 + 3U - 1), i < (test_cases_).size()); ((void)cpptestFastCoverageStmt(1910 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(1910 + 0 + 5U - 1);
const TestCase *const test_case = test_cases_[i]; cpptestFastCoverageStmt(1910 + 0 + 6U - 1);
bool printed_test_case_name = false; cpptestFastCoverageStmt(1910 + 0 + 7U - 1);

for (size_t j = (0); ((void)cpptestFastCoverageStmt(1910 + 0 + 8U - 1), j < test_case->test_info_list().size()); ((void)cpptestFastCoverageStmt(1910 + 0 + 9U - 1), j++)) { cpptestFastCoverageStmt(1910 + 0 + 10U - 1);
const TestInfo *const test_info = test_case->test_info_list()[j]; 

if (((void)cpptestFastCoverageStmt(1910 + 0 + 11U - 1), test_info->matches_filter_)) { 
if (((void)cpptestFastCoverageStmt(1910 + 0 + 12U - 1), !printed_test_case_name)) { cpptestFastCoverageStmt(1910 + 0 + 13U - 1);
printed_test_case_name = true; cpptestFastCoverageStmt(1910 + 0 + 14U - 1);
printf("%s.", test_case->name()); 
if (((void)cpptestFastCoverageStmt(1910 + 0 + 15U - 1), test_case->type_param() != (nullptr))) { cpptestFastCoverageStmt(1910 + 0 + 16U - 1);
printf("  # %s = ", kTypeParamLabel); cpptestFastCoverageStmt(1910 + 0 + 17U - 1);


PrintOnOneLine(test_case->type_param(), kMaxParamLength); 
}  cpptestFastCoverageStmt(1910 + 0 + 18U - 1);
printf("\n"); 
}  cpptestFastCoverageStmt(1910 + 0 + 19U - 1);
printf("  %s", test_info->name()); 
if (((void)cpptestFastCoverageStmt(1910 + 0 + 20U - 1), test_info->value_param() != (nullptr))) { cpptestFastCoverageStmt(1910 + 0 + 21U - 1);
printf("  # %s = ", kValueParamLabel); cpptestFastCoverageStmt(1910 + 0 + 22U - 1);


PrintOnOneLine(test_info->value_param(), kMaxParamLength); 
}  cpptestFastCoverageStmt(1910 + 0 + 23U - 1);
printf("\n"); 
}  
}  
}  cpptestFastCoverageStmt(1910 + 0 + 24U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(1910 + 0 + 25U - 1);
# 5497 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
const std::string &output_format = UnitTestOptions::GetOutputFormat(); 
if (((void)cpptestFastCoverageStmt(1910 + 0 + 26U - 1), (output_format == ("xml")) || (output_format == ("json")))) { cpptestFastCoverageStmt(1910 + 0 + 27U - 1);
FILE *fileout = OpenFileForWriting((UnitTestOptions::GetAbsolutePathToOutputFile()).c_str()); cpptestFastCoverageStmt(1910 + 0 + 28U - 1);

std::stringstream stream; 
if (((void)cpptestFastCoverageStmt(1910 + 0 + 29U - 1), (output_format == ("xml")))) { cpptestFastCoverageStmt(1910 + 0 + 30U - 1);
((XmlUnitTestResultPrinter)((UnitTestOptions::GetAbsolutePathToOutputFile()).c_str())).PrintXmlTestsList(&stream, test_cases_); 


} else if (((void)cpptestFastCoverageStmt(1910 + 0 + 31U - 1), (output_format == ("json")))) { cpptestFastCoverageStmt(1910 + 0 + 32U - 1);
((JsonUnitTestResultPrinter)((UnitTestOptions::GetAbsolutePathToOutputFile()).c_str())).PrintJsonTestList(&stream, test_cases_); 


}    cpptestFastCoverageStmt(1910 + 0 + 33U - 1);
fprintf(fileout, "%s", (StringStreamToString(&stream)).c_str()); cpptestFastCoverageStmt(1910 + 0 + 34U - 1);
fclose(fileout); 
}  
} 
# 5521
void UnitTestImpl::set_os_stack_trace_getter(OsStackTraceGetterInterface *
getter) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1944 + 0 + 1U - 1), os_stack_trace_getter_ != getter)) { cpptestFastCoverageStmt(1944 + 0 + 2U - 1);
delete (os_stack_trace_getter_); cpptestFastCoverageStmt(1944 + 0 + 3U - 1);
os_stack_trace_getter_ = getter; 
}  
} 




OsStackTraceGetterInterface *UnitTestImpl::os_stack_trace_getter() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1947 + 0 + 1U - 1), os_stack_trace_getter_ == (nullptr))) { cpptestFastCoverageStmt(1947 + 0 + 2U - 1);



os_stack_trace_getter_ = (new OsStackTraceGetter); 

}  cpptestFastCoverageStmt(1947 + 0 + 3U - 1);

return os_stack_trace_getter_; 
} 


TestResult *UnitTestImpl::current_test_result() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(1950 + 0 + 1U - 1), current_test_info_ != (nullptr))) { cpptestFastCoverageStmt(1950 + 0 + 2U - 1);
return &(current_test_info_->result_); 
}  
if (((void)cpptestFastCoverageStmt(1950 + 0 + 3U - 1), current_test_case_ != (nullptr))) { cpptestFastCoverageStmt(1950 + 0 + 4U - 1);
return &(current_test_case_->ad_hoc_test_result_); 
}  cpptestFastCoverageStmt(1950 + 0 + 5U - 1);
return &(ad_hoc_test_result_); 
} 



void UnitTestImpl::ShuffleTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1955 + 0 + 1U - 1);

ShuffleRange(this->random(), 0, last_death_test_case_ + 1, &(test_case_indices_)); cpptestFastCoverageStmt(1955 + 0 + 2U - 1);


ShuffleRange(this->random(), last_death_test_case_ + 1, static_cast< int>((test_cases_).size()), &(test_case_indices_)); cpptestFastCoverageStmt(1955 + 0 + 3U - 1);



for (size_t i = (0); ((void)cpptestFastCoverageStmt(1955 + 0 + 4U - 1), i < (test_cases_).size()); ((void)cpptestFastCoverageStmt(1955 + 0 + 5U - 1), i++)) { cpptestFastCoverageStmt(1955 + 0 + 6U - 1);
test_cases_[i]->ShuffleTests(this->random()); 
}  
} 


void UnitTestImpl::UnshuffleTests() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1961 + 0 + 1U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(1961 + 0 + 2U - 1), i < (test_cases_).size()); ((void)cpptestFastCoverageStmt(1961 + 0 + 3U - 1), i++)) { cpptestFastCoverageStmt(1961 + 0 + 4U - 1);

test_cases_[i]->UnshuffleTests(); cpptestFastCoverageStmt(1961 + 0 + 5U - 1);

test_case_indices_[i] = static_cast< int>(i); 
}  
} 
# 5591 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
std::string GetCurrentOsStackTraceExceptTop(UnitTest *, int 
skip_count) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1966 + 0 + 1U - 1);


return GetUnitTestImpl()->CurrentOsStackTraceExceptTop(skip_count + 1); 
} 



namespace { 
class ClassUniqueToAlwaysTrue { }; 
}

bool IsTrue(bool condition) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1967 + 0 + 1U - 1);return condition; } 

bool AlwaysTrue() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);



if (((void)cpptestFastCoverageStmt(1968 + 0 + 1U - 1), IsTrue(false))) {cpptestFastCoverageStmt(1968 + 0 + 2U - 1);
throw internal::ClassUniqueToAlwaysTrue(); }  cpptestFastCoverageStmt(1968 + 0 + 3U - 1);

return true; 
} 




bool SkipPrefix(const char *prefix, const char **pstr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1971 + 0 + 1U - 1);
const size_t prefix_len = strlen(prefix); 
if (((void)cpptestFastCoverageStmt(1971 + 0 + 2U - 1), strncmp(*pstr, prefix, prefix_len) == 0)) { cpptestFastCoverageStmt(1971 + 0 + 3U - 1);
*pstr += prefix_len; cpptestFastCoverageStmt(1971 + 0 + 4U - 1);
return true; 
}  cpptestFastCoverageStmt(1971 + 0 + 5U - 1);
return false; 
} 
# 5633
static const char *ParseFlagValue(const char *str, const char *flag, bool 
def_optional) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);

if (((void)cpptestFastCoverageStmt(1976 + 0 + 1U - 1), str == (nullptr) || flag == (nullptr))) {cpptestFastCoverageStmt(1976 + 0 + 2U - 1);return nullptr; }  cpptestFastCoverageStmt(1976 + 0 + 3U - 1);


const std::string flag_str = ((((std::__cxx11::basic_string< char> )("--")) + ("gtest_")) + flag); cpptestFastCoverageStmt(1976 + 0 + 4U - 1);
const size_t flag_len = flag_str.length(); 
if (((void)cpptestFastCoverageStmt(1976 + 0 + 5U - 1), strncmp(str, flag_str.c_str(), flag_len) != 0)) {cpptestFastCoverageStmt(1976 + 0 + 6U - 1);return nullptr; }  cpptestFastCoverageStmt(1976 + 0 + 7U - 1);


const char *flag_end = str + flag_len; 


if (((void)cpptestFastCoverageStmt(1976 + 0 + 8U - 1), def_optional && (flag_end[0] == '\000'))) { cpptestFastCoverageStmt(1976 + 0 + 9U - 1);
return flag_end; 
}  




if (((void)cpptestFastCoverageStmt(1976 + 0 + 10U - 1), flag_end[0] != '=')) {cpptestFastCoverageStmt(1976 + 0 + 11U - 1);return nullptr; }  cpptestFastCoverageStmt(1976 + 0 + 12U - 1);


return flag_end + 1; 
} 
# 5670 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static bool ParseBoolFlag(const char *str, const char *flag, bool *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1988 + 0 + 1U - 1);

const char *const value_str = ParseFlagValue(str, flag, true); 


if (((void)cpptestFastCoverageStmt(1988 + 0 + 2U - 1), value_str == (nullptr))) {cpptestFastCoverageStmt(1988 + 0 + 3U - 1);return false; }  cpptestFastCoverageStmt(1988 + 0 + 4U - 1);


*value = !((*value_str == '0' || *value_str == 'f') || *value_str == 'F'); cpptestFastCoverageStmt(1988 + 0 + 5U - 1);
return true; 
} 
# 5687
bool ParseInt32Flag(const char *str, const char *flag, Int32 *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1993 + 0 + 1U - 1);

const char *const value_str = ParseFlagValue(str, flag, false); 


if (((void)cpptestFastCoverageStmt(1993 + 0 + 2U - 1), value_str == (nullptr))) {cpptestFastCoverageStmt(1993 + 0 + 3U - 1);return false; }  cpptestFastCoverageStmt(1993 + 0 + 4U - 1);


return ParseInt32(((Message() << ("The value of flag --")) << flag), value_str, value); 

} 
# 5704
template < typename String > 
static bool ParseStringFlag (const char * str , const char * flag , String * value) { 

const char * const value_str = ParseFlagValue (str , flag , false) ; 


if (value_str == nullptr) return false ; 


* value = value_str ; 
return true ; 
} 
# 5723
static bool HasGoogleTestFlagPrefix(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1997 + 0 + 1U - 1);
return (((SkipPrefix("--", &str) || SkipPrefix("-", &str)) || SkipPrefix("/", &str)) && !SkipPrefix("gtest_internal_", &str)) && (SkipPrefix("gtest_", &str) || SkipPrefix("gtest-", &str)); 
# 5730
} 
# 5743 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
static void PrintColorEncoded(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(1998 + 0 + 1U - 1);
GTestColor color = COLOR_DEFAULT; 
# 5750
for (; 1;) { cpptestFastCoverageStmt(1998 + 0 + 2U - 1);
const char *p = strchr(str, '@'); 
if (((void)cpptestFastCoverageStmt(1998 + 0 + 3U - 1), p == (nullptr))) { cpptestFastCoverageStmt(1998 + 0 + 4U - 1);
ColoredPrintf(color, "%s", str); cpptestFastCoverageStmt(1998 + 0 + 5U - 1);
return; 
}  cpptestFastCoverageStmt(1998 + 0 + 6U - 1);

ColoredPrintf(color, "%s", std::string(str, p).c_str()); cpptestFastCoverageStmt(1998 + 0 + 7U - 1);

const char ch = p[1]; cpptestFastCoverageStmt(1998 + 0 + 8U - 1);
str = p + 2; 
if (((void)cpptestFastCoverageStmt(1998 + 0 + 9U - 1), ch == '@')) { cpptestFastCoverageStmt(1998 + 0 + 10U - 1);
ColoredPrintf(color, "@"); 
} else if (((void)cpptestFastCoverageStmt(1998 + 0 + 11U - 1), ch == 'D')) { cpptestFastCoverageStmt(1998 + 0 + 12U - 1);
color = COLOR_DEFAULT; 
} else if (((void)cpptestFastCoverageStmt(1998 + 0 + 13U - 1), ch == 'R')) { cpptestFastCoverageStmt(1998 + 0 + 14U - 1);
color = COLOR_RED; 
} else if (((void)cpptestFastCoverageStmt(1998 + 0 + 15U - 1), ch == 'G')) { cpptestFastCoverageStmt(1998 + 0 + 16U - 1);
color = COLOR_GREEN; 
} else if (((void)cpptestFastCoverageStmt(1998 + 0 + 17U - 1), ch == 'Y')) { cpptestFastCoverageStmt(1998 + 0 + 18U - 1);
color = COLOR_YELLOW; 
} else { cpptestFastCoverageStmt(1998 + 0 + 19U - 1);
--str; 
}          
}  
} 

static const char kColorEncodedHelpMessage[] = "This program contains tests written using Google Test. You can use the\nfollowing command line flags to control its behavior:\n\n" "Test Selection:\n  @G--gtest_list_tests@D\n      List the names of all tests instead of running them. The name of\n      TEST(Fo" "o, Bar) is \"Foo.Bar\".\n  @G--gtest_filter=@YPOSTIVE_PATTERNS[@G-@YNEGATIVE_PATTERNS]@D\n      Run only the tests whose name ma" "tches one of the positive patterns but\n      none of the negative patterns. \'\?\' matches any single character; \'*\'\n      m" "atches any substring; \':\' separates two patterns.\n  @G--gtest_also_run_disabled_tests@D\n      Run all disabled tests too.\n\n" "Test Execution:\n  @G--gtest_repeat=@Y[COUNT]@D\n      Run the tests repeatedly; use a negative count to repeat forever.\n  @G--" "gtest_shuffle@D\n      Randomize tests\' orders on every iteration.\n  @G--gtest_random_seed=@Y[NUMBER]@D\n      Random number s" "eed to use for shuffling test orders (between 1 and\n      99999, or 0 to use a seed based on the current time).\n\nTest Output:" "\n  @G--gtest_color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n      Enable/disable colored output. The default is @Gauto@D.\n  -@G-gtest_pr" "int_time=0@D\n      Don\'t print the elapsed time of each test.\n  @G--gtest_output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G\\" "@Y|@G:@YFILE_PATH]@D\n      Generate a JSON or XML report in the given directory or with the given\n      file name. @YFILE_PATH" "@D defaults to @Gtest_details.xml@D.\n\nAssertion Behavior:\n  @G--gtest_break_on_failure@D\n      Turn assertion failures into " "debugger break-points.\n  @G--gtest_throw_on_failure@D\n      Turn assertion failures into C++ exceptions for use by an external" "\n      test framework.\n  @G--gtest_catch_exceptions=0@D\n      Do not report exceptions as test failures. Instead, allow them\n" "      to crash the program or throw a pop-up (on Windows).\n\nExcept for @G--gtest_list_tests@D, you can alternatively set the c" "orresponding\nenvironment variable of a flag (all letters in upper-case). For example, to\ndisable colored text output, you can " "either specify @G--gtest_color=no@D or set\nthe @GGTEST_COLOR@D environment variable to @Gno@D.\n\nFor more information, please " "read the Google Test documentation at\n@Ghttps://github.com/google/googletest/@D. If you find a bug in Google Test\n(not one in " "your own code or tests), please report it to\n@G<googletestframework@@googlegroups.com>@D.\n"; 
# 5842
static bool ParseGoogleTestFlag(const char *const arg) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2017 + 0 + 1U - 1);
return ((((((((((((((((ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag, &FLAGS_gtest_also_run_disabled_tests) || ParseBoolFlag(arg, kBreakOnFailureFlag, &FLAGS_gtest_break_on_failure)) || ParseBoolFlag(arg, kCatchExceptionsFlag, &FLAGS_gtest_catch_exceptions)) || ParseStringFlag(arg, kColorFlag, &FLAGS_gtest_color)) || ParseStringFlag(arg, kDeathTestStyleFlag, &FLAGS_gtest_death_test_style)) || ParseBoolFlag(arg, kDeathTestUseFork, &FLAGS_gtest_death_test_use_fork)) || ParseStringFlag(arg, kFilterFlag, &FLAGS_gtest_filter)) || ParseStringFlag(arg, kInternalRunDeathTestFlag, &FLAGS_gtest_internal_run_death_test)) || ParseBoolFlag(arg, kListTestsFlag, &FLAGS_gtest_list_tests)) || ParseStringFlag(arg, kOutputFlag, &FLAGS_gtest_output)) || ParseBoolFlag(arg, kPrintTimeFlag, &FLAGS_gtest_print_time)) || ParseBoolFlag(arg, kPrintUTF8Flag, &FLAGS_gtest_print_utf8)) || ParseInt32Flag(arg, kRandomSeedFlag, &FLAGS_gtest_random_seed)) || ParseInt32Flag(arg, kRepeatFlag, &FLAGS_gtest_repeat)) || ParseBoolFlag(arg, kShuffleFlag, &FLAGS_gtest_shuffle)) || ParseInt32Flag(arg, kStackTraceDepthFlag, &FLAGS_gtest_stack_trace_depth)) || ParseStringFlag(arg, kStreamResultToFlag, &FLAGS_gtest_stream_result_to)) || ParseBoolFlag(arg, kThrowOnFailureFlag, &FLAGS_gtest_throw_on_failure); 
# 5870
} 


static void LoadFlagsFromFile(const std::string &path) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2018 + 0 + 1U - 1);
FILE *flagfile = posix::FOpen(path.c_str(), "r"); 
if (((void)cpptestFastCoverageStmt(2018 + 0 + 2U - 1), !flagfile)) { cpptestFastCoverageStmt(2018 + 0 + 3U - 1);
(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc", 5876).GetStream() << ("Unable to open file \"")) << FLAGS_gtest_flagfile) << ("\"")); 

}  cpptestFastCoverageStmt(2018 + 0 + 4U - 1);
std::string contents(ReadEntireFile(flagfile)); cpptestFastCoverageStmt(2018 + 0 + 5U - 1);
posix::FClose(flagfile); cpptestFastCoverageStmt(2018 + 0 + 6U - 1);
std::vector< std::__cxx11::basic_string< char> >  lines; cpptestFastCoverageStmt(2018 + 0 + 7U - 1);
SplitString(contents, '\n', &lines); cpptestFastCoverageStmt(2018 + 0 + 8U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(2018 + 0 + 9U - 1), i < lines.size()); ((void)cpptestFastCoverageStmt(2018 + 0 + 10U - 1), ++i)) { 
if (((void)cpptestFastCoverageStmt(2018 + 0 + 11U - 1), lines[i].empty())) {cpptestFastCoverageStmt(2018 + 0 + 12U - 1);
continue; }  
if (((void)cpptestFastCoverageStmt(2018 + 0 + 13U - 1), !ParseGoogleTestFlag(lines[i].c_str()))) {cpptestFastCoverageStmt(2018 + 0 + 14U - 1);
g_help_flag = true; }  
}  
} 
# 5895
template < typename CharType > 
void ParseGoogleTestFlagsOnlyImpl (int * argc , CharType * * argv) { 
for (int i = 1 ; i < * argc ; i ++) { 
const std :: string arg_string = StreamableToString (argv [ i ]) ; 
const char * const arg = arg_string . c_str () ; 

using internal :: ParseBoolFlag ; 
using internal :: ParseInt32Flag ; 
using internal :: ParseStringFlag ; 

bool remove_flag = false ; 
if (ParseGoogleTestFlag (arg)) { 
remove_flag = true ; 

} else if (ParseStringFlag (arg , kFlagfileFlag , & FLAGS_gtest_flagfile)) { 
LoadFlagsFromFile (FLAGS_gtest_flagfile) ; 
remove_flag = true ; 

} else if (arg_string == "--help" || arg_string == "-h" || 
arg_string == "-?" || arg_string == "/?" || 
HasGoogleTestFlagPrefix (arg)) { 


g_help_flag = true ; 
} 

if (remove_flag) { 




for (int j = i ; j != * argc ; j ++) { 
argv [ j ] = argv [ j + 1 ] ; 
} 


(* argc) -- ; 



i -- ; 
} 
} 

if (g_help_flag) { 



PrintColorEncoded (kColorEncodedHelpMessage) ; 
} 
} 



void ParseGoogleTestFlagsOnly(int *argc, char **argv) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2032 + 0 + 1U - 1);
ParseGoogleTestFlagsOnlyImpl(argc, argv); 
# 5962 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
} 
void ParseGoogleTestFlagsOnly(int *argc, wchar_t **argv) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2033 + 0 + 1U - 1);
ParseGoogleTestFlagsOnlyImpl(argc, argv); 
} 
# 5971
template < typename CharType > 
void InitGoogleTestImpl (int * argc , CharType * * argv) { 

if (GTestIsInitialized ()) return ; 

if (* argc <= 0) return ; 

g_argvs . clear () ; 
for (int i = 0 ; i != * argc ; i ++) { 
g_argvs . push_back (StreamableToString (argv [ i ])) ; 
} 
# 5987
ParseGoogleTestFlagsOnly (argc , argv) ; 
GetUnitTestImpl () -> PostFlagParsingInit () ; 
} 

}
# 6002 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
void InitGoogleTest(int *argc, char **argv) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2034 + 0 + 1U - 1);



internal::InitGoogleTestImpl(argc, argv); 

} 



void InitGoogleTest(int *argc, wchar_t **argv) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2035 + 0 + 1U - 1);



internal::InitGoogleTestImpl(argc, argv); 

} 

std::string TempDir() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2036 + 0 + 1U - 1);
# 6028
const char *temp_dir = internal::posix::GetEnv("TEMP"); 
if (((void)cpptestFastCoverageStmt(2036 + 0 + 2U - 1), temp_dir == __null || temp_dir[0] == '\000')) {cpptestFastCoverageStmt(2036 + 0 + 3U - 1);
# 6030 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest.cc"
return "\\temp\\"; } else 
if (((void)cpptestFastCoverageStmt(2036 + 0 + 4U - 1), temp_dir[strlen(temp_dir) - 1] == '\\')) {cpptestFastCoverageStmt(2036 + 0 + 5U - 1);
return temp_dir; } else {cpptestFastCoverageStmt(2036 + 0 + 6U - 1);

return (((std::__cxx11::basic_string< char> )(temp_dir)) + ("\\")); }    
# 6040
} 
# 6046
void ScopedTrace::PushTrace(const char *file, int line, std::string message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2042 + 0 + 1U - 1);
internal::TraceInfo trace; cpptestFastCoverageStmt(2042 + 0 + 2U - 1);
trace.file = file; cpptestFastCoverageStmt(2042 + 0 + 3U - 1);
trace.line = line; cpptestFastCoverageStmt(2042 + 0 + 4U - 1);
(trace.message).swap(message); cpptestFastCoverageStmt(2042 + 0 + 5U - 1);

UnitTest::GetInstance()->PushGTestTrace(trace); 
} 


ScopedTrace::~ScopedTrace() 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2047 + 0 + 1U - 1);
UnitTest::GetInstance()->PopGTestTrace(); 
} 

}
# 78 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
namespace testing { 
# 87 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
static const char kDefaultDeathTestStyle[] = "fast"; 

__attribute((visibility("default"))) std::string FLAGS_gtest_death_test_style = (internal::StringFromGTestEnv("death_test_style", kDefaultDeathTestStyle)); 
# 98
__attribute((visibility("default"))) bool FLAGS_gtest_death_test_use_fork = (internal::BoolFromGTestEnv("death_test_use_fork", false)); 
# 110 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
namespace internal { 
__attribute((visibility("default"))) std::string FLAGS_gtest_internal_run_death_test = (""); 
# 119
}



namespace internal { 
# 136 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
bool InDeathTestChild() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2048 + 0 + 1U - 1);




return !FLAGS_gtest_internal_run_death_test.empty(); 
# 150 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
} 

}


ExitedWithCode::ExitedWithCode(int exit_code) : exit_code_(exit_code) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2049 + 0 + 1U - 1);
} 


bool ExitedWithCode::operator()(int exit_status) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2050 + 0 + 1U - 1);


return exit_status == exit_code_; 
# 169
} 
# 190 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
namespace internal { 
# 196
static std::string ExitSummary(int exit_code) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2051 + 0 + 1U - 1);
Message m; cpptestFastCoverageStmt(2051 + 0 + 2U - 1);



((m << ("Exited with exit status ")) << exit_code); cpptestFastCoverageStmt(2051 + 0 + 3U - 1);
# 217 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
return m.GetString(); 
} 



bool ExitedUnsuccessfully(int exit_status) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2054 + 0 + 1U - 1);
return !((ExitedWithCode)(0))(exit_status); 
} 
# 250 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
static const char kDeathTestLived = 'L'; 
static const char kDeathTestReturned = 'R'; 
static const char kDeathTestThrew = 'T'; 
static const char kDeathTestInternalError = 'I'; 
# 271 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
enum DeathTestOutcome { IN_PROGRESS, DIED, LIVED, RETURNED, THREW}; 
# 278
static void DeathTestAbort(const std::string &message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2055 + 0 + 1U - 1);



const InternalRunDeathTestFlag *const flag = GetUnitTestImpl()->internal_run_death_test_flag(); 

if (((void)cpptestFastCoverageStmt(2055 + 0 + 2U - 1), flag != (nullptr))) { cpptestFastCoverageStmt(2055 + 0 + 3U - 1);
FILE *parent = posix::FDOpen(flag->write_fd(), "w"); cpptestFastCoverageStmt(2055 + 0 + 4U - 1);
fputc(kDeathTestInternalError, parent); cpptestFastCoverageStmt(2055 + 0 + 5U - 1);
fprintf(parent, "%s", message.c_str()); cpptestFastCoverageStmt(2055 + 0 + 6U - 1);
fflush(parent); cpptestFastCoverageStmt(2055 + 0 + 7U - 1);
_exit(1); 
} else { cpptestFastCoverageStmt(2055 + 0 + 8U - 1);
fprintf((&((_iob)[2])), "%s", message.c_str()); cpptestFastCoverageStmt(2055 + 0 + 9U - 1);
# 292 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
fflush((&((_iob)[2]))); cpptestFastCoverageStmt(2055 + 0 + 10U - 1);
# 293 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
posix::Abort(); 
}  
} 
# 331 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
std::string GetLastErrnoDescription() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2065 + 0 + 1U - 1);
return ((*_errno()) == 0) ? "" : posix::StrError((*_errno())); 
# 333 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
} 
# 339
static void FailFromInternalError(int fd) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2066 + 0 + 1U - 1);
Message error; cpptestFastCoverageStmt(2066 + 0 + 2U - 1);
char buffer[256]; cpptestFastCoverageStmt(2066 + 0 + 3U - 1);
int num_read; 

do { 
while (((void)cpptestFastCoverageStmt(2066 + 0 + 4U - 1), (num_read = posix::Read(fd, buffer, 255)) > 0)) { cpptestFastCoverageStmt(2066 + 0 + 5U - 1);
(buffer)[num_read] = '\000'; cpptestFastCoverageStmt(2066 + 0 + 6U - 1);
(error << buffer); 
}  
} while (((void)cpptestFastCoverageStmt(2066 + 0 + 7U - 1), num_read == -1 && (*_errno()) == 4)); 
# 351 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2066 + 0 + 8U - 1), num_read == 0)) { cpptestFastCoverageStmt(2066 + 0 + 9U - 1);
(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 352).GetStream() << error.GetString()); 
} else { cpptestFastCoverageStmt(2066 + 0 + 10U - 1);
const int last_error = (*_errno()); cpptestFastCoverageStmt(2066 + 0 + 11U - 1);
# 355 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
(((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 355).GetStream() << ("Error while reading death test internal: ")) << GetLastErrnoDescription()) << (" [")) << last_error) << ("]")); 

}  
} 



DeathTest::DeathTest() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2077 + 0 + 1U - 1);
TestInfo *const info = GetUnitTestImpl()->current_test_info(); 
if (((void)cpptestFastCoverageStmt(2077 + 0 + 2U - 1), info == (nullptr))) { cpptestFastCoverageStmt(2077 + 0 + 3U - 1);
DeathTestAbort("Cannot run a death test outside of a TEST or TEST_F construct"); 

}  
} 



bool DeathTest::Create(const char *statement, const RE *regex, const char *
file, int line, DeathTest **test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2080 + 0 + 1U - 1);
return GetUnitTestImpl()->death_test_factory()->Create(statement, regex, file, line, test); 

} 

const char *DeathTest::LastMessage() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2081 + 0 + 1U - 1);
return last_death_test_message_.c_str(); 
} 

void DeathTest::set_last_death_test_message(const std::string &message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2082 + 0 + 1U - 1);
(last_death_test_message_ = message); 
} 

std::string DeathTest::last_death_test_message_; 


class DeathTestImpl : public DeathTest { 

protected: DeathTestImpl(const char *a_statement, const RE *a_regex) : statement_(a_statement), regex_(a_regex), spawned_(false), status_((-1)), outcome_(IN_PROGRESS), read_fd_((-1)), write_fd_((-1)) 
# 398
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2083 + 0 + 1U - 1);} 


virtual ~DeathTestImpl() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);do { if (((void)cpptestFastCoverageStmt(2084 + 0 + 1U - 1), !::testing::internal::IsTrue(read_fd_ == -1))) { cpptestFastCoverageStmt(2084 + 0 + 2U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(401)) + (": ")) + ("read_fd_ == -1"))); }  } while (((void)cpptestFastCoverageStmt(2084 + 0 + 3U - 1), ::testing::internal::AlwaysFalse())); } 

virtual void Abort(AbortReason reason); 
virtual bool Passed(bool status_ok); 

const char *statement() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2087 + 0 + 1U - 1);return statement_; } 
const RE *regex() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2088 + 0 + 1U - 1);return regex_; } 
bool spawned() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2089 + 0 + 1U - 1);return spawned_; } 
void set_spawned(bool is_spawned) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2090 + 0 + 1U - 1);spawned_ = is_spawned; } 
int status() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2091 + 0 + 1U - 1);return status_; } 
void set_status(int a_status) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2092 + 0 + 1U - 1);status_ = a_status; } 
DeathTestOutcome outcome() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2093 + 0 + 1U - 1);return outcome_; } 
void set_outcome(DeathTestOutcome an_outcome) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2094 + 0 + 1U - 1);outcome_ = an_outcome; } 
int read_fd() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2095 + 0 + 1U - 1);return read_fd_; } 
void set_read_fd(int fd) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2096 + 0 + 1U - 1);read_fd_ = fd; } 
int write_fd() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2097 + 0 + 1U - 1);return write_fd_; } 
void set_write_fd(int fd) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2098 + 0 + 1U - 1);write_fd_ = fd; } 
# 423
void ReadAndInterpretStatusByte(); 




private: const char *const statement_; 


const RE *const regex_; 

bool spawned_; 

int status_; 

DeathTestOutcome outcome_; 



int read_fd_; 



int write_fd_; 
}; 
# 452
void DeathTestImpl::ReadAndInterpretStatusByte() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2099 + 0 + 1U - 1);
char flag; cpptestFastCoverageStmt(2099 + 0 + 2U - 1);
int bytes_read; 
# 460
do { cpptestFastCoverageStmt(2099 + 0 + 3U - 1);
bytes_read = posix::Read(this->read_fd(), &flag, 1); 
} while (((void)cpptestFastCoverageStmt(2099 + 0 + 4U - 1), bytes_read == -1 && (*_errno()) == 4)); 
# 464 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2099 + 0 + 5U - 1), bytes_read == 0)) { cpptestFastCoverageStmt(2099 + 0 + 6U - 1);
this->set_outcome(DIED); 
} else if (((void)cpptestFastCoverageStmt(2099 + 0 + 7U - 1), bytes_read == 1)) { 
switch (((void)cpptestFastCoverageStmt(2099 + 0 + 8U - 1), flag)) { 
case kDeathTestReturned:  cpptestFastCoverageStmt(2099 + 0 + 9U - 1);
this->set_outcome(RETURNED); cpptestFastCoverageStmt(2099 + 0 + 10U - 1);
break; 
case kDeathTestThrew:  cpptestFastCoverageStmt(2099 + 0 + 11U - 1);
this->set_outcome(THREW); cpptestFastCoverageStmt(2099 + 0 + 12U - 1);
break; 
case kDeathTestLived:  cpptestFastCoverageStmt(2099 + 0 + 13U - 1);
this->set_outcome(LIVED); cpptestFastCoverageStmt(2099 + 0 + 14U - 1);
break; 
case kDeathTestInternalError:  cpptestFastCoverageStmt(2099 + 0 + 15U - 1);
FailFromInternalError(this->read_fd()); cpptestFastCoverageStmt(2099 + 0 + 16U - 1);
break; 
default:  cpptestFastCoverageStmt(2099 + 0 + 17U - 1);
((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 481).GetStream() << ("Death test child process reported ")) << ("unexpected status byte (")) << static_cast< unsigned>(flag)) << (")")); 


}  
} else { cpptestFastCoverageStmt(2099 + 0 + 18U - 1);
((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 486).GetStream() << ("Read from death test child process failed: ")) << GetLastErrnoDescription()); 

}    
do { cpptestFastCoverageStmt(2099 + 0 + 19U - 1);int gtest_retval; do { cpptestFastCoverageStmt(2099 + 0 + 20U - 1);gtest_retval = (posix::Close(this->read_fd())); } while (((void)cpptestFastCoverageStmt(2099 + 0 + 21U - 1), gtest_retval == -1 && (*_errno()) == 4)); 
# 489 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2099 + 0 + 22U - 1), gtest_retval == -1)) { cpptestFastCoverageStmt(2099 + 0 + 23U - 1);DeathTestAbort(((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(489)) + (": ")) + ("posix::Close(read_fd())")) + (" != -1"))); }  } while (((void)cpptestFastCoverageStmt(2099 + 0 + 24U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2099 + 0 + 25U - 1);
this->set_read_fd(-1); 
} 
# 497
void DeathTestImpl::Abort(AbortReason reason) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2124 + 0 + 1U - 1);



const char status_ch = (reason == TEST_DID_NOT_DIE) ? kDeathTestLived : ((reason == TEST_THREW_EXCEPTION) ? kDeathTestThrew : kDeathTestReturned); 



do { cpptestFastCoverageStmt(2124 + 0 + 2U - 1);int gtest_retval; do { cpptestFastCoverageStmt(2124 + 0 + 3U - 1);gtest_retval = (posix::Write(this->write_fd(), &status_ch, 1)); } while (((void)cpptestFastCoverageStmt(2124 + 0 + 4U - 1), gtest_retval == -1 && (*_errno()) == 4)); 
# 505 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2124 + 0 + 5U - 1), gtest_retval == -1)) { cpptestFastCoverageStmt(2124 + 0 + 6U - 1);DeathTestAbort(((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(505)) + (": ")) + ("posix::Write(write_fd(), &status_ch, 1)")) + (" != -1"))); }  } while (((void)cpptestFastCoverageStmt(2124 + 0 + 7U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2124 + 0 + 8U - 1);
# 514 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
_exit(1); 
} 




static std::string FormatDeathTestOutput(const std::string &output) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2132 + 0 + 1U - 1);
std::string ret; cpptestFastCoverageStmt(2132 + 0 + 2U - 1);
for (size_t at = (0); 1;) { cpptestFastCoverageStmt(2132 + 0 + 3U - 1);
const size_t line_end = output.find('\n', at); cpptestFastCoverageStmt(2132 + 0 + 4U - 1);
(ret += ("[  DEATH   ] ")); 
if (((void)cpptestFastCoverageStmt(2132 + 0 + 5U - 1), line_end == ::std::string::npos)) { cpptestFastCoverageStmt(2132 + 0 + 6U - 1);
(ret += output.substr(at)); cpptestFastCoverageStmt(2132 + 0 + 7U - 1);
break; 
}  cpptestFastCoverageStmt(2132 + 0 + 8U - 1);
(ret += output.substr(at, (line_end + 1) - at)); cpptestFastCoverageStmt(2132 + 0 + 9U - 1);
at = line_end + 1; 
}  cpptestFastCoverageStmt(2132 + 0 + 10U - 1);
return ret; 
} 
# 557 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
bool DeathTestImpl::Passed(bool status_ok) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2142 + 0 + 1U - 1), !this->spawned())) {cpptestFastCoverageStmt(2142 + 0 + 2U - 1);
return false; }  cpptestFastCoverageStmt(2142 + 0 + 3U - 1);

const std::string error_message = GetCapturedStderr(); cpptestFastCoverageStmt(2142 + 0 + 4U - 1);

bool success = false; cpptestFastCoverageStmt(2142 + 0 + 5U - 1);
Message buffer; cpptestFastCoverageStmt(2142 + 0 + 6U - 1);

(((buffer << ("Death test: ")) << this->statement()) << ("\n")); 
switch (((void)cpptestFastCoverageStmt(2142 + 0 + 7U - 1), this->outcome())) { 
case LIVED:  cpptestFastCoverageStmt(2142 + 0 + 8U - 1);
(((buffer << ("    Result: failed to die.\n")) << (" Error msg:\n")) << FormatDeathTestOutput(error_message)); cpptestFastCoverageStmt(2142 + 0 + 9U - 1);

break; 
case THREW:  cpptestFastCoverageStmt(2142 + 0 + 10U - 1);
(((buffer << ("    Result: threw an exception.\n")) << (" Error msg:\n")) << FormatDeathTestOutput(error_message)); cpptestFastCoverageStmt(2142 + 0 + 11U - 1);

break; 
case RETURNED:  cpptestFastCoverageStmt(2142 + 0 + 12U - 1);
(((buffer << ("    Result: illegal return in test statement.\n")) << (" Error msg:\n")) << FormatDeathTestOutput(error_message)); cpptestFastCoverageStmt(2142 + 0 + 13U - 1);

break; 
case DIED:  
if (((void)cpptestFastCoverageStmt(2142 + 0 + 14U - 1), status_ok)) { cpptestFastCoverageStmt(2142 + 0 + 15U - 1);




const bool matched = RE::PartialMatch(error_message.c_str(), *this->regex()); 

if (((void)cpptestFastCoverageStmt(2142 + 0 + 16U - 1), matched)) { cpptestFastCoverageStmt(2142 + 0 + 17U - 1);
success = true; 
} else { cpptestFastCoverageStmt(2142 + 0 + 18U - 1);
((((((buffer << ("    Result: died but not with expected error.\n")) << ("  Expected: ")) << this->regex()->pattern()) << ("\n")) << ("Actual msg:\n")) << FormatDeathTestOutput(error_message)); 


}  
} else { cpptestFastCoverageStmt(2142 + 0 + 19U - 1);
((((((buffer << ("    Result: died but not with expected exit code:\n")) << ("            ")) << ExitSummary(this->status())) << ("\n")) << ("Actual msg:\n")) << FormatDeathTestOutput(error_message)); 


}  cpptestFastCoverageStmt(2142 + 0 + 20U - 1);
break; 
case IN_PROGRESS:  
default:  cpptestFastCoverageStmt(2142 + 0 + 21U - 1);
(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 603).GetStream() << ("DeathTest::Passed somehow called before conclusion of test")); 

}  cpptestFastCoverageStmt(2142 + 0 + 22U - 1);

DeathTest::set_last_death_test_message(buffer.GetString()); cpptestFastCoverageStmt(2142 + 0 + 23U - 1);
return success; 
} 
# 640 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
class WindowsDeathTest : public DeathTestImpl { 

public: WindowsDeathTest(const char *a_statement, const RE *
a_regex, const char *
file, int 
line) : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2165 + 0 + 1U - 1);} 


virtual int Wait(); 
virtual TestRole AssumeRole(); 



private: const char *const file_; 

const int line_; 

AutoHandle write_handle_; 

AutoHandle child_handle_; 




AutoHandle event_handle_; 
}; 




int WindowsDeathTest::Wait() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2166 + 0 + 1U - 1), !this->spawned())) {cpptestFastCoverageStmt(2166 + 0 + 2U - 1);
return 0; }  cpptestFastCoverageStmt(2166 + 0 + 3U - 1);



const HANDLE wait_handles[2] = {(child_handle_).Get(), (event_handle_).Get()}; 
switch (((void)cpptestFastCoverageStmt(2166 + 0 + 4U - 1), ::WaitForMultipleObjects(2, wait_handles, 0, 0xffffffffU))) 
# 681 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ 
case 0:  
# 683 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
case 0 + 1:  cpptestFastCoverageStmt(2166 + 0 + 5U - 1);
# 684 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
break; 
default:  
do { if (((void)cpptestFastCoverageStmt(2166 + 0 + 6U - 1), !::testing::internal::IsTrue(false))) { cpptestFastCoverageStmt(2166 + 0 + 7U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(686)) + (": ")) + ("false"))); }  } while (((void)cpptestFastCoverageStmt(2166 + 0 + 8U - 1), ::testing::internal::AlwaysFalse())); 
}  cpptestFastCoverageStmt(2166 + 0 + 9U - 1);



(write_handle_).Reset(); cpptestFastCoverageStmt(2166 + 0 + 10U - 1);
(event_handle_).Reset(); cpptestFastCoverageStmt(2166 + 0 + 11U - 1);

this->ReadAndInterpretStatusByte(); 
# 700
do { if (((void)cpptestFastCoverageStmt(2166 + 0 + 12U - 1), !::testing::internal::IsTrue(0 == ::WaitForSingleObject((child_handle_).Get(), 0xffffffffU)))) 
# 700 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2166 + 0 + 13U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(700)) + (": ")) + ("WAIT_OBJECT_0 == ::WaitForSingleObject(child_handle_.Get(), INFINITE)"))); }  } while (((void)cpptestFastCoverageStmt(2166 + 0 + 14U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2166 + 0 + 15U - 1);


DWORD status_code; 
do { if (((void)cpptestFastCoverageStmt(2166 + 0 + 16U - 1), !::testing::internal::IsTrue(::GetExitCodeProcess((child_handle_).Get(), &status_code) != 0))) 
# 704 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2166 + 0 + 17U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(704)) + (": ")) + ("::GetExitCodeProcess(child_handle_.Get(), &status_code) != FALSE"))); }  } while (((void)cpptestFastCoverageStmt(2166 + 0 + 18U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2166 + 0 + 19U - 1);

(child_handle_).Reset(); cpptestFastCoverageStmt(2166 + 0 + 20U - 1);
this->set_status(static_cast< int>(status_code)); cpptestFastCoverageStmt(2166 + 0 + 21U - 1);
return this->status(); 
} 
# 716
DeathTest::TestRole WindowsDeathTest::AssumeRole() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2187 + 0 + 1U - 1);
const UnitTestImpl *const impl = GetUnitTestImpl(); cpptestFastCoverageStmt(2187 + 0 + 2U - 1);
const InternalRunDeathTestFlag *const flag = impl->internal_run_death_test_flag(); cpptestFastCoverageStmt(2187 + 0 + 3U - 1);

const TestInfo *const info = impl->current_test_info(); cpptestFastCoverageStmt(2187 + 0 + 4U - 1);
const int death_test_index = info->result()->death_test_count(); 

if (((void)cpptestFastCoverageStmt(2187 + 0 + 5U - 1), flag != __null)) 
# 723 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2187 + 0 + 6U - 1);


this->set_write_fd(flag->write_fd()); cpptestFastCoverageStmt(2187 + 0 + 7U - 1);
return EXECUTE_TEST; 
}  cpptestFastCoverageStmt(2187 + 0 + 8U - 1);



SECURITY_ATTRIBUTES handles_are_inheritable = {(sizeof(SECURITY_ATTRIBUTES)), (__null), 1}; cpptestFastCoverageStmt(2187 + 0 + 9U - 1);
# 734 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
HANDLE read_handle, write_handle; 
do { if (((void)cpptestFastCoverageStmt(2187 + 0 + 10U - 1), !::testing::internal::IsTrue(::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable, 0) != 0))) 
# 735 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2187 + 0 + 11U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(735)) + (": ")) + ("::CreatePipe(&read_handle, &write_handle, &handles_are_inheritable, 0) != FALSE"))); }  } while (((void)cpptestFastCoverageStmt(2187 + 0 + 12U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2187 + 0 + 13U - 1);



this->set_read_fd(::_open_osfhandle(reinterpret_cast< intptr_t>(read_handle), 0)); cpptestFastCoverageStmt(2187 + 0 + 14U - 1);
# 741 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
(write_handle_).Reset(write_handle); cpptestFastCoverageStmt(2187 + 0 + 15U - 1);
(event_handle_).Reset(::CreateEventA(&handles_are_inheritable, 1, 0, __null)); 
# 747 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
do { if (((void)cpptestFastCoverageStmt(2187 + 0 + 16U - 1), !::testing::internal::IsTrue((event_handle_).Get() != __null))) 
# 747 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2187 + 0 + 17U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(747)) + (": ")) + ("event_handle_.Get() != NULL"))); }  } while (((void)cpptestFastCoverageStmt(2187 + 0 + 18U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2187 + 0 + 19U - 1);
const std::string filter_flag = ((((((((std::__cxx11::basic_string< char> )("--")) + ("gtest_")) + (kFilterFlag)) + ("=")) + info->test_case_name()) + (".")) + info->name()); cpptestFastCoverageStmt(2187 + 0 + 20U - 1);


const std::string internal_flag = ((((((((((((((((std::__cxx11::basic_string< char> )("--")) + ("gtest_")) + (kInternalRunDeathTestFlag)) + ("=")) + file_) + ("|")) + StreamableToString(line_)) + ("|")) + StreamableToString(death_test_index)) + ("|")) + StreamableToString(static_cast< unsigned>(::GetCurrentProcessId()))) + ("|")) + StreamableToString(reinterpret_cast< size_t>(write_handle))) + ("|")) + StreamableToString(reinterpret_cast< size_t>((event_handle_).Get()))); cpptestFastCoverageStmt(2187 + 0 + 21U - 1);
# 762
char executable_path[260 + 1]; 
# 763 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
do { if (((void)cpptestFastCoverageStmt(2187 + 0 + 22U - 1), !::testing::internal::IsTrue(260 + 1 != ::GetModuleFileNameA(__null, executable_path, 260)))) 
# 763 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2187 + 0 + 23U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(763)) + (": ")) + ("_MAX_PATH + 1 != ::GetModuleFileNameA(NULL, executable_path, _MAX_PATH)"))); }  } while (((void)cpptestFastCoverageStmt(2187 + 0 + 24U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2187 + 0 + 25U - 1);




std::string command_line = (((((((std::__cxx11::basic_string< char> )(::GetCommandLineA())) + (" ")) + filter_flag) + (" \"")) + internal_flag) + ("\"")); cpptestFastCoverageStmt(2187 + 0 + 26U - 1);



DeathTest::set_last_death_test_message(""); cpptestFastCoverageStmt(2187 + 0 + 27U - 1);

CaptureStderr(); cpptestFastCoverageStmt(2187 + 0 + 28U - 1);

FlushInfoLog(); cpptestFastCoverageStmt(2187 + 0 + 29U - 1);


STARTUPINFOA startup_info; cpptestFastCoverageStmt(2187 + 0 + 30U - 1);
memset(&startup_info, 0, sizeof(STARTUPINFO)); cpptestFastCoverageStmt(2187 + 0 + 31U - 1);
startup_info.dwFlags = 256; cpptestFastCoverageStmt(2187 + 0 + 32U - 1);
# 782 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
startup_info.hStdInput = ::GetStdHandle((DWORD)(0xfffffff6U)); cpptestFastCoverageStmt(2187 + 0 + 33U - 1);
# 783 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
startup_info.hStdOutput = ::GetStdHandle((DWORD)(0xfffffff5U)); cpptestFastCoverageStmt(2187 + 0 + 34U - 1);
# 784 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
startup_info.hStdError = ::GetStdHandle((DWORD)(0xfffffff4U)); cpptestFastCoverageStmt(2187 + 0 + 35U - 1);
# 786 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
PROCESS_INFORMATION process_info; 
do { if (((void)cpptestFastCoverageStmt(2187 + 0 + 36U - 1), !::testing::internal::IsTrue(::CreateProcessA(executable_path, const_cast< char *>(command_line.c_str()), __null, __null, 1, 0, __null, UnitTest::GetInstance()->original_working_dir(), &startup_info, &process_info) != 0))) 
# 787 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2187 + 0 + 37U - 1);DeathTestAbort((((((((std::__cxx11::basic_string< char> )("CHECK failed: File ")) + ("D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc")) + (", line ")) + ::testing::internal::StreamableToString(787)) + (": ")) + ("::CreateProcessA( executable_path, const_cast<char*>(command_line.c_str()), NULL, NULL, TRUE, 0x0, NULL, UnitTest::GetInstance()" "->original_working_dir(), &startup_info, &process_info) != FALSE"))); }  } while (((void)cpptestFastCoverageStmt(2187 + 0 + 38U - 1), ::testing::internal::AlwaysFalse())); cpptestFastCoverageStmt(2187 + 0 + 39U - 1);
# 798 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
(child_handle_).Reset(process_info.hProcess); cpptestFastCoverageStmt(2187 + 0 + 40U - 1);
::CloseHandle(process_info.hThread); cpptestFastCoverageStmt(2187 + 0 + 41U - 1);
this->set_spawned(true); cpptestFastCoverageStmt(2187 + 0 + 42U - 1);
return OVERSEE_TEST; 
} 
# 1385 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
bool DefaultDeathTestFactory::Create(const char *statement, const RE *regex, const char *
file, int line, DeathTest **
test) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2229 + 0 + 1U - 1);
UnitTestImpl *const impl = GetUnitTestImpl(); cpptestFastCoverageStmt(2229 + 0 + 2U - 1);
const InternalRunDeathTestFlag *const flag = impl->internal_run_death_test_flag(); cpptestFastCoverageStmt(2229 + 0 + 3U - 1);

const int death_test_index = impl->current_test_info()->increment_death_test_count(); 


if (((void)cpptestFastCoverageStmt(2229 + 0 + 4U - 1), flag != (nullptr))) { 
if (((void)cpptestFastCoverageStmt(2229 + 0 + 5U - 1), death_test_index > flag->index())) { cpptestFastCoverageStmt(2229 + 0 + 6U - 1);
DeathTest::set_last_death_test_message(((((("Death test count (") + StreamableToString(death_test_index)) + (") somehow exceeded expected maximum (")) + StreamableToString(flag->index())) + (")"))); cpptestFastCoverageStmt(2229 + 0 + 7U - 1);



return false; 
}  

if (((void)cpptestFastCoverageStmt(2229 + 0 + 8U - 1), !(((flag->file() == file) && flag->line() == line) && flag->index() == death_test_index))) 
{ cpptestFastCoverageStmt(2229 + 0 + 9U - 1);
*test = (nullptr); cpptestFastCoverageStmt(2229 + 0 + 10U - 1);
return true; 
}  
}  



if (((void)cpptestFastCoverageStmt(2229 + 0 + 11U - 1), (FLAGS_gtest_death_test_style == ("threadsafe")) || (FLAGS_gtest_death_test_style == ("fast")))) 
{ cpptestFastCoverageStmt(2229 + 0 + 12U - 1);
*test = (new WindowsDeathTest(statement, regex, file, line)); 
} else 
# 1434 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2229 + 0 + 13U - 1);
DeathTest::set_last_death_test_message(((("Unknown death test style \"") + FLAGS_gtest_death_test_style) + ("\" encountered"))); cpptestFastCoverageStmt(2229 + 0 + 14U - 1);


return false; 
}  cpptestFastCoverageStmt(2229 + 0 + 15U - 1);

return true; 
} 
# 1448
static int GetStatusFileDescriptor(unsigned parent_process_id, size_t 
write_handle_as_size_t, size_t 
event_handle_as_size_t) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2244 + 0 + 1U - 1);
AutoHandle parent_process_handle(::OpenProcess(64, 0, parent_process_id)); 
# 1454 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2244 + 0 + 2U - 1), parent_process_handle.Get() == (HANDLE)(-1))) 
# 1454 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2244 + 0 + 3U - 1);
DeathTestAbort((("Unable to open parent process ") + StreamableToString(parent_process_id))); 

}  



switch (((void)cpptestFastCoverageStmt(2244 + 0 + 4U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2244 + 0 + 5U - 1), ::testing::internal::IsTrue(sizeof(HANDLE) <= sizeof(size_t)))) {cpptestFastCoverageStmt(2244 + 0 + 6U - 1);; } else {cpptestFastCoverageStmt(2244 + 0 + 7U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc", 1461).GetStream() << ("Condition sizeof(HANDLE) <= sizeof(size_t) failed. ")); }  }  cpptestFastCoverageStmt(2244 + 0 + 8U - 1);

const HANDLE write_handle = reinterpret_cast< HANDLE>(write_handle_as_size_t); cpptestFastCoverageStmt(2244 + 0 + 9U - 1);

HANDLE dup_write_handle; 




if (((void)cpptestFastCoverageStmt(2244 + 0 + 10U - 1), !::DuplicateHandle(parent_process_handle.Get(), write_handle, ::GetCurrentProcess(), &dup_write_handle, 0, 0, 0x2))) 
# 1475 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2244 + 0 + 11U - 1);
DeathTestAbort((((("Unable to duplicate the pipe handle ") + StreamableToString(write_handle_as_size_t)) + (" from the parent process ")) + StreamableToString(parent_process_id))); 



}  cpptestFastCoverageStmt(2244 + 0 + 12U - 1);

const HANDLE event_handle = reinterpret_cast< HANDLE>(event_handle_as_size_t); cpptestFastCoverageStmt(2244 + 0 + 13U - 1);
HANDLE dup_event_handle; 

if (((void)cpptestFastCoverageStmt(2244 + 0 + 14U - 1), !::DuplicateHandle(parent_process_handle.Get(), event_handle, ::GetCurrentProcess(), &dup_event_handle, 0, 0, 0x2))) 
# 1489 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
{ cpptestFastCoverageStmt(2244 + 0 + 15U - 1);
DeathTestAbort((((("Unable to duplicate the event handle ") + StreamableToString(event_handle_as_size_t)) + (" from the parent process ")) + StreamableToString(parent_process_id))); 



}  cpptestFastCoverageStmt(2244 + 0 + 16U - 1);

const int write_fd = ::_open_osfhandle(reinterpret_cast< intptr_t>(dup_write_handle), 0x8); 
# 1498 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
if (((void)cpptestFastCoverageStmt(2244 + 0 + 17U - 1), write_fd == -1)) { cpptestFastCoverageStmt(2244 + 0 + 18U - 1);
DeathTestAbort(((("Unable to convert pipe handle ") + StreamableToString(write_handle_as_size_t)) + (" to a file descriptor"))); 


}  cpptestFastCoverageStmt(2244 + 0 + 19U - 1);



::SetEvent(dup_event_handle); cpptestFastCoverageStmt(2244 + 0 + 20U - 1);

return write_fd; 
} 
# 1515
InternalRunDeathTestFlag *ParseInternalRunDeathTestFlag() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2264 + 0 + 1U - 1), (FLAGS_gtest_internal_run_death_test == ("")))) {cpptestFastCoverageStmt(2264 + 0 + 2U - 1);return nullptr; }  cpptestFastCoverageStmt(2264 + 0 + 3U - 1);



int line = (-1); cpptestFastCoverageStmt(2264 + 0 + 4U - 1);
int index = (-1); cpptestFastCoverageStmt(2264 + 0 + 5U - 1);
std::vector< std::__cxx11::basic_string< char> >  fields; cpptestFastCoverageStmt(2264 + 0 + 6U - 1);
SplitString(FLAGS_gtest_internal_run_death_test.c_str(), '|', &fields); cpptestFastCoverageStmt(2264 + 0 + 7U - 1);
int write_fd = (-1); cpptestFastCoverageStmt(2264 + 0 + 8U - 1);



unsigned parent_process_id = (0); cpptestFastCoverageStmt(2264 + 0 + 9U - 1);
size_t write_handle_as_size_t = (0); cpptestFastCoverageStmt(2264 + 0 + 10U - 1);
size_t event_handle_as_size_t = (0); 

if (((void)cpptestFastCoverageStmt(2264 + 0 + 11U - 1), ((((fields.size() != 6 || !ParseNaturalNumber(fields[1], &line)) || !ParseNaturalNumber(fields[2], &index)) || !ParseNaturalNumber(fields[3], &parent_process_id)) || !ParseNaturalNumber(fields[4], &write_handle_as_size_t)) || !ParseNaturalNumber(fields[5], &event_handle_as_size_t))) 




{ cpptestFastCoverageStmt(2264 + 0 + 12U - 1);
DeathTestAbort((("Bad --gtest_internal_run_death_test flag: ") + FLAGS_gtest_internal_run_death_test)); 

}  cpptestFastCoverageStmt(2264 + 0 + 13U - 1);
write_fd = GetStatusFileDescriptor(parent_process_id, write_handle_as_size_t, event_handle_as_size_t); cpptestFastCoverageStmt(2264 + 0 + 14U - 1);
# 1566 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-death-test.cc"
return new InternalRunDeathTestFlag(fields[0], line, index, write_fd); 
} 

}



}
# 61 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
namespace testing { 
namespace internal { 
# 69
const char kPathSeparator = '\\'; 
const char kAlternatePathSeparator = '/'; 
const char kAlternatePathSeparatorString[] = "/"; 
# 80 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
const char kCurrentDirectoryString[] = ".\\"; 
# 88
static bool IsPathSeparator(char c) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2278 + 0 + 1U - 1);

return (c == kPathSeparator) || (c == kAlternatePathSeparator); 



} 


FilePath FilePath::GetCurrentDir() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2279 + 0 + 1U - 1);
# 103
char cwd[260 + 1] = {'\000'}; 
# 103 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
cpptestFastCoverageStmt(2279 + 0 + 2U - 1);
return ((FilePath)((_getcwd(cwd, sizeof (cwd)) == __null) ? "" : (cwd))); 
# 116 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
} 
# 122
FilePath FilePath::RemoveExtension(const char *extension) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2281 + 0 + 1U - 1);
const std::string dot_extension = (((std::__cxx11::basic_string< char> )(".")) + extension); 
if (((void)cpptestFastCoverageStmt(2281 + 0 + 2U - 1), String::EndsWithCaseInsensitive(pathname_, dot_extension))) { cpptestFastCoverageStmt(2281 + 0 + 3U - 1);
return ((FilePath)((pathname_).substr(0, (pathname_).length() - dot_extension.length()))); 

}  cpptestFastCoverageStmt(2281 + 0 + 4U - 1);
return *this; 
} 




const char *FilePath::FindLastPathSeparator() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2285 + 0 + 1U - 1);
const char *const last_sep = strrchr(this->c_str(), kPathSeparator); cpptestFastCoverageStmt(2285 + 0 + 2U - 1);

const char *const last_alt_sep = strrchr(this->c_str(), kAlternatePathSeparator); 

if (((void)cpptestFastCoverageStmt(2285 + 0 + 3U - 1), last_alt_sep != __null && (last_sep == __null || last_alt_sep > last_sep))) 
# 140 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
{ cpptestFastCoverageStmt(2285 + 0 + 4U - 1);
return last_alt_sep; 
}  cpptestFastCoverageStmt(2285 + 0 + 5U - 1);

return last_sep; 
} 
# 153
FilePath FilePath::RemoveDirectoryName() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2290 + 0 + 1U - 1);
const char *const last_sep = this->FindLastPathSeparator(); cpptestFastCoverageStmt(2290 + 0 + 2U - 1);
return ((last_sep) ? ((FilePath)(last_sep + 1)) : *this); 
} 
# 164
FilePath FilePath::RemoveFileName() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2292 + 0 + 1U - 1);
const char *const last_sep = this->FindLastPathSeparator(); cpptestFastCoverageStmt(2292 + 0 + 2U - 1);
std::string dir; 
if (((void)cpptestFastCoverageStmt(2292 + 0 + 3U - 1), last_sep)) { cpptestFastCoverageStmt(2292 + 0 + 4U - 1);
(dir = std::string(this->c_str(), (last_sep + 1) - this->c_str())); 
} else { cpptestFastCoverageStmt(2292 + 0 + 5U - 1);
(dir = (kCurrentDirectoryString)); 
}  cpptestFastCoverageStmt(2292 + 0 + 6U - 1);
return ((FilePath)(dir)); 
} 
# 181
FilePath FilePath::MakeFileName(const FilePath &directory, const FilePath &
base_name, int 
number, const char *
extension) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2298 + 0 + 1U - 1);
std::string file; 
if (((void)cpptestFastCoverageStmt(2298 + 0 + 2U - 1), number == 0)) { cpptestFastCoverageStmt(2298 + 0 + 3U - 1);
(file = ((base_name.string() + (".")) + extension)); 
} else { cpptestFastCoverageStmt(2298 + 0 + 4U - 1);
(file = ((((base_name.string() + ("_")) + StreamableToString(number)) + (".")) + extension)); 

}  cpptestFastCoverageStmt(2298 + 0 + 5U - 1);
return ConcatPaths(directory, ((FilePath)(file))); 
} 



FilePath FilePath::ConcatPaths(const FilePath &directory, const FilePath &
relative_path) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2303 + 0 + 1U - 1), directory.IsEmpty())) {cpptestFastCoverageStmt(2303 + 0 + 2U - 1);
return relative_path; }  cpptestFastCoverageStmt(2303 + 0 + 3U - 1);
const FilePath dir(directory.RemoveTrailingPathSeparator()); cpptestFastCoverageStmt(2303 + 0 + 4U - 1);
return ((FilePath)(((dir.string() + kPathSeparator) + relative_path.string()))); 
} 



bool FilePath::FileOrDirectoryExists() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2307 + 0 + 1U - 1);
# 214
posix::StatStruct file_stat; cpptestFastCoverageStmt(2307 + 0 + 2U - 1);
return posix::Stat((pathname_).c_str(), &file_stat) == 0; 

} 



bool FilePath::DirectoryExists() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2309 + 0 + 1U - 1);
bool result = false; cpptestFastCoverageStmt(2309 + 0 + 2U - 1);



const FilePath &path((this->IsRootDirectory() ? *this : this->RemoveTrailingPathSeparator())); cpptestFastCoverageStmt(2309 + 0 + 3U - 1);
# 241 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
posix::StatStruct file_stat; cpptestFastCoverageStmt(2309 + 0 + 4U - 1);
result = posix::Stat(path.c_str(), &file_stat) == 0 && posix::IsDir(file_stat); cpptestFastCoverageStmt(2309 + 0 + 5U - 1);



return result; 
} 



bool FilePath::IsRootDirectory() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2314 + 0 + 1U - 1);




return (pathname_).length() == 3 && this->IsAbsolutePath(); 



} 


bool FilePath::IsAbsolutePath() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2315 + 0 + 1U - 1);
const char *const name = (pathname_).c_str(); cpptestFastCoverageStmt(2315 + 0 + 2U - 1);

return (((pathname_).length() >= 3 && ((name[0] >= 'a' && name[0] <= 'z') || (name[0] >= 'A' && name[0] <= 'Z'))) && name[1] == ':') && IsPathSeparator(name[2]); 
# 274
} 
# 284 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-filepath.cc"
FilePath FilePath::GenerateUniqueFileName(const FilePath &directory, const FilePath &
base_name, const char *
extension) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2317 + 0 + 1U - 1);
FilePath full_pathname; cpptestFastCoverageStmt(2317 + 0 + 2U - 1);
int number = 0; 
do { cpptestFastCoverageStmt(2317 + 0 + 3U - 1);
full_pathname.Set(MakeFileName(directory, base_name, number++, extension)); 
} while (((void)cpptestFastCoverageStmt(2317 + 0 + 4U - 1), full_pathname.FileOrDirectoryExists())); cpptestFastCoverageStmt(2317 + 0 + 5U - 1);
return full_pathname; 
} 




bool FilePath::IsDirectory() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2322 + 0 + 1U - 1);
return !(pathname_).empty() && IsPathSeparator((pathname_).c_str()[(pathname_).length() - 1]); 

} 




bool FilePath::CreateDirectoriesRecursively() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2323 + 0 + 1U - 1), !this->IsDirectory())) { cpptestFastCoverageStmt(2323 + 0 + 2U - 1);
return false; 
}  

if (((void)cpptestFastCoverageStmt(2323 + 0 + 3U - 1), (pathname_).length() == 0 || this->DirectoryExists())) { cpptestFastCoverageStmt(2323 + 0 + 4U - 1);
return true; 
}  cpptestFastCoverageStmt(2323 + 0 + 5U - 1);

const FilePath parent((this->RemoveTrailingPathSeparator()).RemoveFileName()); cpptestFastCoverageStmt(2323 + 0 + 6U - 1);
return parent.CreateDirectoriesRecursively() && this->CreateFolder(); 
} 
# 323
bool FilePath::CreateFolder() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2329 + 0 + 1U - 1);
# 330
int result = _mkdir((pathname_).c_str()); 




if (((void)cpptestFastCoverageStmt(2329 + 0 + 2U - 1), result == -1)) { cpptestFastCoverageStmt(2329 + 0 + 3U - 1);
return this->DirectoryExists(); 
}  cpptestFastCoverageStmt(2329 + 0 + 4U - 1);
return true; 
} 




FilePath FilePath::RemoveTrailingPathSeparator() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2333 + 0 + 1U - 1);
return (this->IsDirectory() ? ((FilePath)((pathname_).substr(0, (pathname_).length() - 1))) : *this); 


} 
# 354
void FilePath::Normalize() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2334 + 0 + 1U - 1), (pathname_).c_str() == (nullptr))) { cpptestFastCoverageStmt(2334 + 0 + 2U - 1);
(pathname_ = ("")); cpptestFastCoverageStmt(2334 + 0 + 3U - 1);
return; 
}  cpptestFastCoverageStmt(2334 + 0 + 4U - 1);
const char *src = (pathname_).c_str(); cpptestFastCoverageStmt(2334 + 0 + 5U - 1);
char *const dest = new char [(pathname_).length() + 1]; cpptestFastCoverageStmt(2334 + 0 + 6U - 1);
char *dest_ptr = dest; cpptestFastCoverageStmt(2334 + 0 + 7U - 1);
memset(dest_ptr, 0, (pathname_).length() + 1); 

while (((void)cpptestFastCoverageStmt(2334 + 0 + 8U - 1), *src != '\000')) { cpptestFastCoverageStmt(2334 + 0 + 9U - 1);
*dest_ptr = *src; 
if (((void)cpptestFastCoverageStmt(2334 + 0 + 10U - 1), !IsPathSeparator(*src))) { cpptestFastCoverageStmt(2334 + 0 + 11U - 1);
src++; 
} else { 

if (((void)cpptestFastCoverageStmt(2334 + 0 + 12U - 1), *dest_ptr == kAlternatePathSeparator)) { cpptestFastCoverageStmt(2334 + 0 + 13U - 1);
*dest_ptr = kPathSeparator; 
}  

while (((void)cpptestFastCoverageStmt(2334 + 0 + 14U - 1), IsPathSeparator(*src))) {cpptestFastCoverageStmt(2334 + 0 + 15U - 1);
src++; }  
}  cpptestFastCoverageStmt(2334 + 0 + 16U - 1);
dest_ptr++; 
}  cpptestFastCoverageStmt(2334 + 0 + 17U - 1);
*dest_ptr = '\000'; cpptestFastCoverageStmt(2334 + 0 + 18U - 1);
(pathname_ = dest); cpptestFastCoverageStmt(2334 + 0 + 19U - 1);
delete [] dest; 
} 

}
}
# 38 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\c++io.h" 3
namespace std { 



typedef __gthread_mutex_t __c_lock; 


typedef FILE __c_file; 


}
# 44 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\mingw32\\bits\\basic_file.h" 3
namespace std { 




template < typename _CharT >
    class __basic_file;



template<> class __basic_file< char>  { 


__c_file *_M_cfile; 


bool _M_cfile_created; 


public: __basic_file(__c_lock * __lock = 0) throw(); 


__basic_file(std::__basic_file< char>  &&__rv, __c_lock * = 0) noexcept : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created) 

{ 
__rv._M_cfile = (nullptr); 
__rv._M_cfile_created = false; 
} 

std::__basic_file< char>  &operator=(const std::__basic_file< char>  &) = delete;
std::__basic_file< char>  &operator=(std::__basic_file< char>  &&) = delete;


void swap(std::__basic_file< char>  &__f) noexcept 
{ 
std::swap(_M_cfile, __f._M_cfile); 
std::swap(_M_cfile_created, __f._M_cfile_created); 
} 



std::__basic_file< char>  *open(const char * __name, ios_base::openmode __mode, int __prot = 0x1b4); 



std::__basic_file< char>  *open(const wchar_t * __name, ios_base::openmode __mode); 



std::__basic_file< char>  *sys_open(__c_file * __file, ios_base::openmode); 


std::__basic_file< char>  *sys_open(int __fd, ios_base::openmode __mode) throw(); 


std::__basic_file< char>  *close(); 


__attribute((__pure__)) bool is_open() const throw(); 


__attribute((__pure__)) int fd() throw(); 


__attribute((__pure__)) __c_file *file() throw(); 

~__basic_file(); 


streamsize xsputn(const char * __s, streamsize __n); 


streamsize xsputn_2(const char * __s1, streamsize __n1, const char * __s2, streamsize __n2); 



streamsize xsgetn(char * __s, streamsize __n); 


streamoff seekoff(streamoff __off, ios_base::seekdir __way) throw(); 


int sync(); 


streamsize showmanyc(); 
}; 


}
# 47 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
namespace std { 
# 79 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
template < typename _CharT , typename _Traits > 
class basic_filebuf : public basic_streambuf < _CharT , _Traits > 
{ 

template < typename _Tp > 
using __chk_state = __and_ < is_copy_assignable < _Tp > , 
is_copy_constructible < _Tp > , 
is_default_constructible < _Tp > > ; 

static_assert (__chk_state < typename _Traits :: state_type > :: value , 
"state_type must be CopyAssignable, CopyConstructible" 
" and DefaultConstructible") ; 

static_assert (is_same < typename _Traits :: pos_type , 
fpos < typename _Traits :: state_type > > :: value , 
"pos_type must be fpos<state_type>") ; 

public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 

typedef basic_streambuf < char_type , traits_type > __streambuf_type ; 
typedef basic_filebuf < char_type , traits_type > __filebuf_type ; 
typedef __basic_file < char > __file_type ; 
typedef typename traits_type :: state_type __state_type ; 
typedef codecvt < char_type , char , __state_type > __codecvt_type ; 

friend class ios_base ; 

protected : 


__c_lock _M_lock ; 


__file_type _M_file ; 


ios_base :: openmode _M_mode ; 


__state_type _M_state_beg ; 




__state_type _M_state_cur ; 



__state_type _M_state_last ; 


char_type * _M_buf ; 
# 143
size_t _M_buf_size ; 


bool _M_buf_allocated ; 
# 155 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
bool _M_reading ; 
bool _M_writing ; 
# 164
char_type _M_pback ; 
char_type * _M_pback_cur_save ; 
char_type * _M_pback_end_save ; 
bool _M_pback_init ; 



const __codecvt_type * _M_codecvt ; 
# 178
char * _M_ext_buf ; 




streamsize _M_ext_buf_size ; 
# 190
const char * _M_ext_next ; 
char * _M_ext_end ; 
# 198
void 
_M_create_pback () 
{ 
if (! _M_pback_init) 
{ 
_M_pback_cur_save = this -> gptr () ; 
_M_pback_end_save = this -> egptr () ; 
this -> setg (& _M_pback , & _M_pback , & _M_pback + 1) ; 
_M_pback_init = true ; 
} 
} 
# 215
void 
_M_destroy_pback () throw () 
{ 
if (_M_pback_init) 
{ 

_M_pback_cur_save += this -> gptr () != this -> eback () ; 
this -> setg (_M_buf , _M_pback_cur_save , _M_pback_end_save) ; 
_M_pback_init = false ; 
} 
} 

public : 
# 235
basic_filebuf () ; 


basic_filebuf (const basic_filebuf &) = delete ; 
basic_filebuf (basic_filebuf &&) ; 
# 245
virtual 
~ basic_filebuf () 
{ 
try 
{ this -> close () ; } 
catch (...) 
{ } 
} 


basic_filebuf & operator = (const basic_filebuf &) = delete ; 
basic_filebuf & operator = (basic_filebuf &&) ; 
void swap (basic_filebuf &) ; 
# 264
bool 
is_open () const throw () 
{ return _M_file . is_open () ; } 
# 309 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
open (const char * __s , ios_base :: openmode __mode) ; 
# 319 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
open (const wchar_t * __s , ios_base :: openmode __mode) ; 
# 330 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
open (const std :: string & __s , ios_base :: openmode __mode) 
{ return open (__s . c_str () , __mode) ; } 
# 360 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
close () ; 

protected : 
void 
_M_allocate_internal_buffer () ; 

void 
_M_destroy_internal_buffer () throw () ; 


virtual streamsize 
showmanyc () ; 
# 379
virtual int_type 
underflow () ; 

virtual int_type 
pbackfail (int_type __c = _Traits :: eof ()) ; 
# 392 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
virtual int_type 
overflow (int_type __c = _Traits :: eof ()) ; 



bool 
_M_convert_to_external (char_type * , streamsize) ; 
# 412 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
virtual __streambuf_type * 
setbuf (char_type * __s , streamsize __n) ; 

virtual pos_type 
seekoff (off_type __off , ios_base :: seekdir __way , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) ; 

virtual pos_type 
seekpos (pos_type __pos , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) ; 


pos_type 
_M_seek (off_type __off , ios_base :: seekdir __way , __state_type __state) ; 

int 
_M_get_ext_pos (__state_type & __state) ; 

virtual int 
sync () ; 

virtual void 
imbue (const locale & __loc) ; 

virtual streamsize 
xsgetn (char_type * __s , streamsize __n) ; 

virtual streamsize 
xsputn (const char_type * __s , streamsize __n) ; 


bool 
_M_terminate_output () ; 
# 458 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
_M_set_buffer (streamsize __off) 
{ 
const bool __testin = _M_mode & ios_base :: in ; 
const bool __testout = (_M_mode & ios_base :: out 
|| _M_mode & ios_base :: app) ; 

if (__testin && __off > 0) 
this -> setg (_M_buf , _M_buf , _M_buf + __off) ; 
else 
this -> setg (_M_buf , _M_buf , _M_buf) ; 

if (__testout && __off == 0 && _M_buf_size > 1) 
this -> setp (_M_buf , _M_buf + _M_buf_size - 1) ; 
else 
this -> setp (0 , 0) ; 
} 
} ;
# 491 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
template < typename _CharT , typename _Traits > 
class basic_ifstream : public basic_istream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_filebuf < char_type , traits_type > __filebuf_type ; 
typedef basic_istream < char_type , traits_type > __istream_type ; 

private : 
__filebuf_type _M_filebuf ; 

public : 
# 518 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ifstream () : __istream_type () , _M_filebuf () 
{ this -> init (& _M_filebuf) ; } 
# 528 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
explicit 
basic_ifstream (const char * __s , ios_base :: openmode __mode = ios_base :: in) 
: __istream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 544 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ifstream (const wchar_t * __s , 
ios_base :: openmode __mode = ios_base :: in) 
: __istream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 561 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
explicit 
basic_ifstream (const std :: string & __s , 
ios_base :: openmode __mode = ios_base :: in) 
: __istream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 585 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ifstream (const basic_ifstream &) = delete ; 

basic_ifstream (basic_ifstream && __rhs) 
: __istream_type (std :: move (__rhs)) , 
_M_filebuf (std :: move (__rhs . _M_filebuf)) 
{ __istream_type :: set_rdbuf (& _M_filebuf) ; } 
# 599 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
~ basic_ifstream () 
{ } 




basic_ifstream & 
operator = (const basic_ifstream &) = delete ; 

basic_ifstream & 
operator = (basic_ifstream && __rhs) 
{ 
__istream_type :: operator = (std :: move (__rhs)) ; 
_M_filebuf = std :: move (__rhs . _M_filebuf) ; 
return * this ; 
} 

void 
swap (basic_ifstream & __rhs) 
{ 
__istream_type :: swap (__rhs) ; 
_M_filebuf . swap (__rhs . _M_filebuf) ; 
} 
# 631 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
rdbuf () const 
{ return const_cast < __filebuf_type * > (& _M_filebuf) ; } 
# 639
bool 
is_open () 
{ return _M_filebuf . is_open () ; } 



bool 
is_open () const 
{ return _M_filebuf . is_open () ; } 
# 657 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const char * __s , ios_base :: openmode __mode = ios_base :: in) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: in)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 677 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const wchar_t * __s , ios_base :: openmode __mode = ios_base :: in) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: in)) 
this -> setstate (ios_base :: failbit) ; 
else 
this -> clear () ; 
} 
# 696 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const std :: string & __s , ios_base :: openmode __mode = ios_base :: in) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: in)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 729 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
close () 
{ 
if (! _M_filebuf . close ()) 
this -> setstate (ios_base :: failbit) ; 
} 
} ;
# 752 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
template < typename _CharT , typename _Traits > 
class basic_ofstream : public basic_ostream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_filebuf < char_type , traits_type > __filebuf_type ; 
typedef basic_ostream < char_type , traits_type > __ostream_type ; 

private : 
__filebuf_type _M_filebuf ; 

public : 
# 779 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ofstream () : __ostream_type () , _M_filebuf () 
{ this -> init (& _M_filebuf) ; } 
# 789 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
explicit 
basic_ofstream (const char * __s , 
ios_base :: openmode __mode = ios_base :: out) 
: __ostream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 807 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ofstream (const wchar_t * __s , 
ios_base :: openmode __mode = ios_base :: out | ios_base :: trunc) 
: __ostream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 824 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
explicit 
basic_ofstream (const std :: string & __s , 
ios_base :: openmode __mode = ios_base :: out) 
: __ostream_type () , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 848 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_ofstream (const basic_ofstream &) = delete ; 

basic_ofstream (basic_ofstream && __rhs) 
: __ostream_type (std :: move (__rhs)) , 
_M_filebuf (std :: move (__rhs . _M_filebuf)) 
{ __ostream_type :: set_rdbuf (& _M_filebuf) ; } 
# 862 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
~ basic_ofstream () 
{ } 




basic_ofstream & 
operator = (const basic_ofstream &) = delete ; 

basic_ofstream & 
operator = (basic_ofstream && __rhs) 
{ 
__ostream_type :: operator = (std :: move (__rhs)) ; 
_M_filebuf = std :: move (__rhs . _M_filebuf) ; 
return * this ; 
} 

void 
swap (basic_ofstream & __rhs) 
{ 
__ostream_type :: swap (__rhs) ; 
_M_filebuf . swap (__rhs . _M_filebuf) ; 
} 
# 894 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
rdbuf () const 
{ return const_cast < __filebuf_type * > (& _M_filebuf) ; } 
# 902
bool 
is_open () 
{ return _M_filebuf . is_open () ; } 



bool 
is_open () const 
{ return _M_filebuf . is_open () ; } 
# 920 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const char * __s , ios_base :: openmode __mode = ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: out)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 940 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const wchar_t * __s , ios_base :: openmode __mode = ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: out)) 
this -> setstate (ios_base :: failbit) ; 
else 
this -> clear () ; 
} 
# 959 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const std :: string & __s , ios_base :: openmode __mode = ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode | ios_base :: out)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 992 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
close () 
{ 
if (! _M_filebuf . close ()) 
this -> setstate (ios_base :: failbit) ; 
} 
} ;
# 1015 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
template < typename _CharT , typename _Traits > 
class basic_fstream : public basic_iostream < _CharT , _Traits > 
{ 
public : 

typedef _CharT char_type ; 
typedef _Traits traits_type ; 
typedef typename traits_type :: int_type int_type ; 
typedef typename traits_type :: pos_type pos_type ; 
typedef typename traits_type :: off_type off_type ; 


typedef basic_filebuf < char_type , traits_type > __filebuf_type ; 
typedef basic_ios < char_type , traits_type > __ios_type ; 
typedef basic_iostream < char_type , traits_type > __iostream_type ; 

private : 
__filebuf_type _M_filebuf ; 

public : 
# 1043 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_fstream () 
: __iostream_type () , _M_filebuf () 
{ this -> init (& _M_filebuf) ; } 
# 1052
explicit 
basic_fstream (const char * __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
: __iostream_type (0) , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 1067
basic_fstream (const wchar_t * __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
: __iostream_type (0) , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 1082 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
explicit 
basic_fstream (const std :: string & __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
: __iostream_type (0) , _M_filebuf () 
{ 
this -> init (& _M_filebuf) ; 
this -> open (__s , __mode) ; 
} 
# 1104 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
basic_fstream (const basic_fstream &) = delete ; 

basic_fstream (basic_fstream && __rhs) 
: __iostream_type (std :: move (__rhs)) , 
_M_filebuf (std :: move (__rhs . _M_filebuf)) 
{ __iostream_type :: set_rdbuf (& _M_filebuf) ; } 
# 1118 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
~ basic_fstream () 
{ } 




basic_fstream & 
operator = (const basic_fstream &) = delete ; 

basic_fstream & 
operator = (basic_fstream && __rhs) 
{ 
__iostream_type :: operator = (std :: move (__rhs)) ; 
_M_filebuf = std :: move (__rhs . _M_filebuf) ; 
return * this ; 
} 

void 
swap (basic_fstream & __rhs) 
{ 
__iostream_type :: swap (__rhs) ; 
_M_filebuf . swap (__rhs . _M_filebuf) ; 
} 
# 1150 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
__filebuf_type * 
rdbuf () const 
{ return const_cast < __filebuf_type * > (& _M_filebuf) ; } 
# 1158
bool 
is_open () 
{ return _M_filebuf . is_open () ; } 



bool 
is_open () const 
{ return _M_filebuf . is_open () ; } 
# 1176 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const char * __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 1197 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const wchar_t * __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode)) 
this -> setstate (ios_base :: failbit) ; 
else 
this -> clear () ; 
} 
# 1217 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
open (const std :: string & __s , 
ios_base :: openmode __mode = ios_base :: in | ios_base :: out) 
{ 
if (! _M_filebuf . open (__s , __mode)) 
this -> setstate (ios_base :: failbit) ; 
else 


this -> clear () ; 
} 
# 1252 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\fstream" 3
void 
close () 
{ 
if (! _M_filebuf . close ()) 
this -> setstate (ios_base :: failbit) ; 
} 
} ;



template < class _CharT , class _Traits > 
inline void 
swap (basic_filebuf < _CharT , _Traits > & __x , 
basic_filebuf < _CharT , _Traits > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits > 
inline void 
swap (basic_ifstream < _CharT , _Traits > & __x , 
basic_ifstream < _CharT , _Traits > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits > 
inline void 
swap (basic_ofstream < _CharT , _Traits > & __x , 
basic_ofstream < _CharT , _Traits > & __y) 
{ __x . swap (__y) ; } 


template < class _CharT , class _Traits > 
inline void 
swap (basic_fstream < _CharT , _Traits > & __x , 
basic_fstream < _CharT , _Traits > & __y) 
{ __x . swap (__y) ; } 



}
# 43 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\fstream.tcc" 3
namespace std { 



template < typename _CharT , typename _Traits > 
void 
basic_filebuf < _CharT , _Traits > :: 
_M_allocate_internal_buffer () 
{ 


if (! _M_buf_allocated && ! _M_buf) 
{ 
_M_buf = new char_type [ _M_buf_size ] ; 
_M_buf_allocated = true ; 
} 
} 

template < typename _CharT , typename _Traits > 
void 
basic_filebuf < _CharT , _Traits > :: 
_M_destroy_internal_buffer () throw () 
{ 
if (_M_buf_allocated) 
{ 
delete [ ] _M_buf ; 
_M_buf = 0 ; 
_M_buf_allocated = false ; 
} 
delete [ ] _M_ext_buf ; 
_M_ext_buf = 0 ; 
_M_ext_buf_size = 0 ; 
_M_ext_next = 0 ; 
_M_ext_end = 0 ; 
} 

template < typename _CharT , typename _Traits > 
basic_filebuf < _CharT , _Traits > :: 
basic_filebuf () : __streambuf_type () , _M_lock () , _M_file (& _M_lock) , 
_M_mode (ios_base :: openmode (0)) , _M_state_beg () , _M_state_cur () , 
_M_state_last () , _M_buf (0) , _M_buf_size (512) , 
_M_buf_allocated (false) , _M_reading (false) , _M_writing (false) , _M_pback () , 
_M_pback_cur_save (0) , _M_pback_end_save (0) , _M_pback_init (false) , 
_M_codecvt (0) , _M_ext_buf (0) , _M_ext_buf_size (0) , _M_ext_next (0) , 
_M_ext_end (0) 
{ 
if (has_facet < __codecvt_type > (this -> _M_buf_locale)) 
_M_codecvt = & use_facet < __codecvt_type > (this -> _M_buf_locale) ; 
} 


template < typename _CharT , typename _Traits > 
basic_filebuf < _CharT , _Traits > :: 
basic_filebuf (basic_filebuf && __rhs) 
: __streambuf_type (__rhs) , 
_M_lock () , _M_file (std :: move (__rhs . _M_file) , & _M_lock) , 
_M_mode (std :: __exchange (__rhs . _M_mode , ios_base :: openmode (0))) , 
_M_state_beg (std :: move (__rhs . _M_state_beg)) , 
_M_state_cur (std :: move (__rhs . _M_state_cur)) , 
_M_state_last (std :: move (__rhs . _M_state_last)) , 
_M_buf (std :: __exchange (__rhs . _M_buf , nullptr)) , 
_M_buf_size (std :: __exchange (__rhs . _M_buf_size , 1)) , 
_M_buf_allocated (std :: __exchange (__rhs . _M_buf_allocated , false)) , 
_M_reading (std :: __exchange (__rhs . _M_reading , false)) , 
_M_writing (std :: __exchange (__rhs . _M_writing , false)) , 
_M_pback (__rhs . _M_pback) , 
_M_pback_cur_save (std :: __exchange (__rhs . _M_pback_cur_save , nullptr)) , 
_M_pback_end_save (std :: __exchange (__rhs . _M_pback_end_save , nullptr)) , 
_M_pback_init (std :: __exchange (__rhs . _M_pback_init , false)) , 
_M_codecvt (__rhs . _M_codecvt) , 
_M_ext_buf (std :: __exchange (__rhs . _M_ext_buf , nullptr)) , 
_M_ext_buf_size (std :: __exchange (__rhs . _M_ext_buf_size , 0)) , 
_M_ext_next (std :: __exchange (__rhs . _M_ext_next , nullptr)) , 
_M_ext_end (std :: __exchange (__rhs . _M_ext_end , nullptr)) 
{ 
__rhs . _M_set_buffer (- 1) ; 
__rhs . _M_state_last = __rhs . _M_state_cur = __rhs . _M_state_beg ; 
} 

template < typename _CharT , typename _Traits > 
basic_filebuf < _CharT , _Traits > & 
basic_filebuf < _CharT , _Traits > :: 
operator = (basic_filebuf && __rhs) 
{ 
this -> close () ; 
__streambuf_type :: operator = (__rhs) ; 
_M_file . swap (__rhs . _M_file) ; 
_M_mode = std :: __exchange (__rhs . _M_mode , ios_base :: openmode (0)) ; 
_M_state_beg = std :: move (__rhs . _M_state_beg) ; 
_M_state_cur = std :: move (__rhs . _M_state_cur) ; 
_M_state_last = std :: move (__rhs . _M_state_last) ; 
_M_buf = std :: __exchange (__rhs . _M_buf , nullptr) ; 
_M_buf_size = std :: __exchange (__rhs . _M_buf_size , 1) ; 
_M_buf_allocated = std :: __exchange (__rhs . _M_buf_allocated , false) ; 
_M_ext_buf = std :: __exchange (__rhs . _M_ext_buf , nullptr) ; 
_M_ext_buf_size = std :: __exchange (__rhs . _M_ext_buf_size , 0) ; 
_M_ext_next = std :: __exchange (__rhs . _M_ext_next , nullptr) ; 
_M_ext_end = std :: __exchange (__rhs . _M_ext_end , nullptr) ; 
_M_reading = std :: __exchange (__rhs . _M_reading , false) ; 
_M_writing = std :: __exchange (__rhs . _M_writing , false) ; 
_M_pback_cur_save = std :: __exchange (__rhs . _M_pback_cur_save , nullptr) ; 
_M_pback_end_save = std :: __exchange (__rhs . _M_pback_end_save , nullptr) ; 
_M_pback_init = std :: __exchange (__rhs . _M_pback_init , false) ; 
__rhs . _M_set_buffer (- 1) ; 
__rhs . _M_state_last = __rhs . _M_state_cur = __rhs . _M_state_beg ; 
return * this ; 
} 

template < typename _CharT , typename _Traits > 
void 
basic_filebuf < _CharT , _Traits > :: 
swap (basic_filebuf & __rhs) 
{ 
__streambuf_type :: swap (__rhs) ; 
_M_file . swap (__rhs . _M_file) ; 
std :: swap (_M_mode , __rhs . _M_mode) ; 
std :: swap (_M_state_beg , __rhs . _M_state_beg) ; 
std :: swap (_M_state_cur , __rhs . _M_state_cur) ; 
std :: swap (_M_state_last , __rhs . _M_state_last) ; 
std :: swap (_M_buf , __rhs . _M_buf) ; 
std :: swap (_M_buf_size , __rhs . _M_buf_size) ; 
std :: swap (_M_buf_allocated , __rhs . _M_buf_allocated) ; 
std :: swap (_M_ext_buf , __rhs . _M_ext_buf) ; 
std :: swap (_M_ext_buf_size , __rhs . _M_ext_buf_size) ; 
std :: swap (_M_ext_next , __rhs . _M_ext_next) ; 
std :: swap (_M_ext_end , __rhs . _M_ext_end) ; 
std :: swap (_M_reading , __rhs . _M_reading) ; 
std :: swap (_M_writing , __rhs . _M_writing) ; 
std :: swap (_M_pback_cur_save , __rhs . _M_pback_cur_save) ; 
std :: swap (_M_pback_end_save , __rhs . _M_pback_end_save) ; 
std :: swap (_M_pback_init , __rhs . _M_pback_init) ; 
} 


template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: __filebuf_type * 
basic_filebuf < _CharT , _Traits > :: 
open (const char * __s , ios_base :: openmode __mode) 
{ 
__filebuf_type * __ret = 0 ; 
if (! this -> is_open ()) 
{ 
_M_file . open (__s , __mode) ; 
if (this -> is_open ()) 
{ 
_M_allocate_internal_buffer () ; 
_M_mode = __mode ; 


_M_reading = false ; 
_M_writing = false ; 
_M_set_buffer (- 1) ; 


_M_state_last = _M_state_cur = _M_state_beg ; 


if ((__mode & ios_base :: ate) 
&& this -> seekoff (0 , ios_base :: end , __mode) 
== pos_type (off_type (- 1))) 
this -> close () ; 
else 
__ret = this ; 
} 
} 
return __ret ; 
} 


template < typename _CharT , typename _Traits > 
basic_filebuf < _CharT , _Traits > * 
basic_filebuf < _CharT , _Traits > :: 
open (const wchar_t * __s , ios_base :: openmode __mode) 
{ 
__filebuf_type * __ret = 0 ; 
if (! this -> is_open ()) 
{ 
_M_file . open (__s , __mode) ; 
if (this -> is_open ()) 
{ 
_M_allocate_internal_buffer () ; 
_M_mode = __mode ; 


_M_reading = false ; 
_M_writing = false ; 
_M_set_buffer (- 1) ; 


_M_state_last = _M_state_cur = _M_state_beg ; 


if ((__mode & ios_base :: ate) 
&& this -> seekoff (0 , ios_base :: end , __mode) 
== pos_type (off_type (- 1))) 
this -> close () ; 
else 
__ret = this ; 
} 
} 
return __ret ; 
} 


template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: __filebuf_type * 
basic_filebuf < _CharT , _Traits > :: 
close () 
{ 
if (! this -> is_open ()) 
return 0 ; 

bool __testfail = false ; 
{ 

struct __close_sentry 
{ 
basic_filebuf * __fb ; 
__close_sentry (basic_filebuf * __fbi) : __fb (__fbi) { } 
~ __close_sentry () 
{ 
__fb -> _M_mode = ios_base :: openmode (0) ; 
__fb -> _M_pback_init = false ; 
__fb -> _M_destroy_internal_buffer () ; 
__fb -> _M_reading = false ; 
__fb -> _M_writing = false ; 
__fb -> _M_set_buffer (- 1) ; 
__fb -> _M_state_last = __fb -> _M_state_cur = __fb -> _M_state_beg ; 
} 
} __cs (this) ; 

try 
{ 
if (! _M_terminate_output ()) 
__testfail = true ; 
} 
catch (...) 
{ 
_M_file . close () ; 
throw ; 
} 
} 

if (! _M_file . close ()) 
__testfail = true ; 

if (__testfail) 
return 0 ; 
else 
return this ; 
} 

template < typename _CharT , typename _Traits > 
streamsize 
basic_filebuf < _CharT , _Traits > :: 
showmanyc () 
{ 
streamsize __ret = - 1 ; 
const bool __testin = _M_mode & ios_base :: in ; 
if (__testin && this -> is_open ()) 
{ 


__ret = this -> egptr () - this -> gptr () ; 



const bool __testbinary = _M_mode & ios_base :: binary ; 
if (__check_facet (_M_codecvt) . encoding () >= 0 
&& __testbinary) 



__ret += _M_file . showmanyc () / _M_codecvt -> max_length () ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: int_type 
basic_filebuf < _CharT , _Traits > :: 
underflow () 
{ 
int_type __ret = traits_type :: eof () ; 
const bool __testin = _M_mode & ios_base :: in ; 
if (__testin) 
{ 
if (_M_writing) 
{ 
if (overflow () == traits_type :: eof ()) 
return __ret ; 
_M_set_buffer (- 1) ; 
_M_writing = false ; 
} 



_M_destroy_pback () ; 

if (this -> gptr () < this -> egptr ()) 
return traits_type :: to_int_type (* this -> gptr ()) ; 


const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1 ; 


bool __got_eof = false ; 

streamsize __ilen = 0 ; 
codecvt_base :: result __r = codecvt_base :: ok ; 
if (__check_facet (_M_codecvt) . always_noconv ()) 
{ 
__ilen = _M_file . xsgetn (reinterpret_cast < char * > (this -> eback ()) , 
__buflen) ; 
if (__ilen == 0) 
__got_eof = true ; 
} 
else 
{ 


const int __enc = _M_codecvt -> encoding () ; 
streamsize __blen ; 
streamsize __rlen ; 
if (__enc > 0) 
__blen = __rlen = __buflen * __enc ; 
else 
{ 
__blen = __buflen + _M_codecvt -> max_length () - 1 ; 
__rlen = __buflen ; 
} 
const streamsize __remainder = _M_ext_end - _M_ext_next ; 
__rlen = __rlen > __remainder ? __rlen - __remainder : 0 ; 



if (_M_reading && this -> egptr () == this -> eback () && __remainder) 
__rlen = 0 ; 



if (_M_ext_buf_size < __blen) 
{ 
char * __buf = new char [ __blen ] ; 
if (__remainder) 
__builtin_memcpy (__buf , _M_ext_next , __remainder) ; 

delete [ ] _M_ext_buf ; 
_M_ext_buf = __buf ; 
_M_ext_buf_size = __blen ; 
} 
else if (__remainder) 
__builtin_memmove (_M_ext_buf , _M_ext_next , __remainder) ; 

_M_ext_next = _M_ext_buf ; 
_M_ext_end = _M_ext_buf + __remainder ; 
_M_state_last = _M_state_cur ; 

do 
{ 
if (__rlen > 0) 
{ 



if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size) 
{ 
__throw_ios_failure (("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

) ; 
} 
streamsize __elen = _M_file . xsgetn (_M_ext_end , __rlen) ; 
if (__elen == 0) 
__got_eof = true ; 
else if (__elen == - 1) 
break ; 
_M_ext_end += __elen ; 
} 

char_type * __iend = this -> eback () ; 
if (_M_ext_next < _M_ext_end) 
__r = _M_codecvt -> in (_M_state_cur , _M_ext_next , 
_M_ext_end , _M_ext_next , 
this -> eback () , 
this -> eback () + __buflen , __iend) ; 
if (__r == codecvt_base :: noconv) 
{ 
size_t __avail = _M_ext_end - _M_ext_buf ; 
__ilen = std :: min (__avail , __buflen) ; 
traits_type :: copy (this -> eback () , 
reinterpret_cast < char_type * > 
(_M_ext_buf) , __ilen) ; 
_M_ext_next = _M_ext_buf + __ilen ; 
} 
else 
__ilen = __iend - this -> eback () ; 




if (__r == codecvt_base :: error) 
break ; 

__rlen = 1 ; 
} 
while (__ilen == 0 && ! __got_eof) ; 
} 

if (__ilen > 0) 
{ 
_M_set_buffer (__ilen) ; 
_M_reading = true ; 
__ret = traits_type :: to_int_type (* this -> gptr ()) ; 
} 
else if (__got_eof) 
{ 



_M_set_buffer (- 1) ; 
_M_reading = false ; 


if (__r == codecvt_base :: partial) 
__throw_ios_failure (("basic_filebuf::underflow " "incomplete character in file")
) ; 
} 
else if (__r == codecvt_base :: error) 
__throw_ios_failure (("basic_filebuf::underflow " "invalid byte sequence in file")
) ; 
else 
__throw_ios_failure (("basic_filebuf::underflow " "error reading the file") 
, (* _errno ())) ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: int_type 
basic_filebuf < _CharT , _Traits > :: 
pbackfail (int_type __i) 
{ 
int_type __ret = traits_type :: eof () ; 
const bool __testin = _M_mode & ios_base :: in ; 
if (__testin) 
{ 
if (_M_writing) 
{ 
if (overflow () == traits_type :: eof ()) 
return __ret ; 
_M_set_buffer (- 1) ; 
_M_writing = false ; 
} 


const bool __testpb = _M_pback_init ; 
const bool __testeof = traits_type :: eq_int_type (__i , __ret) ; 
int_type __tmp ; 
if (this -> eback () < this -> gptr ()) 
{ 
this -> gbump (- 1) ; 
__tmp = traits_type :: to_int_type (* this -> gptr ()) ; 
} 
else if (this -> seekoff (- 1 , ios_base :: cur) != pos_type (off_type (- 1))) 
{ 
__tmp = this -> underflow () ; 
if (traits_type :: eq_int_type (__tmp , __ret)) 
return __ret ; 
} 
else 
{ 
# 519
return __ret ; 
} 



if (! __testeof && traits_type :: eq_int_type (__i , __tmp)) 
__ret = __i ; 
else if (__testeof) 
__ret = traits_type :: not_eof (__i) ; 
else if (! __testpb) 
{ 
_M_create_pback () ; 
_M_reading = true ; 
* this -> gptr () = traits_type :: to_char_type (__i) ; 
__ret = __i ; 
} 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: int_type 
basic_filebuf < _CharT , _Traits > :: 
overflow (int_type __c) 
{ 
int_type __ret = traits_type :: eof () ; 
const bool __testeof = traits_type :: eq_int_type (__c , __ret) ; 
const bool __testout = (_M_mode & ios_base :: out 
|| _M_mode & ios_base :: app) ; 
if (__testout) 
{ 
if (_M_reading) 
{ 
_M_destroy_pback () ; 
const int __gptr_off = _M_get_ext_pos (_M_state_last) ; 
if (_M_seek (__gptr_off , ios_base :: cur , _M_state_last) 
== pos_type (off_type (- 1))) 
return __ret ; 
} 
if (this -> pbase () < this -> pptr ()) 
{ 

if (! __testeof) 
{ 
* this -> pptr () = traits_type :: to_char_type (__c) ; 
this -> pbump (1) ; 
} 



if (_M_convert_to_external (this -> pbase () , 
this -> pptr () - this -> pbase ())) 
{ 
_M_set_buffer (0) ; 
__ret = traits_type :: not_eof (__c) ; 
} 
} 
else if (_M_buf_size > 1) 
{ 



_M_set_buffer (0) ; 
_M_writing = true ; 
if (! __testeof) 
{ 
* this -> pptr () = traits_type :: to_char_type (__c) ; 
this -> pbump (1) ; 
} 
__ret = traits_type :: not_eof (__c) ; 
} 
else 
{ 

char_type __conv = traits_type :: to_char_type (__c) ; 
if (__testeof || _M_convert_to_external (& __conv , 1)) 
{ 
_M_writing = true ; 
__ret = traits_type :: not_eof (__c) ; 
} 
} 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
bool 
basic_filebuf < _CharT , _Traits > :: 
_M_convert_to_external (_CharT * __ibuf , streamsize __ilen) 
{ 

streamsize __elen ; 
streamsize __plen ; 
if (__check_facet (_M_codecvt) . always_noconv ()) 
{ 
__elen = _M_file . xsputn (reinterpret_cast < char * > (__ibuf) , __ilen) ; 
__plen = __ilen ; 
} 
else 
{ 


streamsize __blen = __ilen * _M_codecvt -> max_length () ; 
char * __buf = static_cast < char * > (__builtin_alloca (__blen)) ; 

char * __bend ; 
const char_type * __iend ; 
codecvt_base :: result __r ; 
__r = _M_codecvt -> out (_M_state_cur , __ibuf , __ibuf + __ilen , 
__iend , __buf , __buf + __blen , __bend) ; 

if (__r == codecvt_base :: ok || __r == codecvt_base :: partial) 
__blen = __bend - __buf ; 
else if (__r == codecvt_base :: noconv) 
{ 

__buf = reinterpret_cast < char * > (__ibuf) ; 
__blen = __ilen ; 
} 
else 
__throw_ios_failure (("basic_filebuf::_M_convert_to_external " "conversion error")
) ; 

__elen = _M_file . xsputn (__buf , __blen) ; 
__plen = __blen ; 


if (__r == codecvt_base :: partial && __elen == __plen) 
{ 
const char_type * __iresume = __iend ; 
streamsize __rlen = this -> pptr () - __iend ; 
__r = _M_codecvt -> out (_M_state_cur , __iresume , 
__iresume + __rlen , __iend , __buf , 
__buf + __blen , __bend) ; 
if (__r != codecvt_base :: error) 
{ 
__rlen = __bend - __buf ; 
__elen = _M_file . xsputn (__buf , __rlen) ; 
__plen = __rlen ; 
} 
else 
__throw_ios_failure (("basic_filebuf::_M_convert_to_external " "conversion error")
) ; 
} 
} 
return __elen == __plen ; 
} 

template < typename _CharT , typename _Traits > 
streamsize 
basic_filebuf < _CharT , _Traits > :: 
xsgetn (_CharT * __s , streamsize __n) 
{ 

streamsize __ret = 0 ; 
if (_M_pback_init) 
{ 
if (__n > 0 && this -> gptr () == this -> eback ()) 
{ 
* __s ++ = * this -> gptr () ; 
this -> gbump (1) ; 
__ret = 1 ; 
-- __n ; 
} 
_M_destroy_pback () ; 
} 
else if (_M_writing) 
{ 
if (overflow () == traits_type :: eof ()) 
return __ret ; 
_M_set_buffer (- 1) ; 
_M_writing = false ; 
} 




const bool __testin = _M_mode & ios_base :: in ; 
const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1 ; 

if (__n > __buflen && __check_facet (_M_codecvt) . always_noconv () 
&& __testin) 
{ 

const streamsize __avail = this -> egptr () - this -> gptr () ; 
if (__avail != 0) 
{ 
traits_type :: copy (__s , this -> gptr () , __avail) ; 
__s += __avail ; 
this -> setg (this -> eback () , this -> gptr () + __avail , this -> egptr ()) ; 
__ret += __avail ; 
__n -= __avail ; 
} 



streamsize __len ; 
for (; ;) 
{ 
__len = _M_file . xsgetn (reinterpret_cast < char * > (__s) , __n) ; 
if (__len == - 1) 
__throw_ios_failure (("basic_filebuf::xsgetn " "error reading the file") 
, (* _errno ())) ; 
if (__len == 0) 
break ; 

__n -= __len ; 
__ret += __len ; 
if (__n == 0) 
break ; 

__s += __len ; 
} 

if (__n == 0) 
{ 

_M_reading = true ; 
} 
else if (__len == 0) 
{ 



_M_set_buffer (- 1) ; 
_M_reading = false ; 
} 
} 
else 
__ret += __streambuf_type :: xsgetn (__s , __n) ; 

return __ret ; 
} 

template < typename _CharT , typename _Traits > 
streamsize 
basic_filebuf < _CharT , _Traits > :: 
xsputn (const _CharT * __s , streamsize __n) 
{ 
streamsize __ret = 0 ; 



const bool __testout = (_M_mode & ios_base :: out 
|| _M_mode & ios_base :: app) ; 
if (__check_facet (_M_codecvt) . always_noconv () 
&& __testout && ! _M_reading) 
{ 

const streamsize __chunk = 1ul << 10 ; 
streamsize __bufavail = this -> epptr () - this -> pptr () ; 


if (! _M_writing && _M_buf_size > 1) 
__bufavail = _M_buf_size - 1 ; 

const streamsize __limit = std :: min (__chunk , __bufavail) ; 
if (__n >= __limit) 
{ 
const streamsize __buffill = this -> pptr () - this -> pbase () ; 
const char * __buf = reinterpret_cast < const char * > (this -> pbase ()) ; 
__ret = _M_file . xsputn_2 (__buf , __buffill , 
reinterpret_cast < const char * > (__s) , 
__n) ; 
if (__ret == __buffill + __n) 
{ 
_M_set_buffer (0) ; 
_M_writing = true ; 
} 
if (__ret > __buffill) 
__ret -= __buffill ; 
else 
__ret = 0 ; 
} 
else 
__ret = __streambuf_type :: xsputn (__s , __n) ; 
} 
else 
__ret = __streambuf_type :: xsputn (__s , __n) ; 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: __streambuf_type * 
basic_filebuf < _CharT , _Traits > :: 
setbuf (char_type * __s , streamsize __n) 
{ 
if (! this -> is_open ()) 
{ 
if (__s == 0 && __n == 0) 
_M_buf_size = 1 ; 
else if (__s && __n > 0) 
{ 
# 820 "d:\\mingw\\mingw\\lib\\gcc\\mingw32\\9.2.0\\include\\c++\\bits\\fstream.tcc" 3
_M_buf = __s ; 
_M_buf_size = __n ; 
} 
} 
return this ; 
} 




template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: pos_type 
basic_filebuf < _CharT , _Traits > :: 
seekoff (off_type __off , ios_base :: seekdir __way , ios_base :: openmode) 
{ 
int __width = 0 ; 
if (_M_codecvt) 
__width = _M_codecvt -> encoding () ; 
if (__width < 0) 
__width = 0 ; 

pos_type __ret = pos_type (off_type (- 1)) ; 
const bool __testfail = __off != 0 && __width <= 0 ; 
if (this -> is_open () && ! __testfail) 
{ 




bool __no_movement = __way == ios_base :: cur && __off == 0 
&& (! _M_writing || _M_codecvt -> always_noconv ()) ; 


if (! __no_movement) 
_M_destroy_pback () ; 
# 861
__state_type __state = _M_state_beg ; 
off_type __computed_off = __off * __width ; 
if (_M_reading && __way == ios_base :: cur) 
{ 
__state = _M_state_last ; 
__computed_off += _M_get_ext_pos (__state) ; 
} 
if (! __no_movement) 
__ret = _M_seek (__computed_off , __way , __state) ; 
else 
{ 
if (_M_writing) 
__computed_off = this -> pptr () - this -> pbase () ; 

off_type __file_off = _M_file . seekoff (0 , ios_base :: cur) ; 
if (__file_off != off_type (- 1)) 
{ 
__ret = __file_off + __computed_off ; 
__ret . state (__state) ; 
} 
} 
} 
return __ret ; 
} 
# 890
template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: pos_type 
basic_filebuf < _CharT , _Traits > :: 
seekpos (pos_type __pos , ios_base :: openmode) 
{ 
pos_type __ret = pos_type (off_type (- 1)) ; 
if (this -> is_open ()) 
{ 

_M_destroy_pback () ; 
__ret = _M_seek (off_type (__pos) , ios_base :: beg , __pos . state ()) ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
typename basic_filebuf < _CharT , _Traits > :: pos_type 
basic_filebuf < _CharT , _Traits > :: 
_M_seek (off_type __off , ios_base :: seekdir __way , __state_type __state) 
{ 
pos_type __ret = pos_type (off_type (- 1)) ; 
if (_M_terminate_output ()) 
{ 
off_type __file_off = _M_file . seekoff (__off , __way) ; 
if (__file_off != off_type (- 1)) 
{ 
_M_reading = false ; 
_M_writing = false ; 
_M_ext_next = _M_ext_end = _M_ext_buf ; 
_M_set_buffer (- 1) ; 
_M_state_cur = __state ; 
__ret = __file_off ; 
__ret . state (_M_state_cur) ; 
} 
} 
return __ret ; 
} 




template < typename _CharT , typename _Traits > 
int basic_filebuf < _CharT , _Traits > :: 
_M_get_ext_pos (__state_type & __state) 
{ 
if (_M_codecvt -> always_noconv ()) 
return this -> gptr () - this -> egptr () ; 
else 
{ 



const int __gptr_off = 
_M_codecvt -> length (__state , _M_ext_buf , _M_ext_next , 
this -> gptr () - this -> eback ()) ; 
return _M_ext_buf + __gptr_off - _M_ext_end ; 
} 
} 

template < typename _CharT , typename _Traits > 
bool 
basic_filebuf < _CharT , _Traits > :: 
_M_terminate_output () 
{ 

bool __testvalid = true ; 
if (this -> pbase () < this -> pptr ()) 
{ 
const int_type __tmp = this -> overflow () ; 
if (traits_type :: eq_int_type (__tmp , traits_type :: eof ())) 
__testvalid = false ; 
} 


if (_M_writing && ! __check_facet (_M_codecvt) . always_noconv () 
&& __testvalid) 
{ 



const size_t __blen = 128 ; 
char __buf [ __blen ] ; 
codecvt_base :: result __r ; 
streamsize __ilen = 0 ; 

do 
{ 
char * __next ; 
__r = _M_codecvt -> unshift (_M_state_cur , __buf , 
__buf + __blen , __next) ; 
if (__r == codecvt_base :: error) 
__testvalid = false ; 
else if (__r == codecvt_base :: ok || 
__r == codecvt_base :: partial) 
{ 
__ilen = __next - __buf ; 
if (__ilen > 0) 
{ 
const streamsize __elen = _M_file . xsputn (__buf , __ilen) ; 
if (__elen != __ilen) 
__testvalid = false ; 
} 
} 
} 
while (__r == codecvt_base :: partial && __ilen > 0 && __testvalid) ; 

if (__testvalid) 
{ 




const int_type __tmp = this -> overflow () ; 
if (traits_type :: eq_int_type (__tmp , traits_type :: eof ())) 
__testvalid = false ; 
} 
} 
return __testvalid ; 
} 

template < typename _CharT , typename _Traits > 
int 
basic_filebuf < _CharT , _Traits > :: 
sync () 
{ 


int __ret = 0 ; 
if (this -> pbase () < this -> pptr ()) 
{ 
const int_type __tmp = this -> overflow () ; 
if (traits_type :: eq_int_type (__tmp , traits_type :: eof ())) 
__ret = - 1 ; 
} 
return __ret ; 
} 

template < typename _CharT , typename _Traits > 
void 
basic_filebuf < _CharT , _Traits > :: 
imbue (const locale & __loc) 
{ 
bool __testvalid = true ; 

const __codecvt_type * _M_codecvt_tmp = 0 ; 
if (__builtin_expect (has_facet < __codecvt_type > (__loc) , true)) 
_M_codecvt_tmp = & use_facet < __codecvt_type > (__loc) ; 

if (this -> is_open ()) 
{ 

if ((_M_reading || _M_writing) 
&& __check_facet (_M_codecvt) . encoding () == - 1) 
__testvalid = false ; 
else 
{ 
if (_M_reading) 
{ 
if (__check_facet (_M_codecvt) . always_noconv ()) 
{ 
if (_M_codecvt_tmp 
&& ! __check_facet (_M_codecvt_tmp) . always_noconv ()) 
__testvalid = this -> seekoff (0 , ios_base :: cur , _M_mode) 
!= pos_type (off_type (- 1)) ; 
} 
else 
{ 

_M_ext_next = _M_ext_buf 
+ _M_codecvt -> length (_M_state_last , _M_ext_buf , 
_M_ext_next , 
this -> gptr () - this -> eback ()) ; 
const streamsize __remainder = _M_ext_end - _M_ext_next ; 
if (__remainder) 
__builtin_memmove (_M_ext_buf , _M_ext_next , __remainder) ; 

_M_ext_next = _M_ext_buf ; 
_M_ext_end = _M_ext_buf + __remainder ; 
_M_set_buffer (- 1) ; 
_M_state_last = _M_state_cur = _M_state_beg ; 
} 
} 
else if (_M_writing && (__testvalid = _M_terminate_output ())) 
_M_set_buffer (- 1) ; 
} 
} 

if (__testvalid) 
_M_codecvt = _M_codecvt_tmp ; 
else 
_M_codecvt = 0 ; 
} 




extern template class basic_filebuf< char> ;
extern template class basic_ifstream< char> ;
extern template class basic_ofstream< char> ;
extern template class basic_fstream< char> ;


extern template class basic_filebuf< wchar_t> ;
extern template class basic_ifstream< wchar_t> ;
extern template class basic_ofstream< wchar_t> ;
extern template class basic_fstream< wchar_t> ;




}
# 76 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
namespace testing { 
namespace internal { 
# 84
const int kStdOutFileno = 1; 
# 85 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
const int kStdErrFileno = 2; 
# 184 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
size_t GetThreadCount() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2353 + 0 + 1U - 1);


return 0; 
} 
# 194
void SleepMilliseconds(int n) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2354 + 0 + 1U - 1);
::Sleep(n); 
} 

AutoHandle::AutoHandle() : handle_(((HANDLE)(-1))) 
# 199 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2355 + 0 + 1U - 1);} 

AutoHandle::AutoHandle(Handle handle) : handle_(handle) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2356 + 0 + 1U - 1);} 

AutoHandle::~AutoHandle() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2357 + 0 + 1U - 1);
this->Reset(); 
} 

AutoHandle::Handle AutoHandle::Get() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2358 + 0 + 1U - 1);
return handle_; 
} 

void AutoHandle::Reset() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2359 + 0 + 1U - 1);
this->Reset((HANDLE)(-1)); 
# 214 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
} 

void AutoHandle::Reset(HANDLE handle) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);

if (((void)cpptestFastCoverageStmt(2360 + 0 + 1U - 1), handle_ != handle)) { 
if (((void)cpptestFastCoverageStmt(2360 + 0 + 2U - 1), this->IsCloseable())) { cpptestFastCoverageStmt(2360 + 0 + 3U - 1);
::CloseHandle(handle_); 
}  cpptestFastCoverageStmt(2360 + 0 + 4U - 1);
handle_ = handle; 
} else { 
switch (((void)cpptestFastCoverageStmt(2360 + 0 + 5U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2360 + 0 + 6U - 1), ::testing::internal::IsTrue(!this->IsCloseable()))) {cpptestFastCoverageStmt(2360 + 0 + 7U - 1);; } else {cpptestFastCoverageStmt(2360 + 0 + 8U - 1);((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 224).GetStream() << ("Condition !IsCloseable() failed. ")) << ("Resetting a valid handle to itself is likely a programmer error and thus not allowed.")); }  }  


}  
} 

bool AutoHandle::IsCloseable() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2368 + 0 + 1U - 1);


return handle_ != __null && handle_ != (HANDLE)(-1); 
# 234 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
} 

Notification::Notification() : event_(::CreateEventA(__null, 1, 0, __null)) 
# 240 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2369 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2369 + 0 + 2U - 1), ::testing::internal::IsTrue((event_).Get() != __null))) {cpptestFastCoverageStmt(2369 + 0 + 3U - 1);
# 241 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2369 + 0 + 4U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 241).GetStream() << ("Condition event_.Get() != NULL failed. ")); }  }  
} 

void Notification::Notify() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2373 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2373 + 0 + 2U - 1), ::testing::internal::IsTrue(::SetEvent((event_).Get()) != 0))) {cpptestFastCoverageStmt(2373 + 0 + 3U - 1);
# 245 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2373 + 0 + 4U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 245).GetStream() << ("Condition ::SetEvent(event_.Get()) != FALSE failed. ")); }  }  
} 

void Notification::WaitForNotification() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2377 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2377 + 0 + 2U - 1), ::testing::internal::IsTrue(::WaitForSingleObject((event_).Get(), 0xffffffffU) == 0))) {cpptestFastCoverageStmt(2377 + 0 + 3U - 1);
# 249 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2377 + 0 + 4U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 249).GetStream() << ("Condition ::WaitForSingleObject(event_.Get(), INFINITE) == WAIT_OBJECT_0 failed. ")); }  }  

} 

Mutex::Mutex() : owner_thread_id_((0)), type_(kDynamic), critical_section_init_phase_((0)), critical_section_(new CRITICAL_SECTION) 



{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2381 + 0 + 1U - 1);
::InitializeCriticalSection(critical_section_); 
} 

Mutex::~Mutex() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
# 267
if (((void)cpptestFastCoverageStmt(2382 + 0 + 1U - 1), type_ == kDynamic)) { cpptestFastCoverageStmt(2382 + 0 + 2U - 1);
::DeleteCriticalSection(critical_section_); cpptestFastCoverageStmt(2382 + 0 + 3U - 1);
delete (critical_section_); cpptestFastCoverageStmt(2382 + 0 + 4U - 1);
critical_section_ = __null; 
# 271 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
}  
} 

void Mutex::Lock() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2386 + 0 + 1U - 1);
this->ThreadSafeLazyInit(); cpptestFastCoverageStmt(2386 + 0 + 2U - 1);
::EnterCriticalSection(critical_section_); cpptestFastCoverageStmt(2386 + 0 + 3U - 1);
owner_thread_id_ = ::GetCurrentThreadId(); 
} 

void Mutex::Unlock() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2389 + 0 + 1U - 1);
this->ThreadSafeLazyInit(); cpptestFastCoverageStmt(2389 + 0 + 2U - 1);



owner_thread_id_ = 0; cpptestFastCoverageStmt(2389 + 0 + 3U - 1);
::LeaveCriticalSection(critical_section_); 
} 



void Mutex::AssertHeld() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2392 + 0 + 1U - 1);
this->ThreadSafeLazyInit(); 
switch (((void)cpptestFastCoverageStmt(2392 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2392 + 0 + 3U - 1), ::testing::internal::IsTrue(owner_thread_id_ == ::GetCurrentThreadId()))) {cpptestFastCoverageStmt(2392 + 0 + 4U - 1);; } else {cpptestFastCoverageStmt(2392 + 0 + 5U - 1);(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 293).GetStream() << ("Condition owner_thread_id_ == ::GetCurrentThreadId() failed. ")) << ("The current thread is not holding the mutex @")) << this); }  }  

} 

namespace { 
# 307 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
class MemoryIsNotDeallocated { 


public: MemoryIsNotDeallocated() : old_crtdbg_flag_(0) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2397 + 0 + 1U - 1);
# 317
} 

~MemoryIsNotDeallocated() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2398 + 0 + 1U - 1);




} 


private: int old_crtdbg_flag_; 

MemoryIsNotDeallocated(const MemoryIsNotDeallocated &) = delete;void operator=(const MemoryIsNotDeallocated &) = delete;
}; 

}


void Mutex::ThreadSafeLazyInit() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);

if (((void)cpptestFastCoverageStmt(2399 + 0 + 1U - 1), type_ == kStatic)) { 
switch (((void)cpptestFastCoverageStmt(2399 + 0 + 2U - 1), ::InterlockedCompareExchange(&(critical_section_init_phase_), 1L, 0L))) 
{ 
case 0:  cpptestFastCoverageStmt(2399 + 0 + 3U - 1);


owner_thread_id_ = 0; 
{ cpptestFastCoverageStmt(2399 + 0 + 4U - 1);

internal::MemoryIsNotDeallocated memory_is_not_deallocated; cpptestFastCoverageStmt(2399 + 0 + 5U - 1);
critical_section_ = (new CRITICAL_SECTION); 
} cpptestFastCoverageStmt(2399 + 0 + 6U - 1);
::InitializeCriticalSection(critical_section_); 


switch (((void)cpptestFastCoverageStmt(2399 + 0 + 7U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2399 + 0 + 8U - 1), ::testing::internal::IsTrue(::InterlockedCompareExchange(&(critical_section_init_phase_), 2L, 1L) == 1L))) {cpptestFastCoverageStmt(2399 + 0 + 9U - 1);; } else {cpptestFastCoverageStmt(2399 + 0 + 10U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 352).GetStream() << ("Condition ::InterlockedCompareExchange( &critical_section_init_phase_, 2L, 1L) == 1L failed. ")); }  }  cpptestFastCoverageStmt(2399 + 0 + 11U - 1);


break; 
case 1:  


while (((void)cpptestFastCoverageStmt(2399 + 0 + 12U - 1), ::InterlockedCompareExchange(&(critical_section_init_phase_), 2L, 2L) != 2L)) 

{ cpptestFastCoverageStmt(2399 + 0 + 13U - 1);


::Sleep(0); 
}  cpptestFastCoverageStmt(2399 + 0 + 14U - 1);
break; 

case 2:  cpptestFastCoverageStmt(2399 + 0 + 15U - 1);
break; 

default:  
switch (((void)cpptestFastCoverageStmt(2399 + 0 + 16U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2399 + 0 + 17U - 1), ::testing::internal::IsTrue(false))) {cpptestFastCoverageStmt(2399 + 0 + 18U - 1);; } else {cpptestFastCoverageStmt(2399 + 0 + 19U - 1);(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 372).GetStream() << ("Condition false failed. ")) << ("Unexpected value of critical_section_init_phase_ ")) << ("while initializing a static mutex.")); }  }  


}  
}  
} 

namespace { 

class ThreadWithParamSupport : public ThreadWithParamBase { 

public: static HANDLE CreateThread(Runnable *runnable, Notification *
thread_can_start) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2418 + 0 + 1U - 1);
ThreadMainParam *param = new ThreadMainParam(runnable, thread_can_start); cpptestFastCoverageStmt(2418 + 0 + 2U - 1);
DWORD thread_id; cpptestFastCoverageStmt(2418 + 0 + 3U - 1);

HANDLE thread_handle = ::CreateThread(__null, 0, &ThreadWithParamSupport::ThreadMain, param, 0, &thread_id); 
# 395 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
switch (((void)cpptestFastCoverageStmt(2418 + 0 + 4U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2418 + 0 + 5U - 1), ::testing::internal::IsTrue(thread_handle != __null))) {cpptestFastCoverageStmt(2418 + 0 + 6U - 1);
# 395 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2418 + 0 + 7U - 1);((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 395).GetStream() << ("Condition thread_handle != NULL failed. ")) << ("CreateThread failed with error ")) << ::GetLastError()) << (".")); }  }  

if (((void)cpptestFastCoverageStmt(2418 + 0 + 8U - 1), thread_handle == __null)) 
# 397 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ cpptestFastCoverageStmt(2418 + 0 + 9U - 1);
delete param; 
}  cpptestFastCoverageStmt(2418 + 0 + 10U - 1);
return thread_handle; 
} 


private: struct ThreadMainParam { 
ThreadMainParam(Runnable *runnable, Notification *thread_can_start) : runnable_(runnable), thread_can_start_(thread_can_start) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2428 + 0 + 1U - 1);
} 
scoped_ptr< Runnable>  runnable_; 

Notification *thread_can_start_; 
}; 

__attribute((__stdcall__)) static DWORD ThreadMain(void *ptr) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2429 + 0 + 1U - 1);

scoped_ptr< ThreadMainParam>  param(static_cast< ThreadMainParam *>(ptr)); 
if (((void)cpptestFastCoverageStmt(2429 + 0 + 2U - 1), param->thread_can_start_ != __null)) {cpptestFastCoverageStmt(2429 + 0 + 3U - 1);
# 418 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
(param->thread_can_start_)->WaitForNotification(); }  cpptestFastCoverageStmt(2429 + 0 + 4U - 1);
param->runnable_->Run(); cpptestFastCoverageStmt(2429 + 0 + 5U - 1);
return 0; 
} 


ThreadWithParamSupport(); 

ThreadWithParamSupport(const ThreadWithParamSupport &) = delete;void operator=(const ThreadWithParamSupport &) = delete;
}; 

}

ThreadWithParamBase::ThreadWithParamBase(Runnable *runnable, Notification *
thread_can_start) : thread_(ThreadWithParamSupport::CreateThread(runnable, thread_can_start)) 

{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2434 + 0 + 1U - 1);
} 

ThreadWithParamBase::~ThreadWithParamBase() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2435 + 0 + 1U - 1);
this->Join(); 
} 

void ThreadWithParamBase::Join() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2436 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2436 + 0 + 2U - 1), ::testing::internal::IsTrue(::WaitForSingleObject((thread_).Get(), 0xffffffffU) == 0))) {cpptestFastCoverageStmt(2436 + 0 + 3U - 1);
# 442 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2436 + 0 + 4U - 1);((((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 442).GetStream() << ("Condition ::WaitForSingleObject(thread_.Get(), INFINITE) == WAIT_OBJECT_0 failed. ")) << ("Failed to join the thread with error ")) << ::GetLastError()) << (".")); }  }  

} 
# 450
class ThreadLocalRegistryImpl { 



public: static ThreadLocalValueHolderBase *GetValueOnCurrentThread(const ThreadLocalBase *
thread_local_instance) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2440 + 0 + 1U - 1);
DWORD current_thread = ::GetCurrentThreadId(); cpptestFastCoverageStmt(2440 + 0 + 2U - 1);
MutexLock lock(&mutex_); cpptestFastCoverageStmt(2440 + 0 + 3U - 1);
std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > >  *const thread_to_thread_locals = GetThreadLocalsMapLocked(); cpptestFastCoverageStmt(2440 + 0 + 4U - 1);

std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > > ::iterator thread_local_pos = thread_to_thread_locals->find(current_thread); 

if (((void)cpptestFastCoverageStmt(2440 + 0 + 5U - 1), (thread_local_pos == thread_to_thread_locals->end()))) { cpptestFastCoverageStmt(2440 + 0 + 6U - 1);
thread_local_pos = thread_to_thread_locals->insert(std::make_pair(current_thread, ThreadLocalValues())).first; cpptestFastCoverageStmt(2440 + 0 + 7U - 1);

StartWatcherThreadFor(current_thread); 
}  cpptestFastCoverageStmt(2440 + 0 + 8U - 1);
std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> >  &thread_local_values = thread_local_pos->second; cpptestFastCoverageStmt(2440 + 0 + 9U - 1);
std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > ::iterator value_pos = thread_local_values.find(thread_local_instance); 

if (((void)cpptestFastCoverageStmt(2440 + 0 + 10U - 1), (value_pos == thread_local_values.end()))) { cpptestFastCoverageStmt(2440 + 0 + 11U - 1);
value_pos = thread_local_values.insert(std::make_pair(thread_local_instance, ((linked_ptr< ThreadLocalValueHolderBase> )(thread_local_instance->NewValueForCurrentThread())))).first; 
# 478
}  cpptestFastCoverageStmt(2440 + 0 + 12U - 1);
return (value_pos->second).get(); 
} 

static void OnThreadLocalDestroyed(const ThreadLocalBase *
thread_local_instance) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2452 + 0 + 1U - 1);
std::vector< linked_ptr< ThreadLocalValueHolderBase> >  value_holders; 


{ cpptestFastCoverageStmt(2452 + 0 + 2U - 1);
MutexLock lock(&mutex_); cpptestFastCoverageStmt(2452 + 0 + 3U - 1);
std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > >  *const thread_to_thread_locals = GetThreadLocalsMapLocked(); cpptestFastCoverageStmt(2452 + 0 + 4U - 1);

for (std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > > ::iterator it = thread_to_thread_locals->begin(); ((void)cpptestFastCoverageStmt(2452 + 0 + 5U - 1), it != thread_to_thread_locals->end()); ((void)cpptestFastCoverageStmt(2452 + 0 + 6U - 1), ++it)) 


{ cpptestFastCoverageStmt(2452 + 0 + 7U - 1);
std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> >  &thread_local_values = it->second; cpptestFastCoverageStmt(2452 + 0 + 8U - 1);
std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > ::iterator value_pos = thread_local_values.find(thread_local_instance); 

if (((void)cpptestFastCoverageStmt(2452 + 0 + 9U - 1), (value_pos != thread_local_values.end()))) { cpptestFastCoverageStmt(2452 + 0 + 10U - 1);
value_holders.push_back(value_pos->second); cpptestFastCoverageStmt(2452 + 0 + 11U - 1);
thread_local_values.erase(value_pos); 


}  
}  
} 


} 

static void OnThreadExit(DWORD thread_id) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2463 + 0 + 1U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2463 + 0 + 2U - 1), ::testing::internal::IsTrue(thread_id != 0))) {cpptestFastCoverageStmt(2463 + 0 + 3U - 1);; } else {cpptestFastCoverageStmt(2463 + 0 + 4U - 1);((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 511).GetStream() << ("Condition thread_id != 0 failed. ")) << ::GetLastError()); }  }  cpptestFastCoverageStmt(2463 + 0 + 5U - 1);
std::vector< linked_ptr< ThreadLocalValueHolderBase> >  value_holders; 


{ cpptestFastCoverageStmt(2463 + 0 + 6U - 1);
MutexLock lock(&mutex_); cpptestFastCoverageStmt(2463 + 0 + 7U - 1);
std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > >  *const thread_to_thread_locals = GetThreadLocalsMapLocked(); cpptestFastCoverageStmt(2463 + 0 + 8U - 1);

std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > > ::iterator thread_local_pos = thread_to_thread_locals->find(thread_id); 

if (((void)cpptestFastCoverageStmt(2463 + 0 + 9U - 1), (thread_local_pos != thread_to_thread_locals->end()))) { cpptestFastCoverageStmt(2463 + 0 + 10U - 1);
std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> >  &thread_local_values = thread_local_pos->second; cpptestFastCoverageStmt(2463 + 0 + 11U - 1);
for (std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > ::iterator value_pos = thread_local_values.begin(); ((void)cpptestFastCoverageStmt(2463 + 0 + 12U - 1), value_pos != thread_local_values.end()); ((void)cpptestFastCoverageStmt(2463 + 0 + 13U - 1), ++value_pos)) 


{ cpptestFastCoverageStmt(2463 + 0 + 14U - 1);
value_holders.push_back(value_pos->second); 
}  cpptestFastCoverageStmt(2463 + 0 + 15U - 1);
thread_to_thread_locals->erase(thread_local_pos); 
}  
} 


} 




private: typedef std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> >  ThreadLocalValues; 


typedef std::map< unsigned long, std::map< const ThreadLocalBase *, linked_ptr< ThreadLocalValueHolderBase> > >  ThreadIdToThreadLocals; 



typedef std::pair< unsigned long, void *>  ThreadIdAndHandle; 

static void StartWatcherThreadFor(DWORD thread_id) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2478 + 0 + 1U - 1);


HANDLE thread = ::OpenThread(0x100000L | 64, 0, thread_id); 
# 554 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
switch (((void)cpptestFastCoverageStmt(2478 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2478 + 0 + 3U - 1), ::testing::internal::IsTrue(thread != __null))) {cpptestFastCoverageStmt(2478 + 0 + 4U - 1);
# 554 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2478 + 0 + 5U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 554).GetStream() << ("Condition thread != NULL failed. ")); }  }  cpptestFastCoverageStmt(2478 + 0 + 6U - 1);


DWORD watcher_thread_id; cpptestFastCoverageStmt(2478 + 0 + 7U - 1);
HANDLE watcher_thread = ::CreateThread(__null, 0, &ThreadLocalRegistryImpl::WatcherThreadFunc, reinterpret_cast< LPVOID>(new ThreadIdAndHandle(thread_id, thread)), 0x4, &watcher_thread_id); 
# 565 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
switch (((void)cpptestFastCoverageStmt(2478 + 0 + 8U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2478 + 0 + 9U - 1), ::testing::internal::IsTrue(watcher_thread != __null))) {cpptestFastCoverageStmt(2478 + 0 + 10U - 1);
# 565 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2478 + 0 + 11U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 565).GetStream() << ("Condition watcher_thread != NULL failed. ")); }  }  cpptestFastCoverageStmt(2478 + 0 + 12U - 1);


::SetThreadPriority(watcher_thread, ::GetThreadPriority(::GetCurrentThread())); cpptestFastCoverageStmt(2478 + 0 + 13U - 1);

::ResumeThread(watcher_thread); cpptestFastCoverageStmt(2478 + 0 + 14U - 1);
::CloseHandle(watcher_thread); 
} 



__attribute((__stdcall__)) static DWORD WatcherThreadFunc(LPVOID param) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2492 + 0 + 1U - 1);
const ThreadIdAndHandle *tah = reinterpret_cast< const ThreadIdAndHandle *>(param); 

switch (((void)cpptestFastCoverageStmt(2492 + 0 + 2U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2492 + 0 + 3U - 1), ::testing::internal::IsTrue(::WaitForSingleObject(tah->second, 0xffffffffU) == 0))) {cpptestFastCoverageStmt(2492 + 0 + 4U - 1);
# 579 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
; } else {cpptestFastCoverageStmt(2492 + 0 + 5U - 1);(GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 579).GetStream() << ("Condition ::WaitForSingleObject(tah->second, INFINITE) == WAIT_OBJECT_0 failed. ")); }  }  cpptestFastCoverageStmt(2492 + 0 + 6U - 1);

OnThreadExit(tah->first); cpptestFastCoverageStmt(2492 + 0 + 7U - 1);
::CloseHandle(tah->second); cpptestFastCoverageStmt(2492 + 0 + 8U - 1);
delete tah; cpptestFastCoverageStmt(2492 + 0 + 9U - 1);
return 0; 
} 


static ThreadIdToThreadLocals *GetThreadLocalsMapLocked() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2501 + 0 + 1U - 1);
mutex_.AssertHeld(); cpptestFastCoverageStmt(2501 + 0 + 2U - 1);
internal::MemoryIsNotDeallocated memory_is_not_deallocated; cpptestFastCoverageStmt(2501 + 0 + 3U - 1);
static ThreadIdToThreadLocals *map = new ThreadIdToThreadLocals(); cpptestFastCoverageStmt(2501 + 0 + 4U - 1);
return map; 
} 


static Mutex mutex_; 

static Mutex thread_map_mutex_; 
}; 

Mutex ThreadLocalRegistryImpl::mutex_(Mutex::kStaticMutex); 
Mutex ThreadLocalRegistryImpl::thread_map_mutex_(Mutex::kStaticMutex); 

ThreadLocalValueHolderBase *ThreadLocalRegistry::GetValueOnCurrentThread(const ThreadLocalBase *
thread_local_instance) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2505 + 0 + 1U - 1);
return ThreadLocalRegistryImpl::GetValueOnCurrentThread(thread_local_instance); 

} 

void ThreadLocalRegistry::OnThreadLocalDestroyed(const ThreadLocalBase *
thread_local_instance) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2506 + 0 + 1U - 1);
ThreadLocalRegistryImpl::OnThreadLocalDestroyed(thread_local_instance); 
} 
# 684 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
bool IsInSet(char ch, const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2507 + 0 + 1U - 1);
return ch != '\000' && strchr(str, ch) != __null; 
# 686 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
} 




bool IsAsciiDigit(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2508 + 0 + 1U - 1);return '0' <= ch && ch <= '9'; } 
bool IsAsciiPunct(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2509 + 0 + 1U - 1);
return IsInSet(ch, "^-!\"#$%&\'()*+,./:;<=>\?@[\\]_`{|}~"); 
} 
bool IsRepeat(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2510 + 0 + 1U - 1);return IsInSet(ch, "\?*+"); } 
bool IsAsciiWhiteSpace(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2511 + 0 + 1U - 1);return IsInSet(ch, " \f\n\r	\v"); } 
bool IsAsciiWordChar(char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2512 + 0 + 1U - 1);
return ((('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z')) || ('0' <= ch && ch <= '9')) || ch == '_'; 

} 


bool IsValidEscape(char c) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2513 + 0 + 1U - 1);
return (IsAsciiPunct(c) || IsInSet(c, "dDfnrsStvwW")); 
} 



bool AtomMatchesChar(bool escaped, char pattern_char, char ch) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2514 + 0 + 1U - 1), escaped)) { 
switch (((void)cpptestFastCoverageStmt(2514 + 0 + 2U - 1), pattern_char)) { 
case 'd':  cpptestFastCoverageStmt(2514 + 0 + 3U - 1);return IsAsciiDigit(ch); 
case 'D':  cpptestFastCoverageStmt(2514 + 0 + 4U - 1);return !IsAsciiDigit(ch); 
case 'f':  cpptestFastCoverageStmt(2514 + 0 + 5U - 1);return ch == '\f'; 
case 'n':  cpptestFastCoverageStmt(2514 + 0 + 6U - 1);return ch == '\n'; 
case 'r':  cpptestFastCoverageStmt(2514 + 0 + 7U - 1);return ch == '\r'; 
case 's':  cpptestFastCoverageStmt(2514 + 0 + 8U - 1);return IsAsciiWhiteSpace(ch); 
case 'S':  cpptestFastCoverageStmt(2514 + 0 + 9U - 1);return !IsAsciiWhiteSpace(ch); 
case 't':  cpptestFastCoverageStmt(2514 + 0 + 10U - 1);return ch == '	'; 
case 'v':  cpptestFastCoverageStmt(2514 + 0 + 11U - 1);return ch == '\v'; 
case 'w':  cpptestFastCoverageStmt(2514 + 0 + 12U - 1);return IsAsciiWordChar(ch); 
case 'W':  cpptestFastCoverageStmt(2514 + 0 + 13U - 1);return !IsAsciiWordChar(ch); 
}  cpptestFastCoverageStmt(2514 + 0 + 14U - 1);
return IsAsciiPunct(pattern_char) && pattern_char == ch; 
}  cpptestFastCoverageStmt(2514 + 0 + 15U - 1);

return (pattern_char == '.' && ch != '\n') || pattern_char == ch; 
} 


static std::string FormatRegexSyntaxError(const char *regex, int index) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2529 + 0 + 1U - 1);
return ((((((Message() << ("Syntax error at index ")) << index) << (" in simple regular expression \"")) << regex) << ("\": "))).GetString(); 

} 



bool ValidateRegex(const char *regex) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2530 + 0 + 1U - 1), regex == __null)) 
# 739 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ cpptestFastCoverageStmt(2530 + 0 + 2U - 1);



(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 743, "Failed") = (Message() << ("NULL is not a valid simple regular expression."))); cpptestFastCoverageStmt(2530 + 0 + 3U - 1);
return false; 
}  cpptestFastCoverageStmt(2530 + 0 + 4U - 1);

bool is_valid = true; cpptestFastCoverageStmt(2530 + 0 + 5U - 1);


bool prev_repeatable = false; cpptestFastCoverageStmt(2530 + 0 + 6U - 1);
for (int i = 0; ((void)cpptestFastCoverageStmt(2530 + 0 + 7U - 1), regex[i]); ((void)cpptestFastCoverageStmt(2530 + 0 + 8U - 1), i++)) { 
if (((void)cpptestFastCoverageStmt(2530 + 0 + 9U - 1), regex[i] == '\\')) { cpptestFastCoverageStmt(2530 + 0 + 10U - 1);
i++; 
if (((void)cpptestFastCoverageStmt(2530 + 0 + 11U - 1), regex[i] == '\000')) { cpptestFastCoverageStmt(2530 + 0 + 12U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 755, "Failed") = ((Message() << FormatRegexSyntaxError(regex, i - 1)) << ("\'\\\' cannot appear at the end."))); cpptestFastCoverageStmt(2530 + 0 + 13U - 1);

return false; 
}  

if (((void)cpptestFastCoverageStmt(2530 + 0 + 14U - 1), !IsValidEscape(regex[i]))) { cpptestFastCoverageStmt(2530 + 0 + 15U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 761, "Failed") = ((((Message() << FormatRegexSyntaxError(regex, i - 1)) << ("invalid escape sequence \"\\")) << regex[i]) << ("\"."))); cpptestFastCoverageStmt(2530 + 0 + 16U - 1);

is_valid = false; 
}  cpptestFastCoverageStmt(2530 + 0 + 17U - 1);
prev_repeatable = true; 
} else { cpptestFastCoverageStmt(2530 + 0 + 18U - 1);
const char ch = regex[i]; 

if (((void)cpptestFastCoverageStmt(2530 + 0 + 19U - 1), ch == '^' && i > 0)) { cpptestFastCoverageStmt(2530 + 0 + 20U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 770, "Failed") = ((Message() << FormatRegexSyntaxError(regex, i)) << ("\'^\' can only appear at the beginning."))); cpptestFastCoverageStmt(2530 + 0 + 21U - 1);

is_valid = false; 
} else if (((void)cpptestFastCoverageStmt(2530 + 0 + 22U - 1), ch == '$' && regex[i + 1] != '\000')) { cpptestFastCoverageStmt(2530 + 0 + 23U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 774, "Failed") = ((Message() << FormatRegexSyntaxError(regex, i)) << ("\'$\' can only appear at the end."))); cpptestFastCoverageStmt(2530 + 0 + 24U - 1);

is_valid = false; 
} else if (((void)cpptestFastCoverageStmt(2530 + 0 + 25U - 1), IsInSet(ch, "()[]{}|"))) { cpptestFastCoverageStmt(2530 + 0 + 26U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 778, "Failed") = ((((Message() << FormatRegexSyntaxError(regex, i)) << ("\'")) << ch) << ("\' is unsupported."))); cpptestFastCoverageStmt(2530 + 0 + 27U - 1);

is_valid = false; 
} else if (((void)cpptestFastCoverageStmt(2530 + 0 + 28U - 1), IsRepeat(ch) && !prev_repeatable)) { cpptestFastCoverageStmt(2530 + 0 + 29U - 1);
(AssertHelper(::testing::TestPartResult::kNonFatalFailure, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 782, "Failed") = ((((Message() << FormatRegexSyntaxError(regex, i)) << ("\'")) << ch) << ("\' can only follow a repeatable token."))); cpptestFastCoverageStmt(2530 + 0 + 30U - 1);

is_valid = false; 
}        cpptestFastCoverageStmt(2530 + 0 + 31U - 1);

prev_repeatable = !IsInSet(ch, "^$\?*+"); 
}  
}  cpptestFastCoverageStmt(2530 + 0 + 32U - 1);

return is_valid; 
} 
# 801 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
bool MatchRepetitionAndRegexAtHead(bool 
escaped, char c, char repeat, const char *regex, const char *
str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2562 + 0 + 1U - 1);
const size_t min_count = (repeat == '+') ? 1 : 0; cpptestFastCoverageStmt(2562 + 0 + 2U - 1);
const size_t max_count = (repeat == '\?') ? 1 : (static_cast< size_t>(-1) - 1); cpptestFastCoverageStmt(2562 + 0 + 3U - 1);




for (size_t i = (0); ((void)cpptestFastCoverageStmt(2562 + 0 + 4U - 1), i <= max_count); ((void)cpptestFastCoverageStmt(2562 + 0 + 5U - 1), ++i)) { 

if (((void)cpptestFastCoverageStmt(2562 + 0 + 6U - 1), i >= min_count && MatchRegexAtHead(regex, str + i))) { cpptestFastCoverageStmt(2562 + 0 + 7U - 1);




return true; 
}  
if (((void)cpptestFastCoverageStmt(2562 + 0 + 8U - 1), str[i] == '\000' || !AtomMatchesChar(escaped, c, str[i]))) {cpptestFastCoverageStmt(2562 + 0 + 9U - 1);
return false; }  
}  cpptestFastCoverageStmt(2562 + 0 + 10U - 1);
return false; 
} 




bool MatchRegexAtHead(const char *regex, const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2572 + 0 + 1U - 1), *regex == '\000')) {cpptestFastCoverageStmt(2572 + 0 + 2U - 1);
return true; }  



if (((void)cpptestFastCoverageStmt(2572 + 0 + 3U - 1), *regex == '$')) {cpptestFastCoverageStmt(2572 + 0 + 4U - 1);
return *str == '\000'; }  cpptestFastCoverageStmt(2572 + 0 + 5U - 1);


const bool escaped = *regex == '\\'; 
if (((void)cpptestFastCoverageStmt(2572 + 0 + 6U - 1), escaped)) {cpptestFastCoverageStmt(2572 + 0 + 7U - 1);
++regex; }  
if (((void)cpptestFastCoverageStmt(2572 + 0 + 8U - 1), IsRepeat(regex[1]))) { cpptestFastCoverageStmt(2572 + 0 + 9U - 1);



return MatchRepetitionAndRegexAtHead(escaped, regex[0], regex[1], regex + 2, str); 

} else { cpptestFastCoverageStmt(2572 + 0 + 10U - 1);



return ((*str != '\000') && AtomMatchesChar(escaped, *regex, *str)) && MatchRegexAtHead(regex + 1, str + 1); 

}  
} 
# 864 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
bool MatchRegexAnywhere(const char *regex, const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2582 + 0 + 1U - 1), regex == __null || str == __null)) {cpptestFastCoverageStmt(2582 + 0 + 2U - 1);
# 866 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
return false; }  

if (((void)cpptestFastCoverageStmt(2582 + 0 + 3U - 1), *regex == '^')) {cpptestFastCoverageStmt(2582 + 0 + 4U - 1);
return MatchRegexAtHead(regex + 1, str); }  


do { 
if (((void)cpptestFastCoverageStmt(2582 + 0 + 5U - 1), MatchRegexAtHead(regex, str))) {cpptestFastCoverageStmt(2582 + 0 + 6U - 1);
return true; }  
} while (((void)cpptestFastCoverageStmt(2582 + 0 + 7U - 1), *(str++) != '\000')); cpptestFastCoverageStmt(2582 + 0 + 8U - 1);
return false; 
} 



RE::~RE() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2590 + 0 + 1U - 1);
free(const_cast< char *>(pattern_)); cpptestFastCoverageStmt(2590 + 0 + 2U - 1);
free(const_cast< char *>(full_pattern_)); 
} 


bool RE::FullMatch(const char *str, const RE &re) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2592 + 0 + 1U - 1);
return re.is_valid_ && MatchRegexAnywhere(re.full_pattern_, str); 
} 



bool RE::PartialMatch(const char *str, const RE &re) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2593 + 0 + 1U - 1);
return re.is_valid_ && MatchRegexAnywhere(re.pattern_, str); 
} 


void RE::Init(const char *regex) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2594 + 0 + 1U - 1);
pattern_ = (full_pattern_ = __null); 
# 900 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
if (((void)cpptestFastCoverageStmt(2594 + 0 + 2U - 1), regex != __null)) 
# 900 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ cpptestFastCoverageStmt(2594 + 0 + 3U - 1);
pattern_ = posix::StrDup(regex); 
}  cpptestFastCoverageStmt(2594 + 0 + 4U - 1);

is_valid_ = ValidateRegex(regex); 
if (((void)cpptestFastCoverageStmt(2594 + 0 + 5U - 1), !is_valid_)) { cpptestFastCoverageStmt(2594 + 0 + 6U - 1);

return; 
}  cpptestFastCoverageStmt(2594 + 0 + 7U - 1);

const size_t len = strlen(regex); cpptestFastCoverageStmt(2594 + 0 + 8U - 1);



char *buffer = static_cast< char *>(malloc(len + 3)); cpptestFastCoverageStmt(2594 + 0 + 9U - 1);
full_pattern_ = buffer; 

if (((void)cpptestFastCoverageStmt(2594 + 0 + 10U - 1), *regex != '^')) {cpptestFastCoverageStmt(2594 + 0 + 11U - 1);
*(buffer++) = '^'; }  cpptestFastCoverageStmt(2594 + 0 + 12U - 1);



memcpy(buffer, regex, len); cpptestFastCoverageStmt(2594 + 0 + 13U - 1);
buffer += len; 

if (((void)cpptestFastCoverageStmt(2594 + 0 + 14U - 1), len == 0 || regex[len - 1] != '$')) {cpptestFastCoverageStmt(2594 + 0 + 15U - 1);
*(buffer++) = '$'; }  cpptestFastCoverageStmt(2594 + 0 + 16U - 1);

*buffer = '\000'; 
} 



const char kUnknownFile[] = "unknown file"; 



__attribute((visibility("default"))) std::string FormatFileLocation(const char *file, int line) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2610 + 0 + 1U - 1);
const std::string file_name((file == (nullptr)) ? kUnknownFile : file); 

if (((void)cpptestFastCoverageStmt(2610 + 0 + 2U - 1), line < 0)) { cpptestFastCoverageStmt(2610 + 0 + 3U - 1);
return (file_name + (":")); 
}  cpptestFastCoverageStmt(2610 + 0 + 4U - 1);



return (((file_name + (":")) + StreamableToString(line)) + (":")); 

} 
# 955
__attribute((visibility("default"))) std::string FormatCompilerIndependentFileLocation(const char *
file, int line) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2614 + 0 + 1U - 1);
const std::string file_name((file == (nullptr)) ? kUnknownFile : file); 

if (((void)cpptestFastCoverageStmt(2614 + 0 + 2U - 1), line < 0)) {cpptestFastCoverageStmt(2614 + 0 + 3U - 1);
return file_name; } else {cpptestFastCoverageStmt(2614 + 0 + 4U - 1);

return ((file_name + (":")) + StreamableToString(line)); }  
} 

GTestLog::GTestLog(GTestLogSeverity severity, const char *file, int line) : severity_(severity) 
{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2618 + 0 + 1U - 1);
const char *const marker = (severity == GTEST_INFO) ? "[  INFO ]" : ((severity == GTEST_WARNING) ? "[WARNING]" : ((severity == GTEST_ERROR) ? "[ ERROR ]" : ("[ FATAL ]"))); cpptestFastCoverageStmt(2618 + 0 + 2U - 1);



(((((this->GetStream() << (::std::endl)) << marker) << (" ")) << (FormatFileLocation(file, line)).c_str()) << (": ")); 

} 


GTestLog::~GTestLog() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2620 + 0 + 1U - 1);
(this->GetStream() << (::std::endl)); 
if (((void)cpptestFastCoverageStmt(2620 + 0 + 2U - 1), severity_ == GTEST_FATAL)) { cpptestFastCoverageStmt(2620 + 0 + 3U - 1);
fflush((&((_iob)[2]))); cpptestFastCoverageStmt(2620 + 0 + 4U - 1);
# 980 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
posix::Abort(); 
}  
} 
# 991
class CapturedStream { 


public: explicit CapturedStream(int fd) : fd_(fd), uncaptured_fd_(dup(fd)) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2624 + 0 + 1U - 1);

char temp_dir_path[260 + 1] = {'\000'}; 
# 996 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
cpptestFastCoverageStmt(2624 + 0 + 2U - 1);
char temp_file_path[260 + 1] = {'\000'}; 
# 997 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
cpptestFastCoverageStmt(2624 + 0 + 3U - 1);

::GetTempPathA(sizeof (temp_dir_path), temp_dir_path); cpptestFastCoverageStmt(2624 + 0 + 4U - 1);
const UINT success = ::GetTempFileNameA(temp_dir_path, "gtest_redir", 0, temp_file_path); 



switch (((void)cpptestFastCoverageStmt(2624 + 0 + 5U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2624 + 0 + 6U - 1), ::testing::internal::IsTrue(success != 0))) {cpptestFastCoverageStmt(2624 + 0 + 7U - 1);; } else {cpptestFastCoverageStmt(2624 + 0 + 8U - 1);(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 1004).GetStream() << ("Condition success != 0 failed. ")) << ("Unable to create a temporary file in ")) << (temp_dir_path)); }  }  cpptestFastCoverageStmt(2624 + 0 + 9U - 1);

const int captured_fd = creat(temp_file_path, 0x100 | 0x80); 
# 1007 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
switch (((void)cpptestFastCoverageStmt(2624 + 0 + 10U - 1), 0)) { case 0:  default:  if (((void)cpptestFastCoverageStmt(2624 + 0 + 11U - 1), ::testing::internal::IsTrue(captured_fd != -1))) {cpptestFastCoverageStmt(2624 + 0 + 12U - 1);; } else {cpptestFastCoverageStmt(2624 + 0 + 13U - 1);(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 1007).GetStream() << ("Condition captured_fd != -1 failed. ")) << ("Unable to open temporary file ")) << (temp_file_path)); }  }  cpptestFastCoverageStmt(2624 + 0 + 14U - 1);

(filename_ = (temp_file_path)); cpptestFastCoverageStmt(2624 + 0 + 15U - 1);
# 1037 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
fflush(nullptr); cpptestFastCoverageStmt(2624 + 0 + 16U - 1);
dup2(captured_fd, fd_); cpptestFastCoverageStmt(2624 + 0 + 17U - 1);
close(captured_fd); 
} 

~CapturedStream() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2641 + 0 + 1U - 1);
remove((filename_).c_str()); 
} 

std::string GetCapturedString() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2642 + 0 + 1U - 1), uncaptured_fd_ != -1)) { cpptestFastCoverageStmt(2642 + 0 + 2U - 1);

fflush(nullptr); cpptestFastCoverageStmt(2642 + 0 + 3U - 1);
dup2(uncaptured_fd_, fd_); cpptestFastCoverageStmt(2642 + 0 + 4U - 1);
close(uncaptured_fd_); cpptestFastCoverageStmt(2642 + 0 + 5U - 1);
uncaptured_fd_ = -1; 
}  cpptestFastCoverageStmt(2642 + 0 + 6U - 1);

FILE *const file = posix::FOpen((filename_).c_str(), "r"); cpptestFastCoverageStmt(2642 + 0 + 7U - 1);
const std::string content = ReadEntireFile(file); cpptestFastCoverageStmt(2642 + 0 + 8U - 1);
posix::FClose(file); cpptestFastCoverageStmt(2642 + 0 + 9U - 1);
return content; 
} 


private: const int fd_; 
int uncaptured_fd_; 

std::string filename_; 

CapturedStream(const CapturedStream &) = delete;void operator=(const CapturedStream &) = delete;
}; 



static CapturedStream *g_captured_stderr = (nullptr); 
static CapturedStream *g_captured_stdout = (nullptr); 


static void CaptureStream(int fd, const char *stream_name, CapturedStream **
stream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2651 + 0 + 1U - 1), *stream != (nullptr))) { cpptestFastCoverageStmt(2651 + 0 + 2U - 1);
(((GTestLog(::testing::internal::GTEST_FATAL, "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc", 1079).GetStream() << ("Only one ")) << stream_name) << (" capturer can exist at a time.")); 

}  cpptestFastCoverageStmt(2651 + 0 + 3U - 1);
*stream = (new CapturedStream(fd)); 
} 


static std::string GetCapturedStream(CapturedStream **captured_stream) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2654 + 0 + 1U - 1);
const std::string content = (*captured_stream)->GetCapturedString(); cpptestFastCoverageStmt(2654 + 0 + 2U - 1);

delete (*captured_stream); cpptestFastCoverageStmt(2654 + 0 + 3U - 1);
*captured_stream = (nullptr); cpptestFastCoverageStmt(2654 + 0 + 4U - 1);

return content; 
} 


void CaptureStdout() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2658 + 0 + 1U - 1);
CaptureStream(kStdOutFileno, "stdout", &g_captured_stdout); 
} 


void CaptureStderr() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2659 + 0 + 1U - 1);
CaptureStream(kStdErrFileno, "stderr", &g_captured_stderr); 
} 


std::string GetCapturedStdout() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2660 + 0 + 1U - 1);
return GetCapturedStream(&g_captured_stdout); 
} 


std::string GetCapturedStderr() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2661 + 0 + 1U - 1);
return GetCapturedStream(&g_captured_stderr); 
} 
# 1121
size_t GetFileSize(FILE *file) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2662 + 0 + 1U - 1);
fseek(file, 0, 2); cpptestFastCoverageStmt(2662 + 0 + 2U - 1);
# 1123 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
return static_cast< size_t>(ftell(file)); 
} 

std::string ReadEntireFile(FILE *file) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2664 + 0 + 1U - 1);
const size_t file_size = GetFileSize(file); cpptestFastCoverageStmt(2664 + 0 + 2U - 1);
char *const buffer = new char [file_size]; cpptestFastCoverageStmt(2664 + 0 + 3U - 1);

size_t bytes_last_read = (0); cpptestFastCoverageStmt(2664 + 0 + 4U - 1);
size_t bytes_read = (0); cpptestFastCoverageStmt(2664 + 0 + 5U - 1);

fseek(file, 0, 0); 
# 1137 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
do { cpptestFastCoverageStmt(2664 + 0 + 6U - 1);
bytes_last_read = fread(buffer + bytes_read, 1, file_size - bytes_read, file); cpptestFastCoverageStmt(2664 + 0 + 7U - 1);
bytes_read += bytes_last_read; 
} while (((void)cpptestFastCoverageStmt(2664 + 0 + 8U - 1), bytes_last_read > 0 && bytes_read < file_size)); cpptestFastCoverageStmt(2664 + 0 + 9U - 1);

const std::string content(buffer, bytes_read); cpptestFastCoverageStmt(2664 + 0 + 10U - 1);
delete [] buffer; cpptestFastCoverageStmt(2664 + 0 + 11U - 1);

return content; 
} 


static const std::vector< std::__cxx11::basic_string< char> >  *g_injected_test_argvs = (nullptr); 


std::vector< std::__cxx11::basic_string< char> >  GetInjectableArgvs() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2675 + 0 + 1U - 1), g_injected_test_argvs != (nullptr))) { cpptestFastCoverageStmt(2675 + 0 + 2U - 1);
return *g_injected_test_argvs; 
}  cpptestFastCoverageStmt(2675 + 0 + 3U - 1);
return GetArgvs(); 
} 

void SetInjectableArgvs(const std::vector< std::__cxx11::basic_string< char> >  *new_argvs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2678 + 0 + 1U - 1), g_injected_test_argvs != new_argvs)) {cpptestFastCoverageStmt(2678 + 0 + 2U - 1);delete g_injected_test_argvs; }  cpptestFastCoverageStmt(2678 + 0 + 3U - 1);
g_injected_test_argvs = new_argvs; 
} 

void SetInjectableArgvs(const std::vector< std::__cxx11::basic_string< char> >  &new_argvs) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2681 + 0 + 1U - 1);
SetInjectableArgvs(new std::vector< std::__cxx11::basic_string< char> > (new_argvs.begin(), new_argvs.end())); 

} 
# 1176 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
void ClearInjectableArgvs() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2682 + 0 + 1U - 1);
delete g_injected_test_argvs; cpptestFastCoverageStmt(2682 + 0 + 2U - 1);
g_injected_test_argvs = (nullptr); 
} 
# 1194 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
static std::string FlagToEnvVar(const char *flag) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2684 + 0 + 1U - 1);
const std::string full_flag = (((Message() << ("gtest_")) << flag)).GetString(); cpptestFastCoverageStmt(2684 + 0 + 2U - 1);


Message env_var; cpptestFastCoverageStmt(2684 + 0 + 3U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(2684 + 0 + 4U - 1), i != full_flag.length()); ((void)cpptestFastCoverageStmt(2684 + 0 + 5U - 1), i++)) { cpptestFastCoverageStmt(2684 + 0 + 6U - 1);
(env_var << ToUpper(full_flag.c_str()[i])); 
}  cpptestFastCoverageStmt(2684 + 0 + 7U - 1);

return env_var.GetString(); 
} 




bool ParseInt32(const Message &src_text, const char *str, Int32 *value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2691 + 0 + 1U - 1);

char *end = (nullptr); cpptestFastCoverageStmt(2691 + 0 + 2U - 1);
const long long_value = strtol(str, &end, 10); 


if (((void)cpptestFastCoverageStmt(2691 + 0 + 3U - 1), *end != '\000')) { cpptestFastCoverageStmt(2691 + 0 + 4U - 1);

Message msg; cpptestFastCoverageStmt(2691 + 0 + 5U - 1);
((((((msg << ("WARNING: ")) << src_text) << (" is expected to be a 32-bit integer, but actually")) << (" has value \"")) << str) << ("\".\n")); cpptestFastCoverageStmt(2691 + 0 + 6U - 1);


printf("%s", (msg.GetString()).c_str()); cpptestFastCoverageStmt(2691 + 0 + 7U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(2691 + 0 + 8U - 1);
# 1223 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
return false; 
}  cpptestFastCoverageStmt(2691 + 0 + 9U - 1);


const Int32 result = static_cast< Int32>(long_value); 
if (((void)cpptestFastCoverageStmt(2691 + 0 + 10U - 1), (long_value == 2147483647L || long_value == (-2147483647L - 1)) || result != long_value)) 
# 1233 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ cpptestFastCoverageStmt(2691 + 0 + 11U - 1);
Message msg; cpptestFastCoverageStmt(2691 + 0 + 12U - 1);
((((((msg << ("WARNING: ")) << src_text) << (" is expected to be a 32-bit integer, but actually")) << (" has value ")) << str) << (", which overflows.\n")); cpptestFastCoverageStmt(2691 + 0 + 13U - 1);


printf("%s", (msg.GetString()).c_str()); cpptestFastCoverageStmt(2691 + 0 + 14U - 1);
fflush((&((_iob)[1]))); cpptestFastCoverageStmt(2691 + 0 + 15U - 1);
# 1240 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
return false; 
}  cpptestFastCoverageStmt(2691 + 0 + 16U - 1);

*value = result; cpptestFastCoverageStmt(2691 + 0 + 17U - 1);
return true; 
} 
# 1251
bool BoolFromGTestEnv(const char *flag, bool default_value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2708 + 0 + 1U - 1);



const std::string env_var = FlagToEnvVar(flag); cpptestFastCoverageStmt(2708 + 0 + 2U - 1);
const char *const string_value = posix::GetEnv(env_var.c_str()); cpptestFastCoverageStmt(2708 + 0 + 3U - 1);
return (string_value == __null) ? default_value : (strcmp(string_value, "0") != 0); 
# 1260 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
} 




Int32 Int32FromGTestEnv(const char *flag, Int32 default_value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2711 + 0 + 1U - 1);



const std::string env_var = FlagToEnvVar(flag); cpptestFastCoverageStmt(2711 + 0 + 2U - 1);
const char *const string_value = posix::GetEnv(env_var.c_str()); 
if (((void)cpptestFastCoverageStmt(2711 + 0 + 3U - 1), string_value == __null)) 
# 1271 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
{ cpptestFastCoverageStmt(2711 + 0 + 4U - 1);

return default_value; 
}  cpptestFastCoverageStmt(2711 + 0 + 5U - 1);

Int32 result = default_value; 
if (((void)cpptestFastCoverageStmt(2711 + 0 + 6U - 1), !ParseInt32(((Message() << ("Environment variable ")) << env_var), string_value, &result))) 
{ cpptestFastCoverageStmt(2711 + 0 + 7U - 1);
printf("The default value %s is used.\n", (((Message() << default_value)).GetString()).c_str()); cpptestFastCoverageStmt(2711 + 0 + 8U - 1);

fflush((&((_iob)[1]))); cpptestFastCoverageStmt(2711 + 0 + 9U - 1);
# 1282 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
return default_value; 
}  cpptestFastCoverageStmt(2711 + 0 + 10U - 1);

return result; 

} 
# 1297 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
std::string OutputFlagAlsoCheckEnvVar() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2721 + 0 + 1U - 1);
std::string default_value_for_output_flag = ""; cpptestFastCoverageStmt(2721 + 0 + 2U - 1);
const char *xml_output_file_env = posix::GetEnv("XML_OUTPUT_FILE"); 
if (((void)cpptestFastCoverageStmt(2721 + 0 + 3U - 1), (nullptr) != xml_output_file_env)) { cpptestFastCoverageStmt(2721 + 0 + 4U - 1);
(default_value_for_output_flag = (((std::__cxx11::basic_string< char> )("xml:")) + xml_output_file_env)); 
}  cpptestFastCoverageStmt(2721 + 0 + 5U - 1);
return default_value_for_output_flag; 
} 



const char *StringFromGTestEnv(const char *flag, const char *default_value) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2726 + 0 + 1U - 1);



const std::string env_var = FlagToEnvVar(flag); cpptestFastCoverageStmt(2726 + 0 + 2U - 1);
const char *const value = posix::GetEnv(env_var.c_str()); cpptestFastCoverageStmt(2726 + 0 + 3U - 1);
return (value == __null) ? default_value : value; 
# 1316 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-port.cc"
} 

}
}
# 53 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-printers.cc"
namespace testing { 

namespace { 

using std::ostream;
# 63
void PrintByteSegmentInObjectTo(const unsigned char *obj_bytes, size_t start, size_t 
count, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2729 + 0 + 1U - 1);
char text[5] = ""; cpptestFastCoverageStmt(2729 + 0 + 2U - 1);
for (size_t i = (0); ((void)cpptestFastCoverageStmt(2729 + 0 + 3U - 1), i != count); ((void)cpptestFastCoverageStmt(2729 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(2729 + 0 + 5U - 1);
const size_t j = start + i; 
if (((void)cpptestFastCoverageStmt(2729 + 0 + 6U - 1), i != 0)) { 


if (((void)cpptestFastCoverageStmt(2729 + 0 + 7U - 1), (j % 2) == 0)) {cpptestFastCoverageStmt(2729 + 0 + 8U - 1);
(*os << ' '); } else {cpptestFastCoverageStmt(2729 + 0 + 9U - 1);

(*os << '-'); }  
}  cpptestFastCoverageStmt(2729 + 0 + 10U - 1);
snprintf(text, sizeof (text), "%02X", obj_bytes[j]); cpptestFastCoverageStmt(2729 + 0 + 11U - 1);
(*os << (text)); 
}  
} 


void PrintBytesInObjectToImpl(const unsigned char *obj_bytes, size_t count, std::ostream *
os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2740 + 0 + 1U - 1);

((*os << count) << ("-byte object <")); cpptestFastCoverageStmt(2740 + 0 + 2U - 1);

const size_t kThreshold = (132); cpptestFastCoverageStmt(2740 + 0 + 3U - 1);
const size_t kChunkSize = (64); 




if (((void)cpptestFastCoverageStmt(2740 + 0 + 4U - 1), count < kThreshold)) { cpptestFastCoverageStmt(2740 + 0 + 5U - 1);
PrintByteSegmentInObjectTo(obj_bytes, 0, count, os); 
} else { cpptestFastCoverageStmt(2740 + 0 + 6U - 1);
PrintByteSegmentInObjectTo(obj_bytes, 0, kChunkSize, os); cpptestFastCoverageStmt(2740 + 0 + 7U - 1);
(*os << (" ... ")); cpptestFastCoverageStmt(2740 + 0 + 8U - 1);

const size_t resume_pos = (((count - kChunkSize) + 1) / 2) * 2; cpptestFastCoverageStmt(2740 + 0 + 9U - 1);
PrintByteSegmentInObjectTo(obj_bytes, resume_pos, count - resume_pos, os); 
}  cpptestFastCoverageStmt(2740 + 0 + 10U - 1);
(*os << (">")); 
} 

}

namespace internal2 { 
# 114
void PrintBytesInObjectTo(const unsigned char *obj_bytes, size_t count, std::ostream *
os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2750 + 0 + 1U - 1);
PrintBytesInObjectToImpl(obj_bytes, count, os); 
} 

}

namespace internal { 
# 128
enum CharFormat { 
kAsIs, 
kHexEscape, 
kSpecialEscape
}; 




inline bool IsPrintableAscii(wchar_t c) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2751 + 0 + 1U - 1);
return 0x20 <= c && c <= 0x7e; 
} 
# 145
template < typename UnsignedChar , typename Char > 
static CharFormat PrintAsCharLiteralTo (Char c , ostream * os) { 
switch (static_cast < wchar_t > (c)) { 
case L'\0' : 
* os << "\\0" ; 
break ; 
case L'\'' : 
* os << "\\'" ; 
break ; 
case L'\\' : 
* os << "\\\\" ; 
break ; 
case L'\a' : 
* os << "\\a" ; 
break ; 
case L'\b' : 
* os << "\\b" ; 
break ; 
case L'\f' : 
* os << "\\f" ; 
break ; 
case L'\n' : 
* os << "\\n" ; 
break ; 
case L'\r' : 
* os << "\\r" ; 
break ; 
case L'\t' : 
* os << "\\t" ; 
break ; 
case L'\v' : 
* os << "\\v" ; 
break ; 
default : 
if (IsPrintableAscii (c)) { 
* os << static_cast < char > (c) ; 
return kAsIs ; 
} else { 
ostream :: fmtflags flags = os -> flags () ; 
* os << "\\x" << std :: hex << std :: uppercase 
<< static_cast < int > (static_cast < UnsignedChar > (c)) ; 
os -> flags (flags) ; 
return kHexEscape ; 
} 
} 
return kSpecialEscape ; 
} 



static CharFormat PrintAsStringLiteralTo(wchar_t c, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
switch (((void)cpptestFastCoverageStmt(2752 + 0 + 1U - 1), c)) { 
case L'\x27':  cpptestFastCoverageStmt(2752 + 0 + 2U - 1);
(*os << ("\'")); cpptestFastCoverageStmt(2752 + 0 + 3U - 1);
return kAsIs; 
case L'\x22':  cpptestFastCoverageStmt(2752 + 0 + 4U - 1);
(*os << ("\\\"")); cpptestFastCoverageStmt(2752 + 0 + 5U - 1);
return kSpecialEscape; 
default:  cpptestFastCoverageStmt(2752 + 0 + 6U - 1);
return PrintAsCharLiteralTo< wchar_t> (c, os); 
}  
} 



static CharFormat PrintAsStringLiteralTo(char c, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2758 + 0 + 1U - 1);
return PrintAsStringLiteralTo(static_cast< wchar_t>(static_cast< unsigned char>(c)), os); 

} 
# 219
template < typename UnsignedChar , typename Char > 
void PrintCharAndCodeTo (Char c , ostream * os) { 

* os << ((sizeof (c) > 1) ? "L'" : "'") ; 
const CharFormat format = PrintAsCharLiteralTo < UnsignedChar > (c , os) ; 
* os << "'" ; 




if (c == 0) 
return ; 
* os << " (" << static_cast < int > (c) ; 




if (format == kHexEscape || (1 <= c && c <= 9)) { 

} else { 
* os << ", 0x" << String :: FormatHexInt (static_cast < UnsignedChar > (c)) ; 
} 
* os << ")" ; 
} 

void PrintTo(unsigned char c, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2759 + 0 + 1U - 1);
PrintCharAndCodeTo< unsigned char> (c, os); 
} 
void PrintTo(signed char c, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2760 + 0 + 1U - 1);
PrintCharAndCodeTo< unsigned char> (c, os); 
} 



void PrintTo(wchar_t wc, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2761 + 0 + 1U - 1);
PrintCharAndCodeTo< wchar_t> (wc, os); 
} 
# 261
template < typename CharType > 



static CharFormat PrintCharsAsStringTo (
const CharType * begin , size_t len , ostream * os) { 
const char * const kQuoteBegin = sizeof (CharType) == 1 ? "\"" : "L\"" ; 
* os << kQuoteBegin ; 
bool is_previous_hex = false ; 
CharFormat print_format = kAsIs ; 
for (size_t index = 0 ; index < len ; ++ index) { 
const CharType cur = begin [ index ] ; 
if (is_previous_hex && IsXDigit (cur)) { 



* os << "\" " << kQuoteBegin ; 
} 
is_previous_hex = PrintAsStringLiteralTo (cur , os) == kHexEscape ; 

if (is_previous_hex) { 
print_format = kHexEscape ; 
} 
} 
* os << "\"" ; 
return print_format ; 
} 



template < typename CharType > 



static void UniversalPrintCharArray (
const CharType * begin , size_t len , ostream * os) { 
# 304
if (len > 0 && begin [ len - 1 ] == '\0') { 
PrintCharsAsStringTo (begin , len - 1 , os) ; 
return ; 
} 
# 313
PrintCharsAsStringTo (begin , len , os) ; 
* os << " (no terminating NUL)" ; 
} 


void UniversalPrintArray(const char *begin, size_t len, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2762 + 0 + 1U - 1);
UniversalPrintCharArray(begin, len, os); 
} 



void UniversalPrintArray(const wchar_t *begin, size_t len, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2763 + 0 + 1U - 1);
UniversalPrintCharArray(begin, len, os); 
} 


void PrintTo(const char *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2764 + 0 + 1U - 1), s == (nullptr))) { cpptestFastCoverageStmt(2764 + 0 + 2U - 1);
(*os << ("NULL")); 
} else { cpptestFastCoverageStmt(2764 + 0 + 3U - 1);
((*os << ImplicitCast_< const void *> (s)) << (" pointing to ")); cpptestFastCoverageStmt(2764 + 0 + 4U - 1);
PrintCharsAsStringTo(s, strlen(s), os); 
}  
} 
# 346 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-printers.cc"
void PrintTo(const wchar_t *s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2768 + 0 + 1U - 1), s == (nullptr))) { cpptestFastCoverageStmt(2768 + 0 + 2U - 1);
(*os << ("NULL")); 
} else { cpptestFastCoverageStmt(2768 + 0 + 3U - 1);
((*os << ImplicitCast_< const void *> (s)) << (" pointing to ")); cpptestFastCoverageStmt(2768 + 0 + 4U - 1);
PrintCharsAsStringTo(s, std::wcslen(s), os); 
}  
} 


namespace { 

bool ContainsUnprintableControlCodes(const char *str, size_t length) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2772 + 0 + 1U - 1);
const unsigned char *s = reinterpret_cast< const unsigned char *>(str); cpptestFastCoverageStmt(2772 + 0 + 2U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(2772 + 0 + 3U - 1), i < length); ((void)cpptestFastCoverageStmt(2772 + 0 + 4U - 1), i++)) { cpptestFastCoverageStmt(2772 + 0 + 5U - 1);
unsigned char ch = *(s++); 
if (((void)cpptestFastCoverageStmt(2772 + 0 + 6U - 1), std::iscntrl(ch))) { 
switch (((void)cpptestFastCoverageStmt(2772 + 0 + 7U - 1), ch)) { 
case '	':  
case '\n':  
case '\r':  cpptestFastCoverageStmt(2772 + 0 + 8U - 1);
break; 
default:  cpptestFastCoverageStmt(2772 + 0 + 9U - 1);
return true; 
}  
}  
}  cpptestFastCoverageStmt(2772 + 0 + 10U - 1);
return false; 
} 

bool IsUTF8TrailByte(unsigned char t) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2782 + 0 + 1U - 1);return 0x80 <= t && t <= 0xbf; } 

bool IsValidUTF8(const char *str, size_t length) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2783 + 0 + 1U - 1);
const unsigned char *s = reinterpret_cast< const unsigned char *>(str); cpptestFastCoverageStmt(2783 + 0 + 2U - 1);

for (size_t i = (0); ((void)cpptestFastCoverageStmt(2783 + 0 + 3U - 1), i < length);) { { cpptestFastCoverageStmt(2783 + 0 + 4U - 1);
unsigned char lead = s[i++]; 

if (((void)cpptestFastCoverageStmt(2783 + 0 + 5U - 1), lead <= 0x7f)) { cpptestFastCoverageStmt(2783 + 0 + 6U - 1);
continue; 
}  
if (((void)cpptestFastCoverageStmt(2783 + 0 + 7U - 1), lead < 0xc2)) { cpptestFastCoverageStmt(2783 + 0 + 8U - 1);
return false; 
} else if (((void)cpptestFastCoverageStmt(2783 + 0 + 9U - 1), (lead <= 0xdf && (i + 1) <= length) && IsUTF8TrailByte(s[i]))) { cpptestFastCoverageStmt(2783 + 0 + 10U - 1);
++i; 
} else if (((void)cpptestFastCoverageStmt(2783 + 0 + 11U - 1), (((((0xe0 <= lead && lead <= 0xef) && (i + 2) <= length) && IsUTF8TrailByte(s[i])) && IsUTF8TrailByte(s[i + 1])) && (lead != 0xe0 || s[i] >= 0xa0)) && (lead != 0xed || s[i] < 0xa0))) 




{ cpptestFastCoverageStmt(2783 + 0 + 12U - 1);
i += 2; 
} else if (((void)cpptestFastCoverageStmt(2783 + 0 + 13U - 1), ((((((0xf0 <= lead && lead <= 0xf4) && (i + 3) <= length) && IsUTF8TrailByte(s[i])) && IsUTF8TrailByte(s[i + 1])) && IsUTF8TrailByte(s[i + 2])) && (lead != 0xf0 || s[i] >= 0x90)) && (lead != 0xf4 || s[i] < 0x90))) 
# 405
{ cpptestFastCoverageStmt(2783 + 0 + 14U - 1);
i += 3; 
} else { cpptestFastCoverageStmt(2783 + 0 + 15U - 1);
return false; 
}        
} }  cpptestFastCoverageStmt(2783 + 0 + 16U - 1);
return true; 
} 

void ConditionalPrintAsText(const char *str, size_t length, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2799 + 0 + 1U - 1), !ContainsUnprintableControlCodes(str, length) && IsValidUTF8(str, length))) 
{ cpptestFastCoverageStmt(2799 + 0 + 2U - 1);
(((*os << ("\n    As Text: \"")) << str) << ("\"")); 
}  
} 

}
# 434 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-printers.cc"
void PrintStringTo(const std::string &s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2801 + 0 + 1U - 1), PrintCharsAsStringTo(s.data(), s.size(), os) == kHexEscape)) { 
if (((void)cpptestFastCoverageStmt(2801 + 0 + 2U - 1), FLAGS_gtest_print_utf8)) { cpptestFastCoverageStmt(2801 + 0 + 3U - 1);
ConditionalPrintAsText(s.data(), s.size(), os); 
}  
}  
} 
# 450 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-printers.cc"
void PrintWideStringTo(const std::wstring &s, std::ostream *os) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2804 + 0 + 1U - 1);
PrintCharsAsStringTo(s.data(), s.size(), os); 
} 


}

}
# 36 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-test-part.cc"
namespace testing { 

using internal::GetUnitTestImpl;



std::string TestPartResult::ExtractSummary(const char *message) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2805 + 0 + 1U - 1);
const char *const stack_trace = strstr(message, internal::kStackTraceMarker); cpptestFastCoverageStmt(2805 + 0 + 2U - 1);
return ((stack_trace == (nullptr)) ? message : std::string(message, stack_trace)); 
} 


std::ostream &operator<<(std::ostream &os, const TestPartResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2807 + 0 + 1U - 1);
return ((((((((os << result.file_name()) << (":")) << result.line_number()) << (": ")) << ((result.type() == TestPartResult::kSuccess) ? "Success" : ((result.type() == TestPartResult::kSkip) ? "Skipped" : ((result.type() == TestPartResult::kFatalFailure) ? "Fatal failure" : ("Non-fatal failure"))))) << (":\n")) << result.message()) << (std::endl)); 
# 59
} 


void TestPartResultArray::Append(const TestPartResult &result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2808 + 0 + 1U - 1);
(array_).push_back(result); 
} 


const TestPartResult &TestPartResultArray::GetTestPartResult(int index) const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2809 + 0 + 1U - 1), index < 0 || index >= this->size())) { cpptestFastCoverageStmt(2809 + 0 + 2U - 1);
printf("\nInvalid index (%d) into TestPartResultArray.\n", index); cpptestFastCoverageStmt(2809 + 0 + 3U - 1);
internal::posix::Abort(); 
}  cpptestFastCoverageStmt(2809 + 0 + 4U - 1);

return array_[index]; 
} 


int TestPartResultArray::size() const { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2813 + 0 + 1U - 1);
return static_cast< int>((array_).size()); 
} 

namespace internal { 

HasNewFatalFailureHelper::HasNewFatalFailureHelper() : has_new_fatal_failure_(false), original_reporter_(GetUnitTestImpl()->GetTestPartResultReporterForCurrentThread()) 


{ const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2814 + 0 + 1U - 1);
GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(this); 
} 

HasNewFatalFailureHelper::~HasNewFatalFailureHelper() { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2815 + 0 + 1U - 1);
GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(original_reporter_); 

} 

void HasNewFatalFailureHelper::ReportTestPartResult(const TestPartResult &
result) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
if (((void)cpptestFastCoverageStmt(2816 + 0 + 1U - 1), result.fatally_failed())) {cpptestFastCoverageStmt(2816 + 0 + 2U - 1);
has_new_fatal_failure_ = true; }  cpptestFastCoverageStmt(2816 + 0 + 3U - 1);
(original_reporter_)->ReportTestPartResult(result); 
} 

}

}
# 35 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-typed-test.cc"
namespace testing { 
namespace internal { 
# 42
static const char *SkipSpaces(const char *str) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);
while (((void)cpptestFastCoverageStmt(2819 + 0 + 1U - 1), IsSpace(*str))) {cpptestFastCoverageStmt(2819 + 0 + 2U - 1);
str++; }  cpptestFastCoverageStmt(2819 + 0 + 3U - 1);
return str; 
} 

static std::vector< std::__cxx11::basic_string< char> >  SplitIntoTestNames(const char *src) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2822 + 0 + 1U - 1);
std::vector< std::__cxx11::basic_string< char> >  name_vec; cpptestFastCoverageStmt(2822 + 0 + 2U - 1);
src = SkipSpaces(src); 
for (; ((void)cpptestFastCoverageStmt(2822 + 0 + 3U - 1), src != (nullptr)); ((void)cpptestFastCoverageStmt(2822 + 0 + 4U - 1), src = SkipComma(src))) { cpptestFastCoverageStmt(2822 + 0 + 5U - 1);
name_vec.push_back(StripTrailingSpaces(GetPrefixUntilComma(src))); 
}  cpptestFastCoverageStmt(2822 + 0 + 6U - 1);
return name_vec; 
} 




const char *TypedTestCasePState::VerifyRegisteredTestNames(const char *
file, int line, const char *registered_tests) { const unsigned int _CppTest_autoInitVar = CPPTEST_COVERAGE_AUTO_INIT(__CPTR_cui);cpptestFastCoverageStmt(2828 + 0 + 1U - 1);
typedef std::map< std::__cxx11::basic_string< char> , CodeLocation> ::const_iterator RegisteredTestIter; cpptestFastCoverageStmt(2828 + 0 + 2U - 1);
registered_ = true; cpptestFastCoverageStmt(2828 + 0 + 3U - 1);

std::vector< std::__cxx11::basic_string< char> >  name_vec = SplitIntoTestNames(registered_tests); cpptestFastCoverageStmt(2828 + 0 + 4U - 1);

Message errors; cpptestFastCoverageStmt(2828 + 0 + 5U - 1);

std::set< std::__cxx11::basic_string< char> >  tests; cpptestFastCoverageStmt(2828 + 0 + 6U - 1);
for (std::vector< std::__cxx11::basic_string< char> > ::const_iterator name_it = name_vec.begin(); ((void)cpptestFastCoverageStmt(2828 + 0 + 7U - 1), name_it != name_vec.end()); ((void)cpptestFastCoverageStmt(2828 + 0 + 8U - 1), ++name_it)) { 
{ cpptestFastCoverageStmt(2828 + 0 + 9U - 1);
const std::string &name = (*name_it); 
if (((void)cpptestFastCoverageStmt(2828 + 0 + 10U - 1), tests.count(name) != 0)) { cpptestFastCoverageStmt(2828 + 0 + 11U - 1);
(((errors << ("Test ")) << name) << (" is listed more than once.\n")); cpptestFastCoverageStmt(2828 + 0 + 12U - 1);
continue; 
}  cpptestFastCoverageStmt(2828 + 0 + 13U - 1);

bool found = false; cpptestFastCoverageStmt(2828 + 0 + 14U - 1);
for (RegisteredTestIter it = (registered_tests_).begin(); ((void)cpptestFastCoverageStmt(2828 + 0 + 15U - 1), it != (registered_tests_).end()); ((void)cpptestFastCoverageStmt(2828 + 0 + 16U - 1), ++it)) 

{ 
if (((void)cpptestFastCoverageStmt(2828 + 0 + 17U - 1), (name == it->first))) { cpptestFastCoverageStmt(2828 + 0 + 18U - 1);
found = true; cpptestFastCoverageStmt(2828 + 0 + 19U - 1);
break; 
}  
}  

if (((void)cpptestFastCoverageStmt(2828 + 0 + 20U - 1), found)) { cpptestFastCoverageStmt(2828 + 0 + 21U - 1);
tests.insert(name); 
} else { cpptestFastCoverageStmt(2828 + 0 + 22U - 1);
(((errors << ("No test named ")) << name) << (" can be found in this test case.\n")); 

}  
} }  cpptestFastCoverageStmt(2828 + 0 + 23U - 1);

for (RegisteredTestIter it = (registered_tests_).begin(); ((void)cpptestFastCoverageStmt(2828 + 0 + 24U - 1), it != (registered_tests_).end()); ((void)cpptestFastCoverageStmt(2828 + 0 + 25U - 1), ++it)) 

{ 
if (((void)cpptestFastCoverageStmt(2828 + 0 + 26U - 1), tests.count(it->first) == 0)) { cpptestFastCoverageStmt(2828 + 0 + 27U - 1);
(((errors << ("You forgot to list test ")) << it->first) << (".\n")); 
}  
}  cpptestFastCoverageStmt(2828 + 0 + 28U - 1);

const std::string &errors_str = errors.GetString(); 
if (((void)cpptestFastCoverageStmt(2828 + 0 + 29U - 1), (errors_str != ("")))) { cpptestFastCoverageStmt(2828 + 0 + 30U - 1);
fprintf((&((_iob)[2])), "%s %s", (FormatFileLocation(file, line)).c_str(), errors_str.c_str()); cpptestFastCoverageStmt(2828 + 0 + 31U - 1);
# 108 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-typed-test.cc"
fflush((&((_iob)[2]))); cpptestFastCoverageStmt(2828 + 0 + 32U - 1);
# 109 "D:/Download/gitlab/gitlabRunner/builds/4qPaxrvx6/0/dtangParasoft/cppstad/test/lib/googletest/googletest/src/gtest-typed-test.cc"
posix::Abort(); 
}  cpptestFastCoverageStmt(2828 + 0 + 33U - 1);

return registered_tests; 
} 



}
}
#line 1 "__TEST_HARNESS__"
;


#if CPPTEST_USE_GLOBAL_AUTO_FINALIZER
static __CPTR_Finalizer_3200903944_13504_4049562350 __CPTR_finalizer;
#endif


