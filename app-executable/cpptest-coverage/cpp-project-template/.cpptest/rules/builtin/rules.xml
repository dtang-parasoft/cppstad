<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<rules>
   <builtin>
      <category description="编码规范" name="CODSTA">
         <rule header="数组元素必须由数组操作符[ ]访问" id="01" impl="CODSTA-01" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-01.rule"/>
         </rule>
         <rule header="不要将成员变量声明为位域" id="02" impl="CODSTA-02" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-02.rule"/>
         </rule>
         <rule header="union 成员不应被声明为位域" id="02_b" impl="CODSTA-02_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-02_b.rule"/>
         </rule>
         <rule header="不要通过 #define 定义常量" id="03" impl="CODSTA-03" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-03.rule"/>
         </rule>
         <rule header="不要使用 'static' 关键字声明局部变量" id="04" impl="CODSTA-04" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-04.rule"/>
         </rule>
         <rule header="应该尽可能避免使用指向指针的指针" id="05" impl="CODSTA-05" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-05.rule"/>
         </rule>
         <rule header="避免使用 '?:' 三元运算符" id="06" impl="CODSTA-06" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-06.rule"/>
         </rule>
         <rule header="如果函数没有参数，使用 ( ) 而不是 ( void )" id="07" impl="CODSTA-07" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-07.rule"/>
         </rule>
         <rule header="在 for 循环中不要使用 break" id="08" impl="CODSTA-08" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-08.rule"/>
         </rule>
         <rule header="不能将函数指针强制转换为原始类型指针" id="09" impl="CODSTA-09" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-09.rule"/>
         </rule>
         <rule header="存储类型修饰符应该关联类型，而不是变量或函数" id="10" impl="CODSTA-10" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-10.rule"/>
         </rule>
         <rule header="在算术运算中不允许混合使用有符号值和无符号值" id="100" impl="CODSTA-100" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-100.rule"/>
         </rule>
         <rule header="在条件运算符的第二个和第三个操作数中不允许混合使用有符号和无符号值" id="101" impl="CODSTA-101" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-101.rule"/>
         </rule>
         <rule header="可能会导致错误的单个运算符只能在适当的上下文中使用" id="102" impl="CODSTA-102" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-102.rule"/>
         </rule>
         <rule header="具有副作用的函数调用只能在适当的上下文中使用" id="103" impl="CODSTA-103" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-103.rule"/>
         </rule>
         <rule header="如果逻辑 &amp;&amp; 或 || 的操作数包含二元运算符则操作数应该被括起来" id="104" impl="CODSTA-104" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-104.rule"/>
         </rule>
         <rule header="三元运算符 '?:' 的第二个或第三个操作数不得含有副作用" id="105" impl="CODSTA-105" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-105.rule"/>
         </rule>
         <rule header="不得使用在&lt;stdlib.h&gt;中的 bsearch 和 qsort 库函数" id="107" impl="CODSTA-107" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-107.rule"/>
         </rule>
         <rule header="不得使用标准头文件 &lt;tgmath.h&gt;" id="108" impl="CODSTA-108" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108.rule"/>
         </rule>
         <rule header="不应使用指定为由 &lt;tgmath.h&gt; 提供的设施" id="108_b" impl="CODSTA-108_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-108_b.rule"/>
         </rule>
         <rule header="在&lt;tgmath.h&gt;中声明的任何通用类型宏的所有参数都应具有适当的基本类型" id="108_c" impl="CODSTA-108_c" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-108_c.rule"/>
         </rule>
         <rule header="在 &lt;tgmath.h&gt; 中声明的任何多参数通用类型宏的所有参数应具有相同的标准类型" id="108_d" impl="CODSTA-108_d" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-108_d.rule"/>
         </rule>
         <rule header="&lt;fenv.h&gt; 提供的功能不应被使用" id="109" impl="CODSTA-109" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-109.rule"/>
         </rule>
         <rule header="标准头文件 &lt;fenv.h&gt; 不应被使用" id="109_b" impl="CODSTA-109_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-109_b.rule"/>
         </rule>
         <rule header="广泛地使用断言证明内部假设和不变式" id="11" impl="CODSTA-11" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-11.rule"/>
         </rule>
         <rule header="不得使用标准的库的 input/output 函数" id="110" impl="CODSTA-110" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-110.rule"/>
         </rule>
         <rule header="不得使用联合体关键字" id="111" impl="CODSTA-111" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-111.rule"/>
         </rule>
         <rule header="不应使用变长数组" id="112" impl="CODSTA-112" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-112.rule"/>
         </rule>
         <rule header="不应使用指向可变修改数组类型的指针" id="112_b" impl="CODSTA-112_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-112_b.rule"/>
         </rule>
         <rule header="不得声明灵活的数组成员" id="113" impl="CODSTA-113" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-113.rule"/>
         </rule>
         <rule header="汇编语言应该封装在 C/C++ 函数中并被隔离" id="114" impl="CODSTA-114" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-114.rule"/>
         </rule>
         <rule header="如果指向一个结构体或联合体的指针在一个编译单元内从未被间接引用，那么该对象的实现应该被隐藏起来" id="115" impl="CODSTA-115" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-115.rule"/>
         </rule>
         <rule header="'default' 标签（如果存在）应显示为 switch 语句的第一个或最后一个 switch 标签" id="116" impl="CODSTA-116" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-116.rule"/>
         </rule>
         <rule header="八进制和十六进制转义序列将被终止" id="117" impl="CODSTA-117" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-117.rule"/>
         </rule>
         <rule header="当一个有外部链接的对象或函数被定义时，则声明应该为可见的" id="118" impl="CODSTA-118" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-118.rule"/>
         </rule>
         <rule header="'default' 标签在终止 'break' 之前应有声明或注释" id="119" impl="CODSTA-119" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-119.rule"/>
         </rule>
         <rule header="避免使用移位操作，尽量使用算术运算" id="12" impl="CODSTA-12" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-12.rule"/>
         </rule>
         <rule header="内联函数应该声明为静态存储类" id="120" impl="CODSTA-120" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-120.rule"/>
         </rule>
         <rule header="不得使用严格的类型限定符" id="121" impl="CODSTA-121" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-121.rule"/>
         </rule>
         <rule header="应该使用具有非 void 返回类型的函数返回值" id="122_a" impl="CODSTA-122_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_a.rule"/>
         </rule>
         <rule header="应使用一个非 void 返回类型函数返回的值" id="122_b" impl="CODSTA-122_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-122_b.rule"/>
         </rule>
         <rule header="包含递增(++)或递减(--)运算符的完整表达式应该没有其他潜在的附带后果" id="123" impl="CODSTA-123" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-123.rule"/>
         </rule>
         <rule header="不得在指向函数的指针与指向函数的指针以外的任何类型之间执行转换" id="124_a" impl="CODSTA-124_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_a.rule"/>
         </rule>
         <rule header="函数类型的不兼容指针之间不能进行转换" id="124_b" impl="CODSTA-124_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-124_b.rule"/>
         </rule>
         <rule header="不能在指向不完整类型的指针和任何其他类型的指针之间进行转换" id="125" impl="CODSTA-125" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-125.rule"/>
         </rule>
         <rule header="不得在指向对象类型的指针和指向不同对象类型的指针之间执行强制转换" id="126" impl="CODSTA-126" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-126.rule"/>
         </rule>
         <rule header="不应在指向对象的指针和指向整数类型的指针之间转换" id="127" impl="CODSTA-127" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127.rule"/>
         </rule>
         <rule header="不应在指向对象类型的指针与除 'uintptr_t' 或 'intptr_t' 以外的整数类型之间执行转换" id="127_b" impl="CODSTA-127_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-127_b.rule"/>
         </rule>
         <rule header="不应该执行从指向 void 的指针到指向对象的指针的转换" id="128" impl="CODSTA-128" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-128.rule"/>
         </rule>
         <rule header="不能在指向 void 的指针和算术类型之间执行强制类型转换" id="129_a" impl="CODSTA-129_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_a.rule"/>
         </rule>
         <rule header="不应在指向 void 的指针和算术类型之间执行隐式转换" id="129_b" impl="CODSTA-129_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-129_b.rule"/>
         </rule>
         <rule header="&gt;, &gt;=, &lt;, &lt;= 不应用于指针类型，除非它们指向相同的数组" id="13" impl="CODSTA-13" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13.rule"/>
         </rule>
         <rule header="不应在指向对象的指针和非整数算术类型之间执行强制转换" id="130" impl="CODSTA-130" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-130.rule"/>
         </rule>
         <rule header="使用 NULL 而不是文本零 （0） 作为空指针常量" id="131" impl="CODSTA-131" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-131.rule"/>
         </rule>
         <rule header="不应该修改函数参数" id="132" impl="CODSTA-132" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-132.rule"/>
         </rule>
         <rule header="C90中规定宏不应该与关键字定义为相同名称" id="133_a" impl="CODSTA-133_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_a.rule"/>
         </rule>
         <rule header="C99中规定宏不应该与关键字定义为相同名称" id="133_b" impl="CODSTA-133_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-133_b.rule"/>
         </rule>
         <rule header="函数参数对应的数组类型参数应该包含合适数量的元素" id="134" impl="CODSTA-134" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-134.rule"/>
         </rule>
         <rule header="不得使用从任何类型到指针或者指针到任何类型的类型转换" id="135" impl="CODSTA-135" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-135.rule"/>
         </rule>
         <rule header="不应使用标识符 va_list, va_arg, va_start, va_end, va_copy" id="136_a" impl="CODSTA-136_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_a.rule"/>
         </rule>
         <rule header="不应使用标识符 va_list, va_arg, va_start, va_end" id="136_b" impl="CODSTA-136_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;stdarg.h&gt; 或 &lt;cstdarg&gt;" id="136_c" impl="CODSTA-136_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-136_c.rule"/>
         </rule>
         <rule header="函数调用不得是 sizeof 运算符的操作数" id="137" impl="CODSTA-137" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-137.rule"/>
         </rule>
         <rule header="不得使用一个内置赋值运算符的结果" id="138" impl="CODSTA-138" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-138.rule"/>
         </rule>
         <rule header="指针减法仅适用于同一数组元素的地址指针" id="13_b" impl="CODSTA-13_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-13_b.rule"/>
         </rule>
         <rule header="禁止将 const 转换成非 const" id="14" impl="CODSTA-14" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-14.rule"/>
         </rule>
         <rule header="初始化器列表不应该包含持久的副作用" id="141_a" impl="CODSTA-141_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-141_a.rule"/>
         </rule>
         <rule header="全局函数不能声明数组类型的参数" id="142" impl="CODSTA-142" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-142.rule"/>
         </rule>
         <rule header="使用数组参数调用的函数不应该声明具有指针参数" id="142_b" impl="CODSTA-142_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-142_b.rule"/>
         </rule>
         <rule header="未检查源缓冲区大小而使用 'strcpy' 是可疑的" id="143" impl="CODSTA-143" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-143.rule"/>
         </rule>
         <rule header="应当使用函数 'read' 和 'readlink' 返回的值" id="144" impl="CODSTA-144" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-144.rule"/>
         </rule>
         <rule header="在期望有空终止的字符串的函数中使用可能没有空终止的字符串" id="145" impl="CODSTA-145" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-145.rule"/>
         </rule>
         <rule header="从一个面向字符的标准输入输出 I/O 函数返回的一个值不应该隐式转换为一个小于的 'int' 类型" id="146" impl="CODSTA-146" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-146.rule"/>
         </rule>
         <rule header="不应该使用相关的操作符 &lt;, &gt;, &gt;=, &lt;= 比较指针和 NULL" id="147" impl="CODSTA-147" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-147.rule"/>
         </rule>
         <rule header="不要使用字符串字面量作为等号或关系运算符的操作数" id="148" impl="CODSTA-148" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-148.rule"/>
         </rule>
         <rule header="switch 语句中各 case 之间缺失 break 语句" id="149" impl="CODSTA-149" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-149.rule"/>
         </rule>
         <rule header="当数组作为参数传入一个函数时不要声明数组的大小" id="15" impl="CODSTA-15" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-15.rule"/>
         </rule>
         <rule header="断言不应该包含赋值，自增或自减运算符" id="150" impl="CODSTA-150" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150.rule"/>
         </rule>
         <rule header="断言不应该包含函数调用或者类似于函数的宏调用" id="150_b" impl="CODSTA-150_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-150_b.rule"/>
         </rule>
         <rule header="避免不安全宏参数造成的不良影响" id="150_c" impl="CODSTA-150_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-150_c.rule"/>
         </rule>
         <rule header="不要在布尔条件中使用枚举" id="151" impl="CODSTA-151" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-151.rule"/>
         </rule>
         <rule header="复合表达式的值不得传递给一个不同的基本类型类别或更广泛的基本类型" id="152" impl="CODSTA-152" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-152.rule"/>
         </rule>
         <rule header="在转换单元中外部对象或函数不得有多个non-defining声明" id="154" impl="CODSTA-154" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-154.rule"/>
         </rule>
         <rule header="应该使用C99中stdint.h的typedefs而不是个人自己的声明" id="155" impl="CODSTA-155" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-155.rule"/>
         </rule>
         <rule header="如果复合表达式用作执行通常算术转换的运算符的一个操作数，则另一个操作数不应具有更广泛的基本类型" id="156_a" impl="CODSTA-156_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_a.rule"/>
         </rule>
         <rule header="如果复合表达式用作执行通常算术转换的运算符的第一个(第二个或第三个)操作数，则另一个操作数不应具有更广泛的基本类型" id="156_b" impl="CODSTA-156_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-156_b.rule"/>
         </rule>
         <rule header="复合表达式的值不应该赋值给宽数据类型的一个对象" id="157" impl="CODSTA-157" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-157.rule"/>
         </rule>
         <rule header="函数类型应该包含具体名称的参数" id="158" impl="CODSTA-158" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-158.rule"/>
         </rule>
         <rule header="函数类型应当为原型形式" id="159" impl="CODSTA-159" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-159.rule"/>
         </rule>
         <rule header="当数组被初始化的时不要声明数组的大小" id="16" impl="CODSTA-16" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-16.rule"/>
         </rule>
         <rule header="数组参数的声明不得在 [ ] 之间包含 'static' 关键字" id="160" impl="CODSTA-160" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-160.rule"/>
         </rule>
         <rule header="当操作数被解释为布尔值时，应使用基本布尔类型的表达式" id="161_a" impl="CODSTA-161_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_a.rule"/>
         </rule>
         <rule header="当操作数被解释为数值时，不应使用本质上为布尔类型的操作数当操作数被解释为数值时，不应使用本质上为布尔类型的操作数" id="161_b" impl="CODSTA-161_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_b.rule"/>
         </rule>
         <rule header="字符类型的操作数不应该用在需要数类型的地方" id="161_c" impl="CODSTA-161_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_c.rule"/>
         </rule>
         <rule header="在算术运算中不应该使用枚举类型" id="161_d" impl="CODSTA-161_d" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_d.rule"/>
         </rule>
         <rule header="不要对有符号类型和枚举类型使用移位和位运算" id="161_e" impl="CODSTA-161_e" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_e.rule"/>
         </rule>
         <rule header="本质上带符号或枚举类型的操作数不应用作移位操作符的右侧操作数" id="161_f" impl="CODSTA-161_f" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_f.rule"/>
         </rule>
         <rule header="一元减运算符的操作数不应该是无符号类型" id="161_g" impl="CODSTA-161_g" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-161_g.rule"/>
         </rule>
         <rule header="基本字符类型表达式不能用于加减运算符" id="162" impl="CODSTA-162" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-162.rule"/>
         </rule>
         <rule header="表达式的值不能赋给更小基本类型的对象" id="163_a" impl="CODSTA-163_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_a.rule"/>
         </rule>
         <rule header="表达式的值不应分配给不同基本类型类别的对象" id="163_b" impl="CODSTA-163_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-163_b.rule"/>
         </rule>
         <rule header="执行常规算术转换的运算符的两个操作数应具有相同的基本类型类别" id="164_a" impl="CODSTA-164_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_a.rule"/>
         </rule>
         <rule header="第二个和第三个三元操作符的操作数有相同的基本类型类别" id="164_b" impl="CODSTA-164_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-164_b.rule"/>
         </rule>
         <rule header="不允许对枚举类型进行转换操作" id="165_a" impl="CODSTA-165_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_a.rule"/>
         </rule>
         <rule header="不要从基本布尔类型转换或转换为基本布尔类型" id="165_b" impl="CODSTA-165_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-165_b.rule"/>
         </rule>
         <rule header="不要在基本字符类型和基本浮点类型之间使用强制类型转换" id="165_c" impl="CODSTA-165_c" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-165_c.rule"/>
         </rule>
         <rule header="指向 FILE 对象的指针不应被解引用" id="166_a" impl="CODSTA-166_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_a.rule"/>
         </rule>
         <rule header="指向 FILE 对象的指针不应由库函数解引用" id="166_b" impl="CODSTA-166_b" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-166_b.rule"/>
         </rule>
         <rule header="for循环的循环计数器不能是浮点类型" id="167_a" impl="CODSTA-167_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_a.rule"/>
         </rule>
         <rule header="在'while' 和 'do-while' 中的循环计数器不要使用浮点类型" id="167_b" impl="CODSTA-167_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-167_b.rule"/>
         </rule>
         <rule header="'for' 循环中只能有一个循环计数器，而不能在 'for' 循环体中进行修改" id="168" impl="CODSTA-168" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-168.rule"/>
         </rule>
         <rule header="for循环的第一个判断条件应该是格式良好的" id="169_a" impl="CODSTA-169_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_a.rule"/>
         </rule>
         <rule header="'for' 循环的第二个子句应格式正确" id="169_b" impl="CODSTA-169_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_b.rule"/>
         </rule>
         <rule header="for 循环的第三部分应该是格式良好的" id="169_c" impl="CODSTA-169_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-169_c.rule"/>
         </rule>
         <rule header="不要使用 NULL 标识符; 而是使用 0 替代" id="17" impl="CODSTA-17" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-17.rule"/>
         </rule>
         <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="170_c90" impl="CODSTA-170_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c90.rule"/>
         </rule>
         <rule header="在预处理之前的宏命名应该与预处理之后的标识符区分开来" id="170_c99" impl="CODSTA-170_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-170_c99.rule"/>
         </rule>
         <rule header="宏命名应该与参数区分开来（c90)" id="171_c90" impl="CODSTA-171_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c90.rule"/>
         </rule>
         <rule header="宏命名需要与它的参数名区分开来（c99)" id="171_c99" impl="CODSTA-171_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-171_c99.rule"/>
         </rule>
         <rule header="宏的命名需要与当前定义的其他宏的命名区分开来（c90）" id="172_c90" impl="CODSTA-172_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c90.rule"/>
         </rule>
         <rule header="宏的名称应该有别于其他当前定义的宏的名称(c99)" id="172_c99" impl="CODSTA-172_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-172_c99.rule"/>
         </rule>
         <rule header="程序不应超过标准 (c90) 强加的转换限制" id="174_a_c90" impl="CODSTA-174_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c90.rule"/>
         </rule>
         <rule header="程序不应超过施加的标准编译限制 (c99)" id="174_a_c99" impl="CODSTA-174_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_a_c99.rule"/>
         </rule>
         <rule header="程序不应超过(c90)标准规定的编译限制" id="174_b_c90" impl="CODSTA-174_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c90.rule"/>
         </rule>
         <rule header="程序不应超过施加的标准编译限制 (c99)" id="174_b_c99" impl="CODSTA-174_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-174_b_c99.rule"/>
         </rule>
         <rule header="函数中不应该包含无用的类型声明" id="175_a" impl="CODSTA-175_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_a.rule"/>
         </rule>
         <rule header="源文件中不能包含未使用的类型声明" id="175_b" impl="CODSTA-175_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-175_b.rule"/>
         </rule>
         <rule header="函数不应该包含无用的局部标签声明" id="176_a" impl="CODSTA-176_a" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_a.rule"/>
         </rule>
         <rule header="源文件中不应该包含未使用的标签声明" id="176_b" impl="CODSTA-176_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-176_b.rule"/>
         </rule>
         <rule header="源文件不应包含未使用的宏定义" id="177" impl="CODSTA-177" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-177.rule"/>
         </rule>
         <rule header="外部标识符应不同" id="178" impl="CODSTA-178" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-178.rule"/>
         </rule>
         <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c90)" id="179_a_c90" impl="CODSTA-179_a_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c90.rule"/>
         </rule>
         <rule header="在文件范围和命名空间中声明的不同标识符应该区分开来 (c99)" id="179_a_c99" impl="CODSTA-179_a_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_a_c99.rule"/>
         </rule>
         <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c90)" id="179_b_c90" impl="CODSTA-179_b_c90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c90.rule"/>
         </rule>
         <rule header="在同样的块范围和命名空间中的标识符必须不相同 (c99)" id="179_b_c99" impl="CODSTA-179_b_c99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-179_b_c99.rule"/>
         </rule>
         <rule header="选择使用 while 而非 do 语句" id="18" impl="CODSTA-18" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-18.rule"/>
         </rule>
         <rule header="不要将+, -, += 和 -= 类型操作符应用于指针类型表达式" id="181" impl="CODSTA-181" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-181.rule"/>
         </rule>
         <rule header="运算符'sizeof'的操作数不能是声明为&quot;array of type&quot;的函数参数" id="182" impl="CODSTA-182" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-182.rule"/>
         </rule>
         <rule header="标准库函数 'memcmp', 'memmove' and 'memcmp' 的指针参数应该指向兼容的类型" id="183" impl="CODSTA-183" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-183.rule"/>
         </rule>
         <rule header="传入标准库函数 'memcmp' 的指针参数不能指向指针类型、无符号类型、有符号类型、布尔类型或枚举类型" id="184" impl="CODSTA-184" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-184.rule"/>
         </rule>
         <rule header="标准库函数 'localeconv', 'getenv', 'setlocale' 或 'strerror' 返回的指针仅当它们具有指向 const 限定类型的指针时使用" id="185_a" impl="CODSTA-185_a" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-185_a.rule"/>
         </rule>
         <rule header="由结构体 'lconv' 的成员指向的字符串不应该被修改" id="185_b" impl="CODSTA-185_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-185_b.rule"/>
         </rule>
         <rule header="指定的用来初始化数组对象的初始化器应明确指定数组对象的大小" id="186" impl="CODSTA-186" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-186.rule"/>
         </rule>
         <rule header="在赋值给较大的整型之前将字符强制转换为 unsigned char 类型" id="187_a" impl="CODSTA-187_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_a.rule"/>
         </rule>
         <rule header="'signed char' 类型的表达式不应该作为数组下标使用" id="187_b" impl="CODSTA-187_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_b.rule"/>
         </rule>
         <rule header="在转换为更大的整型之前将字符转换为无符号字符类型" id="187_c" impl="CODSTA-187_c" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-187_c.rule"/>
         </rule>
         <rule header="不要混淆窄字符串、宽字符串和函数" id="188" impl="CODSTA-188" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-188.rule"/>
         </rule>
         <rule header="不要拿整型和指针做加减运算" id="189" impl="CODSTA-189" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-189.rule"/>
         </rule>
         <rule header="除了在类似函数的宏中，不应使用'Do'语句" id="18_b" impl="CODSTA-18_b" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-18_b.rule"/>
         </rule>
         <rule header="使用 ctype.h 的函数对字符测试" id="19" impl="CODSTA-19" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-19.rule"/>
         </rule>
         <rule header="不要使用对象表示形式来比较浮点值" id="190" impl="CODSTA-190" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-190.rule"/>
         </rule>
         <rule header="封装可以在循环中伪唤醒的函数" id="191" impl="CODSTA-191" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-191.rule"/>
         </rule>
         <rule header="结构体的最终成员不应该是“0”或“1”的数组" id="192" impl="CODSTA-192" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-192.rule"/>
         </rule>
         <rule header="动态分配包含灵活数组成员的结构体" id="193" impl="CODSTA-193" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-193.rule"/>
         </rule>
         <rule header="循环中使用包装函数可能失败" id="194" impl="CODSTA-194" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-194.rule"/>
         </rule>
         <rule header="不要在表达式中两次引用原子变量" id="195" impl="CODSTA-195" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-195.rule"/>
         </rule>
         <rule header="不要修改具有临时生命周期的对象" id="196" impl="CODSTA-196" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-196.rule"/>
         </rule>
         <rule header="不要指定用字符串文本初始化的字符数组的大小" id="197" impl="CODSTA-197" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-197.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为更广泛的浮点型" id="198" impl="CODSTA-198" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198.rule"/>
         </rule>
         <rule header="浮点型复杂表达式的值不应转换为整数类型" id="198_b" impl="CODSTA-198_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-198_b.rule"/>
         </rule>
         <rule header="不要使用断言" id="199" impl="CODSTA-199" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-199.rule"/>
         </rule>
         <rule header="应该使用 EOS 作为字符串的结尾而不是使用 NULL" id="20" impl="CODSTA-20" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-20.rule"/>
         </rule>
         <rule header="使用初始化器显式指定数组声明中的数组大小" id="200" impl="CODSTA-200" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-200.rule"/>
         </rule>
         <rule header="不以本机方式处理结构化文本数据" id="201" impl="CODSTA-201" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-201.rule"/>
         </rule>
         <rule header="带有外部链接的函数的内联定义不应包含静态对象的定义和使用" id="202" impl="CODSTA-202" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-202.rule"/>
         </rule>
         <rule header="不要硬编码字符串字面量" id="203" impl="CODSTA-203" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-203.rule"/>
         </rule>
         <rule header="声明为 'noreturn' 的函数应该具有 'void' 返回类型" id="204" impl="CODSTA-204" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-204.rule"/>
         </rule>
         <rule header="不要将数组转换为指向比数组大的结构的指针" id="205" impl="CODSTA-205" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-205.rule"/>
         </rule>
         <rule header="不应使用 '_Noreturn' 函数说明符" id="206" impl="CODSTA-206" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-206.rule"/>
         </rule>
         <rule header="不应该使用 &lt;stdnoreturn.h&gt; 头文件" id="207" impl="CODSTA-207" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-207.rule"/>
         </rule>
         <rule header="不应使用 &lt;stdalign.h&gt; 头文件" id="208" impl="CODSTA-208" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-208.rule"/>
         </rule>
         <rule header="不应使用指定为由 &lt;stdatomic.h&gt; 提供的功能" id="209" impl="CODSTA-209" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-209.rule"/>
         </rule>
         <rule header="不要使用宏 ATOMIC_VAR_INIT" id="209_b" impl="CODSTA-209_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-209_b.rule"/>
         </rule>
         <rule header="当使用枚举类型 enum 时，必须显式声明每个成员的值" id="21" impl="CODSTA-21" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-21.rule"/>
         </rule>
         <rule header="不应使用 '_Thread_local' 存储类说明符" id="210" impl="CODSTA-210" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-210.rule"/>
         </rule>
         <rule header="不应该使用被指定为由 &lt;threads.h&gt; 头文件提供的功能" id="211" impl="CODSTA-211" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-211.rule"/>
         </rule>
         <rule header="不应使用 “rsize_t” 类型" id="212" impl="CODSTA-212" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-212.rule"/>
         </rule>
         <rule header="不应使用 '_Alignas' 对齐说明符和 '_Alignof' 运算符" id="213" impl="CODSTA-213" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-213.rule"/>
         </rule>
         <rule header="不应该使用 '_Atomic' 类型说明符和 '_Atomic' 类型限定符" id="214" impl="CODSTA-214" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-214.rule"/>
         </rule>
         <rule header="宏 '__STDC_WANT_LIB_EXT1__' 不应定义为 '0' 以外的值" id="215" impl="CODSTA-215" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-215.rule"/>
         </rule>
         <rule header="不应使用 '_Generic' 运算符" id="216" impl="CODSTA-216" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-216.rule"/>
         </rule>
         <rule header="不应该使用 'errno_t' 类型" id="217" impl="CODSTA-217" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-217.rule"/>
         </rule>
         <rule header="不要使用以下宏：RSIZE_MAX，L_tmpnam_s，TMP_MAX_S" id="218" impl="CODSTA-218" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-218.rule"/>
         </rule>
         <rule header="不使用 ISO/IEC 9899:2011 标准的附件 K 中定义的函数" id="219" impl="CODSTA-219" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-219.rule"/>
         </rule>
         <rule header="局部变量或参数名称跟类成员变量或父类/结构体成员变量的名称至少应该2个或以上字符不同" id="22" impl="CODSTA-22" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-22.rule"/>
         </rule>
         <rule header="整数常量宏的参数应为具有适当值的十进制，八进制或十六进制常量" id="220" impl="CODSTA-220" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-220.rule"/>
         </rule>
         <rule header="不应使用最小宽度的整数常数宏的小整数变体" id="220_b" impl="CODSTA-220_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-220_b.rule"/>
         </rule>
         <rule header="函数类型的规范中不要包含任何类型限定符" id="221" impl="CODSTA-221" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-221.rule"/>
         </rule>
         <rule header="避免隐式整体从大范围的类型转换到小范围的类型转换" id="222" impl="CODSTA-222" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-222.rule"/>
         </rule>
         <rule header="&lt;cstdint&gt; 中的固定宽度整数类型，指示大小和符号，应用于代替基本数字类型" id="223" impl="CODSTA-223" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-223.rule"/>
         </rule>
         <rule header="应使用 typedef 替代普通 char 类型" id="223_b" impl="CODSTA-223_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-223_b.rule"/>
         </rule>
         <rule header="条件运算符不应用作子表达式" id="224" impl="CODSTA-224" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-224.rule"/>
         </rule>
         <rule header="不得显示（语法上）测试浮点表达式的等号（==）或不等号（！=）" id="225" impl="CODSTA-225" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-225.rule"/>
         </rule>
         <rule header="应使用可能返回错误的标准库函数所返回的值" id="226_a" impl="CODSTA-226_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-226_a.rule"/>
         </rule>
         <rule header="不需要检查返回值的标准库函数应该被转换为 'void'" id="226_b" impl="CODSTA-226_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-226_b.rule"/>
         </rule>
         <rule header="应该使用可能返回错误的POSIX库函数所返回的值" id="227" impl="CODSTA-227" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-227.rule"/>
         </rule>
         <rule header="不要用含有赋值、增量或减量运算符的流参数调用 'getc()', 'putc()', 'getwc()', 或 'putwc()'" id="228_a" impl="CODSTA-228_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-228_a.rule"/>
         </rule>
         <rule header="不要使用包含函数调用或类似函数的宏调用的流参数调用 'getc()'、 'putc()'、 'getwc()' 或 'putwc()'" id="228_b" impl="CODSTA-228_b" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-228_b.rule"/>
         </rule>
         <rule header="余数运算符 '%' 的操作数应为无符号的整数类型" id="229" impl="CODSTA-229" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-229.rule"/>
         </rule>
         <rule header="所有的 'if' 语句必须有对应的 'else' 分支语句" id="23" impl="CODSTA-23" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-23.rule"/>
         </rule>
         <rule header="不要将指针转换为更严格对齐的指针类型" id="230" impl="CODSTA-230" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-230.rule"/>
         </rule>
         <rule header="不要将具有线程存储期的对象的地址分配给具有静态存储期的对象" id="231" impl="CODSTA-231" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-231.rule"/>
         </rule>
         <rule header="在表达式中，增量（++）和减量（--）运算符不应该与算术运算符混合使用" id="232" impl="CODSTA-232" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-232.rule"/>
         </rule>
         <rule header="宏 FALSE 应该被定义为 0(零)" id="24" impl="CODSTA-24" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-24.rule"/>
         </rule>
         <rule header="命名为 'FALSE' 的枚举常量应该显式地被初始化为 0 值" id="25" impl="CODSTA-25" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-25.rule"/>
         </rule>
         <rule header="避免使用魔数" id="26" impl="CODSTA-26" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-26.rule"/>
         </rule>
         <rule header="避免在函数内修改全局变量" id="27" impl="CODSTA-27" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-27.rule"/>
         </rule>
         <rule header="必须为联合体的声明定义字段" id="28" impl="CODSTA-28" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-28.rule"/>
         </rule>
         <rule header="使用有意义的符号常量来表示字面值" id="29" impl="CODSTA-29" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-29.rule"/>
         </rule>
         <rule header="避免返回句柄给函数的参数" id="30" impl="CODSTA-30" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-30.rule"/>
         </rule>
         <rule header="避免使用显式类型转换(强制类型转换)" id="31" impl="CODSTA-31" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-31.rule"/>
         </rule>
         <rule header="如果 test 是指针时，则不能使用类似于 if(test) 或 if(!test) 的逻辑表达式" id="32" impl="CODSTA-32" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-32.rule"/>
         </rule>
         <rule header="在 if, while 或 switch 语句的条件表达式中不要使用 ++ 或 -- 操作符" id="33" impl="CODSTA-33" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-33.rule"/>
         </rule>
         <rule header="当声明函数指针时使用 typedef 来简化程序语法" id="34" impl="CODSTA-34" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-34.rule"/>
         </rule>
         <rule header="始终为 switch 语句提供一个 default 分支" id="35" impl="CODSTA-35" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-35.rule"/>
         </rule>
         <rule header="通过值传递内置类型，除非你想要修改这些参数" id="36" impl="CODSTA-36" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-36.rule"/>
         </rule>
         <rule header="选择 const 对象或枚举类型来 #defines 定义简单常量" id="37" impl="CODSTA-37" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-37.rule"/>
         </rule>
         <rule header="不要使用防止编译器检查类型的 #define 指令" id="38" impl="CODSTA-38" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-38.rule"/>
         </rule>
         <rule header="避免内部或外部变量名称与 C++ 保留字冲突" id="39" impl="CODSTA-39" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-39.rule"/>
         </rule>
         <rule header="当一个函数没有传递参数值或者没有返回值时应使用 'void'" id="40" impl="CODSTA-40" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-40.rule"/>
         </rule>
         <rule header="避免只有一个 case 分支的 swtich 语句" id="41" impl="CODSTA-41" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-41.rule"/>
         </rule>
         <rule header="宏 TRUE 应该被定义为 1" id="42" impl="CODSTA-42" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-42.rule"/>
         </rule>
         <rule header="命名为 'TRUE' 的枚举常量应该显式地被初始化为 1" id="43" impl="CODSTA-43" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-43.rule"/>
         </rule>
         <rule header="局部变量不应使用与成员变量相同的名称" id="44" impl="CODSTA-44" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-44.rule"/>
         </rule>
         <rule header="参数不应使用与成员变量相同的名称" id="45" impl="CODSTA-45" quickfix="false" scope="line" severity="1">
            <file path="CODSTA\CODSTA-45.rule"/>
         </rule>
         <rule header="实际中尽量使用正逻辑而不是负逻辑" id="46" impl="CODSTA-46" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-46.rule"/>
         </rule>
         <rule header="所有的结构体都应该有 typedefs 类型定义" id="47" impl="CODSTA-47" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-47.rule"/>
         </rule>
         <rule header="请勿使用以下双字符组：&lt;%, %&gt;, &lt;:, :&gt;, %:, %:%:" id="48" impl="CODSTA-48" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-48.rule"/>
         </rule>
         <rule header="如果 'for' 语句中无初始化或者无增量表达式; 应该使用 while 循环替代" id="49" impl="CODSTA-49" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-49.rule"/>
         </rule>
         <rule header="十六进制常量应该全部使用大写字母表示" id="50" impl="CODSTA-50" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-50.rule"/>
         </rule>
         <rule header="字母后缀应使用大写字母而不是小写字母" id="51" impl="CODSTA-51" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-51.rule"/>
         </rule>
         <rule header="除了初始化单个for循环参数的值外，for循环中的初始化表达式将不执行任何操作" id="52" impl="CODSTA-52" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-52.rule"/>
         </rule>
         <rule header="在 for 循环中的增量表达式除了改变单个循环参数到下一个值外，不应该执行其他任何操作" id="53" impl="CODSTA-53" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-53.rule"/>
         </rule>
         <rule header="每个 switch 语句至少有两个 case 分支和一个潜在的 default 分支" id="54" impl="CODSTA-54" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-54.rule"/>
         </rule>
         <rule header="Case 语句的标签应该使用枚举(enum)类型而不是使用整数类型(和常量)" id="55" impl="CODSTA-55" quickfix="false" scope="line" severity="2">
            <file path="CODSTA\CODSTA-55.rule"/>
         </rule>
         <rule header="'switch' 语句的所有 'case' 和 'default' 标签应该有一个显式的 'break' 或 'return' 语句， 或者 'fall through' 注释" id="56" impl="CODSTA-56" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-56.rule"/>
         </rule>
         <rule header="分号的可疑使用" id="57" impl="CODSTA-57" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-57.rule"/>
         </rule>
         <rule header="不允许类型强制转换为 void" id="58" impl="CODSTA-58" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-58.rule"/>
         </rule>
         <rule header="在声明数组大小和 'malloc' 的内存大小时不应该使用硬编码" id="59" impl="CODSTA-59" quickfix="false" scope="line" severity="4">
            <file path="CODSTA\CODSTA-59.rule"/>
         </rule>
         <rule header="避免使用相等运算符 (&quot;==&quot;, &quot;!=&quot;) 来对 TRUE 宏/枚举(enum)常量进行值比较" id="60" impl="CODSTA-60" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-60.rule"/>
         </rule>
         <rule header="除非所有枚举值都经过测试，否则 switch 语句的最后一个子句应为 default-clause" id="61" impl="CODSTA-61" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-61.rule"/>
         </rule>
         <rule header="强制类型转换不应将指向函数的指针转换为任何其他指针类型，包括指向函数类型的指针" id="62" impl="CODSTA-62" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-62.rule"/>
         </rule>
         <rule header="位运算符应只适用于无符号的基本类型操作数" id="63" impl="CODSTA-63" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-63.rule"/>
         </rule>
         <rule header="非条件 throw 或 break 语句应终止每个非空的 switch 语句" id="64" impl="CODSTA-64" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-64.rule"/>
         </rule>
         <rule header="具有整数类型的对象或指向 void 类型的指针不应转换为具有指针类型的对象" id="65" impl="CODSTA-65" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-65.rule"/>
         </rule>
         <rule header="二进制位运算符的非常量的操作数应该具有相同的基本类型" id="66" impl="CODSTA-66" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-66.rule"/>
         </rule>
         <rule header="用于对象，函数返回类型，或函数参数的类型在所有声明和重新声明中应该对应完全相同" id="67" impl="CODSTA-67" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-67.rule"/>
         </rule>
         <rule header="后缀 &quot;U&quot; 应该适用于所有无符号类型的八进制或十六进制整型字面量" id="68" impl="CODSTA-68" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-68.rule"/>
         </rule>
         <rule header="带有类型(普通) char 和 wchar_t 的表达式不能作为内建运算符的操作数，除了 =, ==, != 和一元 &amp; 运算符" id="69" impl="CODSTA-69" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-69.rule"/>
         </rule>
         <rule header="具有枚举类型的表达式不得用作除了 [ ],  =, ==, !=, &lt;, &lt;=, &gt;, &gt;=, 和一元 &amp; 运算符以外的内建运算符的操作数" id="70" impl="CODSTA-70" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-70.rule"/>
         </rule>
         <rule header="具有带符号的整数类型且已命名的位域应该有超过一位的长度" id="71" impl="CODSTA-71" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-71.rule"/>
         </rule>
         <rule header="汇编指令应该只能使用 asm 声明来引入" id="73" impl="CODSTA-73" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-73.rule"/>
         </rule>
         <rule header="位域不得有枚举(enum)类型" id="74" impl="CODSTA-74" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-74.rule"/>
         </rule>
         <rule header="位域应该要么是 bool 类型要么是显式无符号(unsigned)或有符号(signed)的整数类型" id="75" impl="CODSTA-75" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-75.rule"/>
         </rule>
         <rule header="标识符 main 不得用于除了全局的 main 函数以外的其它函数" id="76" impl="CODSTA-76" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-76.rule"/>
         </rule>
         <rule header="goto 语句应该跳转到同一个函数体中位于 goto 语句后面声明的标签" id="77" impl="CODSTA-77" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-77.rule"/>
         </rule>
         <rule header="任何由 goto 语句引用的标签应该声明在同一个模块中，或者在一个包含 goto 语句的模块中" id="78" impl="CODSTA-78" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-78.rule"/>
         </rule>
         <rule header="对任何循环语句，都应存在不止一个用于循环终止的 break 或 goto 语句" id="79" impl="CODSTA-79" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-79.rule"/>
         </rule>
         <rule header="continue 语句只应该被用于具有良好格式的 for 循环中" id="80" impl="CODSTA-80" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-80.rule"/>
         </rule>
         <rule header="如果一个函数有内部链接，那么所有的重新声明都应该包括'static'存储类说明符" id="81" impl="CODSTA-81" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-81.rule"/>
         </rule>
         <rule header="避免无限循环" id="82" impl="CODSTA-82" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82.rule"/>
         </rule>
         <rule header="不要使用空的无限循环" id="82_b" impl="CODSTA-82_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-82_b.rule"/>
         </rule>
         <rule header="所有的循环必须有一个固定的上限或下限" id="83" impl="CODSTA-83" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-83.rule"/>
         </rule>
         <rule header="避免在无限循环中有退出点" id="85" impl="CODSTA-85" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-85.rule"/>
         </rule>
         <rule header="必须在每个函数内部检查参数的有效性" id="86" impl="CODSTA-86" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-86.rule"/>
         </rule>
         <rule header="使用不超过一级的指针引用" id="87" impl="CODSTA-87" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-87.rule"/>
         </rule>
         <rule header="函数指针是不允许的" id="88" impl="CODSTA-88" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-88.rule"/>
         </rule>
         <rule header="声明不得包含超过一级的间接指针" id="89" impl="CODSTA-89" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-89.rule"/>
         </rule>
         <rule header="逻辑 '&amp;&amp;' 或 '||' 的每个操作数应该为后缀表达式" id="90" impl="CODSTA-90" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-90.rule"/>
         </rule>
         <rule header="函数应该最多只有一个退出(exit)点" id="91" impl="CODSTA-91" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-91.rule"/>
         </rule>
         <rule header="不得重复使用标准库宏和对象的名称" id="92" impl="CODSTA-92" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92.rule"/>
         </rule>
         <rule header="不应定义、重新定义、未定义标准程序库中的保留标识符、宏以及函数（C90代码）" id="92_a" impl="CODSTA-92_a" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_a.rule"/>
         </rule>
         <rule header="不应定义、重新定义、未定义标准库中的保留标识符、宏和函数(C99 code)" id="92_b" impl="CODSTA-92_b" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-92_b.rule"/>
         </rule>
         <rule header="标准库函数的名称不应被重写" id="93" impl="CODSTA-93" quickfix="false" scope="line" severity="5">
            <file path="CODSTA\CODSTA-93.rule"/>
         </rule>
         <rule header="不应该声明指针或数组类型" id="94" impl="CODSTA-94" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-94.rule"/>
         </rule>
         <rule header="不应该声明指针类型" id="95" impl="CODSTA-95" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-95.rule"/>
         </rule>
         <rule header="位域只应该有显式的无符号整数或者枚举类型" id="96" impl="CODSTA-96" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-96.rule"/>
         </rule>
         <rule header="如果操作符的优先级低于算术运算符，应该使用圆括号明确表达式的操作顺序" id="97" impl="CODSTA-97" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-97.rule"/>
         </rule>
         <rule header="所有的 'if...else if' 结构应该包含一个最后的 'else' 分支或明确的注释表示为什么不需要最后的 'else' 分支。" id="98" impl="CODSTA-98" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-98.rule"/>
         </rule>
         <rule header="在比较运算中不允许混合使用有符号值和无符号值" id="99" impl="CODSTA-99" quickfix="false" scope="line" severity="3">
            <file path="CODSTA\CODSTA-99.rule"/>
         </rule>
         <category description="C++ 编码规范" name="CPP">
            <rule header="最好使用头文件 iostream.h 而非 stdio.h" id="01" impl="CODSTA-CPP-01" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-01.rule"/>
            </rule>
            <rule header="赋值操作符返回一个 *this 指向的引用；使赋值操作符的返回类型是指向自身 类类型的非常量引用" id="02" impl="CODSTA-CPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-02.rule"/>
            </rule>
            <rule header="位操作符，比较操作符，逻辑操作符，逗号操作符应该为 const" id="03" impl="CODSTA-CPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-03.rule"/>
            </rule>
            <rule header="允许转换的构造函数应该是使用 explicit 修饰" id="04" impl="CODSTA-CPP-04" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-04.rule"/>
            </rule>
            <rule header="不要使用用户自定义的转换函数" id="05" impl="CODSTA-CPP-05" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-05.rule"/>
            </rule>
            <rule header="避免从成员函数返回指向类数据的非 const 句柄(指针或引用)" id="06" impl="CODSTA-CPP-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-06.rule"/>
            </rule>
            <rule header="后缀增量和减量应该依据其前缀的实际情况实现" id="07" impl="CODSTA-CPP-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-07.rule"/>
            </rule>
            <rule header="避免重载逻辑操作符AND, OR (&amp;&amp;, ||)" id="08" impl="CODSTA-CPP-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-08.rule"/>
            </rule>
            <rule header="避免使用强制类型转换符 reinterpret_cast" id="09" impl="CODSTA-CPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-09.rule"/>
            </rule>
            <rule header="不要定义包含成员函数的结构体" id="10" impl="CODSTA-CPP-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-10.rule"/>
            </rule>
            <rule header="不要将可能包含填充位的类的对象与 C 标准库函数进行比较" id="100" impl="CODSTA-CPP-100" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-100.rule"/>
            </rule>
            <rule header="关系运算符应返回布尔值" id="101" impl="CODSTA-CPP-101" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-101.rule"/>
            </rule>
            <rule header="二进制算术运算符和位运算符应返回一个 'prvalue'" id="102" impl="CODSTA-CPP-102" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-102.rule"/>
            </rule>
            <rule header="不得使用输出参数" id="103" impl="CODSTA-CPP-103" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-103.rule"/>
            </rule>
            <rule header="typeid 操作符的操作数不能包含任何有副作用的表达式" id="104" impl="CODSTA-CPP-104" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104.rule"/>
            </rule>
            <rule header="'typeid' 操作符的操作数不应包含导致副作用的函数调用" id="104_b" impl="CODSTA-CPP-104_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-104_b.rule"/>
            </rule>
            <rule header="当操作等同于编译器操作时，将特殊变量定义为 default" id="105" impl="CODSTA-CPP-105" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-105.rule"/>
            </rule>
            <rule header="使用委托构造函数来减少代码重复" id="106" impl="CODSTA-CPP-106" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-106.rule"/>
            </rule>
            <rule header="比较运算符应为非成员函数" id="107" impl="CODSTA-CPP-107" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-107.rule"/>
            </rule>
            <rule header="比较运算符应为具有相同参数类型和 noexcept 的非成员函数" id="107_b" impl="CODSTA-CPP-107_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-107_b.rule"/>
            </rule>
            <rule header="使用 const 引用 'cheap to copy' 类型的参数应按值传递" id="108" impl="CODSTA-CPP-108" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-108.rule"/>
            </rule>
            <rule header="通过值传递具有平凡复制构造函数的小对象" id="108_b" impl="CODSTA-CPP-108_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-108_b.rule"/>
            </rule>
            <rule header="非 'cheap to copy' 类型的参数应该通过引用来传递" id="109" impl="CODSTA-CPP-109" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-109.rule"/>
            </rule>
            <rule header="不应使用 C 风格强制转换" id="11" impl="CODSTA-CPP-11" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-11.rule"/>
            </rule>
            <rule header="基类和成员变量的类应放在不同的头文件当中" id="12" impl="CODSTA-CPP-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-12.rule"/>
            </rule>
            <rule header="作为函数返回类型的类应该放在单独的头文件中" id="13" impl="CODSTA-CPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-13.rule"/>
            </rule>
            <rule header="在函数原形中作为入口参数类型的类应该放在单独的头文件中" id="14" impl="CODSTA-CPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-14.rule"/>
            </rule>
            <rule header="使用在内联成员函数内部的函数应该放在单独的头文件中" id="15" impl="CODSTA-CPP-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-15.rule"/>
            </rule>
            <rule header="当两个操作符是对立的(例如==和!=)时，可以同时定义它们" id="16" impl="CODSTA-CPP-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-16.rule"/>
            </rule>
            <rule header="不要使用 'struct' 关键字来声明 C++ 的变量" id="17" impl="CODSTA-CPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-17.rule"/>
            </rule>
            <rule header="将全局变量，常量，枚举类型和自定义类型变量(typedefs)封装在一个类中" id="18" impl="CODSTA-CPP-18" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-18.rule"/>
            </rule>
            <rule header="至少声明一个构造函数以防止编译器提供一个公共的构造函数" id="19" impl="CODSTA-CPP-19" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-19.rule"/>
            </rule>
            <rule header="如果想支持混合模式的操作, 操作符应该是非成员函数" id="20" impl="CODSTA-CPP-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-20.rule"/>
            </rule>
            <rule header="赋值操作符必须返回常引用" id="21" impl="CODSTA-CPP-21" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-21.rule"/>
            </rule>
            <rule header="最好使用非成员非友元函数(non-member non-friend)替代成员函数" id="22" impl="CODSTA-CPP-22" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-22.rule"/>
            </rule>
            <rule header="每当一个全局函数被引用时，使用::作用域运算符" id="23" impl="CODSTA-CPP-23" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-23.rule"/>
            </rule>
            <rule header="避免使用任何虚的赋值操作符。赋值操作符不能返回常量 T&amp;" id="24" impl="CODSTA-CPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-24.rule"/>
            </rule>
            <rule header="非公共成员应为虚函数，公共函数应为非虚函数" id="25" impl="CODSTA-CPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-25.rule"/>
            </rule>
            <rule header="保持类型和函数在单独的命名空间中，除非它们确实需要一起运行" id="26" impl="CODSTA-CPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-26.rule"/>
            </rule>
            <rule header="保持一个类型和它的非成员函数接口在同一个命名空间" id="27" impl="CODSTA-CPP-27" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-27.rule"/>
            </rule>
            <rule header="如果定义了二进制运算操作符 ( + , - , * , / , ^ , % , | , &amp; )，应同时定义其对应的赋值操作符" id="28" impl="CODSTA-CPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-28.rule"/>
            </rule>
            <rule header="算术和赋值操作符应该有规范的形式" id="29" impl="CODSTA-CPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-29.rule"/>
            </rule>
            <rule header="非成员操作符比成员操作符更支持混合形式的算术运算" id="30" impl="CODSTA-CPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-30.rule"/>
            </rule>
            <rule header="不要在构造函数上使用关键字 'explicit'" id="31" impl="CODSTA-CPP-31" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-31.rule"/>
            </rule>
            <rule header="除非打算内联函数，否则函数定义不应放在类规范中" id="32" impl="CODSTA-CPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-32.rule"/>
            </rule>
            <rule header="不应在模板类定义中定义成员函数" id="33" impl="CODSTA-CPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-33.rule"/>
            </rule>
            <rule header="避免在指针上使用 static_cast" id="34" impl="CODSTA-CPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-34.rule"/>
            </rule>
            <rule header="避免使用dynamic_casts" id="35" impl="CODSTA-CPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-35.rule"/>
            </rule>
            <rule header="全局命名空间应该只包含 main() 和命名空间声明" id="36" impl="CODSTA-CPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-36.rule"/>
            </rule>
            <rule header="在函数的执行体中不应定义类，结构体，联合体(class/struct/union)" id="37" impl="CODSTA-CPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-37.rule"/>
            </rule>
            <rule header="转换操作符, operator-&gt;, operator(), operator[] 应该为常量类型" id="38" impl="CODSTA-CPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-38.rule"/>
            </rule>
            <rule header="不要在头文件中或 #include 之前写 namespace usings" id="39" impl="CODSTA-CPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-39.rule"/>
            </rule>
            <rule header="限制一个类的对象个数" id="40" impl="CODSTA-CPP-40" quickfix="false" scope="line" severity="5">
               <file path="CODSTA-CPP\CODSTA-CPP-40.rule"/>
            </rule>
            <rule header="不要使用 'enum' 关键字在 C++ 中声明变量" id="41" impl="CODSTA-CPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-41.rule"/>
            </rule>
            <rule header="不使用 'mutable' 关键字声明成员变量" id="42" impl="CODSTA-CPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-42.rule"/>
            </rule>
            <rule header="尽可能将引用参数声明为 const 引用" id="43" impl="CODSTA-CPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-43.rule"/>
            </rule>
            <rule header="应使非 const 成员函数调用 const 成员函数，而非复制 const 的定义" id="44" impl="CODSTA-CPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-44.rule"/>
            </rule>
            <rule header="一个类的私有成员部分应该声明成以下顺序:构造函数、析构函数、成员函数、成员操作符函数、枚举以及其他" id="45" impl="CODSTA-CPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-45.rule"/>
            </rule>
            <rule header="在一个类中作用范围的顺序为: public 位置应在最前面" id="46" impl="CODSTA-CPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-46.rule"/>
            </rule>
            <rule header="在一个类中作用范围的顺序: protected 位于 private 之前" id="47" impl="CODSTA-CPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-47.rule"/>
            </rule>
            <rule header="在类的protected域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他" id="48" impl="CODSTA-CPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-48.rule"/>
            </rule>
            <rule header="在类的 public 域中，各项应该以如下顺序声明: 构造函数, 析构函数, 成员函数, 成员操作符函数, 枚举类型和其他" id="49" impl="CODSTA-CPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-49.rule"/>
            </rule>
            <rule header="不要使用 static 关键字，除非在函数或者类中" id="50" impl="CODSTA-CPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-50.rule"/>
            </rule>
            <rule header="在源文件中不要定义内联函数" id="51" impl="CODSTA-CPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-51.rule"/>
            </rule>
            <rule header="构造函数使用赋值型的操作符和独立型的操作符的自然的关系" id="52" impl="CODSTA-CPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-52.rule"/>
            </rule>
            <rule header="尽可能将局部变量声明为 const" id="53" impl="CODSTA-CPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53.rule"/>
            </rule>
            <rule header="尽可能将参数声明为 const" id="53_b" impl="CODSTA-CPP-53_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-53_b.rule"/>
            </rule>
            <rule header="成员函数应尽可能声明为常量" id="54" impl="CODSTA-CPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-54.rule"/>
            </rule>
            <rule header="在接口中不应该使用数组类型参数" id="55" impl="CODSTA-CPP-55" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55.rule"/>
            </rule>
            <rule header="私有方法和被保护的方法不应该用数组类型声明参数" id="55_b" impl="CODSTA-CPP-55_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-55_b.rule"/>
            </rule>
            <rule header="类，结构体或枚举不应该在其类型定义中被声明" id="56" impl="CODSTA-CPP-56" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-56.rule"/>
            </rule>
            <rule header="命名空间的嵌套不能超过两层" id="57" impl="CODSTA-CPP-57" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-57.rule"/>
            </rule>
            <rule header="从不是重载运算符函数得到的非 void 类型的返回值应该始终被使用" id="58" impl="CODSTA-CPP-58" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-58.rule"/>
            </rule>
            <rule header="不能使用C语言库" id="59" impl="CODSTA-CPP-59" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-59.rule"/>
            </rule>
            <rule header="仅应使用 ISO/IEC 14882:2003 中定义的转义序列" id="60" impl="CODSTA-CPP-60" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60.rule"/>
            </rule>
            <rule header="仅应使用 ISO/IEC 14882:2014 中定义的转义序列" id="60_b" impl="CODSTA-CPP-60_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-60_b.rule"/>
            </rule>
            <rule header="NULL 不得用作一个整数值" id="62" impl="CODSTA-CPP-62" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-62.rule"/>
            </rule>
            <rule header="字面量 （0） 不应用作空指针常数" id="63" impl="CODSTA-CPP-63" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-63.rule"/>
            </rule>
            <rule header="if 语句的条件和循环语句的条件应该是布尔类型" id="64" impl="CODSTA-CPP-64" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-64.rule"/>
            </rule>
            <rule header="条件运算符的第一个操作数应该具有布尔类型" id="65" impl="CODSTA-CPP-65" quickfix="false" scope="line" severity="1">
               <file path="CODSTA-CPP\CODSTA-CPP-65.rule"/>
            </rule>
            <rule header="不得使用 C 语言风格的强制类型转换(除 void 强制类型转换外)和函数符号式强制类型转换(除了显式的构造函数调用外)" id="66" impl="CODSTA-CPP-66" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-66.rule"/>
            </rule>
            <rule header="! 运算符，逻辑 &amp;&amp; 或逻辑 || 运算符的每个操作数应该都是布尔类型" id="67" impl="CODSTA-CPP-67" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-67.rule"/>
            </rule>
            <rule header="一元 &amp; 运算符不得被重载" id="68" impl="CODSTA-CPP-68" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-68.rule"/>
            </rule>
            <rule header="for 循环应该包含一个没有浮动类型的单一的循环计数器" id="69" impl="CODSTA-CPP-69" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-69.rule"/>
            </rule>
            <rule header="如果循环计数器不是被 -- 或 ++ 修改，那么在条件中此循环计数器应该只能被用作 &lt;=, &lt;, &gt; 或 &gt;= 的操作数" id="70" impl="CODSTA-CPP-70" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-70.rule"/>
            </rule>
            <rule header="循环计数器应该被 --, ++, -=n, 或 +=n 之一修改；这里的 n 在整个循环期间保持不变" id="71" impl="CODSTA-CPP-71" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-71.rule"/>
            </rule>
            <rule header="循环计数器以外的循环控制变量不得在判定条件或运算表达式中被修改" id="72" impl="CODSTA-CPP-72" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-72.rule"/>
            </rule>
            <rule header="在循环体语句中被修改的循环计数器以外的循环控制变量应该是布尔类型的" id="73" impl="CODSTA-CPP-73" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-73.rule"/>
            </rule>
            <rule header="头文件中不应有未命名的命名空间" id="74" impl="CODSTA-CPP-74" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-74.rule"/>
            </rule>
            <rule header="不得使用 using 指示符" id="75" impl="CODSTA-CPP-75" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-75.rule"/>
            </rule>
            <rule header="在同一个命名空间中标识符的多重声明不得跨越该标识符的 using 声明" id="76" impl="CODSTA-CPP-76" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-76.rule"/>
            </rule>
            <rule header="Const 成员函数不得返回指向类数据的非 const 指针或引用" id="77" impl="CODSTA-CPP-77" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-77.rule"/>
            </rule>
            <rule header="如果一个成员函数可以是 static，那么就应该定义为 static，否则，如果它可以是 const，那么它就应该被定义为 const" id="78" impl="CODSTA-CPP-78" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-78.rule"/>
            </rule>
            <rule header="判等运算符 (== 或 !=)的任何一个操作数都不应该是一个指向虚成员函数的指针" id="79" impl="CODSTA-CPP-79" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-79.rule"/>
            </rule>
            <rule header="避免重载逗号运算符 &quot;,&quot;" id="80" impl="CODSTA-CPP-80" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-80.rule"/>
            </rule>
            <rule header="不允许仅存在 getters/setters(accessors/mutators) 的类" id="81" impl="CODSTA-CPP-81" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-81.rule"/>
            </rule>
            <rule header="避免未封装的全局变量 (包括在命名空间中声明的变量和公共静态成员)" id="82" impl="CODSTA-CPP-82" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-82.rule"/>
            </rule>
            <rule header="在一个局部范围内声明的标识符不应该隐藏在一个类作用域中声明的标识符" id="83" impl="CODSTA-CPP-83" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-83.rule"/>
            </rule>
            <rule header="在类的作用域中声明的标识符不应该隐藏在全局或命名空间范围内声明的标识符" id="84" impl="CODSTA-CPP-84" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-84.rule"/>
            </rule>
            <rule header="在一个内部类作用域中声明的标识符不应该隐藏在外部类作用域中声明的标识符" id="85" impl="CODSTA-CPP-85" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-85.rule"/>
            </rule>
            <rule header="如果在一个类中定义了两个相反的相等运算符（'=='、'!='），则其中一个运算符应以另一个运算符的形式定义" id="86" impl="CODSTA-CPP-86" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-86.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_a" impl="CODSTA-CPP-87_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_a.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_b" impl="CODSTA-CPP-87_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_b.rule"/>
            </rule>
            <rule header="如果标识符指的是一个类型，它不应也指向同一范围内的对象或函数" id="87_c" impl="CODSTA-CPP-87_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-87_c.rule"/>
            </rule>
            <rule header="typedef 的名称不应该与其基本类型的名称相同" id="88" impl="CODSTA-CPP-88" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-88.rule"/>
            </rule>
            <rule header="不要分配枚举到bool" id="89" impl="CODSTA-CPP-89" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-CPP\CODSTA-CPP-89.rule"/>
            </rule>
            <rule header="不应该在头文件中使用 'using' 指令和 'using' 声明(除了类和函数范围内的 using 声明)" id="90" impl="CODSTA-CPP-90" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-90.rule"/>
            </rule>
            <rule header="二进制过载操作符应该用其对应的复合赋值运算符实现" id="91" impl="CODSTA-CPP-91" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-91.rule"/>
            </rule>
            <rule header="多重继承层次中可访问的实例名必须独一无二" id="92" impl="CODSTA-CPP-92" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-92.rule"/>
            </rule>
            <rule header="不要使用C标准库函数初始化具有非普通类类型的对象" id="93" impl="CODSTA-CPP-93" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-93.rule"/>
            </rule>
            <rule header="不要将非标准布局类类型的对象与C标准库函数进行比较" id="94" impl="CODSTA-CPP-94" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-94.rule"/>
            </rule>
            <rule header="不要修改标准命名空间 'std' 和 'posix'" id="95" impl="CODSTA-CPP-95" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-95.rule"/>
            </rule>
            <rule header="不要使用不匹配的语言链接调用函数" id="96" impl="CODSTA-CPP-96" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-96.rule"/>
            </rule>
            <rule header="永远不要使用'const'或'volatile'来限定引用类型" id="97" impl="CODSTA-CPP-97" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-97.rule"/>
            </rule>
            <rule header="拷贝操作不能改变源对象" id="98" impl="CODSTA-CPP-98" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-CPP\CODSTA-CPP-98.rule"/>
            </rule>
            <rule header="在有效的类型以及成员上使用 offsetof()" id="99" impl="CODSTA-CPP-99" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-CPP\CODSTA-CPP-99.rule"/>
            </rule>
         </category>
         <category description="Modern C 编码规范" name="MC">
            <rule header="'alignof' 运算符不应与数组类型一起使用作为其操作数" id="01" impl="CODSTA-MC-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-01.rule"/>
            </rule>
            <rule header="对象的声明最多应包含一个显式对齐说明符" id="02" impl="CODSTA-MC-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-02.rule"/>
            </rule>
            <rule header="不应在对象声明中使用零对齐说明符" id="03" impl="CODSTA-MC-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-03.rule"/>
            </rule>
            <rule header="具有内部链接的对象的所有声明中的显示对齐说明符应相同" id="04" impl="CODSTA-MC-04" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-04.rule"/>
            </rule>
            <rule header="每个泛型选择都应该包含一个默认关联" id="05" impl="CODSTA-MC-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-05.rule"/>
            </rule>
            <rule header="默认关联应放在关联列表中的第一个或最后一个" id="06" impl="CODSTA-MC-06" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-06.rule"/>
            </rule>
            <rule header="泛型选择应指示至少一个非默认关联" id="07" impl="CODSTA-MC-07" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-07.rule"/>
            </rule>
            <rule header="泛型选择只能从宏展开" id="08" impl="CODSTA-MC-08" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-08.rule"/>
            </rule>
            <rule header="泛型关联应列出适当的类型" id="09" impl="CODSTA-MC-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-09.rule"/>
            </rule>
            <rule header="宏定义中使用的泛型选择应在控制表达式中具有宏参数" id="10" impl="CODSTA-MC-10" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-10.rule"/>
            </rule>
            <rule header="泛型选择不应依赖于隐式指针类型转换" id="11" impl="CODSTA-MC-11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MC\CODSTA-MC-11.rule"/>
            </rule>
            <rule header="泛型选择的控制表达式应具有与其标准类型匹配的基本类型" id="12" impl="CODSTA-MC-12" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-12.rule"/>
            </rule>
            <rule header="非从宏展开的泛型选择不应在控制表达式中包含潜在的副作用" id="13" impl="CODSTA-MC-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-13.rule"/>
            </rule>
            <rule header="枚举类型不应与泛型选择中的整数类型混合" id="14" impl="CODSTA-MC-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-14.rule"/>
            </rule>
            <rule header="由宏展开的泛型选择只能计算一次其参数" id="15" impl="CODSTA-MC-15" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-15.rule"/>
            </rule>
            <rule header="'_Atomic' 限定符不应与 'void' 一起使用" id="16" impl="CODSTA-MC-16" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-16.rule"/>
            </rule>
            <rule header="结构和联合类型原子对象的成员不应直接访问" id="17" impl="CODSTA-MC-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-17.rule"/>
            </rule>
            <rule header="转换时不得从指针类型中删除任何 '_Atomic' 限定" id="18" impl="CODSTA-MC-18" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-18.rule"/>
            </rule>
            <rule header="原子类型的表达式的值应独立于线程交错" id="19" impl="CODSTA-MC-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-19.rule"/>
            </rule>
            <rule header="仅使用 'memory_order_seq_cst' 作为显式内存顺序参数" id="20" impl="CODSTA-MC-20" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-20.rule"/>
            </rule>
            <rule header="传递给 'mtx_init()' 函数的第二参数应为 'mtx_plain', 'mtx_timed', 'mtx_plain | mtx_recursive', 或 'mtx_timed | mtx_recursive'" id="21" impl="CODSTA-MC-21" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-21.rule"/>
            </rule>
            <rule header="线程对象、线程同步对象和线程特有存储指针只能由相应的标准库函数访问" id="22" impl="CODSTA-MC-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MC\CODSTA-MC-22.rule"/>
            </rule>
         </category>
         <category description="Modern C++ 编码规范" name="MCPP">
            <rule header="自定义类型转换函数需要使用标识符标识" id="01" impl="CODSTA-MCPP-01" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-01.rule"/>
            </rule>
            <rule header="不能使用typedef定义类型" id="02" impl="CODSTA-MCPP-02" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-02.rule"/>
            </rule>
            <rule header="使用作用域枚举类型" id="03" impl="CODSTA-MCPP-03" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-03.rule"/>
            </rule>
            <rule header="使用 nullptr 代替 null 和 0" id="04" impl="CODSTA-MCPP-04" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-04.rule"/>
            </rule>
            <rule header="每个重载的虚函数都应使用 override 或 final 声明符声明。" id="05" impl="CODSTA-MCPP-05" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-05.rule"/>
            </rule>
            <rule header="使用 delete 关键避免声明拷贝构造函数以及拷贝赋值运算符" id="06_a" impl="CODSTA-MCPP-06_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_a.rule"/>
            </rule>
            <rule header="通过使用 delete 关键字来声明拷贝构造以及拷贝赋值运算符，而不是使用私有方法的基类来避免拷贝类" id="06_b" impl="CODSTA-MCPP-06_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-06_b.rule"/>
            </rule>
            <rule header="优于 std::bind、std::bind1st 和 std::bind2nd 的 lambda" id="07" impl="CODSTA-MCPP-07" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07.rule"/>
            </rule>
            <rule header="不应该使用 'binder1st' 和 'binder2nd' 标识符" id="07_b" impl="CODSTA-MCPP-07_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-07_b.rule"/>
            </rule>
            <rule header="使用 auto 类型来声明变量" id="08_a" impl="CODSTA-MCPP-08_a" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_a.rule"/>
            </rule>
            <rule header="请使用 auto 类型作为函数返回值" id="08_b" impl="CODSTA-MCPP-08_b" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-08_b.rule"/>
            </rule>
            <rule header="如果函数不抛出异常，则请使用关键字 'noexcept' 声明" id="09" impl="CODSTA-MCPP-09" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-09.rule"/>
            </rule>
            <rule header="比起迭代器，更倾向于常量迭代器" id="10_a" impl="CODSTA-MCPP-10_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_a.rule"/>
            </rule>
            <rule header="应该使用 cbegin(), crbegin, cend(), crend() 函数" id="10_b" impl="CODSTA-MCPP-10_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-10_b.rule"/>
            </rule>
            <rule header="尽量使用 constexpr 声明常量类型变量" id="11_a_cpp11" impl="CODSTA-MCPP-11_a_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_a_cpp11.rule"/>
            </rule>
            <rule header="尽量使用 constexpr 来声明函数" id="11_b_cpp11" impl="CODSTA-MCPP-11_b_cpp11" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-11_b_cpp11.rule"/>
            </rule>
            <rule header="在右值(rvalue)引用上使用 std::move() 和在转发引用(forwarding references)上使用 std::forward()" id="13" impl="CODSTA-MCPP-13" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13.rule"/>
            </rule>
            <rule header="'std::forward' 函数应用来转发通用引用" id="13_b" impl="CODSTA-MCPP-13_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-13_b.rule"/>
            </rule>
            <rule header="避免在转发引用上使用重载" id="14" impl="CODSTA-MCPP-14" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-14.rule"/>
            </rule>
            <rule header="避免默认捕获模式" id="15_a" impl="CODSTA-MCPP-15_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_a.rule"/>
            </rule>
            <rule header="在 lambda 中显式地使用 'this' 指针具有捕获副作用" id="15_b" impl="CODSTA-MCPP-15_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-15_b.rule"/>
            </rule>
            <rule header="建议使用智能指针成员而不是原始指针成员" id="16_a" impl="CODSTA-MCPP-16_a" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_a.rule"/>
            </rule>
            <rule header="对于数组或 STL 容器建议使用智能指针而不是原始指针" id="16_b" impl="CODSTA-MCPP-16_b" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_b.rule"/>
            </rule>
            <rule header="建议使用 'std::make_shared' 而不是直接使用 new" id="16_c" impl="CODSTA-MCPP-16_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_c.rule"/>
            </rule>
            <rule header="优先使用 std::unique_ptr 而不是 std::auto_ptr" id="16_d" impl="CODSTA-MCPP-16_d" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_d.rule"/>
            </rule>
            <rule header="'std::make_unique'应该用来构造属于'std::unique_ptr'的对象" id="16_e" impl="CODSTA-MCPP-16_e" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-16_e.rule"/>
            </rule>
            <rule header="永远不要返回通过引用捕获本地对象的lambda" id="17" impl="CODSTA-MCPP-17" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17.rule"/>
            </rule>
            <rule header="永远不要通过引用从外部lambda捕获本地对象" id="17_b" impl="CODSTA-MCPP-17_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_b.rule"/>
            </rule>
            <rule header="通过引用捕获本地对象的lambda不应被赋值给有更长生命周期的变量" id="17_c" impl="CODSTA-MCPP-17_c" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-17_c.rule"/>
            </rule>
            <rule header="在lambda表达式中避免不必要的默认捕获模式" id="18_a" impl="CODSTA-MCPP-18_a" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_a.rule"/>
            </rule>
            <rule header="避免不必要的lambda 捕获" id="18_b" impl="CODSTA-MCPP-18_b" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-18_b.rule"/>
            </rule>
            <rule header="使用引用修饰符&amp;(ref-qualifier)来声明赋值运算符" id="19" impl="CODSTA-MCPP-19" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-19.rule"/>
            </rule>
            <rule header="选择使用智能指针而不是原始局部指针" id="20" impl="CODSTA-MCPP-20" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-20.rule"/>
            </rule>
            <rule header="不要直接在互斥锁上调用lock()" id="21" impl="CODSTA-MCPP-21" quickfix="false" scope="line" severity="4">
               <file path="CODSTA-MCPP\CODSTA-MCPP-21.rule"/>
            </rule>
            <rule header="在基于范围的'for'循环中对自动声明使用显式引用限定符" id="22" impl="CODSTA-MCPP-22" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-22.rule"/>
            </rule>
            <rule header="如果类的 public 析构函数是非虚拟的，则该类应该声明为 final" id="23" impl="CODSTA-MCPP-23" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-23.rule"/>
            </rule>
            <rule header="在成员函数声明中,只应该指定 virtual,override 或 final 中的一个" id="24" impl="CODSTA-MCPP-24" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-24.rule"/>
            </rule>
            <rule header="数字序列分隔符 ' 只能与相应的数值类型匹配使用" id="25" impl="CODSTA-MCPP-25" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-25.rule"/>
            </rule>
            <rule header="指向成员虚拟函数的指针只应该被测试是否与空指针常量相等" id="26" impl="CODSTA-MCPP-26" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-26.rule"/>
            </rule>
            <rule header="用户定义类型的所有std::hash专门化都应具有noexcept函数调用运算符" id="27" impl="CODSTA-MCPP-27" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-27.rule"/>
            </rule>
            <rule header="lambda 不应是 typeid 的操作数" id="28" impl="CODSTA-MCPP-28" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-28.rule"/>
            </rule>
            <rule header="当将指针传递给线程中的对象时，使用智能指针" id="29" impl="CODSTA-MCPP-29" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-29.rule"/>
            </rule>
            <rule header="考虑将本地对象的 'std::shared_ptr' 类型替换为 'std::unique_ptr' 类型" id="30" impl="CODSTA-MCPP-30" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-30.rule"/>
            </rule>
            <rule header="定义操作符 delete 的分级版本和未分级版本" id="31" impl="CODSTA-MCPP-31" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-31.rule"/>
            </rule>
            <rule header="静态对象和线程本地对象应不断初始化" id="32" impl="CODSTA-MCPP-32" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-32.rule"/>
            </rule>
            <rule header="用户定义的文字运算符只能执行传递参数的转换" id="33" impl="CODSTA-MCPP-33" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-33.rule"/>
            </rule>
            <rule header="智能指针只有在表示生存期语义时才可以用作参数类型" id="34" impl="CODSTA-MCPP-34" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-34.rule"/>
            </rule>
            <rule header="如果函数代替被管理的对象，参数应该只声明为对 'std::shared_ptr' 或 'std::unique_ptr' 的非常量左值(const Ivalue)引用" id="35" impl="CODSTA-MCPP-35" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-35.rule"/>
            </rule>
            <rule header="不要将参数类型声明为 'std::shared_ptr' 或 'std::unique_ptr' 的 rvalue 引用" id="36" impl="CODSTA-MCPP-36" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-36.rule"/>
            </rule>
            <rule header="析构类不需要进一步明确初始化，以及要求基类中的所有构造函数都应使用继承构造函数" id="37" impl="CODSTA-MCPP-37" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-37.rule"/>
            </rule>
            <rule header="带括号但不带等号的初始化{}，应用于变量的初始化" id="38" impl="CODSTA-MCPP-38" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-38.rule"/>
            </rule>
            <rule header="不应使用 '{}' 或 '= {}' 括号初始化来初始化 auto 类型的变量" id="39" impl="CODSTA-MCPP-39" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-39.rule"/>
            </rule>
            <rule header="不要过度使用 'auto' 说明符" id="40" impl="CODSTA-MCPP-40" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-40.rule"/>
            </rule>
            <rule header="不应该使用 'random_shuffle' 标识符" id="41" impl="CODSTA-MCPP-41" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-41.rule"/>
            </rule>
            <rule header="不要在 'bool' 类型的操作数上使用递增操作符（++）" id="42" impl="CODSTA-MCPP-42" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-42.rule"/>
            </rule>
            <rule header="不应该使用 'set_unexpected' 标识符" id="43" impl="CODSTA-MCPP-43" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-43.rule"/>
            </rule>
            <rule header="lambda 表达式不应该在另一个 lambda 表达式中定义" id="44" impl="CODSTA-MCPP-44" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-44.rule"/>
            </rule>
            <rule header="应该显式指定非 void 返回类型 lambda 表达式的返回类型" id="45" impl="CODSTA-MCPP-45" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-45.rule"/>
            </rule>
            <rule header="在每个 lambda 表达式中包含一个参数列表" id="46" impl="CODSTA-MCPP-46" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-46.rule"/>
            </rule>
            <rule header="避免使用std::initializer_list重载构造函数" id="47" impl="CODSTA-MCPP-47" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-47.rule"/>
            </rule>
            <rule header="一个函数的多个输出值应该以结构体或元组的形式返回" id="48" impl="CODSTA-MCPP-48" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-48.rule"/>
            </rule>
            <rule header="用户定义的复制和移动赋值运算符应使用用户定义的无抛出交换函数" id="49" impl="CODSTA-MCPP-49" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-49.rule"/>
            </rule>
            <rule header="不应使用循环遍历容器中的所有元素而不使用循环计数器的 for 循环" id="50" impl="CODSTA-MCPP-50" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-50.rule"/>
            </rule>
            <rule header="将结果立即转换为常量迭代器时，请使用常量容器调用" id="51" impl="CODSTA-MCPP-51" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-51.rule"/>
            </rule>
            <rule header="不要在 final 类中引入 virtual 函数" id="52" impl="CODSTA-MCPP-52" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-52.rule"/>
            </rule>
            <rule header="不要在以 const 或 const＆type 声明的对象上使用 std :: move" id="53" impl="CODSTA-MCPP-53" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-53.rule"/>
            </rule>
            <rule header="不要创建 std::array 的右值引用" id="54" impl="CODSTA-MCPP-54" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-54.rule"/>
            </rule>
            <rule header="使用 std::call_once 而不是双重检查锁定模式" id="55" impl="CODSTA-MCPP-55" quickfix="false" scope="line" severity="3">
               <file path="CODSTA-MCPP\CODSTA-MCPP-55.rule"/>
            </rule>
            <rule header="如果一个类通过 '=default'、'=delete' 或用户提供的声明声明了一个复制或移动操作或析构函数，那么这五个特殊成员函数中的所有其他函数也都应被声明" id="56" impl="CODSTA-MCPP-56" quickfix="false" scope="line" severity="2">
               <file path="CODSTA-MCPP\CODSTA-MCPP-56.rule"/>
            </rule>
         </category>
      </category>
      <category description="注释" name="COMMENT">
         <rule header="推荐使用 C++ 风格的注释" id="01" impl="COMMENT-01" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-01.rule"/>
         </rule>
         <rule header="提供版权信息" id="02" impl="COMMENT-02" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-02.rule"/>
         </rule>
         <rule header="每个源文件需要注释文件信息" id="03" impl="COMMENT-03" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-03.rule"/>
         </rule>
         <rule header="在函数定义之前的注释中记录函数" id="04" impl="COMMENT-04" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04.rule"/>
         </rule>
         <rule header="在函数声明之前的注释中记录函数" id="04_b" impl="COMMENT-04_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-04_b.rule"/>
         </rule>
         <rule header="每一个变量声明都应该进行注解" id="05" impl="COMMENT-05" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-05.rule"/>
         </rule>
         <rule header="每一个类型定义(typedef)都应该进行注释" id="06" impl="COMMENT-06" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-06.rule"/>
         </rule>
         <rule header="每一个枚举值都应该进行注释" id="07" impl="COMMENT-07" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-07.rule"/>
         </rule>
         <rule header="每一个结构体成员变量都应该进行注释" id="08" impl="COMMENT-08" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-08.rule"/>
         </rule>
         <rule header="应该注释说明所有汇编程序的使用" id="09" impl="COMMENT-09" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-09.rule"/>
         </rule>
         <rule header="使用对浮点运算注释说明" id="10" impl="COMMENT-10" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-10.rule"/>
         </rule>
         <rule header="字符序列 // 不得被用于 C 语言风格的注释中" id="11" impl="COMMENT-11" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-11.rule"/>
         </rule>
         <rule header="字符序列 /* 不得被用于 C++ 语言风格的注释中" id="12" impl="COMMENT-12" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-12.rule"/>
         </rule>
         <rule header="不得在 // 注释中使用行合并" id="13" impl="COMMENT-13" quickfix="false" scope="line" severity="2">
            <file path="COMMENT\COMMENT-13.rule"/>
         </rule>
         <rule header="所有类型、数据成员和函数的声明之前都应该有一个注释，注释使用 '@brief' 标记" id="14" impl="COMMENT-14" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14.rule"/>
         </rule>
         <rule header="函数参数和返回类型应该记录在函数声明之前的注释中" id="14_b" impl="COMMENT-14_b" quickfix="false" scope="line" severity="3">
            <file path="COMMENT\COMMENT-14_b.rule"/>
         </rule>
      </category>
      <category description="异常" name="EXCEPT">
         <rule header="不允许从析构、释放和交换中抛出异常" id="01" impl="EXCEPT-01" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-01.rule"/>
         </rule>
         <rule header="按值抛出，按参考捕获" id="02" impl="EXCEPT-02" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-02.rule"/>
         </rule>
         <rule header="不要从析构函数内抛出" id="03" impl="EXCEPT-03" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-03.rule"/>
         </rule>
         <rule header="所有的异常应该重新抛出，或者用标准的日志记录器进行记录" id="04" impl="EXCEPT-04" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-04.rule"/>
         </rule>
         <rule header="在程序中不要运用 C++ 异常处理函数(例如,不得使用 throw, catch 和 try 等)" id="05" impl="EXCEPT-05" quickfix="false" scope="line" severity="2">
            <file path="EXCEPT\EXCEPT-05.rule"/>
         </rule>
         <rule header="至少应该有一个异常处理程序来捕获所有其他未处理的异常" id="06" impl="EXCEPT-06" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-06.rule"/>
         </rule>
         <rule header="空抛出(throw;)只能用于catch处理程序的复合语句中" id="07" impl="EXCEPT-07" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-07.rule"/>
         </rule>
         <rule header="只有在程序启动后和终止前才会出现异常情况" id="08" impl="EXCEPT-08" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-08.rule"/>
         </rule>
         <rule header="异常对象不应该有指针类型" id="09" impl="EXCEPT-09" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-09.rule"/>
         </rule>
         <rule header="不得使用 goto 或 switch 开关语句将控制传递到 try 或 catch 模块中" id="10" impl="EXCEPT-10" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-10.rule"/>
         </rule>
         <rule header="throw 语句的赋值表达式不得自身引起一个异常抛出" id="11" impl="EXCEPT-11" quickfix="false" scope="line" severity="1">
            <file path="EXCEPT\EXCEPT-11.rule"/>
         </rule>
         <rule header="NULL 不得被显式地抛出" id="12" impl="EXCEPT-12" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-12.rule"/>
         </rule>
         <rule header="代码中显式抛出的每个异常都应在可能导致该点的所有调用路径中具有兼容类型的处理程序" id="13" impl="EXCEPT-13" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-13.rule"/>
         </rule>
         <rule header="如果函数的声明包含异常规范，则该函数只能抛出指定类型的异常" id="14" impl="EXCEPT-14" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-14.rule"/>
         </rule>
         <rule header="一个类的类型异常应始终通过引用捕获" id="15" impl="EXCEPT-15" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-15.rule"/>
         </rule>
         <rule header="以 function-try-block 实现的类构造函数或析构函数的处理程序不应引用该类或其基类的非静态成员" id="16" impl="EXCEPT-16" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-16.rule"/>
         </rule>
         <rule header="如果在一个 try-catch 语句或函数 try-block 中为派生类及其部分或全部基类提供多个处理程序，则应将派生程度最高的处理程序排序为派生程度最高的基类" id="17" impl="EXCEPT-17" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-17.rule"/>
         </rule>
         <rule header="在全局或命名空间作用域中调用的函数不能抛出未处理的异常" id="18" impl="EXCEPT-18" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-18.rule"/>
         </rule>
         <rule header="异常对象必须是不可抛出复制构造函数" id="19" impl="EXCEPT-19" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-19.rule"/>
         </rule>
         <rule header="继承自'std::exception'的类的显式声明复制构造函数应该具有非抛出异常规范" id="20" impl="EXCEPT-20" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-20.rule"/>
         </rule>
         <rule header="所有用户提供的移动构造函数和移动分配操作符都不应异常退出" id="21" impl="EXCEPT-21" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-21.rule"/>
         </rule>
         <rule header="可以从函数中抛出的检测异常应在函数声明之前的注释中指定" id="22" impl="EXCEPT-22" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-22.rule"/>
         </rule>
         <rule header="不使用throw异常规范" id="23" impl="EXCEPT-23" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-23.rule"/>
         </rule>
         <rule header="如果在 'try-catch' 语句或 'function-try-block' 中提供了多个处理程序，那么任何省略(catch-all)处理程序都应该是最后一个" id="24" impl="EXCEPT-24" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-24.rule"/>
         </rule>
         <rule header="不要让 'catch' 块为空" id="25" impl="EXCEPT-25" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-25.rule"/>
         </rule>
         <rule header="避免使用 catch-all 异常处理程序" id="26" impl="EXCEPT-26" quickfix="false" scope="line" severity="3">
            <file path="EXCEPT\EXCEPT-26.rule"/>
         </rule>
      </category>
      <category description="代码格式" name="FORMAT">
         <rule header="禁止使用未用 ASCII 空格的制表符" id="01" impl="FORMAT-01" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-01.rule"/>
         </rule>
         <rule header="将左边大括号 '{' 置于单独的行上" id="02" impl="FORMAT-02" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-02.rule"/>
         </rule>
         <rule header="将右闭大括号 '}' 置于单独的行上" id="03" impl="FORMAT-03" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-03.rule"/>
         </rule>
         <rule header="单行字符应该不超过 80 个" id="04" impl="FORMAT-04" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-04.rule"/>
         </rule>
         <rule header="宏的长度不能超过 10 行" id="05" impl="FORMAT-05" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-05.rule"/>
         </rule>
         <rule header="每行只允许一个语句" id="06" impl="FORMAT-06" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-06.rule"/>
         </rule>
         <rule header="在赋值运算符之前应该有且仅有一个 ASCII 空格字符" id="07" impl="FORMAT-07" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-07.rule"/>
         </rule>
         <rule header="在赋值运算符之后应该有且仅有一个 ASCII 空格字符" id="08" impl="FORMAT-08" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-08.rule"/>
         </rule>
         <rule header="在位运算符之前应该有且仅有一个 ASCII 空格字符" id="09" impl="FORMAT-09" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-09.rule"/>
         </rule>
         <rule header="在位运算符之后应该有且仅有一个 ASCII 空格字符" id="10" impl="FORMAT-10" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-10.rule"/>
         </rule>
         <rule header="在位运算符 '&amp;'前后应该有且仅有一个 ASCII 空格字符" id="11" impl="FORMAT-11" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-11.rule"/>
         </rule>
         <rule header="在条件语句的关键字和左括号之间应该有且仅有一个 ASCII 空格字符" id="12" impl="FORMAT-12" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-12.rule"/>
         </rule>
         <rule header="在条件语句的开括号之后最多只能有一个 ASCII 的空格字符" id="13" impl="FORMAT-13" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-13.rule"/>
         </rule>
         <rule header="在三元条件操作符之前只能有一个 ASCII 的空格字符" id="14" impl="FORMAT-14" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-14.rule"/>
         </rule>
         <rule header="在三元条件操作符之后只能有一个 ASCII 的空格字符" id="15" impl="FORMAT-15" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-15.rule"/>
         </rule>
         <rule header="在关系和相等运算符前后只能有一个 ASCII 的空格字符" id="16" impl="FORMAT-16" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-16.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之后不能有空白格" id="17" impl="FORMAT-17" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-17.rule"/>
         </rule>
         <rule header="在 '.' 或 '-&gt;' 操作符之前不能有空白格" id="18" impl="FORMAT-18" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-18.rule"/>
         </rule>
         <rule header="在所有逗号后应该有且仅有一个 ASCII 的空格字符" id="19" impl="FORMAT-19" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-19.rule"/>
         </rule>
         <rule header="在所有分号后应该有且仅有一个 ASCII 的空格字符" id="20" impl="FORMAT-20" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-20.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;!&quot; 或 &quot;~&quot; 及其操作数之间不能有空格" id="21" impl="FORMAT-21" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-21.rule"/>
         </rule>
         <rule header="在自增/自减运算符 (++/--) 和其操作数之间不能有空格" id="22" impl="FORMAT-22" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-22.rule"/>
         </rule>
         <rule header="在 'return' 返回语句或 'sizeof' 运算符和以下左括号间不能有空格" id="23" impl="FORMAT-23" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-23.rule"/>
         </rule>
         <rule header="在打开 '(' 之后和关闭 ')' 括号之前不应有空格，这些括号包含 'return' 语句或 'sizeof' 运算符的操作数" id="24" impl="FORMAT-24" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-24.rule"/>
         </rule>
         <rule header="'sizeof' 运算符的操作数应括在括号中" id="25" impl="FORMAT-25" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25.rule"/>
         </rule>
         <rule header="&quot;return&quot; 语句应该使用括号" id="25_b" impl="FORMAT-25_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-25_b.rule"/>
         </rule>
         <rule header="在逻辑运算符的前后应该有且仅有一个 ASCII 空格字符" id="26" impl="FORMAT-26" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-26.rule"/>
         </rule>
         <rule header="代码行以每一级四个空格缩进" id="27" impl="FORMAT-27" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-27.rule"/>
         </rule>
         <rule header="在函数的定义中，函数返回类型应该直接写在函数名称前面的单独一行上" id="28" impl="FORMAT-28" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-28.rule"/>
         </rule>
         <rule header="不允许在同一行声明多个变量" id="29" impl="FORMAT-29" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-29.rule"/>
         </rule>
         <rule header="在函数名后直接写左括号" id="30" impl="FORMAT-30" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-30.rule"/>
         </rule>
         <rule header="条件表达式中单独进行逻辑判断" id="31" impl="FORMAT-31" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-31.rule"/>
         </rule>
         <rule header="解引用运算符 '*' 和地址运算符 '&amp;' 应直接与类型连接在一起" id="32" impl="FORMAT-32" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-32.rule"/>
         </rule>
         <rule header="每个变量都要在单独的声明语句中被声明" id="33" impl="FORMAT-33" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-33.rule"/>
         </rule>
         <rule header="包含一个区域的括号 &quot;{}&quot; 应该放置在同一列" id="34" impl="FORMAT-34" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-34.rule"/>
         </rule>
         <rule header="在函数声明的时候，前括号和第一个形参应该于函数名写在同一行上" id="35" impl="FORMAT-35" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-35.rule"/>
         </rule>
         <rule header="同级语句行应该缩进到相同的位置" id="36" impl="FORMAT-36" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-36.rule"/>
         </rule>
         <rule header="控制语句块的第一行应该比控制语句关键字缩进更多" id="37" impl="FORMAT-37" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-37.rule"/>
         </rule>
         <rule header="当函数的形参超过两个的时候，前括号和第一个参数应该和函数名写在一行,其他参数应该再单独一行写一个" id="38" impl="FORMAT-38" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-38.rule"/>
         </rule>
         <rule header="按字母顺序排序 #include 指令" id="39" impl="FORMAT-39" quickfix="false" scope="line" severity="4">
            <file path="FORMAT\FORMAT-39.rule"/>
         </rule>
         <rule header="空格在开始方括号 '[' 之后和结束方括号 ']' 之前的使用方式应该保持一致" id="40" impl="FORMAT-40" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-40.rule"/>
         </rule>
         <rule header="在开始方括号 '[' 和前面的标识符之间不应该有空格" id="41" impl="FORMAT-41" quickfix="false" scope="line" severity="5">
            <file path="FORMAT\FORMAT-41.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 在同一行上除了注释以外不应该有其它代码" id="42" impl="FORMAT-42" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-42.rule"/>
         </rule>
         <rule header="大括号 (&quot;{}&quot;) 将把一个块放在同一列中" id="43" impl="FORMAT-43" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-43.rule"/>
         </rule>
         <rule header="用于包住一个代码模块的括号 (&quot;{}&quot;) 不允许在 &quot;{&quot; 之后或 &quot;}&quot; 之前有空行" id="44" impl="FORMAT-44" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-44.rule"/>
         </rule>
         <rule header="在一元运算符 &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; 及其操作数之间不能有空格" id="45" impl="FORMAT-45" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-45.rule"/>
         </rule>
         <rule header="在宏定义中的自增/自减运算符 (++/--) 及其操作数之间不能有空格" id="46" impl="FORMAT-46" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-46.rule"/>
         </rule>
         <rule header="将CV限定词放在其适用类型的右侧" id="47_a" impl="FORMAT-47_a" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_a.rule"/>
         </rule>
         <rule header="CV 限定符应放置在类型为声明类型(typedef)或使用名称(using name)的右侧" id="47_b" impl="FORMAT-47_b" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-47_b.rule"/>
         </rule>
         <rule header="函数声明中的参数名不应该括在括号中" id="48" impl="FORMAT-48" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-48.rule"/>
         </rule>
         <rule header="变量声明中的局部变量名不应该用括号括起来" id="49" impl="FORMAT-49" quickfix="false" scope="line" severity="3">
            <file path="FORMAT\FORMAT-49.rule"/>
         </rule>
      </category>
      <category name="GJB5369">
         <rule header="建议不使用单行注释“∥”" id="4_10_2_2" impl="GJB5369-4_10_2_2" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_10_2_2.rule"/>
         </rule>
         <rule header="循环变量必须是局部声明的" id="4_11_1_2" impl="GJB5369-4_11_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_11_1_2.rule"/>
         </rule>
         <rule header="谨慎使用无限循环语句" id="4_11_2_1" impl="GJB5369-4_11_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_11_2_1.rule"/>
         </rule>
         <rule header="谨慎使用无法控制的循环条件" id="4_11_2_3" impl="GJB5369-4_11_2_3" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_11_2_3.rule"/>
         </rule>
         <rule header="谨慎使用其它类型变量给指针赋值" id="4_12_2_1" impl="GJB5369-4_12_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_12_2_1.rule"/>
         </rule>
         <rule header="结构体变量初始化的类型必须一致" id="4_13_1_2" impl="GJB5369-4_13_1_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_13_1_2.rule"/>
         </rule>
         <rule header="建议逻辑表达式采用显式的表达" id="4_14_2_1" impl="GJB5369-4_14_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_14_2_1.rule"/>
         </rule>
         <rule header="禁止枚举类型中的元素名与已有的变量名同名" id="4_15_1_1" impl="GJB5369-4_15_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_15_1_1.rule"/>
         </rule>
         <rule header="禁止使用预处理操作符 # 和 ##" id="4_15_2_2" impl="GJB5369-4_15_2_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_15_2_2.rule"/>
         </rule>
         <rule header="过程名禁止被重用" id="4_1_1_1" impl="GJB5369-4_1_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_1.rule"/>
         </rule>
         <rule header="禁止数组没有边界限定" id="4_1_1_19" impl="GJB5369-4_1_1_19" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_19.rule"/>
         </rule>
         <rule header="禁止在#include&lt;......&gt;中使用绝对路径名" id="4_1_1_20" impl="GJB5369-4_1_1_20" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_20.rule"/>
         </rule>
         <rule header="禁止结构体声明不完整" id="4_1_1_21" impl="GJB5369-4_1_1_21" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_21.rule"/>
         </rule>
         <rule header="禁止在结构体定义中含有空域" id="4_1_1_3" impl="GJB5369-4_1_1_3" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_3.rule"/>
         </rule>
         <rule header="禁止声明多重标号" id="4_1_1_4" impl="GJB5369-4_1_1_4" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_1_1_4.rule"/>
         </rule>
         <rule header="在过程声明中必须对参数说明" id="4_1_1_6" impl="GJB5369-4_1_1_6" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_1_1_6.rule"/>
         </rule>
         <rule header="禁止过程参数只有类型没有标识符" id="4_1_1_7" impl="GJB5369-4_1_1_7" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_1_1_7.rule"/>
         </rule>
         <rule header="禁止重新定义使用 C 或 C++ 的关键字" id="4_1_1_9" impl="GJB5369-4_1_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB5369\GJB5369-4_1_1_9.rule"/>
         </rule>
         <rule header="建议使用typedef在统一的变量声明头文件中对基本变量类型重新定义" id="4_1_2_1" impl="GJB5369-4_1_2_1" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_1_2_1.rule"/>
         </rule>
         <rule header="避免将过程定义为参数" id="4_1_2_2" impl="GJB5369-4_1_2_2" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_2.rule"/>
         </rule>
         <rule header="过程中避免使用过多的参数，建议不要超过20 个" id="4_1_2_3" impl="GJB5369-4_1_2_3" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_3.rule"/>
         </rule>
         <rule header="在结构体定义中谨慎使用位域" id="4_1_2_4" impl="GJB5369-4_1_2_4" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_4.rule"/>
         </rule>
         <rule header="禁止在块中使用 #define 或 #undef" id="4_1_2_6" impl="GJB5369-4_1_2_6" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_6.rule"/>
         </rule>
         <rule header="谨慎使用 #pragma" id="4_1_2_7" impl="GJB5369-4_1_2_7" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_7.rule"/>
         </rule>
         <rule header="在结构体中谨慎使用无名位域" id="4_1_2_9" impl="GJB5369-4_1_2_9" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_1_2_9.rule"/>
         </rule>
         <rule header="main 必须定义为 int main(void) 或 int main(int,char*[]) 的形式" id="4_2_1_10" impl="GJB5369-4_2_1_10" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_10.rule"/>
         </rule>
         <rule header="循环体必须用大括号括起来" id="4_2_1_2" impl="GJB5369-4_2_1_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_2.rule"/>
         </rule>
         <rule header="禁止在头文件前有可执行代码" id="4_2_1_5" impl="GJB5369-4_2_1_5" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_2_1_5.rule"/>
         </rule>
         <rule header="禁止字符串中单独使用“\”，字符串的终止必须使用“\0”" id="4_2_1_9" impl="GJB5369-4_2_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB5369\GJB5369-4_2_1_9.rule"/>
         </rule>
         <rule header="建议一个文件中的程序总行不超过2000 行" id="4_2_2_1" impl="GJB5369-4_2_2_1" quickfix="false" scope="line" severity="5">
            <file path="GJB5369\GJB5369-4_2_2_1.rule"/>
         </rule>
         <rule header="禁止条件判别成立时相应分支无可执行语句" id="4_3_1_1" impl="GJB5369-4_3_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_1.rule"/>
         </rule>
         <rule header="禁止条件判别的 else 分支无可执行语句" id="4_3_1_3" impl="GJB5369-4_3_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_3.rule"/>
         </rule>
         <rule header="禁止switch的case语句中无任何可执行语句" id="4_3_1_8" impl="GJB5369-4_3_1_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_3_1_8.rule"/>
         </rule>
         <rule header="禁止将参数指针赋值给过程指针" id="4_4_1_1" impl="GJB5369-4_4_1_1" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_4_1_1.rule"/>
         </rule>
         <rule header="谨慎使用指针的逻辑比较" id="4_4_2_1" impl="GJB5369-4_4_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_4_2_1.rule"/>
         </rule>
         <rule header="谨慎对指针进行代数运算" id="4_4_2_2" impl="GJB5369-4_4_2_2" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_4_2_2.rule"/>
         </rule>
         <rule header="禁止赋值操作符与“&amp;&amp;”或“||”连用" id="4_6_1_16" impl="GJB5369-4_6_1_16" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_6_1_16.rule"/>
         </rule>
         <rule header="禁止位操作符带有布尔型的操作数" id="4_6_1_17" impl="GJB5369-4_6_1_17" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_17.rule"/>
         </rule>
         <rule header="禁止位操作符作用于布尔值" id="4_6_1_18" impl="GJB5369-4_6_1_18" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_18.rule"/>
         </rule>
         <rule header="禁止对有符号类型进行移位运算" id="4_6_1_3" impl="GJB5369-4_6_1_3" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_3.rule"/>
         </rule>
         <rule header="有符号类型的位长度必须大于等于两位" id="4_6_1_6" impl="GJB5369-4_6_1_6" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_6_1_6.rule"/>
         </rule>
         <rule header="禁止给变量赋的值与变量的类型不一致" id="4_6_1_8" impl="GJB5369-4_6_1_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_6_1_8.rule"/>
         </rule>
         <rule header="主过程所在文件中禁止有未被该文件中任何过程调用的子过程" id="4_7_1_2" impl="GJB5369-4_7_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_7_1_2.rule"/>
         </rule>
         <rule header="禁止 void 类型的变量作为参数进行传递" id="4_7_1_8" impl="GJB5369-4_7_1_8" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_7_1_8.rule"/>
         </rule>
         <rule header="避免以非调用方式使用函数" id="4_7_2_2" impl="GJB5369-4_7_2_2" quickfix="false" scope="line" severity="2">
            <file path="GJB5369\GJB5369-4_7_2_2.rule"/>
         </rule>
         <rule header="禁止单独使用小写字母“l”或大写字母“O”作为变量名" id="4_8_1_1" impl="GJB5369-4_8_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_1.rule"/>
         </rule>
         <rule header="禁止三字母词的使用" id="4_8_1_2" impl="GJB5369-4_8_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_2.rule"/>
         </rule>
         <rule header="使用的八进制数必须加以注释" id="4_8_1_3" impl="GJB5369-4_8_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_1_3.rule"/>
         </rule>
         <rule header="避免使用&quot;+=&quot;或&quot;-=&quot;操作符" id="4_8_2_1" impl="GJB5369-4_8_2_1" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_8_2_1.rule"/>
         </rule>
         <rule header="避免使用空语句" id="4_8_2_6" impl="GJB5369-4_8_2_6" quickfix="false" scope="line" severity="4">
            <file path="GJB5369\GJB5369-4_8_2_6.rule"/>
         </rule>
         <rule header="避免使用老的参数表的定义形式" id="4_8_2_8" impl="GJB5369-4_8_2_8" quickfix="false" scope="line" severity="3">
            <file path="GJB5369\GJB5369-4_8_2_8.rule"/>
         </rule>
      </category>
      <category name="GJB8114">
         <rule header="浮点型数转换成整型数应考虑是否需要四舍五入" id="A_1_10_1" impl="GJB8114-A_1_10_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_1.rule"/>
         </rule>
         <rule header="谨慎将double型数转换成float型数" id="A_1_10_2" impl="GJB8114-A_1_10_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_2.rule"/>
         </rule>
         <rule header="谨慎将长整型数转换成短整型数" id="A_1_10_3" impl="GJB8114-A_1_10_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_3.rule"/>
         </rule>
         <rule header="谨慎将指针量赋予非指针变量或非指针量赋予指针变量" id="A_1_10_4" impl="GJB8114-A_1_10_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_10_4.rule"/>
         </rule>
         <rule header="建议变量在声明的同时进行初始化" id="A_1_11_1" impl="GJB8114-A_1_11_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_11_1.rule"/>
         </rule>
         <rule header="建议所有全局变量在统一设计的初始化模块中进行初始化" id="A_1_11_2" impl="GJB8114-A_1_11_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_11_2.rule"/>
         </rule>
         <rule header="与常数进行是否相等的判别，建议常数在左，变量在右" id="A_1_12_1" impl="GJB8114-A_1_12_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_12_1.rule"/>
         </rule>
         <rule header="推荐使用带类型前缀的变量命名" id="A_1_13_1" impl="GJB8114-A_1_13_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1.rule"/>
         </rule>
         <rule header="字符型变量命名应以c为前缀" id="A_1_13_1_a" impl="GJB8114-A_1_13_1_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_a.rule"/>
         </rule>
         <rule header="有符号字符型变量应以uc为前缀" id="A_1_13_1_b" impl="GJB8114-A_1_13_1_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_b.rule"/>
         </rule>
         <rule header="无符号字符型变量应以uc为前缀" id="A_1_13_1_c" impl="GJB8114-A_1_13_1_c" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_c.rule"/>
         </rule>
         <rule header="所有整型变量以小写字母 'i' 开头" id="A_1_13_1_d" impl="GJB8114-A_1_13_1_d" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_d.rule"/>
         </rule>
         <rule header="所有无符号整型变量以 'ui' 开头" id="A_1_13_1_f" impl="GJB8114-A_1_13_1_f" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_f.rule"/>
         </rule>
         <rule header="所有短整型变量以字母 's' 开头" id="A_1_13_1_g" impl="GJB8114-A_1_13_1_g" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_g.rule"/>
         </rule>
         <rule header="无符号短整型变量应以us为前缀" id="A_1_13_1_i" impl="GJB8114-A_1_13_1_i" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_i.rule"/>
         </rule>
         <rule header="所有长整型变量名以 'l' 开头" id="A_1_13_1_j" impl="GJB8114-A_1_13_1_j" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_j.rule"/>
         </rule>
         <rule header="无符号长整型变量应以'ul'为前缀" id="A_1_13_1_m" impl="GJB8114-A_1_13_1_m" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_m.rule"/>
         </rule>
         <rule header="浮点类型变量名以小写字母 'f' 开头" id="A_1_13_1_n" impl="GJB8114-A_1_13_1_n" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_n.rule"/>
         </rule>
         <rule header="双精类型变量名以小写字母 'd' 开头" id="A_1_13_1_p" impl="GJB8114-A_1_13_1_p" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_p.rule"/>
         </rule>
         <rule header="长双精度型变量应以ld为前缀" id="A_1_13_1_q" impl="GJB8114-A_1_13_1_q" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_1_q.rule"/>
         </rule>
         <rule header="谨慎使用寄存器变量" id="A_1_13_2" impl="GJB8114-A_1_13_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_13_2.rule"/>
         </rule>
         <rule header="建议使用typedef对基本变量类型重新定义。" id="A_1_1_1" impl="GJB8114-A_1_1_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_1.rule"/>
         </rule>
         <rule header="谨慎由于宏中括号不匹配造成使用上的误解" id="A_1_1_2" impl="GJB8114-A_1_1_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_2.rule"/>
         </rule>
         <rule header="宏定义中谨慎使用##或#。" id="A_1_1_3" impl="GJB8114-A_1_1_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_3.rule"/>
         </rule>
         <rule header="建议函数内部变量在函数体开始处统一定义" id="A_1_1_4" impl="GJB8114-A_1_1_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_4.rule"/>
         </rule>
         <rule header="建议结构体嵌套定义不超过3层" id="A_1_1_5" impl="GJB8114-A_1_1_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_5.rule"/>
         </rule>
         <rule header="建议用宏或const定义常数。" id="A_1_1_6_a" impl="GJB8114-A_1_1_6_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_6_a.rule"/>
         </rule>
         <rule header="建议用宏或const定义常数。" id="A_1_1_6_b" impl="GJB8114-A_1_1_6_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_1_6_b.rule"/>
         </rule>
         <rule header="一个文件中的语句总行不超过2000行。" id="A_1_2_1" impl="GJB8114-A_1_2_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_1.rule"/>
         </rule>
         <rule header="一个函数中的语句总行不超过200行。" id="A_1_2_2" impl="GJB8114-A_1_2_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_2.rule"/>
         </rule>
         <rule header="C语言程序建议使用标准C的注释符，谨慎使用 //注释。" id="A_1_2_3" impl="GJB8114-A_1_2_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_2_3.rule"/>
         </rule>
         <rule header="谨慎使用函数指针。" id="A_1_3_1" impl="GJB8114-A_1_3_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_1.rule"/>
         </rule>
         <rule header="谨慎使用无类型指针" id="A_1_3_2" impl="GJB8114-A_1_3_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_2.rule"/>
         </rule>
         <rule header="谨慎对指针进行算术运算。" id="A_1_3_3" impl="GJB8114-A_1_3_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_3_3.rule"/>
         </rule>
         <rule header="避免层数过多的分支嵌套，建议最多不超过7层。" id="A_1_4_1" impl="GJB8114-A_1_4_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_4_1.rule"/>
         </rule>
         <rule header="谨慎使用goto语句" id="A_1_5_1" impl="GJB8114-A_1_5_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_5_1.rule"/>
         </rule>
         <rule header="禁止对有符号整形量进行位运算" id="A_1_6_1" impl="GJB8114-A_1_6_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_1.rule"/>
         </rule>
         <rule header="谨慎做整型量除以整型变量的除法" id="A_1_6_2" impl="GJB8114-A_1_6_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_2.rule"/>
         </rule>
         <rule header="避免使用strcpy函数，应使用strncpy函数替代" id="A_1_6_4" impl="GJB8114-A_1_6_4" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_4.rule"/>
         </rule>
         <rule header="避免使用strcat函数，应使用strncat函数替代" id="A_1_6_5" impl="GJB8114-A_1_6_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_5.rule"/>
         </rule>
         <rule header="谨慎使用逗号操作符" id="A_1_6_6" impl="GJB8114-A_1_6_6" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_6_6.rule"/>
         </rule>
         <rule header="函数中避免使用过多的参数，建议不要超过10个" id="A_1_7_1" impl="GJB8114-A_1_7_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_1.rule"/>
         </rule>
         <rule header="函数中避免存在未被使用的调用参数" id="A_1_7_2" impl="GJB8114-A_1_7_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_2.rule"/>
         </rule>
         <rule header="谨慎使用abort、exit函数" id="A_1_7_3" impl="GJB8114-A_1_7_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_3.rule"/>
         </rule>
         <rule header="函数中数组变量作为参数指针传递时，建议同时传递数组长度" id="A_1_7_5" impl="GJB8114-A_1_7_5" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_7_5.rule"/>
         </rule>
         <rule header="避免使用空语句" id="A_1_8_1" impl="GJB8114-A_1_8_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_1.rule"/>
         </rule>
         <rule header="避免无用的多余变量" id="A_1_8_2_a" impl="GJB8114-A_1_8_2_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_2_a.rule"/>
         </rule>
         <rule header="避免无用的多余变量" id="A_1_8_2_b" impl="GJB8114-A_1_8_2_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_2_b.rule"/>
         </rule>
         <rule header="避免无用的多余函数" id="A_1_8_3" impl="GJB8114-A_1_8_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_3.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_a" impl="GJB8114-A_1_8_4_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_a.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_b" impl="GJB8114-A_1_8_4_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_b.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_c" impl="GJB8114-A_1_8_4_c" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_c.rule"/>
         </rule>
         <rule header="推荐使用数字类型后缀" id="A_1_8_4_d" impl="GJB8114-A_1_8_4_d" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_8_4_d.rule"/>
         </rule>
         <rule header="谨慎使用无限循环语句" id="A_1_9_1" impl="GJB8114-A_1_9_1" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_1.rule"/>
         </rule>
         <rule header="谨慎在循环中使用多个break语句" id="A_1_9_2" impl="GJB8114-A_1_9_2" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_2.rule"/>
         </rule>
         <rule header="谨慎在循环中使用多个continue语句" id="A_1_9_3" impl="GJB8114-A_1_9_3" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-A_1_9_3.rule"/>
         </rule>
         <category name="CPP">
            <rule header="谨慎使用派生类由虚拟基类派生" id="A_2_1_1" impl="GJB8114-CPP-A_2_1_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_1_1.rule"/>
            </rule>
            <rule header="谨慎使用内联函数" id="A_2_1_2" impl="GJB8114-CPP-A_2_1_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_1_2.rule"/>
            </rule>
            <rule header="建议使用C++的类型转换操作符，避免使用C的类型转换形式" id="A_2_5_1" impl="GJB8114-CPP-A_2_5_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_5_1.rule"/>
            </rule>
            <rule header="类中函数的实现代码避免在类定义的内部定义" id="A_2_7_1" impl="GJB8114-CPP-A_2_7_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_7_1.rule"/>
            </rule>
            <rule header="建议在所有指定捕获之后使用缺省捕获防范遗漏的异常" id="A_2_8_1" impl="GJB8114-CPP-A_2_8_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_8_1.rule"/>
            </rule>
            <rule header="谨慎对指针类型进行抛出捕获" id="A_2_8_2" impl="GJB8114-CPP-A_2_8_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_8_2.rule"/>
            </rule>
            <rule header="建议模板参数列表中的类型参数使用typename关键字说明" id="A_2_9_1" impl="GJB8114-CPP-A_2_9_1" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_1.rule"/>
            </rule>
            <rule header="建议除常数指针外，const说明均在类型说明的最外层" id="A_2_9_2" impl="GJB8114-CPP-A_2_9_2" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_2.rule"/>
            </rule>
            <rule header="建议不要对“&amp;&amp;”、“||”、“,”进行操作符重载" id="A_2_9_3" impl="GJB8114-CPP-A_2_9_3" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-A_2_9_3.rule"/>
            </rule>
            <rule header="含有动态分配成员的类，必须编写拷贝构造函数，并重载赋值操作符" id="R_2_1_1" impl="GJB8114-CPP-R_2_1_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_1.rule"/>
            </rule>
            <rule header="虚拟基类指针转换为派生类指针必须使用dynamic_cast转换" id="R_2_1_2" impl="GJB8114-CPP-R_2_1_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_2.rule"/>
            </rule>
            <rule header="菱形层次结构的派生设计，对基类派生必须使用virtual说明" id="R_2_1_3" impl="GJB8114-CPP-R_2_1_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_3.rule"/>
            </rule>
            <rule header="抽象类中的复制操作符重载必须是保护的或私有的" id="R_2_1_4" impl="GJB8114-CPP-R_2_1_4" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_1_4.rule"/>
            </rule>
            <rule header="构造函数中禁止使用全局变量" id="R_2_2_1" impl="GJB8114-CPP-R_2_2_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_1.rule"/>
            </rule>
            <rule header="类中必须明确定义缺省构造函数" id="R_2_2_2" impl="GJB8114-CPP-R_2_2_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_2.rule"/>
            </rule>
            <rule header="单参数构造函数必须使用explicit声明" id="R_2_2_3" impl="GJB8114-CPP-R_2_2_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_3.rule"/>
            </rule>
            <rule header="类中所有成员变量必须在构造函数中初始化" id="R_2_2_4" impl="GJB8114-CPP-R_2_2_4" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_4.rule"/>
            </rule>
            <rule header="派生类构造函数必须在初始化列表中说明直接基类构造函数" id="R_2_2_5" impl="GJB8114-CPP-R_2_2_5" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_2_5.rule"/>
            </rule>
            <rule header="具有虚拟成员函数的类，析构函数必须是虚拟的" id="R_2_3_1" impl="GJB8114-CPP-R_2_3_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_3_1.rule"/>
            </rule>
            <rule header="析构函数中禁止存在不是由自身捕获处理的异常" id="R_2_3_2" impl="GJB8114-CPP-R_2_3_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_3_2.rule"/>
            </rule>
            <rule header="基类虚拟函数的参数缺省值在派生类重写函数中禁止被改变" id="R_2_4_1" impl="GJB8114-CPP-R_2_4_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_1.rule"/>
            </rule>
            <rule header="派生类对基类虚拟函数重写的声明必须使用virtual显示说明" id="R_2_4_2" impl="GJB8114-CPP-R_2_4_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_2.rule"/>
            </rule>
            <rule header="禁止非纯虚函数被纯虚拟函数重写" id="R_2_4_3" impl="GJB8114-CPP-R_2_4_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_4_3.rule"/>
            </rule>
            <rule header="禁止将不相关的指针类型强制转换为对象指针类型" id="R_2_5_1" impl="GJB8114-CPP-R_2_5_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_5_1.rule"/>
            </rule>
            <rule header="指针或引用的类型转换中禁止移除const或volatile属性" id="R_2_5_2" impl="GJB8114-CPP-R_2_5_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_5_2.rule"/>
            </rule>
            <rule header="函数中固定长度数组变量的传递必须使用引用方式" id="R_2_7_1" impl="GJB8114-CPP-R_2_7_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_1.rule"/>
            </rule>
            <rule header="定义为const的成员函数禁止返回非const的指针或引用" id="R_2_7_2" impl="GJB8114-CPP-R_2_7_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_2.rule"/>
            </rule>
            <rule header="禁止可导致非资源性对象数据被外部修改的成员函数返回" id="R_2_7_3" impl="GJB8114-CPP-R_2_7_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_7_3.rule"/>
            </rule>
            <rule header="捕获的顺序必须按由派生类到基类的次序排序" id="R_2_8_1" impl="GJB8114-CPP-R_2_8_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_1.rule"/>
            </rule>
            <rule header="每个指定的抛出必须有与之匹配的捕获" id="R_2_8_2" impl="GJB8114-CPP-R_2_8_2" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_2.rule"/>
            </rule>
            <rule header="异常抛出的对象必须使用引用方式捕获" id="R_2_8_3" impl="GJB8114-CPP-R_2_8_3" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_8_3.rule"/>
            </rule>
            <rule header="禁止显式直接抛出NULL" id="R_2_8_5" impl="GJB8114-CPP-R_2_8_5" quickfix="false" scope="line" severity="3">
               <file path="GJB8114\GJB8114-CPP-R_2_8_5.rule"/>
            </rule>
            <rule header="模板的声明、定义与实现必须在同一个文件之中" id="R_2_9_1" impl="GJB8114-CPP-R_2_9_1" quickfix="false" scope="line" severity="1">
               <file path="GJB8114\GJB8114-CPP-R_2_9_1.rule"/>
            </rule>
         </category>
         <rule header="浮点数变量赋给整型变量必须强制转换" id="R_1_10_1" impl="GJB8114-R_1_10_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_1.rule"/>
         </rule>
         <rule header="长整数变量赋给短整数变量必须强制转换" id="R_1_10_2" impl="GJB8114-R_1_10_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_2.rule"/>
         </rule>
         <rule header="double型变量赋给float型变量必须强制转换" id="R_1_10_3" impl="GJB8114-R_1_10_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_3.rule"/>
         </rule>
         <rule header="将指针量赋予非指针变量或非指针量赋予指针变量，必须使用强制转换" id="R_1_10_5" impl="GJB8114-R_1_10_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_5.rule"/>
         </rule>
         <rule header="禁止使用无实质作用的类型转换" id="R_1_10_6" impl="GJB8114-R_1_10_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_10_6.rule"/>
         </rule>
         <rule header="变量初始化禁止隐含依赖于系统的缺省值" id="R_1_11_2" impl="GJB8114-R_1_11_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_2.rule"/>
         </rule>
         <rule header="结构体初始化的嵌套结构必须与定义一致" id="R_1_11_3" impl="GJB8114-R_1_11_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_3.rule"/>
         </rule>
         <rule header="枚举元素定义中的初始化必须完整" id="R_1_11_4" impl="GJB8114-R_1_11_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_11_4.rule"/>
         </rule>
         <rule header="禁止对逻辑量进行大于或小于的逻辑比较" id="R_1_12_1" impl="GJB8114-R_1_12_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_1.rule"/>
         </rule>
         <rule header="禁止对指针进行大于或小于的逻辑比较" id="R_1_12_2" impl="GJB8114-R_1_12_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_2.rule"/>
         </rule>
         <rule header="禁止对浮点数进行是否相等的比较" id="R_1_12_3" impl="GJB8114-R_1_12_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_3.rule"/>
         </rule>
         <rule header="禁止对无符号数进行大于等于零或小于零的比较" id="R_1_12_4" impl="GJB8114-R_1_12_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_4.rule"/>
         </rule>
         <rule header="禁止无符号数与有符号数之间的直接比较" id="R_1_12_5" impl="GJB8114-R_1_12_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_12_5.rule"/>
         </rule>
         <rule header="禁止局部变量与全局变量同名" id="R_1_13_1" impl="GJB8114-R_1_13_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_1.rule"/>
         </rule>
         <rule header="禁止仅依赖大写字母 'O' 与数字 '0' 区分的变量" id="R_1_13_10" impl="GJB8114-R_1_13_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_10.rule"/>
         </rule>
         <rule header="禁止单独使用小写字母“l”或大写字母“O”作为变量名" id="R_1_13_11" impl="GJB8114-R_1_13_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_11.rule"/>
         </rule>
         <rule header="禁止在表达式中出现多个同一volatile类型变量的运算" id="R_1_13_13" impl="GJB8114-R_1_13_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_13.rule"/>
         </rule>
         <rule header="禁止将NULL做为整型数0使用" id="R_1_13_14" impl="GJB8114-R_1_13_14" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_14.rule"/>
         </rule>
         <rule header="禁止给无符号类型变量赋负值" id="R_1_13_15" impl="GJB8114-R_1_13_15" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_15.rule"/>
         </rule>
         <rule header="禁止函数形参与全局变量同名" id="R_1_13_2" impl="GJB8114-R_1_13_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_2.rule"/>
         </rule>
         <rule header="禁止变量名与函数名同名" id="R_1_13_3" impl="GJB8114-R_1_13_3" quickfix="false" scope="line" severity="2">
            <file path="GJB8114\GJB8114-R_1_13_3.rule"/>
         </rule>
         <rule header="禁止变量名与标识名同名。" id="R_1_13_4" impl="GJB8114-R_1_13_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_4.rule"/>
         </rule>
         <rule header="禁止变量名与枚举元素同名" id="R_1_13_5" impl="GJB8114-R_1_13_5" quickfix="false" scope="line" severity="2">
            <file path="GJB8114\GJB8114-R_1_13_5.rule"/>
         </rule>
         <rule header="禁止变量名与typedef自定义的类型名同名" id="R_1_13_6" impl="GJB8114-R_1_13_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_6.rule"/>
         </rule>
         <rule header="禁止在内部块中重定义已有的变量名" id="R_1_13_7" impl="GJB8114-R_1_13_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_7.rule"/>
         </rule>
         <rule header="禁止仅依赖大小写区分的变量" id="R_1_13_8" impl="GJB8114-R_1_13_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_8.rule"/>
         </rule>
         <rule header="禁止仅依赖小写字母 'l' 与数字 '1' 区分的变量" id="R_1_13_9" impl="GJB8114-R_1_13_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_13_9.rule"/>
         </rule>
         <rule header="禁止通过宏定义改变关键字和基本类型含义" id="R_1_1_1" impl="GJB8114-R_1_1_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_1.rule"/>
         </rule>
         <rule header="位定义的有符号整型变量位长必须大于1" id="R_1_1_10" impl="GJB8114-R_1_1_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_10.rule"/>
         </rule>
         <rule header="位定义的整数型变量必须明确定义是有符号还是无符号的" id="R_1_1_11" impl="GJB8114-R_1_1_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_11.rule"/>
         </rule>
         <rule header="函数声明中必须对参数类型进行声明，并带有变量名" id="R_1_1_13" impl="GJB8114-R_1_1_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_13.rule"/>
         </rule>
         <rule header="禁止函数原形中的参数与实际定义中的形参不一致" id="R_1_1_14_a" impl="GJB8114-R_1_1_14_a" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_1_14_a.rule"/>
         </rule>
         <rule header="函数声明必须与函数原型一致(形参类型和实参必须匹配)" id="R_1_1_14_b" impl="GJB8114-R_1_1_14_b" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_1_14_b.rule"/>
         </rule>
         <rule header="函数中的参数必须使用类型声明" id="R_1_1_15" impl="GJB8114-R_1_1_15" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_15.rule"/>
         </rule>
         <rule header="禁止在函数体内使用外部声明。" id="R_1_1_17" impl="GJB8114-R_1_1_17" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_17.rule"/>
         </rule>
         <rule header="数组定义禁止没有显式的边界限定。" id="R_1_1_18" impl="GJB8114-R_1_1_18" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_18.rule"/>
         </rule>
         <rule header="禁止使用 extern 声明对变量初始化" id="R_1_1_19" impl="GJB8114-R_1_1_19" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_19.rule"/>
         </rule>
         <rule header="禁止将其它标识宏定义为关键字和基本类型" id="R_1_1_2" impl="GJB8114-R_1_1_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_2.rule"/>
         </rule>
         <rule header="用于数值计算的字符型变量必须明确定义是有符号还是无符号。" id="R_1_1_20" impl="GJB8114-R_1_1_20" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_20.rule"/>
         </rule>
         <rule header="禁止在#include语句中使用绝对路径。" id="R_1_1_21" impl="GJB8114-R_1_1_21" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_21.rule"/>
         </rule>
         <rule header="函数参数表为空时，必须使用void明确说明。" id="R_1_1_23" impl="GJB8114-R_1_1_23" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_23.rule"/>
         </rule>
         <rule header="用 typedef 自定义的类型禁止被重新定义。" id="R_1_1_3" impl="GJB8114-R_1_1_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_3.rule"/>
         </rule>
         <rule header="禁止重新定义C或C++的关键字" id="R_1_1_4" impl="GJB8114-R_1_1_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_4.rule"/>
         </rule>
         <rule header="函数中的#define和#undef必须配对使用。" id="R_1_1_6" impl="GJB8114-R_1_1_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_6.rule"/>
         </rule>
         <rule header="以函数形式定义的宏，参数和结果必须用括号括起来" id="R_1_1_7" impl="GJB8114-R_1_1_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_7.rule"/>
         </rule>
         <rule header="结构、联合、枚举的定义中必须定义标识名。" id="R_1_1_8" impl="GJB8114-R_1_1_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_8.rule"/>
         </rule>
         <rule header="结构体定义中禁止含有无名结构体" id="R_1_1_9" impl="GJB8114-R_1_1_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_1_9.rule"/>
         </rule>
         <rule header="循环体必须用大括号括起来。" id="R_1_2_1" impl="GJB8114-R_1_2_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_1.rule"/>
         </rule>
         <rule header="if、else if、else必须用大括号括起来。" id="R_1_2_2" impl="GJB8114-R_1_2_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_2.rule"/>
         </rule>
         <rule header="禁止在头文件前有可执行代码。" id="R_1_2_3" impl="GJB8114-R_1_2_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_3.rule"/>
         </rule>
         <rule header="引起二义性理解的逻辑表达式，必须使用括号显式说明优先级顺序。" id="R_1_2_4" impl="GJB8114-R_1_2_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_4.rule"/>
         </rule>
         <rule header="逻辑判别表达式中的运算项必须要使用括号" id="R_1_2_5" impl="GJB8114-R_1_2_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_5.rule"/>
         </rule>
         <rule header="禁止嵌套注释" id="R_1_2_6" impl="GJB8114-R_1_2_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_2_6.rule"/>
         </rule>
         <rule header="禁止指针的指针超过两级。" id="R_1_3_1" impl="GJB8114-R_1_3_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_1.rule"/>
         </rule>
         <rule header="函数指针的使用必须加以&amp;明确说明" id="R_1_3_2" impl="GJB8114-R_1_3_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_2.rule"/>
         </rule>
         <rule header="禁止对参数指针进行赋值。" id="R_1_3_3" impl="GJB8114-R_1_3_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_3.rule"/>
         </rule>
         <rule header="禁止将局部变量地址做为函数返回值返回。" id="R_1_3_4" impl="GJB8114-R_1_3_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_4.rule"/>
         </rule>
         <rule header="指针变量被释放后必须置为NULL" id="R_1_3_6" impl="GJB8114-R_1_3_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_6.rule"/>
         </rule>
         <rule header="动态分配的指针变量定义时如未被分配空间必须初始化为NULL" id="R_1_3_7" impl="GJB8114-R_1_3_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_7.rule"/>
         </rule>
         <rule header="空指针必须使用NULL，禁止使用整型数0" id="R_1_3_9" impl="GJB8114-R_1_3_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_3_9.rule"/>
         </rule>
         <rule header="在if-else if语句中必须使用else分支。" id="R_1_4_1" impl="GJB8114-R_1_4_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_1.rule"/>
         </rule>
         <rule header="条件判定分支如果为空，必须以单独一行的分号加注释进行明确说明" id="R_1_4_2" impl="GJB8114-R_1_4_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_2.rule"/>
         </rule>
         <rule header="禁止使用空switch语句" id="R_1_4_3" impl="GJB8114-R_1_4_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_3.rule"/>
         </rule>
         <rule header="禁止对bool量使用switch语句。" id="R_1_4_4" impl="GJB8114-R_1_4_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_4.rule"/>
         </rule>
         <rule header="禁止switch语句中只包含default语句" id="R_1_4_5" impl="GJB8114-R_1_4_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_5.rule"/>
         </rule>
         <rule header="除枚举类型列举完全外，switch必须要有default。" id="R_1_4_6" impl="GJB8114-R_1_4_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_6.rule"/>
         </rule>
         <rule header="switch 中的 case 和 default 必须以 break 或 return 终止，共用 case 必须加以明确注释" id="R_1_4_7" impl="GJB8114-R_1_4_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_4_7.rule"/>
         </rule>
         <rule header="禁止从复合语句外goto到复合语句内，或由下向上goto。" id="R_1_5_1_a" impl="GJB8114-R_1_5_1_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_1_a.rule"/>
         </rule>
         <rule header="禁止从复合语句外goto到复合语句内，或由下向上goto。" id="R_1_5_1_b" impl="GJB8114-R_1_5_1_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_1_b.rule"/>
         </rule>
         <rule header="禁止使用 setjmp/longjmp。" id="R_1_5_2" impl="GJB8114-R_1_5_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_5_2.rule"/>
         </rule>
         <rule header="禁止将浮点常数赋给整型变量" id="R_1_6_1" impl="GJB8114-R_1_6_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_1.rule"/>
         </rule>
         <rule header="禁止对常数值做逻辑非的运算" id="R_1_6_10" impl="GJB8114-R_1_6_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_10.rule"/>
         </rule>
         <rule header="禁止非枚举类型变量使用枚举类型的值" id="R_1_6_11" impl="GJB8114-R_1_6_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_11.rule"/>
         </rule>
         <rule header="禁止在sizeof中使用赋值" id="R_1_6_13" impl="GJB8114-R_1_6_13" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_13.rule"/>
         </rule>
         <rule header="禁止使用gets函数，应使用fgets函数替代" id="R_1_6_18" impl="GJB8114-R_1_6_18" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_18.rule"/>
         </rule>
         <rule header="禁止将越界整数赋给整型变量" id="R_1_6_2_a" impl="GJB8114-R_1_6_2_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_2_a.rule"/>
         </rule>
         <rule header="禁止将越界整数赋给整型变量" id="R_1_6_2_b" impl="GJB8114-R_1_6_2_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_2_b.rule"/>
         </rule>
         <rule header="禁止在逻辑表达式中使用赋值语句" id="R_1_6_3" impl="GJB8114-R_1_6_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_3.rule"/>
         </rule>
         <rule header="禁止对逻辑表达式进行位运算" id="R_1_6_4" impl="GJB8114-R_1_6_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_4.rule"/>
         </rule>
         <rule header="禁止在运算表达式中或函数调用参数中使用++或--操作符" id="R_1_6_5" impl="GJB8114-R_1_6_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_5.rule"/>
         </rule>
         <rule header="对变量进行移位运算禁止超出变量长度" id="R_1_6_6" impl="GJB8114-R_1_6_6" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_6.rule"/>
         </rule>
         <rule header="禁止移位操作中的移位数为负数" id="R_1_6_7" impl="GJB8114-R_1_6_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_6_7.rule"/>
         </rule>
         <rule header="禁止覆盖标准函数库的函数" id="R_1_7_1" impl="GJB8114-R_1_7_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_1.rule"/>
         </rule>
         <rule header="函数返回值的类型必须与定义一致" id="R_1_7_10" impl="GJB8114-R_1_7_10" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_10.rule"/>
         </rule>
         <rule header="具有返回值的函数，其返回值如果不被使用，调用时应有(void)说明" id="R_1_7_11" impl="GJB8114-R_1_7_11" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_11.rule"/>
         </rule>
         <rule header="无返回值的函数，调用时禁止再用(void)重复说明" id="R_1_7_12" impl="GJB8114-R_1_7_12" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_12.rule"/>
         </rule>
         <rule header="禁止同一个表达式中调用多个顺序相关函数" id="R_1_7_14" impl="GJB8114-R_1_7_14" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_14.rule"/>
         </rule>
         <rule header="禁止在函数参数表中使用省略号" id="R_1_7_15" impl="GJB8114-R_1_7_15" quickfix="false" scope="line" severity="3">
            <file path="GJB8114\GJB8114-R_1_7_15.rule"/>
         </rule>
         <rule header="禁止使用直接或间接自调用函数" id="R_1_7_16" impl="GJB8114-R_1_7_16" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_16.rule"/>
         </rule>
         <rule header="禁止函数的实参和形参类型不一致" id="R_1_7_2" impl="GJB8114-R_1_7_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_2.rule"/>
         </rule>
         <rule header="禁止使用旧形式的函数参数表定义形式" id="R_1_7_4" impl="GJB8114-R_1_7_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_4.rule"/>
         </rule>
         <rule header="函数声明和函数定义中的参数类型必须一致" id="R_1_7_5" impl="GJB8114-R_1_7_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_5.rule"/>
         </rule>
         <rule header="有返回值的函数必须通过返回语句返回" id="R_1_7_7" impl="GJB8114-R_1_7_7" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_7.rule"/>
         </rule>
         <rule header="禁止无返回值函数的返回语句带有返回值" id="R_1_7_8" impl="GJB8114-R_1_7_8" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_8.rule"/>
         </rule>
         <rule header="有返回值函数的返回语句必须带有返回值" id="R_1_7_9" impl="GJB8114-R_1_7_9" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_7_9.rule"/>
         </rule>
         <rule header="在 &quot;else&quot; 语句块中不应存在不可达代码" id="R_1_8_1_a" impl="GJB8114-R_1_8_1_a" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_a.rule"/>
         </rule>
         <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在不可达代码" id="R_1_8_1_b" impl="GJB8114-R_1_8_1_b" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_b.rule"/>
         </rule>
         <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在不可达代码" id="R_1_8_1_c" impl="GJB8114-R_1_8_1_c" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_c.rule"/>
         </rule>
         <rule header="在 Switch 语句中不应存在不可达代码" id="R_1_8_1_d" impl="GJB8114-R_1_8_1_d" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_d.rule"/>
         </rule>
         <rule header="在 'for' 循环中不应存在不可达代码" id="R_1_8_1_e" impl="GJB8114-R_1_8_1_e" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_e.rule"/>
         </rule>
         <rule header="在 'if' 或 'switch' 语句之后不应存在不可达代码" id="R_1_8_1_f" impl="GJB8114-R_1_8_1_f" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_f.rule"/>
         </rule>
         <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在不可达代码" id="R_1_8_1_g" impl="GJB8114-R_1_8_1_g" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_1_g.rule"/>
         </rule>
         <rule header="禁止使用无效语句" id="R_1_8_3" impl="GJB8114-R_1_8_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_3.rule"/>
         </rule>
         <rule header="使用八进制数必须明确注释" id="R_1_8_4" impl="GJB8114-R_1_8_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_4.rule"/>
         </rule>
         <rule header="数字类型后缀必须使用大写字母" id="R_1_8_5" impl="GJB8114-R_1_8_5" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_8_5.rule"/>
         </rule>
         <rule header="for循环控制变量必须使用局部变量" id="R_1_9_1" impl="GJB8114-R_1_9_1" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_1.rule"/>
         </rule>
         <rule header="for循环控制变量必须使用整数型变量" id="R_1_9_2" impl="GJB8114-R_1_9_2" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_2.rule"/>
         </rule>
         <rule header="禁止在for循环体内部修改循环控制变量" id="R_1_9_3" impl="GJB8114-R_1_9_3" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_3.rule"/>
         </rule>
         <rule header="无限循环必须使用while(1)语句，禁止使用for(;;)等其它形式的语句" id="R_1_9_4" impl="GJB8114-R_1_9_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_1_9_4.rule"/>
         </rule>
         <rule header="缺省捕获必须放在所有指定捕获之后" id="R_2_8_4" impl="GJB8114-R_2_8_4" quickfix="false" scope="line" severity="1">
            <file path="GJB8114\GJB8114-R_2_8_4.rule"/>
         </rule>
      </category>
      <category description="High Integrity C++" name="HICPP">
         <category name="12_4_3">
            <rule header="有默认值的非静态成员不能在构造函数初始化列表中使用" id="a" impl="HICPP-12_4_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_4_3-a.rule"/>
            </rule>
         </category>
         <category name="12_5_1">
            <rule header="显式定义 =default or =delete 由编译器隐式提供的具体类的特殊成员函数" id="a" impl="HICPP-12_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-12_5_1-a.rule"/>
            </rule>
         </category>
         <category name="13_2_3">
            <rule header="将二进制算术和位运算符声明为非成员" id="a" impl="HICPP-13_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_3-a.rule"/>
            </rule>
         </category>
         <category name="13_2_4">
            <rule header="重载 [] 运算符函数时，必须同时实现const和非const版本" id="a" impl="HICPP-13_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-13_2_4-a.rule"/>
            </rule>
         </category>
         <category name="15_1_1">
            <rule header="只能使用 std::exception 异常" id="a" impl="HICPP-15_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-15_1_1-a.rule"/>
            </rule>
         </category>
         <category name="16_1_4">
            <rule header="对于系统和标准库头文件，使用&lt;&gt;方括号。对所有其他头文件使用引号" id="a" impl="HICPP-16_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-16_1_4-a.rule"/>
            </rule>
         </category>
         <category name="17_2_1">
            <rule header="包装使用的 C 标准库" id="a" impl="HICPP-17_2_1-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-17_2_1-a.rule"/>
            </rule>
         </category>
         <category name="17_3_4">
            <rule header="不要创建数组类型的智能指针" id="a" impl="HICPP-17_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-17_3_4-a.rule"/>
            </rule>
         </category>
         <category name="18_1_1">
            <rule header="不使用特定平台的多线程工具" id="a" impl="HICPP-18_1_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_1_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_1">
            <rule header="使用 high_integrity::thread 而不是 std::thread" id="a" impl="HICPP-18_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_1-a.rule"/>
            </rule>
         </category>
         <category name="18_2_3">
            <rule header="不要在线程间共享不稳定的数据" id="a" impl="HICPP-18_2_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_2_3-a.rule"/>
            </rule>
         </category>
         <category name="18_3_3">
            <rule header="不要使用std::recursive_mutex" id="a" impl="HICPP-18_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_3-a.rule"/>
            </rule>
         </category>
         <category name="18_3_4">
            <rule header="当 std::lock 守护不能使用时，只使用std::unique lock" id="a" impl="HICPP-18_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_4-a.rule"/>
            </rule>
         </category>
         <category name="18_3_5">
            <rule header="不要直接访问std::mutex" id="a" impl="HICPP-18_3_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_5-a.rule"/>
            </rule>
         </category>
         <category name="18_3_6">
            <rule header="不要使用松弛原子" id="a" impl="HICPP-18_3_6-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_3_6-a.rule"/>
            </rule>
         </category>
         <category name="18_4_1">
            <rule header="不要对std::mutex使用 std::condition_variable_any" id="a" impl="HICPP-18_4_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-18_4_1-a.rule"/>
            </rule>
         </category>
         <category name="1_3_4">
            <rule header="不要使用已弃用的STL库功能" id="a" impl="HICPP-1_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-1_3_4-a.rule"/>
            </rule>
         </category>
         <category name="2_3_2">
            <rule header="不要使用注释来删除部分代码" id="a" impl="HICPP-2_3_2-a" quickfix="false" scope="line" severity="4">
               <file path="HICPP\HICPP-2_3_2-a.rule"/>
            </rule>
         </category>
         <category name="3_3_1">
            <rule header="不要使用具有静态存储期的函数" id="a" impl="HICPP-3_3_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-3_3_1-a.rule"/>
            </rule>
         </category>
         <category name="4_2_1">
            <rule header="将U后缀应用到需要无符号整型表达式的上下文中" id="a" impl="HICPP-4_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-4_2_1-a.rule"/>
            </rule>
         </category>
         <category name="5_1_4">
            <rule header="不要在lambda中隐式地捕获变量" id="a" impl="HICPP-5_1_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_1_4-a.rule"/>
            </rule>
         </category>
         <category name="5_4_2">
            <rule header="不要将表达式转换为枚举类型" id="a" impl="HICPP-5_4_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-5_4_2-a.rule"/>
            </rule>
         </category>
         <category name="7_1_10">
            <rule header="对于涉及编译时常量的断言使用static_assert" id="a" impl="HICPP-7_1_10-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_10-a.rule"/>
            </rule>
         </category>
         <category name="7_1_3">
            <rule header="在声明中不要将类型说明符放在非类型说明符之前" id="a" impl="HICPP-7_1_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_3-a.rule"/>
            </rule>
         </category>
         <category name="7_1_5">
            <rule header="不要内联大型函数" id="a" impl="HICPP-7_1_5-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_5-a.rule"/>
            </rule>
         </category>
         <category name="7_1_6">
            <rule header="使用类类型或typedef来定义标量或标准整数类型" id="b" impl="HICPP-7_1_6-b" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-b.rule"/>
            </rule>
            <rule header="使用class类型或typedef来抽象基础类型" id="c" impl="HICPP-7_1_6-c" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_6-c.rule"/>
            </rule>
         </category>
         <category name="7_1_8">
            <rule header="使用 auto 关键字声明通过函数调用初始化的变量" id="a" impl="HICPP-7_1_8-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_8-a.rule"/>
            </rule>
         </category>
         <category name="7_1_9">
            <rule header="没有显式地指定lambda的返回类型" id="a" impl="HICPP-7_1_9-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_1_9-a.rule"/>
            </rule>
         </category>
         <category name="7_2_1">
            <rule header="使用明确的枚举基础并确保它足够大以存储所有枚举器" id="a" impl="HICPP-7_2_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_1-a.rule"/>
            </rule>
         </category>
         <category name="7_2_2">
            <rule header="初始化枚举中的所有枚举数时，只初始化第一个枚举数，或不初始化枚举数" id="a" impl="HICPP-7_2_2-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_2_2-a.rule"/>
            </rule>
         </category>
         <category name="7_5_1">
            <rule header="不要使用asm声明" id="a" impl="HICPP-7_5_1-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-7_5_1-a.rule"/>
            </rule>
         </category>
         <category name="8_2_4">
            <rule header="不要传递 const 引用类型的 std::unique_ptr 对象" id="a" impl="HICPP-8_2_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_2_4-a.rule"/>
            </rule>
         </category>
         <category name="8_3_3">
            <rule header="不要使用缺省参数" id="a" impl="HICPP-8_3_3-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_3-a.rule"/>
            </rule>
         </category>
         <category name="8_3_4">
            <rule header="将有 const 参数的 rvalue 引用函数定义为 =delete" id="a" impl="HICPP-8_3_4-a" quickfix="false" scope="line" severity="3">
               <file path="HICPP\HICPP-8_3_4-a.rule"/>
            </rule>
         </category>
      </category>
      <category description="初始化" name="INIT">
         <rule header="头文件中不应该初始化带有external链接类型的对象" id="01" impl="INIT-01" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-01.rule"/>
         </rule>
         <rule header="不能用有符号常量初始化无符号整型变量" id="02" impl="INIT-02" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-02.rule"/>
         </rule>
         <rule header="初始化所有变量" id="03" impl="INIT-03" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-03.rule"/>
         </rule>
         <rule header="初始化所有指针变量" id="04" impl="INIT-04" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-04.rule"/>
         </rule>
         <rule header="不要初始化对地址可以更改的对象的引用" id="05" impl="INIT-05" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-05.rule"/>
         </rule>
         <rule header="所有成员变量都应该在构造函数中初始化" id="06" impl="INIT-06" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-06.rule"/>
         </rule>
         <rule header="通过用户自定义的构造函数显式初始化类成员" id="07" impl="INIT-07" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-07.rule"/>
         </rule>
         <rule header="用户自定义的构造函数必须初始化动态分配的类对象" id="08" impl="INIT-08" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-08.rule"/>
         </rule>
         <rule header="初始化类的静态成员变量" id="09" impl="INIT-09" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-09.rule"/>
         </rule>
         <rule header="在初始化列表中按声明成员的顺序列出成员" id="10" impl="INIT-10" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-10.rule"/>
         </rule>
         <rule header="赋值运算符应赋值所有数据成员" id="11" impl="INIT-11" quickfix="false" scope="line" severity="2">
            <file path="INIT\INIT-11.rule"/>
         </rule>
         <rule header="通过用局部静态对象替换非局部静态对象来避免跨越编译单元的初始化顺序问题" id="12" impl="INIT-12" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-12.rule"/>
         </rule>
         <rule header="不能假设在构造函数中成员的初始化顺序" id="13" impl="INIT-13" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用未初始化的非静态成员变量" id="13_a" impl="INIT-13_a" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_a.rule"/>
         </rule>
         <rule header="不要在虚拟基类构造函数中使用非虚拟基类未初始化的非静态成员变量" id="13_b" impl="INIT-13_b" quickfix="false" scope="line" severity="1">
            <file path="INIT\INIT-13_b.rule"/>
         </rule>
         <rule header="禁止在基类构造函数中使用基类的可能未初始化的非静态成员变量" id="13_c" impl="INIT-13_c" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-13_c.rule"/>
         </rule>
         <rule header="构造函数中推荐使用初始化列表而非赋值" id="14" impl="INIT-14" quickfix="false" scope="line" severity="5">
            <file path="INIT\INIT-14.rule"/>
         </rule>
         <rule header="考虑添加构造函数来初始化 'struct' 结构体成员变量" id="15" impl="INIT-15" quickfix="false" scope="line" severity="4">
            <file path="INIT\INIT-15.rule"/>
         </rule>
         <rule header="集合或联合的初始化程序应放在大括号中" id="16" impl="INIT-16" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-16.rule"/>
         </rule>
         <rule header="在所有构造函数中,使用相同常量值初始化数据成员的用户定义的构造函数应使用NSDMI进行初始化" id="17" impl="INIT-17" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-17.rule"/>
         </rule>
         <rule header="用户定义的构造函数如果在所有构造函数中用相同的常量值初始化数据成员，应该使用NSDMI进行初始化" id="17_b" impl="INIT-17_b" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-17_b.rule"/>
         </rule>
         <rule header="构造函数中的 NSDMI 和非静态成员的初始化不能在同一类型中使用" id="18" impl="INIT-18" quickfix="false" scope="line" severity="3">
            <file path="INIT\INIT-18.rule"/>
         </rule>
      </category>
      <category description="度量指标" name="METRICS">
         <rule header="避免函数超过 50 行" id="01" impl="METRICS-01" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-01.rule"/>
         </rule>
         <rule header="避免 switch 代码段包含过多 case" id="02" impl="METRICS-02" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-02.rule"/>
         </rule>
         <rule header="函数内的代码块" id="03" impl="METRICS-03" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-03.rule"/>
         </rule>
         <rule header="函数中有过多函数调用" id="04" impl="METRICS-04" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-04.rule"/>
         </rule>
         <rule header="类的继承级别" id="05" impl="METRICS-05" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-05.rule"/>
         </rule>
         <rule header="每个函数的成员变量数不应该超过 15个" id="06" impl="METRICS-06" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-06.rule"/>
         </rule>
         <rule header="每个类的方法数" id="07" impl="METRICS-07" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-07.rule"/>
         </rule>
         <rule header="每个方法参数不应该超过10" id="08" impl="METRICS-08" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-08.rule"/>
         </rule>
         <rule header="每个类的私有成员变量数目" id="09" impl="METRICS-09" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-09.rule"/>
         </rule>
         <rule header="每个类的私有方法数" id="10" impl="METRICS-10" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-10.rule"/>
         </rule>
         <rule header="每个类的 protected 成员变量数" id="11" impl="METRICS-11" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-11.rule"/>
         </rule>
         <rule header="每个类的 protected 方法的数量" id="12" impl="METRICS-12" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-12.rule"/>
         </rule>
         <rule header="每个类的公共成员变量数目" id="13" impl="METRICS-13" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-13.rule"/>
         </rule>
         <rule header="每个类的公共方法数目" id="14" impl="METRICS-14" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-14.rule"/>
         </rule>
         <rule header="避免函数的参数数目超过5个" id="15" impl="METRICS-15" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-15.rule"/>
         </rule>
         <rule header="宏参数应该不超过 5个" id="16" impl="METRICS-16" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-16.rule"/>
         </rule>
         <rule header="避免 structs, unions, 或类有超过20个范围" id="17" impl="METRICS-17" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-17.rule"/>
         </rule>
         <rule header="将圈复杂度限制在 10 之内" id="18" impl="METRICS-18" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-18.rule"/>
         </rule>
         <rule header="注释行占模块行总数的百分比应该在 20 到 60 之间" id="19" impl="METRICS-19" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-19.rule"/>
         </rule>
         <rule header="避免太长的函数声明和代码段" id="20" impl="METRICS-20" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-20.rule"/>
         </rule>
         <rule header="避免太长的函数块" id="21" impl="METRICS-21" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-21.rule"/>
         </rule>
         <rule header="避免函数的行数超过75行" id="22" impl="METRICS-22" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-22.rule"/>
         </rule>
         <rule header="嵌套块深度不应高于 5" id="23" impl="METRICS-23" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-23.rule"/>
         </rule>
         <rule header="避免超过 500 行的源代码" id="24" impl="METRICS-24" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-24.rule"/>
         </rule>
         <rule header="任何函数或方法应该不包含超过200行的逻辑代码行数 (L-SLOC)" id="25" impl="METRICS-25" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-25.rule"/>
         </rule>
         <rule header="源代码行的长度不得超过120个字符" id="26" impl="METRICS-26" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-26.rule"/>
         </rule>
         <rule header="不要使用多于 7 个参数的函数" id="27" impl="METRICS-27" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-27.rule"/>
         </rule>
         <rule header="限制圈复杂度在 20 之内" id="28" impl="METRICS-28" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-28.rule"/>
         </rule>
         <rule header="报告圈复杂度" id="29" impl="METRICS-29" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-29.rule"/>
         </rule>
         <rule header="函数不应该超过 60 行代码" id="30" impl="METRICS-30" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-30.rule"/>
         </rule>
         <rule header="代码的断言密度应至少平均每个函数两个断言" id="31" impl="METRICS-31" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-31.rule"/>
         </rule>
         <rule header="所有超过 20 行的函数应该包含至少两个断言" id="32" impl="METRICS-32" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-32.rule"/>
         </rule>
         <rule header="报告基本复杂度" id="33" impl="METRICS-33" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-33.rule"/>
         </rule>
         <rule header="遵守基本复杂度为 4 的限制" id="34" impl="METRICS-34" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-34.rule"/>
         </rule>
         <rule header="遵守基本复杂度为 10 的限制" id="35" impl="METRICS-35" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-35.rule"/>
         </rule>
         <rule header="不应从超过 5 个的不同函数中调用全局函数" id="36" impl="METRICS-36" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-36.rule"/>
         </rule>
         <rule header="函数不得调用超过 7 个不同的函数" id="37" impl="METRICS-37" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-37.rule"/>
         </rule>
         <rule header="函数中的语句数量应该介于 1-50 的范围之间" id="38" impl="METRICS-38" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-38.rule"/>
         </rule>
         <rule header="函数的 VOCF 度量指标值不应该高于 4" id="39" impl="METRICS-39" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-39.rule"/>
         </rule>
         <rule header="函数内的语句不应嵌套超过 4 个级别" id="40" impl="METRICS-40" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-40.rule"/>
         </rule>
         <rule header="函数前面和内部的注释模块的数量与函数内语句的数量之比应该 &gt; 0.2" id="41" impl="METRICS-41" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-41.rule"/>
         </rule>
         <rule header="遵循基本复杂度为 1 的限制" id="42" impl="METRICS-42" quickfix="false" scope="line" severity="5">
            <file path="METRICS\METRICS-42.rule"/>
         </rule>
         <rule header="报告函数的霍尔斯特德交付错误 (B) 值" id="43" impl="METRICS-43" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-43.rule"/>
         </rule>
         <rule header="函数中的执行路径数不应大于80" id="44" impl="METRICS-44" quickfix="false" scope="line" severity="3">
            <file path="METRICS\METRICS-44.rule"/>
         </rule>
      </category>
      <category description="MISRA C 1998" name="MISRA">
         <rule header="应当作出适当的运行时检查的规定" id="004_a" impl="MISRA-004_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_a.rule"/>
         </rule>
         <rule header="应当作出适当的运行时检查的规定" id="004_b" impl="MISRA-004_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-004_b.rule"/>
         </rule>
         <rule header="只使用 ISO C 标准中定义的字符" id="005" impl="MISRA-005" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-005.rule"/>
         </rule>
         <rule header="字符类型值必须是严格定义和记录的 ISO 10646-1 标准的子集" id="006" impl="MISRA-006" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-006.rule"/>
         </rule>
         <rule header="不要使用宽字符串字面量" id="008" impl="MISRA-008" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-008.rule"/>
         </rule>
         <rule header="不应该使用 char, int, short, long, float 和 double 的基本类型, 而是应该用 typedef 来定义特定长度的等效类型" id="013" impl="MISRA-013" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-013.rule"/>
         </rule>
         <rule header="显式地声明 'char' 类型为有符号类型或者无符号类型" id="014" impl="MISRA-014" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-014.rule"/>
         </rule>
         <rule header="不得使用浮点型数向下转换表示" id="016" impl="MISRA-016" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-016.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_a" impl="MISRA-018_a" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_a.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_b" impl="MISRA-018_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_b.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_c" impl="MISRA-018_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_c.rule"/>
         </rule>
         <rule header="数字常量必须使用类型后缀" id="018_d" impl="MISRA-018_d" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-018_d.rule"/>
         </rule>
         <rule header="所有对象和函数必须先声明再使用" id="020" impl="MISRA-020" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-020.rule"/>
         </rule>
         <rule header="在函数范围内声明对象" id="022" impl="MISRA-022" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-022.rule"/>
         </rule>
         <rule header="应该在头文件中声明具有外部链接的对象或函数" id="023" impl="MISRA-023" quickfix="false" scope="line" severity="4">
            <file path="MISRA\MISRA-023.rule"/>
         </rule>
         <rule header="标识符在同一编译单元中不能同时具有内部和外部链接" id="024" impl="MISRA-024" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-024.rule"/>
         </rule>
         <rule header="外部对象不得声明在多个文件中" id="027" impl="MISRA-027" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027.rule"/>
         </rule>
         <rule header="外部对象不应该在实现文件中声明" id="027_b" impl="MISRA-027_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-027_b.rule"/>
         </rule>
         <rule header="不应使用'register'存储类说明符" id="028" impl="MISRA-028" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-028.rule"/>
         </rule>
         <rule header="标签的使用应当与其声明一致" id="029" impl="MISRA-029" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-029.rule"/>
         </rule>
         <rule header="所有自动变量在使用之前都必须被赋值" id="030" impl="MISRA-030" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-030.rule"/>
         </rule>
         <rule header="文件整数除法" id="041" impl="MISRA-041" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-041.rule"/>
         </rule>
         <rule header="除了在 FOR 循环的控制表达式之外，不得使用逗号运算符" id="042" impl="MISRA-042" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-042.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从较宽到较窄的整数类型的隐式转换" id="043" impl="MISRA-043" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043.rule"/>
         </rule>
         <rule header="避免在同一个表达式中混合使用不同精度的算术运算" id="043_b" impl="MISRA-043_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_b.rule"/>
         </rule>
         <rule header="不应使用可能导致信息丢失的从整型到浮点型的隐式转换" id="043_c" impl="MISRA-043_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_c.rule"/>
         </rule>
         <rule header="不应使用可能会导致信息丢失的从整数常量到浮点类型的隐式转换" id="043_d" impl="MISRA-043_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-043_d.rule"/>
         </rule>
         <rule header="不要使用 volatile 关键字" id="046_a" impl="MISRA-046_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_a.rule"/>
         </rule>
         <rule header="赋值语句不应该嵌套使用在赋值语句中" id="046_b" impl="MISRA-046_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-046_b.rule"/>
         </rule>
         <rule header="避免在将结果转换为更广泛的整数类型的表达式中可能出现的整数溢出" id="048_a" impl="MISRA-048_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_a.rule"/>
         </rule>
         <rule header="不要将两个整数的被除数强制类型转换为一个浮点类型" id="048_b" impl="MISRA-048_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-048_b.rule"/>
         </rule>
         <rule header="空语句只能单独一行出现" id="054" impl="MISRA-054" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-054.rule"/>
         </rule>
         <rule header="避免使用标签" id="055" impl="MISRA-055" quickfix="false" scope="line" severity="5">
            <file path="MISRA\MISRA-055.rule"/>
         </rule>
         <rule header="请勿使用 break 语句" id="058" impl="MISRA-058" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-058.rule"/>
         </rule>
         <rule header="不得使用浮点变量作为循环计数器" id="065" impl="MISRA-065" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-065.rule"/>
         </rule>
         <rule header="避免使用有可变数量参数的函数" id="069" impl="MISRA-069" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-069.rule"/>
         </rule>
         <rule header="函数应该有函数原型并且该原型应该对函数定义和调用可见" id="071_a" impl="MISRA-071_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_a.rule"/>
         </rule>
         <rule header="在函数调用时，函数总是有可见的原型" id="071_b" impl="MISRA-071_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-071_b.rule"/>
         </rule>
         <rule header="函数的参数要么不提供标识符要么提供所有标识符" id="073" impl="MISRA-073" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-073.rule"/>
         </rule>
         <rule header="非 void 函数的返回语句必须提供表达式" id="083" impl="MISRA-083" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-083.rule"/>
         </rule>
         <rule header="避免 void 函数中存在 return 语句表达式。" id="084" impl="MISRA-084" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-084.rule"/>
         </rule>
         <rule header="#include 指令后面应当添加 &lt;filename&gt; 或是 &quot;filename&quot;" id="089" impl="MISRA-089" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-089.rule"/>
         </rule>
         <rule header="必须把类函数形式的宏定义放进括号中" id="096" impl="MISRA-096" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-096.rule"/>
         </rule>
         <rule header="只能使用没有歧义性的预处理操作符格式" id="100" impl="MISRA-100" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-100.rule"/>
         </rule>
         <rule header="不应该使用指针算法" id="101" impl="MISRA-101" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-101.rule"/>
         </rule>
         <rule header="不要使用非常量指针指向函数" id="104" impl="MISRA-104" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-104.rule"/>
         </rule>
         <rule header="函数指针应该与其指向的所有函数的参数个数，参数类型和返回值类型相同" id="105" impl="MISRA-105" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-105.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="107_a" impl="MISRA-107_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_a.rule"/>
         </rule>
         <rule header="空指针不应取消引用" id="107_b" impl="MISRA-107_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-107_b.rule"/>
         </rule>
         <rule header="结构体和联合体中的所有成员必须完全指定" id="108" impl="MISRA-108" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-108.rule"/>
         </rule>
         <rule header="不能使用联合体访问大数据结构的子部分" id="110" impl="MISRA-110" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-110.rule"/>
         </rule>
         <rule header="结构体或联合体或类的所有成员变量应该被命名" id="113" impl="MISRA-113" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-113.rule"/>
         </rule>
         <rule header="不得重复使用标准库函数的名称" id="115" impl="MISRA-115" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-115.rule"/>
         </rule>
         <rule header="不要使用 setlocale 函数" id="121_a" impl="MISRA-121_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_a.rule"/>
         </rule>
         <rule header="不应包含 &lt;locale.h&gt; 头文件" id="121_b" impl="MISRA-121_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA\MISRA-121_b.rule"/>
         </rule>
      </category>
      <category description="MISRA C 2004" name="MISRA2004">
         <rule header="避免在有符号和无符号整数类型之间进行隐式转换" id="10_1_a" impl="MISRA2004-10_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_a.rule"/>
         </rule>
         <rule header="不存在从整型到浮点型的隐式转换" id="10_1_b" impl="MISRA2004-10_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_b.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的数据类型转换" id="10_1_c" impl="MISRA2004-10_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_c.rule"/>
         </rule>
         <rule header="避免从更宽到更窄的类型的隐式转换" id="10_1_d" impl="MISRA2004-10_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_d.rule"/>
         </rule>
         <rule header="避免隐式的函数返回表达式类型转换" id="10_1_e" impl="MISRA2004-10_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_e.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的类型转换" id="10_1_f" impl="MISRA2004-10_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_f.rule"/>
         </rule>
         <rule header="避免函数参数进行隐式地类型转换" id="10_1_g" impl="MISRA2004-10_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_g.rule"/>
         </rule>
         <rule header="避免隐式的复合表达式的数据类型转换" id="10_1_i" impl="MISRA2004-10_1_i" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_1_i.rule"/>
         </rule>
         <rule header="避免从浮点类型到整型的隐式转换" id="10_2_a" impl="MISRA2004-10_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_a.rule"/>
         </rule>
         <rule header="避免宽字段到窄字段浮点型数据的隐式转换" id="10_2_b" impl="MISRA2004-10_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_b.rule"/>
         </rule>
         <rule header="避免隐式的窄字段到宽字段浮点型数据转换" id="10_2_c" impl="MISRA2004-10_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_c.rule"/>
         </rule>
         <rule header="避免将浮点数从较宽的浮点类型隐式转换为较窄的浮点类型" id="10_2_d" impl="MISRA2004-10_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_2_d.rule"/>
         </rule>
         <rule header="整型复合表达式的值只能被强制转换到较短的类型，或者与该表达式类型相同的有符号类型" id="10_3" impl="MISRA2004-10_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_3.rule"/>
         </rule>
         <rule header="如果对无符号字符型或无符号短整型进行 ~  和 &lt;&lt; 位运算后，其结果应立即强制转换成操作数的基本类型" id="10_5" impl="MISRA2004-10_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-10_5.rule"/>
         </rule>
         <rule header="无符号类型的所有常量应该使用 'U' 后缀" id="10_6" impl="MISRA2004-10_6" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-10_6.rule"/>
         </rule>
         <rule header="除了整数类型外不允许其他类型和函数指针进行类型转换" id="11_1" impl="MISRA2004-11_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_1.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2" impl="MISRA2004-11_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2_b" impl="MISRA2004-11_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_b.rule"/>
         </rule>
         <rule header="对象指针只能被转换成整数类型，与对象同类型的指针和 void 指针" id="11_2_c" impl="MISRA2004-11_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_2_c.rule"/>
         </rule>
         <rule header="不允许指针类型和整数类型之间进行类型转换" id="11_3_a" impl="MISRA2004-11_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_a.rule"/>
         </rule>
         <rule header="不应在指针类型和整数类型之间进行转换" id="11_3_b" impl="MISRA2004-11_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_3_b.rule"/>
         </rule>
         <rule header="不应在指向对象类型的指针和指向对象类型的其他指针之间执行强制转换" id="11_4" impl="MISRA2004-11_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_4.rule"/>
         </rule>
         <rule header="强制转换不得从指针或引用类型中删除任何“const”或“volatile”限定条件" id="11_5" impl="MISRA2004-11_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-11_5.rule"/>
         </rule>
         <rule header="不应该使用逗号运算符" id="12_10" impl="MISRA2004-12_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_10.rule"/>
         </rule>
         <rule header="禁止对浮点数值进行位操作" id="12_12" impl="MISRA2004-12_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_12.rule"/>
         </rule>
         <rule header="禁止在同一个表达式中混合使用递加符 (++) 和递减符 (--) 与其他运算符" id="12_13" impl="MISRA2004-12_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_13.rule"/>
         </rule>
         <rule header="当赋值运算符包含赋值表达式时，将括号用于赋值运算符的右侧操作数" id="12_1_a" impl="MISRA2004-12_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_a.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_b" impl="MISRA2004-12_1_b" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_b.rule"/>
         </rule>
         <rule header="一元运算符的操作数不需要括号" id="12_1_c" impl="MISRA2004-12_1_c" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_c.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_d" impl="MISRA2004-12_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_d.rule"/>
         </rule>
         <rule header="除非表达式中的所有运算符都相同，否则使用圆括号" id="12_1_e" impl="MISRA2004-12_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_1_e.rule"/>
         </rule>
         <rule header="谨慎使用 C 语言中表达式的优先运算规则" id="12_1_f" impl="MISRA2004-12_1_f" quickfix="false" scope="line" severity="5">
            <file path="MISRA2004\MISRA2004-12_1_f.rule"/>
         </rule>
         <rule header="表达式的值应该在任何标准允许的赋值顺序下是一样的" id="12_2_a" impl="MISRA2004-12_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_a.rule"/>
         </rule>
         <rule header="不要编写依赖于函数参数求值顺序的代码" id="12_2_b" impl="MISRA2004-12_2_b" quickfix="false" scope="line" severity="1">
            <file path="MISRA2004\MISRA2004-12_2_b.rule"/>
         </rule>
         <rule header="不要编写依赖于函数标志符和函数参数的求值顺序的代码" id="12_2_c" impl="MISRA2004-12_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_c.rule"/>
         </rule>
         <rule header="涉及一个函数调用时，不要编写依赖表达式求值顺序的代码" id="12_2_d" impl="MISRA2004-12_2_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_d.rule"/>
         </rule>
         <rule header="在序列点之间，对象的存储值最多只能通过表达式的评估来修改一次" id="12_2_e" impl="MISRA2004-12_2_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_e.rule"/>
         </rule>
         <rule header="不要在两个相邻的序列点之间使用多个 volatile" id="12_2_f" impl="MISRA2004-12_2_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_f.rule"/>
         </rule>
         <rule header="不要编写依赖于函数调用求值顺序的代码" id="12_2_g" impl="MISRA2004-12_2_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_2_g.rule"/>
         </rule>
         <rule header="sizeof 运算符的操作数不应包含任何有副作用的表达式" id="12_3" impl="MISRA2004-12_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3.rule"/>
         </rule>
         <rule header="不应在sizeof运算符的操作数中访问由volatile左值指定的对象" id="12_3_b" impl="MISRA2004-12_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_b.rule"/>
         </rule>
         <rule header="会导致副作用的函数调用不应该用作 sizeof 运算符的操作数" id="12_3_c" impl="MISRA2004-12_3_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_3_c.rule"/>
         </rule>
         <rule header="逻辑&amp;&amp;或||运算符的右操作数不得含有副作用" id="12_4_a" impl="MISRA2004-12_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_4_a.rule"/>
         </rule>
         <rule header="逻辑运算符 &amp;&amp; 或者 || 的操作数应该是基本表达式" id="12_5" impl="MISRA2004-12_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_5.rule"/>
         </rule>
         <rule header="逻辑运算符 (&amp;&amp;, || 和 !) 的操作数应该是有效的布尔值" id="12_6_a" impl="MISRA2004-12_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_a.rule"/>
         </rule>
         <rule header="有效布尔值的表达式不应该用作除 (&amp;&amp;, ||, !, =, ==, !=, ?:) 之外的运算符的操作数。" id="12_6_b" impl="MISRA2004-12_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_6_b.rule"/>
         </rule>
         <rule header="禁止对有符号类型使用位操作" id="12_7" impl="MISRA2004-12_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_7.rule"/>
         </rule>
         <rule header="一个移位操作符的右操作数应该位于 0 与左操作数底层类型的位宽减 1之间" id="12_8" impl="MISRA2004-12_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_8.rule"/>
         </rule>
         <rule header="一元减法运算符不得适用于其原始类型是无符号型的表达式" id="12_9" impl="MISRA2004-12_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-12_9.rule"/>
         </rule>
         <rule header="禁止在产生布尔值的表达式中使用赋值运算符" id="13_1" impl="MISRA2004-13_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_1.rule"/>
         </rule>
         <rule header="测试一个值是否为零应该是显式的，除非操作数实际上是布尔值" id="13_2" impl="MISRA2004-13_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_2.rule"/>
         </rule>
         <rule header="禁止对浮点数类型的表达式做相等或不相等的比较" id="13_3" impl="MISRA2004-13_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_3.rule"/>
         </rule>
         <rule header="for 循环语句中的控制表达式不能包含浮点类型对象" id="13_4" impl="MISRA2004-13_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_4.rule"/>
         </rule>
         <rule header="for 循环语句的三个表达式应该仅与循环控制相关" id="13_5" impl="MISRA2004-13_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_5.rule"/>
         </rule>
         <rule header="禁止在循环体中修改循环计数器" id="13_6" impl="MISRA2004-13_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_6.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_a" impl="MISRA2004-13_7_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_a.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_aa" impl="MISRA2004-13_7_aa" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aa.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ab" impl="MISRA2004-13_7_ab" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ab.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ac" impl="MISRA2004-13_7_ac" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ac.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ad" impl="MISRA2004-13_7_ad" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ad.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ae" impl="MISRA2004-13_7_ae" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ae.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_af" impl="MISRA2004-13_7_af" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_af.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ag" impl="MISRA2004-13_7_ag" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ag.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ah" impl="MISRA2004-13_7_ah" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ah.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ai" impl="MISRA2004-13_7_ai" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ai.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_aj" impl="MISRA2004-13_7_aj" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_aj.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_ak" impl="MISRA2004-13_7_ak" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_ak.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_b" impl="MISRA2004-13_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_b.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_c" impl="MISRA2004-13_7_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_c.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_d" impl="MISRA2004-13_7_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_d.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_j" impl="MISRA2004-13_7_j" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_j.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_k" impl="MISRA2004-13_7_k" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_k.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_l" impl="MISRA2004-13_7_l" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_l.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_m" impl="MISRA2004-13_7_m" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_m.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_n" impl="MISRA2004-13_7_n" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_n.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_s" impl="MISRA2004-13_7_s" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_s.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_t" impl="MISRA2004-13_7_t" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_t.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_u" impl="MISRA2004-13_7_u" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_u.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_v" impl="MISRA2004-13_7_v" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_v.rule"/>
         </rule>
         <rule header="不允许结果不变的布尔运算" id="13_7_w" impl="MISRA2004-13_7_w" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_w.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_x" impl="MISRA2004-13_7_x" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_x.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_y" impl="MISRA2004-13_7_y" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_y.rule"/>
         </rule>
         <rule header="不允许其结果是不变的布尔运算" id="13_7_z" impl="MISRA2004-13_7_z" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-13_7_z.rule"/>
         </rule>
         <rule header="所有 'if...else-if' 结构应使用一个 'else' 子句终止" id="14_10" impl="MISRA2004-14_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_10.rule"/>
         </rule>
         <rule header="在 &quot;else&quot; 语句块中不应存在执行不到的代码" id="14_1_a" impl="MISRA2004-14_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_a.rule"/>
         </rule>
         <rule header="在 'return', 'break', 'continue', 和 'goto' 语句之后不应存在执行不到的代码" id="14_1_b" impl="MISRA2004-14_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_b.rule"/>
         </rule>
         <rule header="在 &quot;if/else/while/for&quot; 语句块中不应存在执行不到的代码" id="14_1_c" impl="MISRA2004-14_1_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_c.rule"/>
         </rule>
         <rule header="在 switch 语句中不应存在执行不到的代码" id="14_1_d" impl="MISRA2004-14_1_d" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_d.rule"/>
         </rule>
         <rule header="在 'for' 循环中不应存在执行不到的代码" id="14_1_e" impl="MISRA2004-14_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_e.rule"/>
         </rule>
         <rule header="在 'if' 或 'switch' 语句后不应存在不可访问的代码" id="14_1_f" impl="MISRA2004-14_1_f" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_f.rule"/>
         </rule>
         <rule header="在 while/for/do...while 循环内的 &quot;if&quot; 或 &quot;switch&quot; 语句后不应存在执行不到的代码" id="14_1_g" impl="MISRA2004-14_1_g" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_1_g.rule"/>
         </rule>
         <rule header="所有非 null 语句无论如何执行都至少有一个副作用，或者导致控制流发生变化" id="14_2" impl="MISRA2004-14_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_2.rule"/>
         </rule>
         <rule header="空语句应单独一行出现，或其后跟有注释" id="14_3" impl="MISRA2004-14_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_3.rule"/>
         </rule>
         <rule header="不应该使用 goto 语句" id="14_4" impl="MISRA2004-14_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_4.rule"/>
         </rule>
         <rule header="不要使用 continue 语句" id="14_5" impl="MISRA2004-14_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_5.rule"/>
         </rule>
         <rule header="对任何循环语句，最多不应超过一个 break 语句用于循环终止" id="14_6" impl="MISRA2004-14_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_6.rule"/>
         </rule>
         <rule header="函数末端应只提供一个出口点" id="14_7" impl="MISRA2004-14_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_7.rule"/>
         </rule>
         <rule header="'switch', 'while', 'do...while' 或 'for' 语句的主体应该是复合语句" id="14_8" impl="MISRA2004-14_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_8.rule"/>
         </rule>
         <rule header="'if' 和 'else' 语句后应跟一个复合句" id="14_9" impl="MISRA2004-14_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-14_9.rule"/>
         </rule>
         <rule header="break 语句应只出现在 switch 子句末端" id="15_0_a" impl="MISRA2004-15_0_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_a.rule"/>
         </rule>
         <rule header="switch 语句应该只包含 switch 标签和 switch 子句，不能包含其他代码" id="15_0_b" impl="MISRA2004-15_0_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_0_b.rule"/>
         </rule>
         <rule header="只有当最紧密包围的复合语句是 switch 语句的主体时才能使用 switch 标签" id="15_1" impl="MISRA2004-15_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_1.rule"/>
         </rule>
         <rule header="无条件的 break 语句应该作为每一个非空 case 子句的结束" id="15_2" impl="MISRA2004-15_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2.rule"/>
         </rule>
         <rule header="无条件的 break 语句应作为所有非空 default 条件的结束" id="15_2_b" impl="MISRA2004-15_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_2_b.rule"/>
         </rule>
         <rule header="switch 语句中最后一个子句必须为 default 子句" id="15_3" impl="MISRA2004-15_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_3.rule"/>
         </rule>
         <rule header="switch 表达式不应该出现一个实际为布尔的值" id="15_4" impl="MISRA2004-15_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4.rule"/>
         </rule>
         <rule header="switch 表达式不应该出现一个实际为布尔的值" id="15_4_b" impl="MISRA2004-15_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_4_b.rule"/>
         </rule>
         <rule header="每一个 switch 语句至少有一个 case 子句" id="15_5" impl="MISRA2004-15_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-15_5.rule"/>
         </rule>
         <rule header="函数不应使用可变数量的参数定义" id="16_1" impl="MISRA2004-16_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_1.rule"/>
         </rule>
         <rule header="如果函数返回了错误信息，那么错误信息应该进行测试" id="16_10" impl="MISRA2004-16_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_10.rule"/>
         </rule>
         <rule header="函数不应该直接或者间接地调用自己" id="16_2" impl="MISRA2004-16_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_2.rule"/>
         </rule>
         <rule header="在函数原型声明中应该为所有参数提供标识符" id="16_3" impl="MISRA2004-16_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_3.rule"/>
         </rule>
         <rule header="禁止函数声明中使用的标识符与实际定义中的标识符不一致" id="16_4" impl="MISRA2004-16_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_4.rule"/>
         </rule>
         <rule header="没有参数的函数必须声明参数类型为 void" id="16_5" impl="MISRA2004-16_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_5.rule"/>
         </rule>
         <rule header="传递给函数的参数个数必须与函数定义的参数一致" id="16_6" impl="MISRA2004-16_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_6.rule"/>
         </rule>
         <rule header="如果函数参数中指针参数在函数中不用来修改地址对象，则应声明为常量类型" id="16_7" impl="MISRA2004-16_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7.rule"/>
         </rule>
         <rule header="如果指针不用于修改指向地址的对象则声明参数的类型为 typedef 的 const 指针" id="16_7_b" impl="MISRA2004-16_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_7_b.rule"/>
         </rule>
         <rule header="具有非空返回类型的函数的所有退出路径都应该有一个带有表达式的显式返回语句" id="16_8" impl="MISRA2004-16_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8.rule"/>
         </rule>
         <rule header="具有非 void 返回类型的函数的所有退出路径，除 main() 外，都应具有带有表达式的显式返回语句" id="16_8_b" impl="MISRA2004-16_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_8_b.rule"/>
         </rule>
         <rule header="函数标识符只能与前面的  '&amp;' 一起使用，或者与括号中的参数列表一起使用，参数列表可以是空的" id="16_9" impl="MISRA2004-16_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-16_9.rule"/>
         </rule>
         <rule header="不要对那些没有指向数组或数组元素地址的指针进行指针运算" id="17_1" impl="MISRA2004-17_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_1.rule"/>
         </rule>
         <rule header="只有数组索引才能进行算术指针操作" id="17_4" impl="MISRA2004-17_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_4.rule"/>
         </rule>
         <rule header="对象的声明应该包含不超过 2 层的指针嵌套" id="17_5" impl="MISRA2004-17_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_5.rule"/>
         </rule>
         <rule header="不得从函数中返回具有自动存储的对象的地址" id="17_6_a" impl="MISRA2004-17_6_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_a.rule"/>
         </rule>
         <rule header="自动存储对象的地址不应分配给在第一个对象不再存在后可能持久存在的另一个对象" id="17_6_b" impl="MISRA2004-17_6_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-17_6_b.rule"/>
         </rule>
         <rule header="在转换单元结束之前，所有的结构体和联合体必须有完整的声明" id="18_1" impl="MISRA2004-18_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_1.rule"/>
         </rule>
         <rule header="不应该将结构体自身的一个成员变量赋给另一个成员变量" id="18_2" impl="MISRA2004-18_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2.rule"/>
         </rule>
         <rule header="结构体的每个成员不应该赋值给自己的其他成员变量" id="18_2_b" impl="MISRA2004-18_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_2_b.rule"/>
         </rule>
         <rule header="禁止使用联合体" id="18_4" impl="MISRA2004-18_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-18_4.rule"/>
         </rule>
         <rule header="#include 之前只允许有预处理命令和注释" id="19_1" impl="MISRA2004-19_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_1.rule"/>
         </rule>
         <rule header="在类函数宏指令的定义中，参数的每个实例都应该用圆括号括起来，除非它用作 # 或者 ## 的运算对象" id="19_10" impl="MISRA2004-19_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_10.rule"/>
         </rule>
         <rule header="不要使用在编译单元中未定义的预编译器指令 #if 和 #elif  宏" id="19_11_b" impl="MISRA2004-19_11_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_11_b.rule"/>
         </rule>
         <rule header="禁止宏定义中使用多个 # 和 ##" id="19_12" impl="MISRA2004-19_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_12.rule"/>
         </rule>
         <rule header="禁止使用预处理操作符 # 和 ##" id="19_13" impl="MISRA2004-19_13" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_13.rule"/>
         </rule>
         <rule header="预处理操作符只能用在两种标准格式之一" id="19_14" impl="MISRA2004-19_14" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_14.rule"/>
         </rule>
         <rule header="必须采取预防措施以防止头文件的内容被引用两次" id="19_15" impl="MISRA2004-19_15" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_15.rule"/>
         </rule>
         <rule header="预处理指令即使被预处理程序排除,在语法上也是有意义的" id="19_16" impl="MISRA2004-19_16" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_16.rule"/>
         </rule>
         <rule header="在同一个文件中 #else, #elif 和 #endif 必须对应有 #if 或 #ifdef 预处理指令" id="19_17" impl="MISRA2004-19_17" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_17.rule"/>
         </rule>
         <rule header="非标准字符不应该用于 #include 指令的头文件名称中" id="19_2" impl="MISRA2004-19_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_2.rule"/>
         </rule>
         <rule header="避免宏定义中存在关键字和基本类型" id="19_4" impl="MISRA2004-19_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_4.rule"/>
         </rule>
         <rule header="禁止在块中使用 #define 或 #undef" id="19_5" impl="MISRA2004-19_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_5.rule"/>
         </rule>
         <rule header="函数应该优先于宏函数的使用" id="19_7" impl="MISRA2004-19_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_7.rule"/>
         </rule>
         <rule header="类似函数的宏在调用时参数个数必须一致" id="19_8" impl="MISRA2004-19_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_8.rule"/>
         </rule>
         <rule header="类似函数的宏的参数不应该包含类似预处理命令的标识" id="19_9" impl="MISRA2004-19_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-19_9.rule"/>
         </rule>
         <rule header="不得使用库stdlib.h中的库函数atof，atoi和atol" id="20_10" impl="MISRA2004-20_10" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_10.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;time.h&gt; 或 &lt;ctime&gt;" id="20_12" impl="MISRA2004-20_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12.rule"/>
         </rule>
         <rule header="不应使用库 &lt;time.h&gt; 中的时间处理函数和宏" id="20_12_b" impl="MISRA2004-20_12_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12_b.rule"/>
         </rule>
         <rule header="不应使用库 &lt;time.h&gt; 中定义的类型" id="20_12_c" impl="MISRA2004-20_12_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_12_c.rule"/>
         </rule>
         <rule header="不要使用以下划线开头的带有#define 或 #undef 名称的标识符" id="20_1_a" impl="MISRA2004-20_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_a.rule"/>
         </rule>
         <rule header="不要重新定义保留字" id="20_1_b" impl="MISRA2004-20_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_b.rule"/>
         </rule>
         <rule header="不使用 #define 或 #undef 标识符 'defined'" id="20_1_e" impl="MISRA2004-20_1_e" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_1_e.rule"/>
         </rule>
         <rule header="标准库宏、对象和函数的名称不应该被重用" id="20_2" impl="MISRA2004-20_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2.rule"/>
         </rule>
         <rule header="不应该重复使用标准库中的宏，对象和函数(C90)" id="20_2_a" impl="MISRA2004-20_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_a.rule"/>
         </rule>
         <rule header="标准库宏，对象和函数的名称不得重复使用（C99）" id="20_2_b" impl="MISRA2004-20_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_2_b.rule"/>
         </rule>
         <rule header="应检查传递给库函数的值的有效性" id="20_3" impl="MISRA2004-20_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_3.rule"/>
         </rule>
         <rule header="不应使用动态堆内存分配" id="20_4" impl="MISRA2004-20_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_4.rule"/>
         </rule>
         <rule header="不得使用错误指示符 'errno'" id="20_5" impl="MISRA2004-20_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_5.rule"/>
         </rule>
         <rule header="不应该使用库文件 stddef.h 中的 offsetof 宏" id="20_6" impl="MISRA2004-20_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_6.rule"/>
         </rule>
         <rule header="不应使用 &lt;setjmp.h&gt; 提供的工具" id="20_7" impl="MISRA2004-20_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;setjmp.h&gt; 或 &lt;csetjmp&gt;" id="20_7_b" impl="MISRA2004-20_7_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_7_b.rule"/>
         </rule>
         <rule header="不应使用标准头文件 &lt;signal.h&gt; 或 &lt;csignal&gt;" id="20_8" impl="MISRA2004-20_8" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8.rule"/>
         </rule>
         <rule header="不应使用 &lt;signal.h&gt; 的信号处理工具" id="20_8_b" impl="MISRA2004-20_8_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_8_b.rule"/>
         </rule>
         <rule header="禁止使用库文件 stdio.h 中的输入/输出函数" id="20_9" impl="MISRA2004-20_9" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-20_9.rule"/>
         </rule>
         <rule header="汇编代码应该是封装且独立的" id="2_1" impl="MISRA2004-2_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_1.rule"/>
         </rule>
         <rule header="源代码只能使用 /* ... */ 来注释" id="2_2" impl="MISRA2004-2_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_2.rule"/>
         </rule>
         <rule header="禁止在 C 语言风格的注释中使用 /* 字符序列" id="2_3" impl="MISRA2004-2_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-2_3.rule"/>
         </rule>
         <rule header="代码段不应该被&quot;注释掉&quot;" id="2_4" impl="MISRA2004-2_4" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-2_4.rule"/>
         </rule>
         <rule header="使用 #pragma 指令必须进行注释并说明" id="3_4" impl="MISRA2004-3_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_4.rule"/>
         </rule>
         <rule header="不要把位域和其他数据混合在同一个结构体里" id="3_5" impl="MISRA2004-3_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-3_5.rule"/>
         </rule>
         <rule header="应只使用 ISO C 标准中定义的转义字符" id="4_1" impl="MISRA2004-4_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_1.rule"/>
         </rule>
         <rule header="禁止使用三联符" id="4_2" impl="MISRA2004-4_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-4_2.rule"/>
         </rule>
         <rule header="在局部或者函数原型体范围内声明的标识符不应该隐藏一个在全局或者命名空间范围内声明的标识符" id="5_2_a" impl="MISRA2004-5_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_a.rule"/>
         </rule>
         <rule header="在内层的局部范围内声明的标识符不应该隐藏在外层的局部范围内声明的标识符" id="5_2_b" impl="MISRA2004-5_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_2_b.rule"/>
         </rule>
         <rule header="不能重用 typedef 名称" id="5_3_a" impl="MISRA2004-5_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_a.rule"/>
         </rule>
         <rule header="不能将 typedef 的名称重用在另一个 typedef 名称" id="5_3_b" impl="MISRA2004-5_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_3_b.rule"/>
         </rule>
         <rule header="在程序中标记(tag)的名称不得重用于其它目的" id="5_4_a" impl="MISRA2004-5_4_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_a.rule"/>
         </rule>
         <rule header="标记(tag)的名称不得被重用于定义一个不同的标号" id="5_4_b" impl="MISRA2004-5_4_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_b.rule"/>
         </rule>
         <rule header="typedef 的名称不应该与 typdef 指定的类型名称相同" id="5_4_c" impl="MISRA2004-5_4_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-5_4_c.rule"/>
         </rule>
         <rule header="禁止重用静态存储周期的对象或函数的标识符" id="5_5_a" impl="MISRA2004-5_5_a" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_a.rule"/>
         </rule>
         <rule header="禁止重用静态存储周期的对象或函数的标识符" id="5_5_b" impl="MISRA2004-5_5_b" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_5_b.rule"/>
         </rule>
         <rule header="除结构体和联合体成员名称外，一个命名空间内的标识符不能与另一个命名空间里面的标识符重名" id="5_6" impl="MISRA2004-5_6" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_6.rule"/>
         </rule>
         <rule header="禁止重用标识符名称" id="5_7" impl="MISRA2004-5_7" quickfix="false" scope="line" severity="4">
            <file path="MISRA2004\MISRA2004-5_7.rule"/>
         </rule>
         <rule header="普通字符(plain char)类型只能用于存储和使用字符值" id="6_1" impl="MISRA2004-6_1" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_1.rule"/>
         </rule>
         <rule header="带符号的 char 和 不带符号的 char 类型只能用于存储和数值类型" id="6_2" impl="MISRA2004-6_2" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_2.rule"/>
         </rule>
         <rule header="typedef 定义基本类型应该在名称中包含数字" id="6_3" impl="MISRA2004-6_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3.rule"/>
         </rule>
         <rule header="typedef 应该用于替代基本类型" id="6_3_b" impl="MISRA2004-6_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_3_b.rule"/>
         </rule>
         <rule header="只能将位域定义为有符号的整型或无符号的整型" id="6_4" impl="MISRA2004-6_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_4.rule"/>
         </rule>
         <rule header="signed整数型的未命名位域的长度应大于1bit" id="6_5_a" impl="MISRA2004-6_5_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-6_5_a.rule"/>
         </rule>
         <rule header="不应该使用八进制常数（除零外）" id="7_1_a" impl="MISRA2004-7_1_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_a.rule"/>
         </rule>
         <rule header="八进制转义序列不应该被使用" id="7_1_b" impl="MISRA2004-7_1_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-7_1_b.rule"/>
         </rule>
         <rule header="静态存储类说明符应该用于具有内部链接的对象和函数的定义和声明" id="8_11" impl="MISRA2004-8_11" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_11.rule"/>
         </rule>
         <rule header="当数组声明具有外部链接，其大小应该显式地说明或者在初始化时隐性地定义" id="8_12" impl="MISRA2004-8_12" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_12.rule"/>
         </rule>
         <rule header="声明或定义某个函数时，必须显式地规定其类型" id="8_2_a" impl="MISRA2004-8_2_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_a.rule"/>
         </rule>
         <rule header="声明或定义某个对象时，必须显式地规定其类型" id="8_2_b" impl="MISRA2004-8_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_2_b.rule"/>
         </rule>
         <rule header="在声明和定义中使用相同的类型" id="8_3_a" impl="MISRA2004-8_3_a" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_a.rule"/>
         </rule>
         <rule header="函数的声明与原型的类型必须一致" id="8_3_b" impl="MISRA2004-8_3_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_3_b.rule"/>
         </rule>
         <rule header="如果对象或者函数被声明了一次以上，那么他们的类型应该是兼容的" id="8_4" impl="MISRA2004-8_4" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_4.rule"/>
         </rule>
         <rule header="在头文件中不应定义函数和对象" id="8_5" impl="MISRA2004-8_5" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_5.rule"/>
         </rule>
         <rule header="始终在文件的范围内声明函数" id="8_6" impl="MISRA2004-8_6" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_6.rule"/>
         </rule>
         <rule header="如果仅从单个函数中访问对象，则应在块范围内定义对象" id="8_7" impl="MISRA2004-8_7" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-8_7.rule"/>
         </rule>
         <rule header="数组不应被部分初始化" id="9_2_b" impl="MISRA2004-9_2_b" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_b.rule"/>
         </rule>
         <rule header="结构体的非零初始化要求每个元素都有显示初始化器" id="9_2_c" impl="MISRA2004-9_2_c" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_2_c.rule"/>
         </rule>
         <rule header="在枚举类型中，要么仅对第一个元素进行显式地初始化，要么所有元素都进行显式的初始化" id="9_3" impl="MISRA2004-9_3" quickfix="false" scope="line" severity="3">
            <file path="MISRA2004\MISRA2004-9_3.rule"/>
         </rule>
      </category>
      <category description="内存和资源管理" name="MRM">
         <rule header="由于函数参数的评估顺序尚未定义，禁止在函数参数列表中进行资源分配" id="01" impl="MRM-01" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-01.rule"/>
         </rule>
         <rule header="不要在一条语句中分配多个资源" id="02" impl="MRM-02" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-02.rule"/>
         </rule>
         <rule header="所有的类应该包含赋值操作符或适当的注释" id="04" impl="MRM-04" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-04.rule"/>
         </rule>
         <rule header="所有的类必须包含拷贝构造函数或适当的注释" id="05" impl="MRM-05" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-05.rule"/>
         </rule>
         <rule header="在对相应的 new/malloc 以及 delete/free 的调用中应使用相同的形式" id="06" impl="MRM-06" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-06.rule"/>
         </rule>
         <rule header="不能对非 POD 使用 memcpy 或 memcmp" id="07" impl="MRM-07" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-07.rule"/>
         </rule>
         <rule header="禁止对含有构造函数的对象调用 malloc/realloc" id="08" impl="MRM-08" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-08.rule"/>
         </rule>
         <rule header="始终将一个新值赋给指向已释放内存的表达式" id="09" impl="MRM-09" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-09.rule"/>
         </rule>
         <rule header="始终将一个新值赋给指向已释放内存的全局或成员变量" id="10" impl="MRM-10" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-10.rule"/>
         </rule>
         <rule header="总是为指向释放内存的参数或局部变量分配新值" id="11" impl="MRM-11" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-11.rule"/>
         </rule>
         <rule header="在编写 new 和 delete 函数时应该遵守规范" id="12" impl="MRM-12" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-12.rule"/>
         </rule>
         <rule header="在编写 new 函数时应该固守常规" id="13" impl="MRM-13" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-13.rule"/>
         </rule>
         <rule header="如果一个类定义了 new 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new 操作符重载" id="14" impl="MRM-14" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-14.rule"/>
         </rule>
         <rule header="如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载" id="15" impl="MRM-15" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-15.rule"/>
         </rule>
         <rule header="如果一个类定义了 new[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 new[] 操作符重载" id="16" impl="MRM-16" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-16.rule"/>
         </rule>
         <rule header="如果一个类定义了 delete[] 操作符的任何重载，就应该提供 plain, in-place, 和 non-throwing 所有三种标准形式的 delete[] 操作符重载" id="17" impl="MRM-17" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-17.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放" id="18" impl="MRM-18" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-18.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放" id="19" impl="MRM-19" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-19.rule"/>
         </rule>
         <rule header="不要分配内存后期望其他人稍后去释放它" id="20" impl="MRM-20" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-20.rule"/>
         </rule>
         <rule header="使用对象来管理资源" id="21" impl="MRM-21" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-21.rule"/>
         </rule>
         <rule header="使用对象来管理资源" id="22" impl="MRM-22" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-22.rule"/>
         </rule>
         <rule header="禁止返回函数范围内的new运算符初始化的解引用本地指针" id="23" impl="MRM-23" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-23.rule"/>
         </rule>
         <rule header="以独立语句将 newed 对象置入智能指针" id="25" impl="MRM-25" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-25.rule"/>
         </rule>
         <rule header="如果写了 new 操作符应该对应写 delete 操作符" id="26" impl="MRM-26" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-26.rule"/>
         </rule>
         <rule header="如果写了 new[] 操作符应该对应写 delete[] 操作符" id="27" impl="MRM-27" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-27.rule"/>
         </rule>
         <rule header="始终同时提供 new 和 delete 操作符" id="28" impl="MRM-28" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-28.rule"/>
         </rule>
         <rule header="始终同时提供 new[] 和 delete[] 操作符" id="29" impl="MRM-29" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-29.rule"/>
         </rule>
         <rule header="使用声明进行内存分配，而不是 new 或者 malloc" id="30" impl="MRM-30" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-30.rule"/>
         </rule>
         <rule header="被释放的内存在任何情况下都不应该被访问" id="31" impl="MRM-31" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31.rule"/>
         </rule>
         <rule header="不应该手动调用析构函数" id="31_b" impl="MRM-31_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-31_b.rule"/>
         </rule>
         <rule header="避免隐藏全局new运算符" id="32" impl="MRM-32" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-32.rule"/>
         </rule>
         <rule header="在析构函数中对指针成员调用delete" id="33" impl="MRM-33" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-33.rule"/>
         </rule>
         <rule header="检查 new 的返回值" id="34" impl="MRM-34" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-34.rule"/>
         </rule>
         <rule header="释放非数组内存时 delete 不能使用括号([])" id="35" impl="MRM-35" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-35.rule"/>
         </rule>
         <rule header="释放数组内存时 delete 必须使用空括号([])" id="36" impl="MRM-36" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-36.rule"/>
         </rule>
         <rule header="为动态分配内存的类声明一个复制赋值运算符" id="37" impl="MRM-37" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-37.rule"/>
         </rule>
         <rule header="为动态分配内存的类声明拷贝构造函数" id="38" impl="MRM-38" quickfix="false" scope="line" severity="1">
            <file path="MRM\MRM-38.rule"/>
         </rule>
         <rule header="在调用fopen函数的附近提供文件打开错误的错误处理机制" id="39" impl="MRM-39" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-39.rule"/>
         </rule>
         <rule header="复制和销毁一致" id="40" impl="MRM-40" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40.rule"/>
         </rule>
         <rule header="声明复制构造函数时应声明复制赋值运算符（反之亦然）" id="40_a" impl="MRM-40_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_a.rule"/>
         </rule>
         <rule header="拷贝构造函数和拷贝赋值操作符应该具有相同的 public/protected/private 权限" id="40_b" impl="MRM-40_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_b.rule"/>
         </rule>
         <rule header="如果存在非平凡拷贝构造函数或拷贝赋值操作符，应声明一个析构函数" id="40_c" impl="MRM-40_c" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_c.rule"/>
         </rule>
         <rule header="复制构造函数和复制赋值运算符都应该为具有非平凡析构函数的类声明" id="40_d" impl="MRM-40_d" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-40_d.rule"/>
         </rule>
         <rule header="拷贝构造函数应复制所有的数据成员以及基类成员" id="41" impl="MRM-41" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-41.rule"/>
         </rule>
         <rule header="在析构函数中调用 fclose() 函数来关闭用于打开文件的指针成员" id="42" impl="MRM-42" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-42.rule"/>
         </rule>
         <rule header="赋值运算符必须对基类型中的成员进行赋值" id="43" impl="MRM-43" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-43.rule"/>
         </rule>
         <rule header="不要在指针类型上使用 sizeof 操作符来指定通过 'malloc'， 'calloc' 或 'realloc' 函数分配的内存大小" id="45" impl="MRM-45" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-45.rule"/>
         </rule>
         <rule header="不要使用 calloc, malloc, realloc 和 free 函数" id="46" impl="MRM-46" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-46.rule"/>
         </rule>
         <rule header="包含至少一个非静态成员变量的类应该声明赋值操作符或包含适当的注释" id="47" impl="MRM-47" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-47.rule"/>
         </rule>
         <rule header="包含至少一个非静态成员变量的类应该声明拷贝构造函数或包含适当的注释" id="48" impl="MRM-48" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-48.rule"/>
         </rule>
         <rule header="应为包含指向数据项或非平凡析构函数的指针的类声明一个拷贝构造函数和一个拷贝赋值操作符" id="49" impl="MRM-49" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-49.rule"/>
         </rule>
         <rule header="私有的拷贝构造函数和拷贝赋值运算符要同时声明" id="50" impl="MRM-50" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-50.rule"/>
         </rule>
         <rule header="不要对指向一个void类型的指针使用'delete'" id="51" impl="MRM-51" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-51.rule"/>
         </rule>
         <rule header="使用 RAII 防止资源泄漏" id="52" impl="MRM-52" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-52.rule"/>
         </rule>
         <rule header="当分配失败时，用户定义的'new'操作符应该抛出'std::bad_alloc'异常" id="53" impl="MRM-53" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-53.rule"/>
         </rule>
         <rule header="避免对过度对齐类型使用默认运算符 'new'" id="54" impl="MRM-54" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-54.rule"/>
         </rule>
         <rule header="不要传递存储容量不足或者没有对正在构造的对象进行适当的对齐以配置 'new' 的指针" id="55" impl="MRM-55" quickfix="false" scope="line" severity="2">
            <file path="MRM\MRM-55.rule"/>
         </rule>
         <rule header="当一个对象数组传递给配置 'new' 的分配作用时会存在开销" id="55_b" impl="MRM-55_b" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-55_b.rule"/>
         </rule>
         <rule header="拷贝赋值运算符不应有可能会影响复制对象的作用" id="56" impl="MRM-56" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-56.rule"/>
         </rule>
         <rule header="移动赋值运算符不应具有可能影响移动对象的副作用" id="57" impl="MRM-57" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-57.rule"/>
         </rule>
         <rule header="内存分配函数的结果应被立即转换" id="58_a" impl="MRM-58_a" quickfix="false" scope="line" severity="3">
            <file path="MRM\MRM-58_a.rule"/>
         </rule>
         <rule header="内存分配函数的结果应该立即被转换为指向被分配类型的指针" id="58_b" impl="MRM-58_b" quickfix="false" scope="line" severity="4">
            <file path="MRM\MRM-58_b.rule"/>
         </rule>
      </category>
      <category description="命名规范" name="NAMING">
         <rule header="所有使用 &quot;#define&quot; 定义的常量必须使用大写" id="01" impl="NAMING-01" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-01.rule"/>
         </rule>
         <rule header="在枚举列表中，列表成员(元素)应该是大写的，列表中的名称或标记应该是小写的" id="02" impl="NAMING-02" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-02.rule"/>
         </rule>
         <rule header="为文件名使用小写字母" id="03" impl="NAMING-03" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-03.rule"/>
         </rule>
         <rule header="带有全局前缀的名字仅能用作全局变量" id="04" impl="NAMING-04" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-04.rule"/>
         </rule>
         <rule header="局部变量名应以小写字母开头" id="05" impl="NAMING-05" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-05.rule"/>
         </rule>
         <rule header="全局变量名应以小写字母开头" id="06" impl="NAMING-06" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-06.rule"/>
         </rule>
         <rule header="成员变量名应以小写字母开头" id="07" impl="NAMING-07" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-07.rule"/>
         </rule>
         <rule header="所有布尔类型变量必须以字母 'b' 开头" id="08" impl="NAMING-08" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-08.rule"/>
         </rule>
         <rule header="类，结构体，联合体，枚举和自定义类型(typedef)的名字必须以大写字母开头" id="09" impl="NAMING-09" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-09.rule"/>
         </rule>
         <rule header="抽象数据类型，结构体，自定义类型(typedef)，枚举类型的名字必须以大写字母开头" id="10" impl="NAMING-10" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-10.rule"/>
         </rule>
         <rule header="枚举类型名称应以大写字母开头并以后缀 '_t' 结尾" id="11" impl="NAMING-11" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-11.rule"/>
         </rule>
         <rule header="结构类型名称应以大写字母开头并以后缀 '_t' 结尾" id="12" impl="NAMING-12" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-12.rule"/>
         </rule>
         <rule header="常量名以小写字母 'c' 开头'" id="13" impl="NAMING-13" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-13.rule"/>
         </rule>
         <rule header="类的数据成员名以 'its' 开头" id="14" impl="NAMING-14" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-14.rule"/>
         </rule>
         <rule header="双精类型变量名以小写字母 'd' 开头" id="15" impl="NAMING-15" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-15.rule"/>
         </rule>
         <rule header="浮点类型变量名以小写字母 'f' 开头" id="16" impl="NAMING-16" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-16.rule"/>
         </rule>
         <rule header="所有函数名字以大写字母开头" id="17" impl="NAMING-17" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-17.rule"/>
         </rule>
         <rule header="全局变量名以 'the' 开头" id="18" impl="NAMING-18" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-18.rule"/>
         </rule>
         <rule header="所有整型变量以小写字母 'i' 开头" id="19" impl="NAMING-19" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-19.rule"/>
         </rule>
         <rule header="以 'is' 开头的函数必须返回布尔值" id="20" impl="NAMING-20" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-20.rule"/>
         </rule>
         <rule header="所有长整型变量名以 'li' 开头" id="21" impl="NAMING-21" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-21.rule"/>
         </rule>
         <rule header="指针类型变量名以字母 'p' 为前缀" id="22" impl="NAMING-22" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-22.rule"/>
         </rule>
         <rule header="所有短整型变量以字母 'si' 开头" id="23" impl="NAMING-23" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-23.rule"/>
         </rule>
         <rule header="所有有符号字符变量以小写字母 'c' 开头" id="24" impl="NAMING-24" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-24.rule"/>
         </rule>
         <rule header="所有有尾字符串的变量名以 'sz' 开头" id="25" impl="NAMING-25" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-25.rule"/>
         </rule>
         <rule header="所有无符号字符类型变量名以 'uc' 开头" id="26" impl="NAMING-26" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-26.rule"/>
         </rule>
         <rule header="所有无符号整型变量以 'ui' 开头" id="27" impl="NAMING-27" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-27.rule"/>
         </rule>
         <rule header="结构和联合的成员名字使用小写字母" id="28" impl="NAMING-28" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-28.rule"/>
         </rule>
         <rule header="所有自定义类型的名字应以 &quot;_t&quot; 结尾" id="29" impl="NAMING-29" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-29.rule"/>
         </rule>
         <rule header="确保在 C 语言中实现文件始终具有文件扩展名 &quot;.c&quot;" id="30" impl="NAMING-30" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-30.rule"/>
         </rule>
         <rule header="不要使用字母的大小写区分数据类型" id="31" impl="NAMING-31" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-31.rule"/>
         </rule>
         <rule header="对应类的包含文件应采用 &lt;类名&gt; 加扩展名的格式" id="32" impl="NAMING-32" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-32.rule"/>
         </rule>
         <rule header="标识符的名字不能以一个下划线 (`_') 或两个下划线 (`__') 开头" id="33" impl="NAMING-33" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-33.rule"/>
         </rule>
         <rule header="全局函数名必须以小写字母开头" id="34" impl="NAMING-34" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-34.rule"/>
         </rule>
         <rule header="成员函数名必须以小写字母开头" id="35" impl="NAMING-35" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-35.rule"/>
         </rule>
         <rule header="函数声明中的参数名必须与函数定义中的参数名字一致" id="36" impl="NAMING-36" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-36.rule"/>
         </rule>
         <rule header="确保在 C++ 中包含文件始终具有扩展名 &quot;.hh&quot;" id="37" impl="NAMING-37" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-37.rule"/>
         </rule>
         <rule header="确保在 C++ 中实现文件始终具有文件扩展名 &quot;.cc&quot;" id="38" impl="NAMING-38" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-38.rule"/>
         </rule>
         <rule header="内联定义文件的扩展名必须为 &quot;.icc&quot;" id="39" impl="NAMING-39" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-39.rule"/>
         </rule>
         <rule header="类，结构体，命名空间，枚举或自定义类型(typedef)的名称中，只有第一个字母可以大写" id="40" impl="NAMING-40" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-40.rule"/>
         </rule>
         <rule header="确保头文件应该始终具有扩展名 '.h'" id="41" impl="NAMING-41" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-41.rule"/>
         </rule>
         <rule header="常量和枚举值的标识符应为小写" id="42" impl="NAMING-42" quickfix="false" scope="line" severity="2">
            <file path="NAMING\NAMING-42.rule"/>
         </rule>
         <rule header="源文件的扩展名必须为 &quot;.cpp&quot; 或者&quot;.h&quot;" id="43" impl="NAMING-43" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-43.rule"/>
         </rule>
         <rule header="函数和变量名称中包含的所有字母将完全由小写字母组成" id="44" impl="NAMING-44" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-44.rule"/>
         </rule>
         <rule header="不能使用大小写字母，下划线区分标识符，也不能使用容易与数字混淆的字母做为标识符名字" id="45" impl="NAMING-45" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-45.rule"/>
         </rule>
         <rule header="字符 ', &quot;, /* 或 // 不得出现在头文件的名称中" id="46" impl="NAMING-46" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-46.rule"/>
         </rule>
         <rule header="不同的标识符应该是书写明确的" id="47" impl="NAMING-47" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-47.rule"/>
         </rule>
         <rule header="字符 \ 不得出现在头文件的名称中" id="48" impl="NAMING-48" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-48.rule"/>
         </rule>
         <rule header="C++ 的实现文件应该总是具有扩展名 &quot;.cpp&quot;" id="49" impl="NAMING-49" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-49.rule"/>
         </rule>
         <rule header="具有重叠可见性的同一命名空间中的标识符应该是排版明确的" id="50" impl="NAMING-50" quickfix="false" scope="line" severity="4">
            <file path="NAMING\NAMING-50.rule"/>
         </rule>
         <rule header="用户定义的文字操作符的后缀应该以下划线和一个或多个字母开头" id="51" impl="NAMING-51" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-51.rule"/>
         </rule>
         <rule header="通用字符名称仅应在字符或字符串字面量内使用" id="52" impl="NAMING-52" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-52.rule"/>
         </rule>
         <rule header="头文件的文件扩展名应该是: &quot;.h&quot;, &quot;.hpp&quot; 或 &quot;.hxx&quot;" id="53" impl="NAMING-53" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-53.rule"/>
         </rule>
         <rule header="使用视觉上不同的标识符" id="54" impl="NAMING-54" quickfix="false" scope="line" severity="3">
            <file path="NAMING\NAMING-54.rule"/>
         </rule>
         <category description="匈牙利记法" name="HN">
            <rule header="应该使用匈牙利命名法的数组变量和参数" id="01" impl="NAMING-HN-01" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-01.rule"/>
            </rule>
            <rule header="应该使用匈牙利命名法的布尔类型" id="02" impl="NAMING-HN-02" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-02.rule"/>
            </rule>
            <rule header="布尔型指针,数组,或引用类型的匈牙利命名法" id="03" impl="NAMING-HN-03" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-03.rule"/>
            </rule>
            <rule header="字节类型的匈牙利命名法" id="04" impl="NAMING-HN-04" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-04.rule"/>
            </rule>
            <rule header="字节指针、数组或引用类型应使用匈牙利命名法" id="05" impl="NAMING-HN-05" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-05.rule"/>
            </rule>
            <rule header="字符(char)类型应该使用匈牙利命名法" id="06" impl="NAMING-HN-06" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-06.rule"/>
            </rule>
            <rule header="字符类型数组的匈牙利命名法" id="07" impl="NAMING-HN-07" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-07.rule"/>
            </rule>
            <rule header="指针,数组或字符类型数组的引用的匈牙利命名法" id="08" impl="NAMING-HN-08" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-08.rule"/>
            </rule>
            <rule header="char类型指针、数组或引用类型应该用匈牙利符号" id="09" impl="NAMING-HN-09" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-09.rule"/>
            </rule>
            <rule header="char类型指针或引用类型应使用匈牙利命名法" id="10" impl="NAMING-HN-10" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-10.rule"/>
            </rule>
            <rule header="常量参数的匈牙利命名法" id="11" impl="NAMING-HN-11" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-11.rule"/>
            </rule>
            <rule header="双精度浮点类型的匈牙利命名法" id="12" impl="NAMING-HN-12" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-12.rule"/>
            </rule>
            <rule header="双精度浮点指针，数组或引用类型应该使用匈牙利命名法" id="13" impl="NAMING-HN-13" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-13.rule"/>
            </rule>
            <rule header="双字（dword）类型应该用匈牙利符号" id="14" impl="NAMING-HN-14" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-14.rule"/>
            </rule>
            <rule header="双字指针,数组,或引用类型的匈牙利命名法" id="15" impl="NAMING-HN-15" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-15.rule"/>
            </rule>
            <rule header="动态分配的数组的匈牙利命名法" id="16" impl="NAMING-HN-16" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-16.rule"/>
            </rule>
            <rule header="浮点类型应该使用匈牙利命名法" id="17" impl="NAMING-HN-17" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-17.rule"/>
            </rule>
            <rule header="浮点指针,数组,或引用类型的匈牙利命名法" id="18" impl="NAMING-HN-18" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-18.rule"/>
            </rule>
            <rule header="类声明的匈牙利命名法" id="19" impl="NAMING-HN-19" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-19.rule"/>
            </rule>
            <rule header="结构体声明的匈牙利命名法" id="20" impl="NAMING-HN-20" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-20.rule"/>
            </rule>
            <rule header="ifstream 类型的变量和参数应该使用匈牙利命名法" id="21" impl="NAMING-HN-21" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-21.rule"/>
            </rule>
            <rule header="整数(int)类型应该使用匈牙利命名法" id="22" impl="NAMING-HN-22" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-22.rule"/>
            </rule>
            <rule header="整数指针,数组,或引用类型的匈牙利命名法" id="23" impl="NAMING-HN-23" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-23.rule"/>
            </rule>
            <rule header="输入流类型的参数和变量的匈牙利命名法" id="24" impl="NAMING-HN-24" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-24.rule"/>
            </rule>
            <rule header="长整型（long int）应该使用匈牙利命名法" id="25" impl="NAMING-HN-25" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-25.rule"/>
            </rule>
            <rule header="长双精度浮点类型的匈牙利命名法" id="26" impl="NAMING-HN-26" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-26.rule"/>
            </rule>
            <rule header="长双精度浮点指针,数组,或引用类型的匈牙利命名法" id="27" impl="NAMING-HN-27" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-27.rule"/>
            </rule>
            <rule header="长整型指针,数组或引用类型的匈牙利命名法" id="28" impl="NAMING-HN-28" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-28.rule"/>
            </rule>
            <rule header="成员变量应该使用匈牙利命名法" id="29" impl="NAMING-HN-29" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-29.rule"/>
            </rule>
            <rule header="整数(int)类型应该使用匈牙利命名法" id="30" impl="NAMING-HN-30" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-30.rule"/>
            </rule>
            <rule header="整型指针,数组,或引用类型的匈牙利命名法" id="31" impl="NAMING-HN-31" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-31.rule"/>
            </rule>
            <rule header="输出文件流类型的参数和变量的匈牙利命名法" id="32" impl="NAMING-HN-32" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-32.rule"/>
            </rule>
            <rule header="ostream 类型的参数和变量应该使用匈牙利命名法" id="33" impl="NAMING-HN-33" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-33.rule"/>
            </rule>
            <rule header="指针应该使用匈牙利命名法" id="34" impl="NAMING-HN-34" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-34.rule"/>
            </rule>
            <rule header="引用参数的匈牙利命名法" id="35" impl="NAMING-HN-35" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-35.rule"/>
            </rule>
            <rule header="短整型的匈牙利命名法" id="36" impl="NAMING-HN-36" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-36.rule"/>
            </rule>
            <rule header="短整型指针，数组或引用类型应该使用匈牙利命名法" id="37" impl="NAMING-HN-37" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-37.rule"/>
            </rule>
            <rule header="静态变量的匈牙利命名法" id="38" impl="NAMING-HN-38" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-38.rule"/>
            </rule>
            <rule header="字符串类型的匈牙利命名法" id="39" impl="NAMING-HN-39" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-39.rule"/>
            </rule>
            <rule header="字符串指针,数组,或引用类型的匈牙利命名法" id="40" impl="NAMING-HN-40" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-40.rule"/>
            </rule>
            <rule header="无符号类型应该使用匈牙利命名法" id="41" impl="NAMING-HN-41" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-41.rule"/>
            </rule>
            <rule header="void 指针类型应该使用匈牙利命名法" id="42" impl="NAMING-HN-42" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-42.rule"/>
            </rule>
            <rule header="字类型的匈牙利命名法" id="43" impl="NAMING-HN-43" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-43.rule"/>
            </rule>
            <rule header="字指针,数组,或引用类型的匈牙利命名法" id="44" impl="NAMING-HN-44" quickfix="false" scope="line" severity="3">
               <file path="NAMING\NAMING-HN-44.rule"/>
            </rule>
         </category>
      </category>
      <category description="面向对象" name="OOP">
         <rule header="在基类中避免使用公共(public)拷贝构造函数和赋值运算符" id="01" impl="OOP-01" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-01.rule"/>
         </rule>
         <rule header="避免使用切片，基类中应该使用克隆而非拷贝" id="02" impl="OOP-02" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-02.rule"/>
         </rule>
         <rule header="类不能多次继承其它类，除非是虚拟继承" id="03" impl="OOP-03" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-03.rule"/>
         </rule>
         <rule header="不要从多于一个基类中派生出相同名字的函数" id="04" impl="OOP-04" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-04.rule"/>
         </rule>
         <rule header="禁止使用多重继承" id="05" impl="OOP-05" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-05.rule"/>
         </rule>
         <rule header="对于多重继承使用虚公共基类" id="06" impl="OOP-06" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-06.rule"/>
         </rule>
         <rule header="要小心使用不是抽象接口的类的多重继承" id="07" impl="OOP-07" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07.rule"/>
         </rule>
         <rule header="多重继承应该限制为之多1个受保护的实现" id="07_a" impl="OOP-07_a" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_a.rule"/>
         </rule>
         <rule header="多重继承不应该使用任何public实现" id="07_b" impl="OOP-07_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-07_b.rule"/>
         </rule>
         <rule header="确保派生类最多具有一个不是接口类的基类" id="07_c" impl="OOP-07_c" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-07_c.rule"/>
         </rule>
         <rule header="禁止构造函数直接访问全局数据" id="08" impl="OOP-08" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-08.rule"/>
         </rule>
         <rule header="避免在析构函数中使用全局对象" id="09" impl="OOP-09" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-09.rule"/>
         </rule>
         <rule header="避免在成员函数中使用全局数据" id="10" impl="OOP-10" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-10.rule"/>
         </rule>
         <rule header="避免使用友元(friend)机制" id="11" impl="OOP-11" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11.rule"/>
         </rule>
         <rule header="除了比较运算符的声明外，不得使用友元声明" id="11_b" impl="OOP-11_b" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-11_b.rule"/>
         </rule>
         <rule header="受保护(Protected)的成员函数不得返回指向私有类数据的非 const 句柄(指针或引用)" id="12" impl="OOP-12" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-12.rule"/>
         </rule>
         <rule header="禁止使用不同的默认参数值来重定义继承的虚拟函数" id="13" impl="OOP-13" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-13.rule"/>
         </rule>
         <rule header="使用组合 composition 而非使用私有继承" id="14" impl="OOP-14" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-14.rule"/>
         </rule>
         <rule header="避免从构造函数调用虚函数" id="16" impl="OOP-16" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16.rule"/>
         </rule>
         <rule header="避免从析构函数调用虚函数" id="16_b" impl="OOP-16_b" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-16_b.rule"/>
         </rule>
         <rule header="Write a using declaration to redeclare overloaded functions" id="17" impl="OOP-17" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-17.rule"/>
         </rule>
         <rule header="避免 &quot;public&quot; 数据成员" id="18" impl="OOP-18" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-18.rule"/>
         </rule>
         <rule header="避免 'protected' 数据成员" id="19" impl="OOP-19" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-19.rule"/>
         </rule>
         <rule header="避免从衍生类到基类的显式类型转换" id="20" impl="OOP-20" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-20.rule"/>
         </rule>
         <rule header="如果子类型实现了虚拟函数，则应使用虚拟关键词" id="21" impl="OOP-21" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-21.rule"/>
         </rule>
         <rule header="在具有虚函数的基类中定义虚拟析构函数" id="22" impl="OOP-22" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-22.rule"/>
         </rule>
         <rule header="如果类中含有虚拟函数，那么它也应该包含虚拟析构函数" id="23" impl="OOP-23" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-23.rule"/>
         </rule>
         <rule header="在基类中将析构函数设置为虚拟的" id="24" impl="OOP-24" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-24.rule"/>
         </rule>
         <rule header="避免把虚函数声明为内联函数" id="25" impl="OOP-25" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-25.rule"/>
         </rule>
         <rule header="禁止把指向派生类中对象的指针转化为指向虚基类的对象的指针" id="26" impl="OOP-26" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-26.rule"/>
         </rule>
         <rule header="为带有引用成员或常量成员的类声明拷贝赋值操作符" id="27" impl="OOP-27" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-27.rule"/>
         </rule>
         <rule header="避免向下转换继承层级结构" id="28" impl="OOP-28" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-28.rule"/>
         </rule>
         <rule header="指向抽象类的指针不能被转换为指向继承于该类的子类的指针" id="29" impl="OOP-29" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-29.rule"/>
         </rule>
         <rule header="未在类中声明复制构造函数以及拷贝赋值运算符为私有，而在特殊设计的基类型中进行声明" id="30" impl="OOP-30" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-30.rule"/>
         </rule>
         <rule header="设置基类的析构函数为 public、virtual 或者 protected、nonvirtual" id="31" impl="OOP-31" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-31.rule"/>
         </rule>
         <rule header="禁止对继承的非虚拟函数进行重定义" id="32" impl="OOP-32" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-32.rule"/>
         </rule>
         <rule header="禁止对含有模板参数的继承非虚拟函数进行重定义" id="33" impl="OOP-33" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-33.rule"/>
         </rule>
         <rule header="检查 operator= 中的自我赋值" id="34" impl="OOP-34" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-34.rule"/>
         </rule>
         <rule header="向下的强制转换(基类到衍生类的转换)是不允许的" id="35" impl="OOP-35" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-35.rule"/>
         </rule>
         <rule header="公共成员函数不应该返回指向私有的/受保护的类数据的非常量句柄" id="36" impl="OOP-36" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-36.rule"/>
         </rule>
         <rule header="不使用继承的时候，最好使用复合关系" id="37" impl="OOP-37" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-37.rule"/>
         </rule>
         <rule header="如果调用了某个类的析构函数并且该类含有虚拟函数，那么该类也应该含有虚拟析构函数" id="38" impl="OOP-38" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-38.rule"/>
         </rule>
         <rule header="有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明" id="39" impl="OOP-39" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-39.rule"/>
         </rule>
         <rule header="有状态的虚拟类应该在每个访问该类的衍生类中进行显式地声明" id="39_b" impl="OOP-39_b" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-39_b.rule"/>
         </rule>
         <rule header="层次结构应该基于抽象类" id="40" impl="OOP-40" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-40.rule"/>
         </rule>
         <rule header="在同一层次结构中，基类不能同时具有虚拟及非虚拟的属性" id="41" impl="OOP-41" quickfix="false" scope="line" severity="2">
            <file path="OOP\OOP-41.rule"/>
         </rule>
         <rule header="在抽象类中拷贝赋值运算符应该被声明为 protected 或 private" id="42" impl="OOP-42" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-42.rule"/>
         </rule>
         <rule header="虚拟函数仅能被自身声明为纯虚拟的纯虚拟函数进行覆盖" id="43" impl="OOP-43" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-43.rule"/>
         </rule>
         <rule header="在继承层次结构中，其每条路径中的每个虚拟函数应该有多个定义" id="44" impl="OOP-44" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-44.rule"/>
         </rule>
         <rule header="具有单一基本类型参数可调用的构造函数应该显式地声明" id="45" impl="OOP-45" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-45.rule"/>
         </rule>
         <rule header="拷贝构造函数应仅对其基类型及该类型的非静态成员进行初始化" id="46" impl="OOP-46" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-46.rule"/>
         </rule>
         <rule header="类不能从虚拟基类型中衍生" id="47" impl="OOP-47" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-47.rule"/>
         </rule>
         <rule header="非 POD 类型的成员数据应该为  private 类型" id="48" impl="OOP-48" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-48.rule"/>
         </rule>
         <rule header="禁止对多态类型进行从基类型到衍生类的强制类型转换" id="49" impl="OOP-49" quickfix="false" scope="line" severity="1">
            <file path="OOP\OOP-49.rule"/>
         </rule>
         <rule header="指向虚拟基类型的指针只能通过dynamic_cast的方式转换为指向其衍生类的指针" id="50" impl="OOP-50" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-50.rule"/>
         </rule>
         <rule header="使用命名空间而不是类或只包含静态的功能结构体" id="51" impl="OOP-51" quickfix="false" scope="line" severity="5">
            <file path="OOP\OOP-51.rule"/>
         </rule>
         <rule header="执行类的指针不能被转换成指向另一个类的指针类型除非该类继承自另一个类" id="52" impl="OOP-52" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-52.rule"/>
         </rule>
         <rule header="派生类里声明的成员函数不应该隐藏基类中声明的函数" id="53" impl="OOP-53" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-53.rule"/>
         </rule>
         <rule header="不要增加重写或隐藏方法的可访问性" id="54" impl="OOP-54" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-54.rule"/>
         </rule>
         <rule header="非 POD 类型应定义为类" id="55" impl="OOP-55" quickfix="false" scope="line" severity="4">
            <file path="OOP\OOP-55.rule"/>
         </rule>
         <rule header="用户定义的赋值操作符不应是虚拟的" id="56" impl="OOP-56" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-56.rule"/>
         </rule>
         <rule header="结构体应该只包含公共数据成员，不应该是基类或继承" id="57" impl="OOP-57" quickfix="false" scope="line" severity="3">
            <file path="OOP\OOP-57.rule"/>
         </rule>
      </category>
      <category description="最优化" name="OPT">
         <rule header="尽可能地声明局部变量" id="01" impl="OPT-01" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-01.rule"/>
         </rule>
         <rule header="避免未使用的局部变量" id="02" impl="OPT-02" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-02.rule"/>
         </rule>
         <rule header="消除未使用的参数" id="03" impl="OPT-03" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-03.rule"/>
         </rule>
         <rule header="规范使用 ++ 和 --。尽量使用前缀形式" id="04" impl="OPT-04" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-04.rule"/>
         </rule>
         <rule header="避免使用未使用的私有成员变量" id="05" impl="OPT-05" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-05.rule"/>
         </rule>
         <rule header="避免使用不必要的局部变量" id="06" impl="OPT-06" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-06.rule"/>
         </rule>
         <rule header="尽量使用 &quot;a @= b&quot; 的形式，而不应使用 &quot;a = a @ b&quot;，其中 &quot;@&quot; 可以是 +, -, *, /, %" id="07" impl="OPT-07" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-07.rule"/>
         </rule>
         <rule header="尽量使用 &quot;a @= b&quot; 的形式，而不应使用 &quot;a = a @ b&quot;，其中 &quot;@&quot; 可以是 &amp;, |, ^, &lt;&lt;, &gt;&gt;" id="08" impl="OPT-08" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-08.rule"/>
         </rule>
         <rule header="删除不必要的 '== true'" id="09" impl="OPT-09" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-09.rule"/>
         </rule>
         <rule header="不要在 &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, 和 &quot;do while&quot; 语句中声明变量" id="10" impl="OPT-10" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-10.rule"/>
         </rule>
         <rule header="如果一个文件级的静态变量仅在一个函数中被使用/引用，就应该只在该函数内部包含此变量" id="11" impl="OPT-11" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-11.rule"/>
         </rule>
         <rule header="如果一个文件级的静态变量仅在一个类中被使用/引用，就应该只在该类内部包含此变量" id="12" impl="OPT-12" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-12.rule"/>
         </rule>
         <rule header="按照降序顺序声明成员变量" id="13" impl="OPT-13" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-13.rule"/>
         </rule>
         <rule header="引用而不是值传递对象" id="14" impl="OPT-14" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-14.rule"/>
         </rule>
         <rule header="使用重载以避免隐式类型转换" id="15" impl="OPT-15" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-15.rule"/>
         </rule>
         <rule header="不应内联包含递归、循环或虚函数调用的全局函数" id="16" impl="OPT-16" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-16.rule"/>
         </rule>
         <rule header="避免使用内联构造函数和析构函数" id="17" impl="OPT-17" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-17.rule"/>
         </rule>
         <rule header="含有递归、循环的成员函数不应定义为内联的" id="18" impl="OPT-18" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-18.rule"/>
         </rule>
         <rule header="使用 op= 而非单独的操作符" id="19" impl="OPT-19" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-19.rule"/>
         </rule>
         <rule header="尽可能推迟变量定义" id="20" impl="OPT-20" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-20.rule"/>
         </rule>
         <rule header="任何一个 switch 语句都至少有一个非空 case 子句" id="21" impl="OPT-21" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-21.rule"/>
         </rule>
         <rule header="不允许使用无用的 case 语句" id="22" impl="OPT-22" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-22.rule"/>
         </rule>
         <rule header="普通的访问器(accessor)和变值器(mutator)函数应该是内联的" id="23" impl="OPT-23" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-23.rule"/>
         </rule>
         <rule header="应该内联普通的转发函数" id="24" impl="OPT-24" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-24.rule"/>
         </rule>
         <rule header="应只将有 1 个或 2 个语句的函数考虑为内联函数的候选函数" id="25" impl="OPT-25" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-25.rule"/>
         </rule>
         <rule header="如果变量不能被初始化为有意义的值就不应引入" id="26" impl="OPT-26" quickfix="false" scope="line" severity="2">
            <file path="OPT\OPT-26.rule"/>
         </rule>
         <rule header="应尽量减少 accessor/mutator 函数的数目" id="27" impl="OPT-27" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-27.rule"/>
         </rule>
         <rule header="'strlen' 函数不应该用来检查字符串是否为 NULL/非NULL" id="28" impl="OPT-28" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-28.rule"/>
         </rule>
         <rule header="不允许冗余显式转换为同一类型" id="29" impl="OPT-29" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-29.rule"/>
         </rule>
         <rule header="每个定义的具有内部链接的函数应该至少被使用一次" id="30" impl="OPT-30" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-30.rule"/>
         </rule>
         <rule header="非虚函数中不应存在未使用的参数（命名或未命名）" id="31" impl="OPT-31" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-31.rule"/>
         </rule>
         <rule header="所有具有 viod 返回类型的非空函数应该具有外部作用" id="32" impl="OPT-32" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-32.rule"/>
         </rule>
         <rule header="具有 void 返回值类型的函数不能为空" id="32_b" impl="OPT-32_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-32_b.rule"/>
         </rule>
         <rule header="考虑通过引用而不是值来返回对象" id="33" impl="OPT-33" quickfix="false" scope="line" severity="5">
            <file path="OPT\OPT-33.rule"/>
         </rule>
         <rule header="不要将变量赋值给它自己" id="35" impl="OPT-35" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-35.rule"/>
         </rule>
         <rule header="不要在变量的初始化器里使用它" id="36" impl="OPT-36" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-36.rule"/>
         </rule>
         <rule header="函数不应该包含未使用的标签声明" id="37" impl="OPT-37" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-37.rule"/>
         </rule>
         <rule header="在函数中不应该有未使用的参数" id="38" impl="OPT-38" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-38.rule"/>
         </rule>
         <rule header="每一个 switch 语句应该含有至少两个 switch 子句" id="39" impl="OPT-39" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-39.rule"/>
         </rule>
         <rule header="if-else-if 链的两个分支具有相同的代码（预处理之后）" id="40_a" impl="OPT-40_a" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_a.rule"/>
         </rule>
         <rule header="在switch语句的不同子句中使用了相同的代码（预处理之后）" id="40_b" impl="OPT-40_b" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-40_b.rule"/>
         </rule>
         <rule header="文件应该只包含(include)具有编译该文件所需的声明和定义的头文件" id="41" impl="OPT-41" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-41.rule"/>
         </rule>
         <rule header="在虚函数中不应有未使用的命名参数" id="42" impl="OPT-42" quickfix="false" scope="line" severity="3">
            <file path="OPT\OPT-42.rule"/>
         </rule>
         <rule header="项目不应包含有内部链接的未使用变量" id="43" impl="OPT-43" quickfix="false" scope="line" severity="4">
            <file path="OPT\OPT-43.rule"/>
         </rule>
      </category>
      <category description="潜在的缺陷" name="PB">
         <rule header="不要使用解引用指针类型的表达式" id="01" impl="PB-01" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-01.rule"/>
         </rule>
         <rule header="不要在 a(b), a[b] 和类型转换语句内部使用赋值" id="02" impl="PB-02" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-02.rule"/>
         </rule>
         <rule header="不允许在三元运算符中使用混合类型" id="03" impl="PB-03" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-03.rule"/>
         </rule>
         <rule header="函数的返回值必须与声明的返回类型一致" id="05" impl="PB-05" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-05.rule"/>
         </rule>
         <rule header="赋值运算符应该具有兼容类型的操作数" id="06" impl="PB-06" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-06.rule"/>
         </rule>
         <rule header="不给不兼容类型的变量赋函数返回值" id="07" impl="PB-07" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-07.rule"/>
         </rule>
         <rule header="不允许将有符号常量赋值给无符号整型变量" id="08" impl="PB-08" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-08.rule"/>
         </rule>
         <rule header="操作符不能使用引用返回值" id="09" impl="PB-09" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-09.rule"/>
         </rule>
         <rule header="不要以多态方式处理数组" id="10" impl="PB-10" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-10.rule"/>
         </rule>
         <rule header="函数声明的形参类型和实参类型必须匹配" id="11" impl="PB-11" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-11.rule"/>
         </rule>
         <rule header="不要将有符号字符强制转换成无符号整型" id="12" impl="PB-12" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-12.rule"/>
         </rule>
         <rule header="不要释放空指针" id="13" impl="PB-13" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-13.rule"/>
         </rule>
         <rule header="不正确的 EOS(串尾)定义" id="14" impl="PB-14" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-14.rule"/>
         </rule>
         <rule header="不能将两个整数相除之后的结果赋给浮点类型" id="15" impl="PB-15" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15.rule"/>
         </rule>
         <rule header="避免无意地丢弃整数除法的余数" id="15_b" impl="PB-15_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-15_b.rule"/>
         </rule>
         <rule header="避免将越界数值赋值给字符类型" id="16" impl="PB-16" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-16.rule"/>
         </rule>
         <rule header="避免将越界数值赋值给无符号字符类型" id="17" impl="PB-17" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-17.rule"/>
         </rule>
         <rule header="避免在指针和数字类型上重载类方法。" id="18" impl="PB-18" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-18.rule"/>
         </rule>
         <rule header="不应创建带有局部静态数据的内联非成员函数" id="19" impl="PB-19" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-19.rule"/>
         </rule>
         <rule header="避免切片函数参数/返回值" id="20" impl="PB-20" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-20.rule"/>
         </rule>
         <rule header="提供正确的字符串终止符" id="21" impl="PB-21" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-21.rule"/>
         </rule>
         <rule header="不能在 a(b),a[b] 和类型转换中使用自增或自减表达式" id="22" impl="PB-22" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-22.rule"/>
         </rule>
         <rule header="如果类具有非静态指针且没有声明的复制构造函数，则应通过引用传递类对象" id="23" impl="PB-23" quickfix="false" scope="line" severity="1">
            <file path="PB\PB-23.rule"/>
         </rule>
         <rule header="构造函数的定义中不能包含特定的缺省参数，这些参数可能产生与隐性声明的复制构造函数完全一样的签名" id="24" impl="PB-24" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-24.rule"/>
         </rule>
         <rule header="不要使用无符号算术" id="25" impl="PB-25" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-25.rule"/>
         </rule>
         <rule header="public 和 protected 的方法不应被类的构造函数调用" id="26" impl="PB-26" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-26.rule"/>
         </rule>
         <rule header="字符串字面量不应该被修改" id="27" impl="PB-27" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-27.rule"/>
         </rule>
         <rule header="下列的字符序列不得出现在头文件名中： ', \, /*, //, 或 &quot;" id="28" impl="PB-28" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-28.rule"/>
         </rule>
         <rule header="右移位操作符的左操作数不能是负数" id="29" impl="PB-29" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-29.rule"/>
         </rule>
         <rule header="多于一个枚举('enum')类型应该用作 switch 的条件或 case 语句的标签" id="30" impl="PB-30" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-30.rule"/>
         </rule>
         <rule header="不要在常量上调用 'sizeof'" id="31" impl="PB-31" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-31.rule"/>
         </rule>
         <rule header="不要在指针类型上调用'sizeof'" id="32" impl="PB-32" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-32.rule"/>
         </rule>
         <rule header="避免使用枚举类型隐式类型转换" id="33" impl="PB-33" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33.rule"/>
         </rule>
         <rule header="在涉及枚举类型的比较中避免隐式类型转换" id="33_b" impl="PB-33_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-33_b.rule"/>
         </rule>
         <rule header="'memcpy'/'strncpy'/'memmove' 的第三个参数不应该依赖于第二个参数" id="34" impl="PB-34" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-34.rule"/>
         </rule>
         <rule header="赋值操作符不得使用在没有括号的条件中" id="35" impl="PB-35" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-35.rule"/>
         </rule>
         <rule header="不得使用库 &lt;cstring&gt; 的无界函数" id="37" impl="PB-37" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-37.rule"/>
         </rule>
         <rule header="窄字符串和宽字符串不应该串联在一起" id="38" impl="PB-38" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38.rule"/>
         </rule>
         <rule header="不应连接具有不同编码前缀的字符串文字" id="38_b" impl="PB-38_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-38_b.rule"/>
         </rule>
         <rule header="函数不得返回一个引用或指针给通过引用或常数引用传递的参数" id="39" impl="PB-39" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39.rule"/>
         </rule>
         <rule header="函数不应返回对常量引用传递的指针或参数的引用" id="39_b" impl="PB-39_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-39_b.rule"/>
         </rule>
         <rule header="作为函数实参传递的数组类型标识符不得退化为一个指针" id="41" impl="PB-41" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41.rule"/>
         </rule>
         <rule header="不要将具有数组类型的表达式传递给一个具有指针或者数组类型参数的函数" id="41_b" impl="PB-41_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-41_b.rule"/>
         </rule>
         <rule header="对象不能赋值给一个重叠的对象" id="42" impl="PB-42" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-42.rule"/>
         </rule>
         <rule header="一个类的所有构造函数应该显式地为它的所有直接基类和所有虚拟基类调用一个构造函数" id="43" impl="PB-43" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-43.rule"/>
         </rule>
         <rule header="使用 'std::atexit()' 或 'std::at_quick_exit()' 注册函数的执行不应异常退出" id="44" impl="PB-44" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-44.rule"/>
         </rule>
         <rule header="格式字符串中的 '%s' 和 '%c' 格式说明符与其在调用字符串格式化函数时的相应参数之间不应存在不匹配" id="45" impl="PB-45" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-45.rule"/>
         </rule>
         <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="46" impl="PB-46" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-46.rule"/>
         </rule>
         <rule header="格式字符串中的'％f'格式说明符与调用字符串格式函数的相应参数之间不应存在不匹配" id="47" impl="PB-47" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-47.rule"/>
         </rule>
         <rule header="在调用字符串格式化函数时，格式字符串中的'%u'格式说明符及其对应的参数之间不应存在不匹配" id="48" impl="PB-48" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-48.rule"/>
         </rule>
         <rule header="在调用字符串格式化函数时，格式字符串中的'%p'格式说明符及其对应的参数之间不应存在不匹配" id="49" impl="PB-49" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-49.rule"/>
         </rule>
         <rule header="格式字符串中的格式说明符的数量和调用字符串格式化函数时相应的参数的数量应该相等" id="50" impl="PB-50" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-50.rule"/>
         </rule>
         <rule header="指针运算不得用于指向非数组类型变量的指针" id="51" impl="PB-51" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-51.rule"/>
         </rule>
         <rule header="避免在指针和数值类型上重载全局函数" id="52" impl="PB-52" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-52.rule"/>
         </rule>
         <rule header="避免在指针和数值类型上重载命名空间函数" id="53" impl="PB-53" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-53.rule"/>
         </rule>
         <rule header="映射过程中不要从不完整类映射，或者映射到不完整类" id="54" impl="PB-54" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-54.rule"/>
         </rule>
         <rule header="不要在删除点上时删除类不完整的对象" id="55" impl="PB-55" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-55.rule"/>
         </rule>
         <rule header="避免从有符号类型到无符号类型的隐式变换" id="56" impl="PB-56" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-56.rule"/>
         </rule>
         <rule header="指向派生类对象数组的指针不应转换为基类指针" id="57" impl="PB-57" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-57.rule"/>
         </rule>
         <rule header="在枚举器列表中，隐式指定的枚举常量的值应该是唯一的" id="58" impl="PB-58" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-58.rule"/>
         </rule>
         <rule header="字符串数组初始化时缺失逗号" id="59" impl="PB-59" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-59.rule"/>
         </rule>
         <rule header="可疑的动态内存分配参数" id="60" impl="PB-60" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-60.rule"/>
         </rule>
         <rule header="不得在新分配的内存上执行指针算术运算" id="61" impl="PB-61" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-61.rule"/>
         </rule>
         <rule header="避免参数顺序不正确的函数调用" id="62" impl="PB-62" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-62.rule"/>
         </rule>
         <rule header="函数地址不应与零相比较" id="63" impl="PB-63" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-63.rule"/>
         </rule>
         <rule header="字符串比较的返回值仅和0比较" id="64" impl="PB-64" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-64.rule"/>
         </rule>
         <rule header="避免将表达式的结果赋给更大整数类型的变量，这可能出现整数溢出" id="65" impl="PB-65" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65.rule"/>
         </rule>
         <rule header="避免将表达式的结果与更广泛的整数类型的表达式进行比较，可能会整数溢出" id="65_b" impl="PB-65_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-65_b.rule"/>
         </rule>
         <rule header="'+'， '-'， '*' 运算符常量表达式中的整数溢出或下溢" id="66_a" impl="PB-66_a" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-66_a.rule"/>
         </rule>
         <rule header="'&lt;&lt;' 运算符常量表达式中的整数溢出或下溢" id="66_b" impl="PB-66_b" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-66_b.rule"/>
         </rule>
         <rule header="if-else 语句的两个分支中的代码(预处理后)相同" id="67" impl="PB-67" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-67.rule"/>
         </rule>
         <rule header="由于只有零或非零常量的枚举，布尔条件总是计算为相同的值" id="68" impl="PB-68" quickfix="false" scope="line" severity="2">
            <file path="PB\PB-68.rule"/>
         </rule>
         <rule header="对象的一个元素不能被初始化超过一次" id="69" impl="PB-69" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-69.rule"/>
         </rule>
         <rule header="带有枚举底层类型的表达式只能具有与枚举的枚举数相对应的值" id="70" impl="PB-70" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-70.rule"/>
         </rule>
         <rule header="不要复制包含柔性数组成员的结构体的实例" id="71" impl="PB-71" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-71.rule"/>
         </rule>
         <rule header="不要使用错误的参数类型调用va_arg" id="72" impl="PB-72" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-72.rule"/>
         </rule>
         <rule header="对常量无符号整数表达式的求值不应该导致循环" id="73" impl="PB-73" quickfix="false" scope="line" severity="5">
            <file path="PB\PB-73.rule"/>
         </rule>
         <rule header="不要从迭代器中添加或减去一个值大于1的常量" id="74" impl="PB-74" quickfix="false" scope="line" severity="4">
            <file path="PB\PB-74.rule"/>
         </rule>
         <rule header="不得使用  'stdlib.h' 或者 'cstdlib' 库中的 'abort()' 函数" id="75" impl="PB-75" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75.rule"/>
         </rule>
         <rule header="'stdlib.h' 或者 'cstdlib' 库中的 'exit()' 函数不应该被使用" id="75_b" impl="PB-75_b" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_b.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'quick_exit()' 和 '_Exit()' 函数" id="75_c" impl="PB-75_c" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-75_c.rule"/>
         </rule>
         <rule header="不能使用 C 风格的字符串" id="76" impl="PB-76" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-76.rule"/>
         </rule>
         <rule header="表达式语句不能只显式调用临时对象的构造函数" id="77" impl="PB-77" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-77.rule"/>
         </rule>
         <rule header="在程序员定义的整数类型上使用 intmax_t 或 uintmax_t 进行格式化 IO" id="78" impl="PB-78" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-78.rule"/>
         </rule>
         <rule header="避免语法上有歧义的函数声明" id="79" impl="PB-79" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-79.rule"/>
         </rule>
         <rule header="使用链式指示符的初始化器不应包含没有指示符的初始化器" id="80" impl="PB-80" quickfix="false" scope="line" severity="3">
            <file path="PB\PB-80.rule"/>
         </rule>
      </category>
      <category description="物理文件组织" name="PFO">
         <rule header="在头文件中不能定义具有链接属性的实体" id="01" impl="PFO-01" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-01.rule"/>
         </rule>
         <rule header="使用多个包含保护" id="02" impl="PFO-02" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-02.rule"/>
         </rule>
         <rule header="一个包含文件中只能带有一个类定义" id="03" impl="PFO-03" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-03.rule"/>
         </rule>
         <rule header="每个实现文件都应该声明一个描述文件的局部常量字符串" id="04" impl="PFO-04" quickfix="false" scope="line" severity="5">
            <file path="PFO\PFO-04.rule"/>
         </rule>
         <rule header="带有 '.c' 扩展名的文件不能包含其它带有 '.c' 扩展名的文件" id="05" impl="PFO-05" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-05.rule"/>
         </rule>
         <rule header="禁止在带有 '.icc' 扩展名的文件中包含其它文件" id="06" impl="PFO-06" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-06.rule"/>
         </rule>
         <rule header="使用基于头文件名的多重包含保护机制" id="07" impl="PFO-07" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-07.rule"/>
         </rule>
         <rule header="使用某种机制以防止文件的多重包含，例如，包含保护或者使用 &quot;#pragma once&quot; 预处理指令" id="08" impl="PFO-08" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-08.rule"/>
         </rule>
         <rule header="&quot;#pragma once&quot;预处理指令不能使用在源代码文件中" id="09" impl="PFO-09" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-09.rule"/>
         </rule>
         <rule header="头文件中的定义不要超过类" id="10" impl="PFO-10" quickfix="false" scope="line" severity="3">
            <file path="PFO\PFO-10.rule"/>
         </rule>
      </category>
      <category description="可移植性" name="PORT">
         <rule header="使用大写 'L' 而非小写 'l' 来指定长整型" id="01" impl="PORT-01" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-01.rule"/>
         </rule>
         <rule header="如果将整型操作的结果赋值给 long，其中至少一个整型必须强制转换成 long" id="02" impl="PORT-02" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-02.rule"/>
         </rule>
         <rule header="不能在结构体中使用硬编码的数值作为偏移量" id="03" impl="PORT-03" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-03.rule"/>
         </rule>
         <rule header="不要使用十六进制常数 '0xffffffff' 作为一个错误标识符" id="04" impl="PORT-04" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-04.rule"/>
         </rule>
         <rule header="指向 long 的指针不能强制转换成指向int型的指针" id="05" impl="PORT-05" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-05.rule"/>
         </rule>
         <rule header="不能将长整型赋值给整型" id="06" impl="PORT-06" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-06.rule"/>
         </rule>
         <rule header="不能在函数调用中将 long 类型强制转换后传递给整型" id="07" impl="PORT-07" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-07.rule"/>
         </rule>
         <rule header="对 long 的常量赋值不应涉及 int 字面量" id="08" impl="PORT-08" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-08.rule"/>
         </rule>
         <rule header="不能使用整型直接初始化长整型" id="10" impl="PORT-10" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-10.rule"/>
         </rule>
         <rule header="不能将整型指针强制类型转化成长整型指针" id="11" impl="PORT-11" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-11.rule"/>
         </rule>
         <rule header="不能将 32 位乘法运算的数值赋值给长整型" id="12" impl="PORT-12" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-12.rule"/>
         </rule>
         <rule header="整型 int 类型必须声明为无符号整型或者有符号整型" id="13" impl="PORT-13" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-13.rule"/>
         </rule>
         <rule header="避免在赋值操作中从&quot;短&quot;(&quot;shorter&quot;)的类型转换成&quot;长&quot;(&quot;longer&quot;)的类型" id="14" impl="PORT-14" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-14.rule"/>
         </rule>
         <rule header="不能将 &quot;短&quot;(&quot;shorter&quot;) 类型强制转换成 &quot;长&quot;(&quot;longer&quot;) 类型" id="15" impl="PORT-15" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-15.rule"/>
         </rule>
         <rule header="避免在函数调用中从&quot;短&quot;(&quot;shorter&quot;)的类型转换成&quot;长&quot;(&quot;longer&quot;)的类型" id="16" impl="PORT-16" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-16.rule"/>
         </rule>
         <rule header="不能直接使用 'i64' 或者 'L' 后缀" id="17" impl="PORT-17" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-17.rule"/>
         </rule>
         <rule header="不要在表达式中将长类型操作符强制转换成整型，将表达式的结果进行强制转换" id="19" impl="PORT-19" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-19.rule"/>
         </rule>
         <rule header="不能直接声明长整型的变量" id="20" impl="PORT-20" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-20.rule"/>
         </rule>
         <rule header="不能将长整型赋值给双精度浮点型" id="21" impl="PORT-21" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-21.rule"/>
         </rule>
         <rule header="使用整型数组而非使用长整型的大数组" id="22" impl="PORT-22" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-22.rule"/>
         </rule>
         <rule header="使用整型数组而非使用动态分配的长整型的大数组" id="23" impl="PORT-23" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-23.rule"/>
         </rule>
         <rule header="不能使用指向布尔、字符、短整型、整型和单精度浮点类型的指针的大数组" id="24" impl="PORT-24" quickfix="false" scope="line" severity="5">
            <file path="PORT\PORT-24.rule"/>
         </rule>
         <rule header="标识符名称不得超过 64 个字符" id="25" impl="PORT-25" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-25.rule"/>
         </rule>
         <rule header="算法中不应假设由访问标识符分隔的非静态数据成员的分配顺序" id="26" impl="PORT-26" quickfix="false" scope="line" severity="2">
            <file path="PORT\PORT-26.rule"/>
         </rule>
         <rule header="避免隐式转换为一种更窄的类型" id="27" impl="PORT-27" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-27.rule"/>
         </rule>
         <rule header="避免将常量值转换为一个窄类型" id="28" impl="PORT-28" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-28.rule"/>
         </rule>
         <rule header="指向结构体的指针不应该传递给向文件写入数据的函数" id="29" impl="PORT-29" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-29.rule"/>
         </rule>
         <rule header="不要越过执行边界抛出异常" id="30" impl="PORT-30" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-30.rule"/>
         </rule>
         <rule header="不要跨越执行边界传递非标准布局类型的对象" id="31" impl="PORT-31" quickfix="false" scope="line" severity="4">
            <file path="PORT\PORT-31.rule"/>
         </rule>
         <rule header="不应使用长双精度浮点型" id="32" impl="PORT-32" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-32.rule"/>
         </rule>
         <rule header="不应使用 wchar_t 类型" id="33" impl="PORT-33" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-33.rule"/>
         </rule>
         <rule header="用户指定的 C++ 外部标识符的前 64 个字符应不同" id="34_a" impl="PORT-34_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_a.rule"/>
         </rule>
         <rule header="用户指定的 C++ 内部标识符应与前 64 个字符中的外部标识符不同" id="34_b" impl="PORT-34_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的 C++ 内部标识符的前64个字符应不同" id="34_c" impl="PORT-34_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-34_c.rule"/>
         </rule>
         <rule header="用户指定的 C 外部标识符的前 31 个字符应不同" id="35_a" impl="PORT-35_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_a.rule"/>
         </rule>
         <rule header="用户指定的C内部标识符应与前31个字符中的外部标识符不同" id="35_b" impl="PORT-35_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_b.rule"/>
         </rule>
         <rule header="在相同范围内声明的用户指定的C内部标识符的前31个字符应不同" id="35_c" impl="PORT-35_c" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-35_c.rule"/>
         </rule>
         <rule header="标识符名称不得超过31个字符" id="36_a" impl="PORT-36_a" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_a.rule"/>
         </rule>
         <rule header="宏标识符的名称不能超过31个字符" id="36_b" impl="PORT-36_b" quickfix="false" scope="line" severity="3">
            <file path="PORT\PORT-36_b.rule"/>
         </rule>
      </category>
      <category description="预处理" name="PREPROC">
         <rule header="避免使用宏定义" id="01" impl="PREPROC-01" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-01.rule"/>
         </rule>
         <rule header="不应在 include 语句中使用宏" id="02" impl="PREPROC-02" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-02.rule"/>
         </rule>
         <rule header="不能重定义原始类型" id="03" impl="PREPROC-03" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-03.rule"/>
         </rule>
         <rule header="不能只定义一部分语句" id="04" impl="PREPROC-04" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-04.rule"/>
         </rule>
         <rule header="在宏函数中，应使用括号将乘法和除法操作括起来" id="05" impl="PREPROC-05" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-05.rule"/>
         </rule>
         <rule header="在 #include 语句中不允许绝对或相对路径名" id="06" impl="PREPROC-06" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-06.rule"/>
         </rule>
         <rule header="不正确的 'NULL' 定义" id="07" impl="PREPROC-07" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-07.rule"/>
         </rule>
         <rule header="仅可以在包含头文件(*.h)时使用 #include 预处理指令" id="08" impl="PREPROC-08" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-08.rule"/>
         </rule>
         <rule header="#include 指令只能使用 &lt;filename.h&gt; 符号来包含头文件" id="09" impl="PREPROC-09" quickfix="false" scope="line" severity="2">
            <file path="PREPROC\PREPROC-09.rule"/>
         </rule>
         <rule header="#ifndef 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="10" impl="PREPROC-10" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10.rule"/>
         </rule>
         <rule header="#endif 程序预处理指示字将仅用于防止同一头文件多个包含" id="10_b" impl="PREPROC-10_b" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10_b.rule"/>
         </rule>
         <rule header="#if 程序预处理指示字仅用于防止相同头文件的多个 inclusion" id="10_c" impl="PREPROC-10_c" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-10_c.rule"/>
         </rule>
         <rule header="不应使用 #ifdef, #else, #elif 程序预处理指示字" id="11" impl="PREPROC-11" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-11.rule"/>
         </rule>
         <rule header="不应使用 #if 程序预处理指示字" id="11_b" impl="PREPROC-11_b" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-11_b.rule"/>
         </rule>
         <rule header="C++ 宏应该只能用于包含保护(include guards)，类型修饰符，或存储类限定符" id="12" impl="PREPROC-12" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-12.rule"/>
         </rule>
         <rule header="宏不应该包含标记(token)粘贴，变量参数列表，也不包括递归宏调用" id="13" impl="PREPROC-13" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-13.rule"/>
         </rule>
         <rule header="所有宏必须扩展到完整的句法单位" id="14" impl="PREPROC-14" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-14.rule"/>
         </rule>
         <rule header="指针解引用操作不应该被隐藏在宏定义中" id="15" impl="PREPROC-15" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-15.rule"/>
         </rule>
         <rule header="一个紧跟在 # 操作符的宏参数不应该在其后紧跟或在其前加上 ## 操作符" id="16" impl="PREPROC-16" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-16.rule"/>
         </rule>
         <rule header="一个被用作 # 或者 ## 操作符的操作数的宏参数，并且它本身受制于进一步的宏替换，那么它应该只能被用作这些操作符的操作数" id="17" impl="PREPROC-17" quickfix="false" scope="line" severity="4">
            <file path="PREPROC\PREPROC-17.rule"/>
         </rule>
         <rule header="不应该包含标准输入/输出库 stdio.h" id="18" impl="PREPROC-18" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-18.rule"/>
         </rule>
         <rule header="#if 或 #elif 预处理指令的控制表达式应评估为 0 或 1" id="19" impl="PREPROC-19" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-19.rule"/>
         </rule>
         <rule header="将 #include 指令中的文件名匹配到文件系统上的文件名" id="20" impl="PREPROC-20" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-20.rule"/>
         </rule>
         <rule header="避免产生通用字符名称的占位符串联" id="21" impl="PREPROC-21" quickfix="false" scope="line" severity="5">
            <file path="PREPROC\PREPROC-21.rule"/>
         </rule>
         <rule header="不应使用 #error 指令" id="22" impl="PREPROC-22" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-22.rule"/>
         </rule>
         <rule header="不应使用 #pragma 指令" id="23" impl="PREPROC-23" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-23.rule"/>
         </rule>
         <rule header="除 #ifdef 和 #ifndef 预处理器指令和 defined() 操作符外，预处理指令中的所有宏标识符都应在使用前定义" id="24" impl="PREPROC-24" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-24.rule"/>
         </rule>
         <rule header="不应使用 #undef" id="25" impl="PREPROC-25" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-25.rule"/>
         </rule>
         <rule header="#ifndef、#ifdef、#if、#elif、#else 和 #endif 预处理器指令只能用于条件文件包含和包含保护" id="26" impl="PREPROC-26" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-26.rule"/>
         </rule>
         <rule header="不要在 #undef 指令中使用'bool'、'false'或'true'标识符" id="27" impl="PREPROC-27" quickfix="false" scope="line" severity="3">
            <file path="PREPROC\PREPROC-27.rule"/>
         </rule>
      </category>
      <category description="Qt 最佳实践" name="QT">
         <rule header="每个QObject子类都应该包含一个Q_OBJECT宏" id="01" impl="QT-01" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-01.rule"/>
         </rule>
         <rule header="QObject 不得多次继承" id="02" impl="QT-02" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-02.rule"/>
         </rule>
         <rule header="只能将一个信号连接到一个槽或一个信号连接到另一个信号" id="03" impl="QT-03" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-03.rule"/>
         </rule>
         <rule header="SIGNAL 和 SLOT 宏中的方法必须存在" id="04" impl="QT-04" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-04.rule"/>
         </rule>
         <rule header="用关键字 &quot;emit&quot; 标记信号发射( signal emission )，以区分信号发射和普通方法调用" id="05" impl="QT-05" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-05.rule"/>
         </rule>
         <rule header="不要为 QThreads 设置 Idle 或 Critical 优先级。只使用 High/Low/Med" id="06" impl="QT-06" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-06.rule"/>
         </rule>
         <rule header="不要通过调用 QThread::terminate() 来强制线程终止" id="07" impl="QT-07" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-07.rule"/>
         </rule>
         <rule header="如果在函数中对互斥使用锁，则释放同一函数中的锁" id="08" impl="QT-08" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-08.rule"/>
         </rule>
         <rule header="在 QMutexLocker 上不调用 new" id="09" impl="QT-09" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-09.rule"/>
         </rule>
         <rule header="为任何具有指针的Qt继承对象声明一个复制构造函数和操作符=" id="10" impl="QT-10" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-10.rule"/>
         </rule>
         <rule header="不要在小部件上使用 setWindowFlags 函数" id="11" impl="QT-11" quickfix="false" scope="line" severity="4">
            <file path="QT\QT-11.rule"/>
         </rule>
         <rule header="不要直接设置由 Qt 内核设置的特定 Widget 属性" id="12" impl="QT-12" quickfix="false" scope="line" severity="1">
            <file path="QT\QT-12.rule"/>
         </rule>
         <rule header="永远不要在赋值中混用常量和非常量迭代器" id="13" impl="QT-13" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-13.rule"/>
         </rule>
         <rule header="如果使用 Q_DECLARE_FLAGS ，那么就必须使用 Q_DECLARE_OPERATORS_FOR_FLAGS" id="14" impl="QT-14" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-14.rule"/>
         </rule>
         <rule header="Q_DECLARE_OPERATORS_FOR_FLAGS 必须位于全局命名空间中，Q_DECLARE_FLAGS 必须位于枚举的命名空间中" id="15" impl="QT-15" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-15.rule"/>
         </rule>
         <rule header="Q_PROPERTY 的 getter 和 setter 函数必须存在，且类型必须匹配" id="16" impl="QT-16" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-16.rule"/>
         </rule>
         <rule header="枚举类型的属性必须使用 Q_ENUMS" id="17" impl="QT-17" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-17.rule"/>
         </rule>
         <rule header="不应该在 Qt 对象上调用非常量函数" id="18" impl="QT-18" quickfix="false" scope="line" severity="3">
            <file path="QT\QT-18.rule"/>
         </rule>
      </category>
      <category description="安全性" name="SECURITY">
         <rule header="不应使用函数 'asctime()' 和 'asctime_r()'" id="01" impl="SECURITY-01" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-01.rule"/>
         </rule>
         <rule header="不应使用随机数函数'rand()'和'srand()'" id="02" impl="SECURITY-02" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02.rule"/>
         </rule>
         <rule header="不要使用 rand() 函数来生成伪随机数" id="02_b" impl="SECURITY-02_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-02_b.rule"/>
         </rule>
         <rule header="限制使用系统属性（环境变量）" id="03" impl="SECURITY-03" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-03.rule"/>
         </rule>
         <rule header="谨慎使用以确保 LoadLibrary() 加载正确的库" id="04" impl="SECURITY-04" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-04.rule"/>
         </rule>
         <rule header="避免调用只有一个参数而不是字符串常量的函数 printf/wprintf" id="05" impl="SECURITY-05" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-05.rule"/>
         </rule>
         <rule header="避免使用 MFC 库中的时间函数" id="06" impl="SECURITY-06" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-06.rule"/>
         </rule>
         <rule header="不要使用不安全的 C 函数来写入未检查范围的缓冲区" id="07" impl="SECURITY-07" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-07.rule"/>
         </rule>
         <rule header="当第二个参数是变量时，避免使用只有两个参数的函数 fprintf/fwprintf" id="08" impl="SECURITY-08" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-08.rule"/>
         </rule>
         <rule header="避免使用标准库中 'string' 类中的 data() 函数" id="09" impl="SECURITY-09" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-09.rule"/>
         </rule>
         <rule header="避免使用 'vfork()' 函数" id="10" impl="SECURITY-10" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-10.rule"/>
         </rule>
         <rule header="避免使用可能受到 shell 元字符影响的不安全 shell 函数" id="11" impl="SECURITY-11" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-11.rule"/>
         </rule>
         <rule header="避免使用可能导致缓冲区溢出的不安全字符串函数" id="12" impl="SECURITY-12" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-12.rule"/>
         </rule>
         <rule header="避免使用不安全的不检查界限的字符串函数" id="13" impl="SECURITY-13" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-13.rule"/>
         </rule>
         <rule header="不要在不指定可变大小的格式字符串的情况下使用 scanf 和 fscanf 函数" id="14" impl="SECURITY-14" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-14.rule"/>
         </rule>
         <rule header="不要将应用程序错误导致的潜在敏感信息打印到异常消息中" id="15" impl="SECURITY-15" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-15.rule"/>
         </rule>
         <rule header="请勿使用 gets() 函数" id="16" impl="SECURITY-16" quickfix="false" scope="line" severity="1">
            <file path="SECURITY\SECURITY-16.rule"/>
         </rule>
         <rule header="避免将非常量参数或变量传递给 exec" id="17" impl="SECURITY-17" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-17.rule"/>
         </rule>
         <rule header="避免将动态生成的字符串传递给 exec" id="18" impl="SECURITY-18" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-18.rule"/>
         </rule>
         <rule header="不允许使用容易发生竞争的功能" id="19" impl="SECURITY-19" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-19.rule"/>
         </rule>
         <rule header="避免将用户的输入作为参数传递给方法" id="20" impl="SECURITY-20" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-20.rule"/>
         </rule>
         <rule header="不能将 'syslog' 函数用于日志记录目的" id="21" impl="SECURITY-21" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-21.rule"/>
         </rule>
         <rule header="不要使用 mbstowcs() 函数" id="22" impl="SECURITY-22" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-22.rule"/>
         </rule>
         <rule header="警惕使用那些返回当前目录或窗口目录的函数" id="23" impl="SECURITY-23" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-23.rule"/>
         </rule>
         <rule header="避免使用InitializeCriticalSection" id="24" impl="SECURITY-24" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-24.rule"/>
         </rule>
         <rule header="避免使用对线程不安全(thread-unsafe)的函数" id="25" impl="SECURITY-25" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-25.rule"/>
         </rule>
         <rule header="不要在源代码中使用 'setuid'" id="26" impl="SECURITY-26" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-26.rule"/>
         </rule>
         <rule header="不要使用 chmod(), chown(), chgrp()" id="27" impl="SECURITY-27" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-27.rule"/>
         </rule>
         <rule header="出于安全考虑，不应该使用标准随机数生成器来生成随机性" id="28" impl="SECURITY-28" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-28.rule"/>
         </rule>
         <rule header="不能使用已弃用的 C 程序 ulimit()" id="29" impl="SECURITY-29" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-29.rule"/>
         </rule>
         <rule header="避免在程序代码中使用 'getpw' 函数" id="30" impl="SECURITY-30" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-30.rule"/>
         </rule>
         <rule header="不要使用 'cuserid' 函数" id="31" impl="SECURITY-31" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-31.rule"/>
         </rule>
         <rule header="避免使用已经废弃的 C 程序 'usleep'" id="32" impl="SECURITY-32" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-32.rule"/>
         </rule>
         <rule header="禁止使用那些不能正确处理非空结束的字符串的函数" id="33" impl="SECURITY-33" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-33.rule"/>
         </rule>
         <rule header="避免使用环境变量" id="34" impl="SECURITY-34" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-34.rule"/>
         </rule>
         <rule header="不要相信任何可能被攻击者设置的命令行值" id="35" impl="SECURITY-35" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-35.rule"/>
         </rule>
         <rule header="禁止使用来自不信任用户的未经过滤的数据作为格式化参数" id="36" impl="SECURITY-36" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-36.rule"/>
         </rule>
         <rule header="请勿使用弱加密功能" id="37" impl="SECURITY-37" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-37.rule"/>
         </rule>
         <rule header="不可信任数据用作循环边界" id="38" impl="SECURITY-38" quickfix="false" scope="line" severity="2">
            <file path="SECURITY\SECURITY-38.rule"/>
         </rule>
         <rule header="使用安全的临时文件名称函数" id="39" impl="SECURITY-39" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-39.rule"/>
         </rule>
         <rule header="在调用 'mkstemp' 之前调用 'umask'" id="40" impl="SECURITY-40" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-40.rule"/>
         </rule>
         <rule header="如果你调用 'chroot' 请调用 'chdir'" id="41" impl="SECURITY-41" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-41.rule"/>
         </rule>
         <rule header="如果文件是使用 'open' 或 'openat' 系统调用创建的，则指定访问权限位" id="42" impl="SECURITY-42" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-42.rule"/>
         </rule>
         <rule header="不应该使用 'PTHREAD_CANCEL_ASYNCHRONOUS'参数来调用函数'pthread_setcanceltype()'" id="43" impl="SECURITY-43" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-43.rule"/>
         </rule>
         <rule header="在放弃特权时遵守正确的撤销命令" id="44" impl="SECURITY-44" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-44.rule"/>
         </rule>
         <rule header="确保成功地放弃特权" id="45" impl="SECURITY-45" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-45.rule"/>
         </rule>
         <rule header="不应将指向结构体的指针传递给可将数据复制到用户空间的函数" id="46" impl="SECURITY-46" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-46.rule"/>
         </rule>
         <rule header="检查 shift 操作符的右指针操作数时，请使用正确的整数精度" id="47" impl="SECURITY-47" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-47.rule"/>
         </rule>
         <rule header="不要调用 'stdlib.h' 或 'cstdlib' 库中参数不为 '0'（空指针）的 'system()' 函数" id="48" impl="SECURITY-48" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'system()' 函数" id="48_b" impl="SECURITY-48_b" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-48_b.rule"/>
         </rule>
         <rule header="使用带有唯一条件变量的 'cnd_signal()' 函数" id="49" impl="SECURITY-49" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-49.rule"/>
         </rule>
         <rule header="当多个线程在等待同一个条件变量时，不要使用 'notify_one()' 函数" id="50" impl="SECURITY-50" quickfix="false" scope="line" severity="4">
            <file path="SECURITY\SECURITY-50.rule"/>
         </rule>
         <rule header="不要使用 'char' 缓冲区来存储来自 'std::cin' 的输入" id="51" impl="SECURITY-51" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-51.rule"/>
         </rule>
         <rule header="不得使用 'stdlib.h' 或 'cstdlib' 库中的 'getenv()' 函数" id="52" impl="SECURITY-52" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-52.rule"/>
         </rule>
         <rule header="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="53" impl="SECURITY-53" quickfix="false" scope="line" severity="3">
            <file path="SECURITY\SECURITY-53.rule"/>
         </rule>
      </category>
      <category description="STL 最佳实践" name="STL">
         <rule header="选择使用类的封装，而不是编写与容器无关的代码" id="01" impl="STL-01" quickfix="false" scope="line" severity="5">
            <file path="STL\STL-01.rule"/>
         </rule>
         <rule header="要使复制有效、正确且不会产生切片问题，应该创建指针容器而不是对象容器" id="02" impl="STL-02" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-02.rule"/>
         </rule>
         <rule header="调用 empty 而不要判断 size() 是否为 0" id="03" impl="STL-03" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-03.rule"/>
         </rule>
         <rule header="避免在显式的循环中递归调用插入操作" id="04" impl="STL-04" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-04.rule"/>
         </rule>
         <rule header="几乎所有的复制是通过调用成员函数而不是插入迭代器来确定目的范围" id="05" impl="STL-05" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-05.rule"/>
         </rule>
         <rule header="当用作函数参数时，应使用 istream_iterator 名字而不是匿名的 istream_iterator 对象" id="06" impl="STL-06" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-06.rule"/>
         </rule>
         <rule header="容器中如果有新创建的指针，切记删除容器之前先删除指针" id="07" impl="STL-07" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-07.rule"/>
         </rule>
         <rule header="禁止创建 auto_ptrs 的容器" id="08" impl="STL-08" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-08.rule"/>
         </rule>
         <rule header="避免对 list 和标准关联容器使用 remove 算法" id="09" impl="STL-09" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-09.rule"/>
         </rule>
         <rule header="对于动态分配的数组最好使用 vector 或 string" id="10" impl="STL-10" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-10.rule"/>
         </rule>
         <rule header="使用 vector&lt;char&gt; 而非 string" id="11" impl="STL-11" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-11.rule"/>
         </rule>
         <rule header="使用 reserve 来避免不必要的重复分配" id="12" impl="STL-12" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-12.rule"/>
         </rule>
         <rule header="每一个 vector 和 string 在被传递给 C 函数之前，应该对它们是否为空做一个检查" id="13" impl="STL-13" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-13.rule"/>
         </rule>
         <rule header="避免使用 vector&lt;bool&gt;" id="14" impl="STL-14" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-14.rule"/>
         </rule>
         <rule header="对存放指针的关联容器指定比较方式" id="15" impl="STL-15" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-15.rule"/>
         </rule>
         <rule header="禁止对关联容器使用判定相等数值为 true 的比较函数" id="16" impl="STL-16" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-16.rule"/>
         </rule>
         <rule header="禁止对关联容器使用判定相等数值为真的比较函数" id="17" impl="STL-17" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-17.rule"/>
         </rule>
         <rule header="使用迭代器而不是常量迭代器,reverse_iterator,或 const_reverse_iterator" id="18" impl="STL-18" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-18.rule"/>
         </rule>
         <rule header="使用 distance 和 advance 将容器的 const_iterators 转换为 iterators" id="19" impl="STL-19" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-19.rule"/>
         </rule>
         <rule header="出于删除目的时，应谨慎使用 reverse_iterator 的基迭代器" id="20" impl="STL-20" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-20.rule"/>
         </rule>
         <rule header="逐字符输入时，使用 istreambuf 的迭代器" id="21" impl="STL-21" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-21.rule"/>
         </rule>
         <rule header="确保目标范围足够大" id="22" impl="STL-22" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-22.rule"/>
         </rule>
         <rule header="通过擦除遵循类似删除的算法从容器中删除元素" id="23" impl="STL-23" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-23.rule"/>
         </rule>
         <rule header="避免对存放动态内存指针的容器使用 remove 或类似的算法（即remove_if和unique）" id="24" impl="STL-24" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-24.rule"/>
         </rule>
         <rule header="如果你传递一个已排序的值域给某个算法，而同时该值域进行一个比较函数操作时，应确保这个比较函数传递的值域是跟用于排序的值域是相同的" id="25" impl="STL-25" quickfix="false" scope="line" severity="4">
            <file path="STL\STL-25.rule"/>
         </rule>
         <rule header="正确执行 copy_if 的前提是不应该在谓词前返回带有 not1 的 remove_copy_if" id="26" impl="STL-26" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-26.rule"/>
         </rule>
         <rule header="如果 accumulate() 用于包含浮点指针值的容器，必须使用浮点数值初始化" id="27" impl="STL-27" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-27.rule"/>
         </rule>
         <rule header="按传递值来设计 functor 类" id="28" impl="STL-28" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-28.rule"/>
         </rule>
         <rule header="使谓词常量成为纯函数" id="29" impl="STL-29" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-29.rule"/>
         </rule>
         <rule header="每一个 functor 类应该有且只有一个 operator()，并且其参数和返回值类型应该通过 unary_function 或 binary_function 来指定" id="30" impl="STL-30" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-30.rule"/>
         </rule>
         <rule header="将函数传递给 STL 构件时，必须使用 ptr_fun,mem_fun,或者 mem_fun_ref" id="31" impl="STL-31" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-31.rule"/>
         </rule>
         <rule header="确保 less&lt;T&gt; 与操作符 &lt; 语义一致" id="32" impl="STL-32" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-32.rule"/>
         </rule>
         <rule header="尽量采用算法调用而不是手写循环" id="33" impl="STL-33" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-33.rule"/>
         </rule>
         <rule header="最好采用成员函数而不是采用同名算法" id="34" impl="STL-34" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-34.rule"/>
         </rule>
         <rule header="不能简单的将某个非零的常量转换为真，将零转换为假" id="35" impl="STL-35" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-35.rule"/>
         </rule>
         <rule header="不要使用一个不是真实范围的迭代器范围" id="36" impl="STL-36" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-36.rule"/>
         </rule>
         <rule header="不得使用 C 样式数组" id="37" impl="STL-37" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-37.rule"/>
         </rule>
         <rule header="使用 != 代替 &lt; 来比较迭代器" id="38" impl="STL-38" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-38.rule"/>
         </rule>
         <rule header="将特征类（Traits）与重载关联使用" id="39" impl="STL-39" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-39.rule"/>
         </rule>
         <rule header="调用 swap 时，使用 using 声明 std::swap，然后调用 swap 不需要命名空间限定" id="40" impl="STL-40" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-40.rule"/>
         </rule>
         <rule header="不能声明非成员作为 std::swap 的重载" id="41" impl="STL-41" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-41.rule"/>
         </rule>
         <rule header="Swap 的成员版本应该禁止抛出异常" id="42" impl="STL-42" quickfix="false" scope="line" severity="3">
            <file path="STL\STL-42.rule"/>
         </rule>
      </category>
      <category description="模板" name="TEMPL">
         <rule header="从模板中分离出参数无关的代码" id="01" impl="TEMPL-01" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-01.rule"/>
         </rule>
         <rule header="需要类型转换时在模板内定义非成员函数" id="02" impl="TEMPL-02" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-02.rule"/>
         </rule>
         <rule header="不要重载模板类中的函数" id="03" impl="TEMPL-03" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-03.rule"/>
         </rule>
         <rule header="在全局模板函数中使用 'typename' 去标识嵌套依赖类型名" id="04" impl="TEMPL-04" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-04.rule"/>
         </rule>
         <rule header="在模板类中使用 'typename' 去标识嵌套依赖类型名" id="05" impl="TEMPL-05" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-05.rule"/>
         </rule>
         <rule header="在模板类中，不要改变默认的虚函数参数" id="06" impl="TEMPL-06" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-06.rule"/>
         </rule>
         <rule header="当存在一个包含单个泛型参数的模板构造函数时，应声明拷贝构造函数" id="07" impl="TEMPL-07" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-07.rule"/>
         </rule>
         <rule header="函数调用的可行函数集合应该要么不包括函数特化，要么只包括函数特化" id="08" impl="TEMPL-08" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-08.rule"/>
         </rule>
         <rule header="重载函数模板不应显式特化" id="09" impl="TEMPL-09" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-09.rule"/>
         </rule>
         <rule header="模板所有的部分和显式专门化都应在与其主模板声明相同的文件中声明" id="10" impl="TEMPL-10" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-10.rule"/>
         </rule>
         <rule header="存在一个包含泛型参数的模板赋值运算符时，拷贝赋值运算符应该被声明" id="11" impl="TEMPL-11" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-11.rule"/>
         </rule>
         <rule header="在含有依赖基础的类模板中，任何可能在这个依赖类中被发现的名称都应该引用使用限定标识（qualified-id）或 -&gt;" id="12" impl="TEMPL-12" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-12.rule"/>
         </rule>
         <rule header="不要在关联的命名空间中声明非成员通用函数" id="13" impl="TEMPL-13" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-13.rule"/>
         </rule>
         <rule header="函数应解析为先前在编译单元中声明的函数" id="14" impl="TEMPL-14" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-14.rule"/>
         </rule>
         <rule header="声明 'extern' 一个显式实例化的模板" id="15" impl="TEMPL-15" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-15.rule"/>
         </rule>
         <rule header="模板专门化应声明在与主模板或用户定义类型相同的文件中，为其声明专门化" id="16" impl="TEMPL-16" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-16.rule"/>
         </rule>
         <rule header="如果返回类型前面带有 'typename' 关键字，使用尾随返回类型语法" id="17" impl="TEMPL-17" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-17.rule"/>
         </rule>
         <rule header="非成员泛型操作符只能在不包含类(结构体)类型、枚举类型或联合类型声明的命名空间中声明" id="18" impl="TEMPL-18" quickfix="false" scope="line" severity="3">
            <file path="TEMPL\TEMPL-18.rule"/>
         </rule>
      </category>
   </builtin>
</rules>
